<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-logo.png">
  <link rel="mask-icon" href="/images/favicon-logo.png" color="#222">
  <meta name="google-site-verification" content="4ub2lNf2WEkusifo-b7xbJIm2G5xxYUczDoWOFGp-NM">
  <meta name="msvalidate.01" content="C2030D8E2452D4B39AED09488E55F2DF">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;wqdy.top&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:true,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:true,&quot;pangu&quot;:true,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:true}}</script>
<meta name="description" content="分享各类资源、经验与技巧">
<meta property="og:type" content="website">
<meta property="og:title" content="我全都要">
<meta property="og:url" content="https://wqdy.top/page/14/index.html">
<meta property="og:site_name" content="我全都要">
<meta property="og:description" content="分享各类资源、经验与技巧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="c">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wqdy.top/page/14/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;14&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>我全都要</title><script src="/js/config.js"></script>

<!-- google 分析 -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9068539038073295"
     crossorigin="anonymous"></script>


  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112496567-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{&quot;tracking_id&quot;:&quot;UA-112496567-1&quot;,&quot;only_pageview&quot;:false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?0a902dd83e2d4f1aebaeaa0bafe307a0"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我全都要</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">搞快点</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-前端"><a href="/c/frontend/" rel="section"><i class="fab fa-html5 fa-fw"></i>前端</a></li>
        <li class="menu-item menu-item-软件"><a href="/c/software/" rel="section"><i class="fas fa-th-large fa-fw"></i>软件</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-面试"><span class="exturl" data-url="aHR0cHM6Ly9tcy53cWR5LnRvcA=="><i class="fas fa-archive fa-fw"></i>面试</span></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="c"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">c</p>
  <div class="site-description" itemprop="description">分享各类资源、经验与技巧</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1aWxvbmdqaW4=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cuilongjin"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/429.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/429.html" class="post-title-link" itemprop="url">Webpack</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2019-01-05" itemprop="dateCreated datePublished" datetime="2019-01-05T22:33:14+00:00">2019-01-05</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy8=">webpack 官网</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcv">webpack 中文网</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1aWxvbmdqaW4vd2VicGFjay1jb25maWcv">webpack 配置文件</span></li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>webpack 是一个现代 JavaScript 应用程序的模块打包器（module bundler）</p>
<p>webpack 是一个模块化方案（预编译）</p>
<p>webpack 获取具有依赖关系的模块，并生成表示这些模块的静态资源</p>
<p>webpack 的两个特点：模块化、打包</p>
<p>四个核心概念：<strong>入口(entry)<strong>、</strong>输出(output)<strong>、</strong>加载器(loader)<strong>、</strong>插件(plugins)</strong></p>
<p>模块化方案：webpack 和 requirejs（通过编写代码的方式将前端的功能，划分成独立的模块）<br>browserify 是与 webpack 相似的模块化打包工具</p>
<h3 id="webpack-起源"><a href="#webpack-起源" class="headerlink" title="webpack 起源"></a>webpack 起源</h3><ul>
<li>webpack 解决了现存模块打包器的两个痛点：<ul>
<li>Code Spliting - 代码分离</li>
<li>静态资源的模块化处理方案</li>
</ul>
</li>
</ul>
<h3 id="webpack-与模块"><a href="#webpack-与模块" class="headerlink" title="webpack 与模块"></a>webpack 与模块</h3><ul>
<li><p><span class="exturl" data-url="aHR0cDovL3poYW9kYS5uZXQvd2VicGFjay1oYW5kYm9vay9tb2R1bGUtc3lzdGVtLmh0bWw=">前端模块系统的演进</span></p>
</li>
<li><p>在 webpack 看来：所有的<strong>静态资源都是模块</strong></p>
</li>
<li><p>webpack 模块能够识别以下等形式的模块之间的依赖：</p>
<ul>
<li><p>ES2015 <code>import</code> <code>export</code></p>
</li>
<li><p>CommonJS <code>require()</code> <code>module.exports</code></p>
</li>
<li><p>AMD <code>define</code> 和 <code>require</code></p>
</li>
<li><p>css/sass/less 文件中的 <code>@import</code></p>
</li>
<li><p>图片连接，比如：样式 <code>url(...)</code> 或 HTML <code>&lt;img src=...&gt;</code></p>
</li>
<li><p>字体等</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>在 webpack 提供的模块化环境中<ul>
<li>想要加载一个 JS 文件，只需要 require(‘a.js’)</li>
<li>想要加载一个 CSS 文件，只需要 require(‘css/index.css’)</li>
<li>想要加载一个图片文件，只需要 require(‘images/a.png’)</li>
</ul>
</li>
</ul>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzQyZTExNTE1YzEwZiM=">入门 Webpack，看这篇就够了</span></li>
</ul>
<h3 id="webpack-打包原理："><a href="#webpack-打包原理：" class="headerlink" title="webpack 打包原理："></a>webpack 打包原理：</h3><p>​ 入口文件： main.js</p>
<p>​ webpack 从入口出发，递归分析项目中所有的依赖项（模块），使用 loader 来处理对应的模块最终，打包生成一个 bundle.js 文件。</p>
<p>​ 如果配置了 webpack 中的 代码分离（Code Spliting），webpack 会根据 分离点 将这个模块生成一个独立的 JS 文件</p>
<p>​ 还可以通过配置，将 CSS 、 图片、 字体 等文件，从 bundle.js 中抽离为独立的文件</p>
<h2 id="webpack-的基本使用"><a href="#webpack-的基本使用" class="headerlink" title="webpack 的基本使用"></a>webpack 的基本使用</h2><p>安装：<code>npm i -D webpack webpack-cli</code></p>
<p>webpack：是 webpack 工具的核心包</p>
<p>webpack-cli：提供了一些在终端中使用的命令</p>
<p>-D(–save-dev)：表示项目开发期间的依赖</p>
<p>webpack 的两种使用方式：命令行、配置文件（<code>webpack.config.js</code>）</p>
<h3 id="命令行使用说明"><a href="#命令行使用说明" class="headerlink" title="命令行使用说明"></a>命令行使用说明</h3><ul>
<li><code>package.json</code>中的<code>scripts</code>中可以存放一些 bash 命令，这些 bash 命令可以通过 <code>npm run 命令名称</code> 来执行</li>
<li>注意：npm 在执行 scripts 中的命令的时候，是在电脑系统后台默认开启一个 bash，将当前目录下的<code>./node_modules/.bin</code>这个文件夹临时加入了系统环境变量</li>
<li>使用方式：<code>npm run build</code></li>
<li>设置开发状态： <code>mode</code> 如果没有设置 mode 配置项，webpack 会默认提供开发环境(production)</li>
<li>在入口文件中可以使用 <code>import</code> 引入 js css less 等文件</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="comment">// webpack 是 webpack-cli 提供的命令</span></span><br><span class="line">  <span class="comment">// src/js/main.js 为入口文件</span></span><br><span class="line">  <span class="comment">// --output dist/bundle.js 为出口文件</span></span><br><span class="line">  <span class="comment">// --mode development 生产环境</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  <span class="string">&quot;build1&quot;</span>: <span class="string">&quot;webpack src/js/main.js --output dist/bundle.js --mode development&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件方式（推荐）"><a href="#配置文件方式（推荐）" class="headerlink" title="配置文件方式（推荐）"></a>配置文件方式（推荐）</h3><p>项目<code>根目录</code>下创建一个 <code>webpack.config.js</code>文件，运行 <code>webpack</code> 命令时的默认配置文件</p>
<p>指定其他文件：<code>--config webpack.XX.js</code></p>
<p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;build&quot;: &quot;webpack&quot;</code></p>
<p>执行命令 : <code>npm run build</code></p>
<p>示例代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 是基于 node的 , 所以配置文件符合 node 方式书写配置</span></span><br><span class="line"><span class="comment">// 注意 : 不要再这个文件中使用ES6的的模块化 import语法</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  <span class="attr">entry</span>: path.join(__dirname, <span class="string">&#x27;./src/js/main.js&#x27;</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出口</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 出口目录</span></span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>安装：<code>npm i -D webpack-dev-server</code></p>
<p>作用：配合 webpack，创建开发环境（启动服务器、监视文件变化、自动编译、刷新浏览器等），提高开发效率</p>
<p>注意：无法直接在终端中执行 <code>webpack-dev-server</code>，需要在 <code>package.json</code> 配置 <code>scripts</code> 后使用</p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul>
<li><code>webpack-dev-server</code>将打包好的文件存储在内存中，提高编译和加载速度，效率更高（不会生成 dist 目录）</li>
<li>在内存中出口目录为项目根目录（命令行中的提示：<code>webpack output is served from /</code>）<ul>
<li>在<code>index.html</code>页面中引入文件不需要加<code>dist</code></li>
</ul>
</li>
</ul>
<h3 id="CLI-配置"><a href="#CLI-配置" class="headerlink" title="CLI 配置"></a>CLI 配置</h3><ul>
<li><code>--contentBase</code> ：告诉服务器在哪个目录中提供服务（可以理解为：打开哪个目录中的 index.html）<ul>
<li><code>--contentBase ./src</code>：当前目录下的 src 文件夹</li>
</ul>
</li>
<li><code>--open true</code> ：自动打开浏览器</li>
<li><code>--port 3000</code> ：指定端口号</li>
<li><code>--hot</code> ：热更新，只加载修改的文件(按需加载修改的内容)，而非全部加载</li>
<li><code>--progress</code>：显示进度条</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --contentBase src --open --port 8888 --hot&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;dev&quot;: &quot;webpack-dev-server --hot&quot;</code></p>
<p>执行命令 : <code>npm run dev</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --hot 热更新写在命令行里，不然的话还要配其他插件麻烦</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: path.join(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">// hot: true,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">// api 表示当前项目请求的 key</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="comment">// 代理服务器路径</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;/api&#x27;</span> &#125;, <span class="comment">// 重写路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求 localhost:8080/api/.. 会被代理到 http://www.baidu.com/api/..</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// plugins: [</span></span><br><span class="line">  <span class="comment">//   new webpack.HotModuleReplacementPlugin()</span></span><br><span class="line">  <span class="comment">// ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="html-webpack-plugin-插件"><a href="#html-webpack-plugin-插件" class="headerlink" title="html-webpack-plugin 插件"></a>html-webpack-plugin 插件</h2><ul>
<li>安装：<code>npm i -D html-webpack-plugin</code></li>
<li>作用：根据模板，在内存中自动生成 html 页面，并自动引入<code>bundle.js</code>、<code>css</code>等文件</li>
</ul>
<p>配置文件配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 html-webpack-plugin 插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 配置插件</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin 配置</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 模板页面路径</span></span><br><span class="line">      <span class="attr">template</span>: path.join(__dirname, <span class="string">&#x27;src/index.html&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打包非-js-文件"><a href="#打包非-js-文件" class="headerlink" title="打包非 js 文件"></a>打包非 js 文件</h2><p>webpack 默认只能处理 js 文件，非 js(css、less、图片、字体等)处理不了，借助 loader 加载器</p>
<h3 id="处理-css-文件"><a href="#处理-css-文件" class="headerlink" title="处理 css 文件"></a>处理 css 文件</h3><p>在 <code>main.js</code>中引入 css 文件 <code>import &#39;../css/main.css&#39;</code></p>
<p>安装 : <code>npm i -D style-loader css-loader</code></p>
<p>在 <code>webpack.config.js</code> 中，添加个新的配置项 <code>module</code></p>
<p>在 <code>module</code> 中添加 <code>loader</code> 来处理 <code>css</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理 css</span></span><br><span class="line">      <span class="comment">// 注意点 use 执行loader 顺序 从右往左</span></span><br><span class="line">      <span class="comment">// css-loader: 读取css文件内容，将其转化为一个模块</span></span><br><span class="line">      <span class="comment">// style-loader: 拿到模块, 创建一个style标签，插入页面中</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理-less-文件"><a href="#处理-less-文件" class="headerlink" title="处理 less 文件"></a>处理 less 文件</h3><p>在 <code>main.js</code>中引入 less 文件 <code>import &#39;../css/main.less&#39;</code></p>
<p>安装 : <code>npm i -D less-loader less style-loader css-loader</code></p>
<p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理 <code>less</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">//处理 css</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理图片文件"><a href="#处理图片文件" class="headerlink" title="处理图片文件"></a>处理图片文件</h3><p>安装 : <code>npm i -D url-loader file-loader</code></p>
<p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理图片</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="comment">//  图片大小 &lt;= 10000 =&gt; 转化为base64</span></span><br><span class="line">              <span class="comment">//  图片大小 &gt;= 10000 =&gt; 不会转base64 内部调用 file-loader 加载图片</span></span><br><span class="line">              <span class="attr">limit</span>: <span class="number">10000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>url-loader</strong> 默认会将图片转化为 base64 编码格式，目的：提高性能</p>
<p><strong>file-loader</strong> 在处理图片时，会对文件进行重命名</p>
<p>base64 编码格式的图片说明：</p>
<ul>
<li>精灵图：将一些小图片合并为一张图片，减少请求次数，提高性能</li>
<li>字体图标：直接将一些小的图片,合并到字体文件中，并且不会失真</li>
<li>base64：是一种编码格式,能够将图片、文字等常见的文件，转化为 base64 格式，这种字符串格式浏览器能够识别并且读取显示到页面中</li>
<li>base64 是一个字符串，也可以直接被内嵌到页面中，或者 css 中</li>
<li>注意：大图片不适合用 base64 处理，只有小的图标才适合 base64 处理</li>
</ul>
<h3 id="处理字体文件"><a href="#处理字体文件" class="headerlink" title="处理字体文件"></a>处理字体文件</h3><p>在 <strong>main.js</strong> 中引入 css 文件 <code>import &#39;../css/iconfont/iconfont.css&#39;</code></p>
<p>在 webpack.config.js 中配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理字体图标</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(svg|woff|woff2|ttf|eot)$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;url-loader&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理-ES6-语法"><a href="#处理-ES6-语法" class="headerlink" title="处理 ES6 语法"></a>处理 ES6 语法</h3><ol>
<li>现在的项目都是使用 ES6 开发的，但是这些新的 ES6 语法，并不是所有的浏览器都支持，所以就需要有一个工具，帮我们转成 es5 语法，这个就是：babel</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvLw==">babel</span></li>
<li>Babel is a JavaScript compiler. ==&gt; babel 是一个 JavaScript 编译器</li>
<li>webpack 只能处理 import / export 这个 es6 模块化语法，而其他的 js 新语法，应该使用 babel 来处理</li>
</ol>
<p>babel 的使用 :</p>
<ul>
<li>安装： <code>npm i -D babel-core babel-loader@7</code><ul>
<li>babel-core 是 babel 的核心包</li>
<li>babel-loader 加载 js 文件，并将 js 代码内容交给 babel-core 解析为 es5 低版本的 js</li>
</ul>
</li>
</ul>
<ul>
<li>安装：<code>npm i -D babel-preset-env babel-preset-stage-2</code><ul>
<li>babel-preset-env：表示能够解析 es2015、es2016、es2017、es2018 这些标准的语法</li>
<li>babel-preset-stage-2：用来解析还没有被采纳为标准的语法</li>
<li><code>babel-polyfill与babel-plugin-transform-runtime</code> 也是做兼容处理的,以前都是用这个，兼容更早的</li>
</ul>
</li>
</ul>
<ul>
<li>配置 : 在 webpack.config.js 中添加一个 loader</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理 ES6 语法</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="comment">// 设置忽略 node-modules 文件夹</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node-modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在项目根目录中创建 babel 的配置文件，叫：<code>.babelrc</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;env&quot;,</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  -----------</span><br><span class="line">  // 暂时不用</span><br><span class="line">  // 如果未来某一天真的用到了polify</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-runtime&quot;, &#123;</span><br><span class="line">      &quot;helpers&quot;: false,</span><br><span class="line">      &quot;polyfill&quot;: true,</span><br><span class="line">      &quot;regenerator&quot;: true,</span><br><span class="line">      &quot;moduleName&quot;: &quot;babel-runtime&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="项目打包上线"><a href="#项目打包上线" class="headerlink" title="项目打包上线"></a>项目打包上线</h2><p>执行 : <code>npm run build</code> 对项目进行打包，生成 dist 文件</p>
<p>模拟本地服务器 : 安装 : <code>npm i -g http-server</code></p>
<p>把 dist 文件里的内容放到服务器里即可，直接运行<code>http-server</code></p>
<h2 id="webpack-和-gulp-区别"><a href="#webpack-和-gulp-区别" class="headerlink" title="webpack 和 gulp 区别"></a>webpack 和 gulp 区别</h2><ol>
<li>Gulp 侧重于前端开发的整个过程的控制管理（像是流水线），我们可以通过给 gulp 配置不通的 task（通过 Gulp 中的 gulp.task() 方法配置，比如启动 server、sass/less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程</li>
<li>Webpack 也称之为模块打包机 ，由此也可以看出 Webpack 更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js 文件、css 文件等）都可以看成模块，最初 Webpack 本身就是为前端 JS 代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack 是通过 loader（加载器）和 plugins（插件）对资源进行处理的</li>
<li>gulp 是构建工具，Webpack 是 js 模块化的解决方案</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/409.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/409.html" class="post-title-link" itemprop="url">nodejs 基本使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-12-29" itemprop="dateCreated datePublished" datetime="2018-12-29T22:21:15+00:00">2018-12-29</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="nodejs-基本介绍"><a href="#nodejs-基本介绍" class="headerlink" title="nodejs 基本介绍"></a>nodejs 基本介绍</h1><h2 id="为什么要学习-nodejs"><a href="#为什么要学习-nodejs" class="headerlink" title="为什么要学习 nodejs"></a>为什么要学习 nodejs</h2><ol>
<li>降低编程语言切换的成本(nodejs 实质上用的还是 javascript)</li>
<li>NodeJS 是前端项目的基础设施，前端项目中用到的大量工具 (大前端)</li>
<li>nodejs 在处理高并发上有得天独厚的优势(利用 nodejs 做中间层)</li>
<li>对于前端工程师，面试时对于 nodejs 有一定的要求</li>
</ol>
<h2 id="node-js-是什么？"><a href="#node-js-是什么？" class="headerlink" title="node.js 是什么？"></a>node.js 是什么？</h2><p>node.js，也叫作 node，或者 nodejs，指的都是一个平台</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnLw==">node.js 官方网站</span></li>
<li><span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi8=">node.js 中文网</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbm9kZWpzLm9yZy8=">node.js 中文社区</span></li>
</ol>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，nodejs 允许 javascript 代码运行在服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. nodejs不是一门新的编程语言，nodejs是在服务端运行javascript的运行环境</span><br><span class="line">2. 运行环境：写得程序想要运行必须要有对应的运行环境</span><br><span class="line">	php代码必须要有apache服务器</span><br><span class="line">	在web端，浏览器就是javascript的运行环境</span><br><span class="line">	在node端，nodejs就是javascript的运行环境</span><br><span class="line">2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。</span><br><span class="line">3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎</span><br></pre></td></tr></table></figure>

<p><strong>nodejs 的本质：不是一门新的编程语言，nodejs 是 javascript 运行在服务端的运行环境，编程语言还是 javascript</strong></p>
<h2 id="nodejs-与浏览器的区别"><a href="#nodejs-与浏览器的区别" class="headerlink" title="nodejs 与浏览器的区别"></a>nodejs 与浏览器的区别</h2><p>相同点：nodejs 与浏览器都是 js 的运行环境，都能够解析 js 程序。对于 ECMAScript 语法来说，在 nodejs 和浏览器中都能运行</p>
<p>不同点：nodejs 无法使用 DOM 和 BOM 的操作，浏览器无法执行 nodejs 中的文件操作等功能</p>
<h2 id="nodejs-可以干什么？"><a href="#nodejs-可以干什么？" class="headerlink" title="nodejs 可以干什么？"></a>nodejs 可以干什么？</h2><ol>
<li>开发服务端程序</li>
<li>开发命令行工具（CLI），比如 npm，webpack，gulp，less，sass 等</li>
<li>开发桌面应用程序（借助 node-webkit、electron 等框架实现）</li>
</ol>
<h1 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h1><h2 id="nodejs-版本"><a href="#nodejs-版本" class="headerlink" title="nodejs 版本"></a>nodejs 版本</h2><p>下载地址</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkLw==">当前版本</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL3JlbGVhc2VzLw==">历史版本</span></li>
</ul>
<p>官网术语解释</p>
<ul>
<li>LTS 版本：Long-term Support 版本，长期支持版，即稳定版。</li>
<li>Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入</li>
</ul>
<p>查看 node 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<h1 id="运行-nodejs-程序"><a href="#运行-nodejs-程序" class="headerlink" title="运行 nodejs 程序"></a>运行 nodejs 程序</h1><h2 id="方式一：使用-node-执行-js-文件"><a href="#方式一：使用-node-执行-js-文件" class="headerlink" title="方式一：使用 node 执行 js 文件"></a>方式一：使用 node 执行 js 文件</h2><ul>
<li><p>创建 js 文件 <code>helloworld.js</code></p>
</li>
<li><p>写 nodejs 的内容：<code>console.log(&#39;hello nodejs&#39;)</code></p>
</li>
<li><p>打开命令窗口 <code>cmd</code></p>
<ul>
<li>shift 加右键打开命令窗口，执行 <code>node 文件名.js</code>即可</li>
</ul>
</li>
<li><p>执行命令：<code>node helloworld.js</code></p>
</li>
</ul>
<p>注意：在 nodejs 中是无法使用 DOM 和 BOM 的内容的，因此<code>document</code>， <code>window</code>等内容是无法使用的</p>
<h2 id="方式二：REPL-介绍"><a href="#方式二：REPL-介绍" class="headerlink" title="方式二：REPL 介绍"></a>方式二：REPL 介绍</h2><ol>
<li>REPL 全称: Read-Eval-Print-Loop（交互式解释器）<ul>
<li>R 读取 - 读取用户输入，解析输入了 Javascript 数据结构并存储在内存中</li>
<li>E 执行 - 执行输入的数据结构</li>
<li>P 打印 - 输出结果</li>
<li>L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出</li>
</ul>
</li>
<li>在 REPL 中编写程序 （类似于浏览器开发人员工具中的控制台功能）<ul>
<li>直接在控制台输入 <code>node</code> 命令进入 REPL 环境</li>
</ul>
</li>
<li>按两次 Control + C 退出 REPL 界面 或者 输入 <code>.exit</code> 退出 REPL 界面<ul>
<li>按住 control 键不要放开, 然后按两下 c 键</li>
</ul>
</li>
</ol>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>当要求系统运行一个<strong>程序</strong> 而没有告诉它程序所在的完整路径时</p>
<ol>
<li>首先在<strong>当前目录</strong>中查找和该字符串匹配的可执行文件</li>
<li>进入用户 path 环境变量查找</li>
<li>进入系统 path 环境变量查找</li>
</ol>
<p>配置环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到环境变量：计算机 --右键--&gt; 属性 --&gt; 高级系统设置 --&gt; 高级 --&gt; 环境变量</span><br></pre></td></tr></table></figure>

<h1 id="global-模块-全局变量"><a href="#global-模块-全局变量" class="headerlink" title="global 模块-全局变量"></a>global 模块-全局变量</h1><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>
<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 <code>global</code>，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>
<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
<p><strong>常用的 global 属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>: 用于打印日志</span><br><span class="line"><span class="built_in">setTimeout</span>/<span class="built_in">clearTimeout</span>: 设置清除延时器</span><br><span class="line"><span class="built_in">setInterval</span>/<span class="built_in">clearInterval</span>: 设置清除定时器</span><br><span class="line"></span><br><span class="line"><span class="attr">__dirname</span>: 当前文件的路径，不包括文件名</span><br><span class="line">__filename：当前文件的路径，包括文件名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与模块化相关的，模块化的时候会用到</span></span><br><span class="line"><span class="built_in">require</span></span><br><span class="line"><span class="built_in">exports</span></span><br><span class="line"><span class="built_in">module</span></span><br></pre></td></tr></table></figure>

<h1 id="fs-模块"><a href="#fs-模块" class="headerlink" title="fs 模块"></a>fs 模块</h1><blockquote>
<p>fs 模块是 nodejs 中最常用的一个模块，因此掌握 fs 模块非常的有必要，fs 模块的方法非常多，用到了哪个查哪个即可。</p>
<p>文档地址：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbA==">http://nodejs.cn/api/fs.html</span></p>
</blockquote>
<p>在 nodejs 中，提供了 fs 模块，这是 node 的核心模块</p>
<p>注意：</p>
<ol>
<li>除了 global 模块中的内容可以直接使用，其他模块都是需要加载的。</li>
<li>fs 模块不是全局的，不能直接使用。因此需要导入才能使用。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><blockquote>
<p>语法：fs.readFile(file[, options], callback)</p>
</blockquote>
<p>方式一：不传编码参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件路径</span></span><br><span class="line"><span class="comment">// 参数2：读取文件的回调函数</span></span><br><span class="line"><span class="comment">// 回调函数参数1：错误对象，如果读取失败，err 会包含错误信息，如果读取成功，err 是 null</span></span><br><span class="line"><span class="comment">// 回调函数参数2：读取成功后的数据（是一个Buffer对象）</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;data.txt&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString()) <span class="comment">// 将Buffer对象转换成字符串</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>方式二：传编码参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件的路径</span></span><br><span class="line"><span class="comment">// 参数2：编码，如果设置了，返回一个字符串，如果没有设置，会返回一个buffer对象</span></span><br><span class="line"><span class="comment">// 参数3：回调函数</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>关于 Buffer 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Buffer对象是Nodejs用于处理二进制数据的</span><br><span class="line">2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制</span><br><span class="line">3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象</span><br><span class="line">4. Buffer对象可以调用toString()方法转换成字符串</span><br></pre></td></tr></table></figure>

<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><blockquote>
<p>语法：fs.writeFile(file, data[, options], callback)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件路径(如果文件不存在，会自动创建)</span></span><br><span class="line"><span class="comment">// 参数2：写入的文件内容（注意：写入的内容会覆盖以前的内容）</span></span><br><span class="line"><span class="comment">// 参数3：写文件后的回调函数</span></span><br><span class="line">fs.writeFile(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;写入文件失败&#x27;</span>, err)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;写入文件成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>写文件的时候，会把原来的内容给覆盖掉</li>
</ol>
<blockquote>
<p>语法：fs.appendFile(path, data[, options], callback)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：追加的文件名(如果文件不存在，会自动创建)</span></span><br><span class="line"><span class="comment">// 参数2：追加的文件内容</span></span><br><span class="line"><span class="comment">// 参数3：追加文件后的回调函数</span></span><br><span class="line">fs.appendFile(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;我是追加的内容&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;追加文件内容失败&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;追加文件内容成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>思考：如果没有 appendFile，通过 readFile 与 writeFile 应该怎么实现？</p>
<h2 id="文件同步与异步的说明"><a href="#文件同步与异步的说明" class="headerlink" title="文件同步与异步的说明"></a>文件同步与异步的说明</h2><blockquote>
<p>fs 中所有的文件操作，都提供了异步和同步两种方式</p>
</blockquote>
<p>异步方式：不会阻塞代码的执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">fs.readFile(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件失败&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;222&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>同步方式：会阻塞代码的执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步方式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line"><span class="keyword">const</span> result = fs.readFileSync(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">222</span>)</span><br></pre></td></tr></table></figure>

<p>总结：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。</p>
<h2 id="其他-api（了解）"><a href="#其他-api（了解）" class="headerlink" title="其他 api（了解）"></a>其他 api（了解）</h2><p>方法有很多，但是用起来都非常的简单，学会查文档</p>
<p>文档：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbA==">http://nodejs.cn/api/fs.html</span></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>fs.readFile(path, callback)</code></td>
<td>读取文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.readFileSync(path)</code></td>
<td>读取文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.writeFile(path, data, callback)</code></td>
<td>写入文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.writeFileSync(path, data)</code></td>
<td>写入文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.appendFile(path, data, callback)</code></td>
<td>追加文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.appendFileSync(path, data)</code></td>
<td>追加文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.rename(oldPath, newPath, callback)</code></td>
<td>重命名文件（异步）</td>
</tr>
<tr>
<td><code>fs.renameSync(oldPath, newPath)</code></td>
<td>重命名文件（同步）</td>
</tr>
<tr>
<td><code>fs.unlink(path, callback)</code></td>
<td>删除文件（异步）</td>
</tr>
<tr>
<td><code>fs.unlinkSync(path)</code></td>
<td>删除文件（同步）</td>
</tr>
<tr>
<td><code>fs.mkdir(path, mode, callback)</code></td>
<td>创建文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.mkdirSync(path, mode)</code></td>
<td>创建文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.rmdir(path, callback)</code></td>
<td>删除文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.rmdirSync(path)</code></td>
<td>删除文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.readdir(path, option, callback)</code></td>
<td>读取文件夹内容（异步）</td>
</tr>
<tr>
<td><code>fs.readdirSync(path, option)</code></td>
<td>读取文件夹内容（同步）</td>
</tr>
<tr>
<td><code>fs.stat(path, callback)</code></td>
<td>查看文件状态（异步）</td>
</tr>
<tr>
<td><code>fs.statSync(path)</code></td>
<td>查看文件状态（同步）</td>
</tr>
</tbody></table>
<h1 id="path-模块"><a href="#path-模块" class="headerlink" title="path 模块"></a>path 模块</h1><h2 id="路径操作的问题"><a href="#路径操作的问题" class="headerlink" title="路径操作的问题"></a>路径操作的问题</h2><p>在读写文件的时候，文件路径可以写相对路径或者绝对路径</p>
<p>data.txt 是相对路径，读取当前目录下的 data.txt，相对路径相对的是指向 node 命令的路径</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果node命令不是在当前目录下执行就会报错，在当前执行node命令的目录下查找data.txt，找不到</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件失败&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>相对路径：相对于执行 node 命令的路径</p>
<p>推荐使用绝对路径：<code>__dirname</code>: 当前文件的目录，<code>__filename</code>: 当前文件的目录，包含文件名</p>
<h2 id="path-模块的常用方法"><a href="#path-模块的常用方法" class="headerlink" title="path 模块的常用方法"></a>path 模块的常用方法</h2><blockquote>
<p>关于路径，在 linux 系统中，路径分隔符使用的是<code>/</code>，但是在 windows 系统中，路径使用的<code>\</code></p>
</blockquote>
<p>在我们拼写路径的时候会带来很多的麻烦，经常会出现 windows 下写的代码，在 linux 操作系统下执行不了，path 模块就是为了解决这个问题而存在的。</p>
<p>常用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.join() <span class="comment">// 拼接路径，返回拼接后的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// windows系统下</span></span><br><span class="line">path.join(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;gg&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abc\def\gg\a.html&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// linux系统下</span></span><br><span class="line">path.join(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;def&#x27;</span>,<span class="string">&#x27;gg&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abc/def/gg/index.html&#x27;</span></span><br><span class="line"></span><br><span class="line">【优化读写文件的代码】</span><br><span class="line"></span><br><span class="line">其他方法:</span><br><span class="line">path.basename(path[, ext])	返回文件的最后一部分</span><br><span class="line">path.dirname(path)	返回路径的目录名</span><br><span class="line">path.extname(path)	获取路径的扩展名(后缀名)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> temp = <span class="string">&#x27;abc\\def\\gg\\a.html&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(temp)) <span class="comment">//a.html</span></span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(temp)) <span class="comment">//abc\def\gg</span></span><br><span class="line"><span class="built_in">console</span>.log(path.extname(temp)) <span class="comment">//.html</span></span><br></pre></td></tr></table></figure>

<h2 id="path-模块其他-api（了解）"><a href="#path-模块其他-api（了解）" class="headerlink" title="path 模块其他 api（了解）"></a>path 模块其他 api（了解）</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>path.basename(path[, ext])</code></td>
<td>返回文件的最后一部分</td>
</tr>
<tr>
<td><code>path.dirname(path)</code></td>
<td>返回路径的目录名</td>
</tr>
<tr>
<td><code>path.extname(path)</code></td>
<td>获取路径的扩展名</td>
</tr>
<tr>
<td><code>path.isAbsolute(path)</code></td>
<td>判断目录是否是绝对路径</td>
</tr>
<tr>
<td><code>path.join([...paths])</code></td>
<td>将所有的 path 片段拼接成一个规范的路径</td>
</tr>
<tr>
<td><code>path.normalize(path)</code></td>
<td>规范化路径</td>
</tr>
<tr>
<td><code>path.parse(path)</code></td>
<td>将一个路径解析成一个 path 对象</td>
</tr>
<tr>
<td><code>path.format(pathObj)</code></td>
<td>讲一个 path 对象解析成一个规范的路径</td>
</tr>
</tbody></table>
<h1 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h1><h2 id="创建服务器基本步骤"><a href="#创建服务器基本步骤" class="headerlink" title="创建服务器基本步骤"></a>创建服务器基本步骤</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入http模块，http模块是node的核心模块，作用是用来创建 http 服务器的</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 服务器处理请求</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我接收到请求了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 启动服务器，监听某个端口</span></span><br><span class="line">server.listen(<span class="number">9999</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;服务器启动成功了, 请访问： http://localhost:9999&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>详细说明</p>
<ol>
<li>给服务器注册 request 事件，只要服务器接收到了客户端的请求，就会触发 request 事件</li>
<li>request 事件有两个参数，req 表示请求对象，可以获取所有与请求相关的信息，res 是响应对象，可以获取所有与响应相关的信息</li>
<li>服务器监听的端口范围为：1-65535 之间，推荐使用 3000 以上的端口，因为 3000 以下的端口一般留给系统使用</li>
</ol>
<h2 id="request-对象详解"><a href="#request-对象详解" class="headerlink" title="request 对象详解"></a>request 对象详解</h2><p>文档地址：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJz">http://nodejs.cn/api/http.html#http_message_headers</span></p>
<p>常见属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">headers: 所有的请求头信息</span><br><span class="line">method：请求的方式</span><br><span class="line">rawHeaders：所有的请求头信息（数组的方式）</span><br><span class="line">url：请求的地址（url地址的路径部分）</span><br><span class="line">	请求 http:<span class="comment">//127.0.0.1:3000/index 获取到的是：/index</span></span><br><span class="line">	请求 http:<span class="comment">//127.0.0.1:3000 获取到的是：/</span></span><br></pre></td></tr></table></figure>

<p>注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个<code>favicon.ico</code>的请求</p>
<p>小结：request 对象中，常用的就是 method 和 url 两个参数</p>
<h2 id="response-对象详解"><a href="#response-对象详解" class="headerlink" title="response 对象详解"></a>response 对象详解</h2><p>文档地址：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvaHR0cC5odG1sI2h0dHBfY2xhc3NfaHR0cF9zZXJ2ZXJyZXNwb25zZQ==">http://nodejs.cn/api/http.html#http_class_http_serverresponse</span></p>
<p>常见的属性和方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.write(data): 给浏览器发送响应体，可以调用多次，从而提供连续的响应体</span><br><span class="line">res.end()：通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成</span><br><span class="line">res.end(data)：结束请求，并且响应一段内容，相当于res.write(data) + res.end()</span><br><span class="line">res.statusCode: 响应的的状态码 <span class="number">200</span> <span class="number">404</span> <span class="number">500</span></span><br><span class="line">res.statusMessage: 响应的状态信息（不能有中文）， 如果不设置会根据statusCode自动设置</span><br><span class="line">res.setHeader(name, value)：设置响应头信息，比如<span class="string">&#x27;content-type&#x27;</span>，<span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line">res.writeHead(statusCode, statusMessage, options)：设置响应头，同时可以设置状态码和状态信息</span><br><span class="line">	options 是对象，写响应头的键值对</span><br></pre></td></tr></table></figure>

<p><strong>注意：必须先设置响应头，才能设置响应主体。</strong></p>
<ul>
<li><p>注意：浏览器中输入的 URL 地址，仅仅是一个标识，可以不与服务器中的文件路径一致。也就是说：返回什么内容是由服务端的逻辑决定</p>
</li>
<li><p>路由 : url 标示和对应文件/数据的一一对应关系</p>
</li>
</ul>
<h2 id="模拟-Apache-服务器"><a href="#模拟-Apache-服务器" class="headerlink" title="模拟 Apache 服务器"></a>模拟 Apache 服务器</h2><ul>
<li>根据 <code>req.url</code> 读取不同的页面内容，返回给浏览器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求: 简单模仿apache服务器，浏览器发送127.0.0.1:8888/index.html</span></span><br><span class="line"><span class="comment">// 对应的返回www文件夹下面的index.html的内容</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer()</span><br><span class="line"><span class="comment">// 监听请求</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 根据不同请求输出不同响应数据</span></span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">&#x27;/&#x27;</span> || req.url === <span class="string">&#x27;/i&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取www下面的index.html</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(__dirname, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">    fs.readFile(filename, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">&#x27;文件读取失败&#x27;</span>)</span><br><span class="line">      <span class="comment">// 服务器响应文件</span></span><br><span class="line">      res.statusCode = <span class="number">200</span></span><br><span class="line">      res.statusMessage = <span class="string">&#x27;ok&#x27;</span></span><br><span class="line">      res.setHeader(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>)</span><br><span class="line">      res.end(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url === <span class="string">&#x27;/l&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取list.html</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(__dirname, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;list.html&#x27;</span>)</span><br><span class="line">    fs.readFile(filename, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;文件读取失败&#x27;</span>)</span><br><span class="line">      <span class="comment">// 服务器响应文件</span></span><br><span class="line">      res.writeHead(<span class="number">200</span>, <span class="string">&#x27;OOOOOOK&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      res.end(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回浏览器, 未找到资源</span></span><br><span class="line">    res.writeHead(<span class="number">404</span>, <span class="string">&#x27;NOT FOUND&#x27;</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    res.end(<span class="string">&#x27;404 ,资源未找到&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 开启服务器</span></span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="MIME-类型"><a href="#MIME-类型" class="headerlink" title="MIME 类型"></a>MIME 类型</h2><ul>
<li>MIME(Multipurpose Internet Mail Extensions)多用途 Internet 邮件扩展类型 是一种表示文档性质和格式的标准化方式</li>
<li>浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的 MIME 类型附加到响应对象的头部是非常重要的</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9NSU1FX1R5cGVz">MIME 类型</span></li>
</ul>
<h2 id="mime-模块"><a href="#mime-模块" class="headerlink" title="mime 模块"></a>mime 模块</h2><ul>
<li>作用：获取文件的 MIME 类型</li>
<li>安装：<code>npm i mime</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mime = <span class="built_in">require</span>(<span class="string">&#x27;mime&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路径对应的 MIME 类型</span></span><br><span class="line">mime.getType(<span class="string">&#x27;txt&#x27;</span>) <span class="comment">// &#x27;text/plain&#x27;</span></span><br><span class="line"><span class="comment">// 根据 MIME 获取到文件后缀名</span></span><br><span class="line">mime.getExtension(<span class="string">&#x27;text/plain&#x27;</span>) <span class="comment">// &#x27;txt&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="nodemon-自动重启"><a href="#nodemon-自动重启" class="headerlink" title="nodemon 自动重启"></a>nodemon 自动重启</h1><ul>
<li>作用：监听到 js 文件修改后，自动重启 node 程序</li>
<li>安装：<code>npm i -g nodemon</code></li>
<li>使用：<code>nodemon app.js</code> 运行 node 程序</li>
</ul>
<h1 id="hacknews-案例"><a href="#hacknews-案例" class="headerlink" title="hacknews 案例"></a>hacknews 案例</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS8=">Hacker News 示例</span></li>
<li>路由（route）：就是一套映射规则，根据 url 地址分配到对应的处理程序</li>
</ul>
<h2 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h2><ul>
<li>1 新闻列表页 - /index get</li>
<li>2 新闻详情页 - /details get</li>
<li>3 新闻添加页 - /submit get</li>
<li>4 新闻添加请求 - /add post</li>
</ul>
<h2 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art-template 模板引擎"></a>art-template 模板引擎</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hdWkuZ2l0aHViLmlvL2FydC10ZW1wbGF0ZS96aC1jbi9kb2NzLw==">文档</span></li>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install art-template</span><br></pre></td></tr></table></figure>

<ul>
<li>核心方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于模板路径渲染模板</span></span><br><span class="line"><span class="comment">// 参数1：文件的路径</span></span><br><span class="line"><span class="comment">// 参数2：数据</span></span><br><span class="line"><span class="comment">// 返回值：返回渲染后的内容</span></span><br><span class="line"><span class="comment">// template(filename, data)</span></span><br><span class="line"><span class="keyword">let</span> html = template(path.join(__dirname, <span class="string">&#x27;pages&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>), &#123; <span class="attr">name</span>: <span class="string">&#x27;大吉大利，今晚吃鸡&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意点：文件的路径必须是绝对路径</strong>；会将整个 html 当做模板返回</p>
<h2 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a>url 模块</h2><ul>
<li>说明：用于 URL 处理与解析</li>
<li>注意：通过 url 拿到的查询参数都是字符串格式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入url模块</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 URL 字符串并返回一个 URL 对象</span></span><br><span class="line"><span class="comment">// 第一个参数：表示要解析的URL字符串</span></span><br><span class="line"><span class="comment">// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象</span></span><br><span class="line"><span class="keyword">var</span> ret = url.parse(<span class="string">&#x27;http://localhost:3000/details?id=1&amp;name=jack&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ret.query) <span class="comment">// &#123;id: &#x27;1&#x27;, name: &#x27;jack&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="querystring-模块"><a href="#querystring-模块" class="headerlink" title="querystring 模块"></a>querystring 模块</h2><ul>
<li>用于解析与格式化 URL 查询字符串</li>
<li>注意：只在专门处理查询字符串时使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo=bar&amp;abc=xyz&amp;abc=123</span></span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将查询参数转化为对象</span></span><br><span class="line"><span class="comment">// 第一个参数: 要解析的 URL 查询字符串</span></span><br><span class="line">querystring.parse(<span class="string">&#x27;foo=bar&amp;abc=xyz&#x27;</span>) <span class="comment">// &#123;foo: &#x27;bar&#x27;, abc: &#x27;xyz&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="服务端重定向"><a href="#服务端重定向" class="headerlink" title="服务端重定向"></a>服务端重定向</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9TdGF0dXM=">HTTP 状态码说明</span></li>
<li><span class="exturl" data-url="aHR0cDovL3NodWFpLmJlL2FyY2hpdmVzLzMwMS0zMDItcmVkaXJlY3Rpb24v">301 和 302</span></li>
<li>说明：服务端可以通过 HTTP 状态码让浏览器中的页面重定向</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.writeHead(<span class="number">302</span>, &#123;</span><br><span class="line">  <span class="attr">Location</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">res.end()</span><br></pre></td></tr></table></figure>

<h2 id="POST-请求参数的处理"><a href="#POST-请求参数的处理" class="headerlink" title="POST 请求参数的处理"></a>POST 请求参数的处理</h2><ul>
<li>说明：POST 请求可以发送大量数据，没有大小限制</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受POST参数</span></span><br><span class="line"><span class="keyword">var</span> postData = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// data事件：用来接受客户端发送过来的POST请求数据</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">  result += chunk</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// end事件：当POST数据接收完毕时，触发</span></span><br><span class="line">req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cosnole.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="模块化改造-hackerNews"><a href="#模块化改造-hackerNews" class="headerlink" title="模块化改造 hackerNews"></a>模块化改造 hackerNews</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/422.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/422.html" class="post-title-link" itemprop="url">gulp 前端自动化环境</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-12-12" itemprop="dateCreated datePublished" datetime="2018-12-12T22:28:56+00:00">2018-12-12</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前端自动化环境"><a href="#前端自动化环境" class="headerlink" title="前端自动化环境"></a>前端自动化环境</h1><p>实现一些简单的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 版本控制</span><br><span class="line">2. 编译SASS</span><br><span class="line">3. 检查JS</span><br><span class="line">4. 图片合并</span><br><span class="line">5. 压缩CSS</span><br><span class="line">6. 压缩JS</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这些都是每个 Web 项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。</p>
<p>构建工具： Gulp、Grunt、Webpack、…</p>
<h2 id="gulp-环境"><a href="#gulp-环境" class="headerlink" title="gulp 环境"></a>gulp 环境</h2><p>Gulp 是基于 Node.js 的，需要要安装 Node.js</p>
<h3 id="安装-4-0-版本"><a href="#安装-4-0-版本" class="headerlink" title="安装 # 4.0 版本"></a>安装 # 4.0 版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查 node 环境</span></span><br><span class="line">$ node -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装 gulp</span></span><br><span class="line">$ npm install -g gulp</span><br><span class="line">$ gulp -v  <span class="comment">#4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到你的在项目根文件夹下，运行</span></span><br><span class="line">$ npm install gulp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 gulp 功能插件依赖包</span></span><br><span class="line">$ npm install gulp-less gulp-sass gulp-concat gulp-connect gulp-rename</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>新建 <code>gulpfile.js</code> 配置文件放在项目根目录下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gulp3.x 配置不能直接在 4.0 上使用</span></span><br><span class="line"><span class="comment">// gulp4.0 配置内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"><span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">&#x27;gulp-less&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fileinclude = <span class="built_in">require</span>(<span class="string">&#x27;gulp-file-include&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> connect = <span class="built_in">require</span>(<span class="string">&#x27;gulp-connect&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 serve</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  connect.server(&#123;</span><br><span class="line">    <span class="attr">root</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="string">&#x27;8888&#x27;</span>,</span><br><span class="line">    <span class="comment">// 启用https</span></span><br><span class="line">    <span class="comment">// https: true,</span></span><br><span class="line">    <span class="attr">livereload</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译 less</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileLess</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    gulp</span><br><span class="line">      <span class="comment">// &#x27;!./**&#x27; 忽略文件</span></span><br><span class="line">      .src([<span class="string">&#x27;./less/*.less&#x27;</span>, <span class="string">&#x27;!./less/_*.less&#x27;</span>])</span><br><span class="line">      .pipe(less())</span><br><span class="line">      .pipe(gulp.dest(<span class="string">&#x27;./public/css&#x27;</span>))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html 刷新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshHtml</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./*.html&#x27;</span>).pipe(connect.reload())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入外部 html 文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileHtml</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src([<span class="string">&#x27;./*.html&#x27;</span>, <span class="string">&#x27;!./_*.html&#x27;</span>])</span><br><span class="line">    .pipe(</span><br><span class="line">      fileinclude(&#123;</span><br><span class="line">        <span class="attr">prefix</span>: <span class="string">&#x27;@@&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 html 中使用 `@@include(&#x27;_header-aside.html&#x27;)` 引入公共 html 结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听文件变化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  gulp.watch([<span class="string">&#x27;./less&#x27;</span>], compileLess)</span><br><span class="line">  gulp.watch([<span class="string">&#x27;./image&#x27;</span>], compileImg)</span><br><span class="line">  gulp.watch([<span class="string">&#x27;./js&#x27;</span>], compileJs)</span><br><span class="line">  gulp.watch([<span class="string">&#x27;./*.html&#x27;</span>], compileHtml)</span><br><span class="line">  gulp.watch([<span class="string">&#x27;./public&#x27;</span>], refreshHtml)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认任务，执行 gulp 会自动执行的任务</span></span><br><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>, gulp.parallel(serve, watch))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制 lib 文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyLib</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./lib/**/*&#x27;</span>).pipe(gulp.dest(<span class="string">&#x27;./dest/lib&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空 dest 文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> del([<span class="string">&#x27;./dest&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行-gulp-任务"><a href="#运行-gulp-任务" class="headerlink" title="运行 gulp 任务"></a>运行 gulp 任务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行定义的 default 任务</span></span><br><span class="line"><span class="comment"># $ gulp default</span></span><br><span class="line">$ gulp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独运行 sass 任务</span></span><br><span class="line">$ gulp less</span><br></pre></td></tr></table></figure>

<p><code>!./**</code> 忽略文件</p>
<p><code>gulp.parallel()</code> –并行运行任务</p>
<p><code>gulp.series()</code> –运行任务序列</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他 gulp 插件参考</span><br><span class="line">gulp-imagemin: 		压缩图片</span><br><span class="line">gulp-minify-css: 	压缩css</span><br><span class="line">gulp-uglify:      压缩js</span><br><span class="line">gulp-concat:    	合并文件</span><br><span class="line">gulp-rename:  		重命名文件</span><br><span class="line">gulp-htmlmin: 		压缩html</span><br><span class="line">gulp-clean:      	清空文件夹</span><br><span class="line">del:              删除文件</span><br></pre></td></tr></table></figure>

<p>gulp-connect 启动服务本机可以打开，局域网下手机打不开解决办法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">connect.server(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">  或</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;::&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 gulp 3.x 版本中报错会暂停监听需重新开启任务，4.0 修复了此问题</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudHVpY29vbC5jb20vYXJ0aWNsZXMvbkF6cWlhTg==">https://www.tuicool.com/articles/nAzqiaN</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/398.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/398.html" class="post-title-link" itemprop="url">防抖和节流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-12-12" itemprop="dateCreated datePublished" datetime="2018-12-12T22:13:29+00:00">2018-12-12</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>防抖和节流都是为了解决<strong>短时间内大量触发某函数</strong>而导致的<strong>性能问题，</strong>比如触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象</p>
</blockquote>
<h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>在事件被触发 n 秒后再执行回调函数，如果在这 n 秒内又被触发，则重新计时（只会触发最后一次）</p>
<p>应用场景</p>
<ul>
<li><p>用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询 ajax 请求，这样可以有效减少请求次数，节约请求资源</p>
</li>
<li><p>window 的 resize、scroll 事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次</p>
</li>
</ul>
<h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p>规定一个单位时间 n，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内事件被触发多次，只有一次能生效（每 n 秒触发一次）</p>
<p>应用场景</p>
<ul>
<li><p>鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次</p>
</li>
<li><p>在页面的无限加载场景下，需要用户在滚动页面时，每隔一段时间发一次 ajax 请求，而不是在用户停下滚动页面操作时才去请求数据</p>
</li>
<li><p>监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断</p>
</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>防抖的作用是将多个连续的<code>debounced</code>调用合并为一次<code>callback</code>调用。防抖是基于最近次 <code>debounced</code> 调用来重置 <code>waitTime</code>，如果<code>debounced</code>事件触发间隔小于 <code>waitTime</code>，<code>callback</code>就不会执行；</p>
<p>节流的作用是限制<code>callback</code>调用的频率（每<code>waitTime</code>调用一次）。是基于上次 <code>callback</code> 调用来计算 <code>waitTime</code> 的，不管<code>callback</code> 事件触发有多频繁，只要距离上次 <code>callback</code> 调用超过了 <code>waitTime</code>，就一定会进行下次 <code>callback</code> 调用。</p>
<p>– 原理：</p>
<p>防抖是 <code>debounced</code> 维护了一个计时器，规定在 <code>waitTime</code> 时间后触发 <code>callback</code>，但是在 <code>waitTime</code> 时间内再次触发 <code>debounced</code> 的话，会清除当前的 timer 然后重新计时，这样一来，只有最后一次<code>debounced</code> 操作才能触发 <code>callback</code>；</p>
<p>节流是通过判断是否到达一定时间 (<code>waitTime</code>) 来再次触发 <code>callback</code> ， <code>func</code> 在 <code>waitTime</code> 时间内不能被再次触发。</p>
<p>实现</p>
<p>throttle-debounce 插件 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdGhyb3R0bGUtZGVib3VuY2U=">https://www.npmjs.com/package/throttle-debounce</span></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">input.oninput = throttle(<span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = debounce(<span class="number">1000</span>, b)</span><br><span class="line">a.call(&#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">delay, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> lastExec = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> elapsed = <span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>()) - lastExec</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback.apply(self, args)</span><br><span class="line">      lastExec = <span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt; delay) &#123;</span><br><span class="line">      exec()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        exec()</span><br><span class="line">      &#125;, delay - elapsed)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">delay, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback.apply(self, args)</span><br><span class="line">      lastExec = <span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      exec()</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/425.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/425.html" class="post-title-link" itemprop="url">LESS 基本使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-12-11" itemprop="dateCreated datePublished" datetime="2018-12-11T22:30:46+00:00">2018-12-11</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Less-简介"><a href="#Less-简介" class="headerlink" title="Less 简介"></a>Less 简介</h2><blockquote>
<p><strong><em>Less</em>  是一门 CSS 预处理语言（预先处理）,它扩展了 CSS 语言，增加了变量、Mixin、函数等特性</strong></p>
<p>浏览器不直接识别 less 文件，浏览器只识别 css 文件，所以我们写了 less 文件之后，我们需要预先把 less 文件转换成 css 文件。</p>
</blockquote>
<p>本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。</p>
<p><strong>less 仅仅是写 css 的另一种方式，写出来的 less 文件浏览器也不识别，所以啊，我们写完了 less 文件，还需要通过 less 解析器解析成 css，最终浏览器引入的还是 css 文件。</strong></p>
<p>学习网站：</p>
<p><span class="exturl" data-url="aHR0cDovL2xlc3Njc3Mub3JnLw==">官网 http://lesscss.org/</span><br><span class="exturl" data-url="aHR0cDovL2xlc3Njc3MuY24v">中文网 http://lesscss.cn/</span></p>
<h2 id="less-的编译"><a href="#less-的编译" class="headerlink" title="less 的编译"></a>less 的编译</h2><blockquote>
<p>如何把 less 文件变成 css 文件</p>
</blockquote>
<h3 id="使用打包工具"><a href="#使用打包工具" class="headerlink" title="使用打包工具"></a>使用打包工具</h3><p><code>gulp</code></p>
<p><code>webpack</code></p>
<h3 id="使用考拉"><a href="#使用考拉" class="headerlink" title="使用考拉"></a>使用考拉</h3><blockquote>
<p>koala 是一个前端预处理器语言（less/sass）图形编译工具，支持 Less、Sass、Compass、CoffeeScript，帮助 web 开发者更高效地使用它们进行开发。跨平台运行，完美兼容 windows、linux、mac。</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cDovL2tvYWxhLWFwcC5jb20vaW5kZXgtemguaHRtbA==">考拉官网</span></p>
<p>使用步骤：</p>
<ol>
<li>把<code>less</code>文件夹拖进去</li>
<li>会在当前目录生成一个<code>css</code>目录</li>
</ol>
<p>优点：不用 node 环境，不用 less 环境，koala 内置了</p>
<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>easy less</p>
<h2 id="Less-语法"><a href="#Less-语法" class="headerlink" title="Less 语法"></a>Less 语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>注释</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是CSS中的注释，因此会编译到css中 */</span></span><br><span class="line"><span class="comment">// 这是less的注释，css不能识别这个注释， 最后不会编译到css文件</span></span><br></pre></td></tr></table></figure>

<p><strong>变量</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @变量名: 变量值;</span></span><br><span class="line"><span class="variable">@color:</span> <span class="number">#ccc</span>;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mixin-函数"><a href="#mixin-函数" class="headerlink" title="mixin 函数"></a>mixin 函数</h3><p><strong>混入函数</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数：不带参数</span></span><br><span class="line"><span class="selector-class">.btn</span>() &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="selector-class">.btn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数：带参数</span></span><br><span class="line"><span class="selector-class">.btn_border</span>(<span class="variable">@width</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@width</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="comment">// 如果函数定义了参数，调用的时候必须传入参数，否则会报错</span></span><br><span class="line">  <span class="selector-class">.btn_border</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数：带参数默认值</span></span><br><span class="line"><span class="selector-class">.btn_border</span>(<span class="variable">@width</span>: <span class="number">1px</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@width</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="comment">// 因为有默认值，所以不会报错</span></span><br><span class="line">  <span class="selector-class">.btn_border</span>();</span><br><span class="line">  <span class="selector-class">.btn_border</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：定义兼容多浏览器的圆角</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.border_radius</span>(<span class="variable">@value</span>: <span class="number">5px</span>) &#123;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.border_radius</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><blockquote>
<p>我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。</p>
</blockquote>
<ul>
<li>使用伪类的时候 可以使用<code>&amp;</code> 表示自己</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="comment">// 子代</span></span><br><span class="line">  <span class="selector-class">.son1</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后代</span></span><br><span class="line">  &gt; <span class="selector-class">.son2</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交集： &amp; 表示本身</span></span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-class">.now</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后缀名</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;variable&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;maxin&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>模块化的思想，分模块进行管理这些 less 文件，最终只需要使用 import 将 less 引入到一起即可</p>
<h3 id="函数（运算）"><a href="#函数（运算）" class="headerlink" title="函数（运算）"></a>函数（运算）</h3><blockquote>
<p>在我们的 CSS 中充斥着大量的数值型的 value，less 可以直接支持运算，也提供了一系列的函数提供给我们使用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: round(100%/6, 2);</span><br><span class="line">  height: 100px + 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cDovL3d3dy4xMDI0aS5jb20vZGVtby9sZXNzL3JlZmVyZW5jZS5odG1s">http://www.1024i.com/demo/less/reference.html</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/390.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/390.html" class="post-title-link" itemprop="url">bootstrap 框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-12-11" itemprop="dateCreated datePublished" datetime="2018-12-11T22:06:47+00:00">2018-12-11</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ib290Y3NzLmNvbS8=">bootstrap 中文网</span></p>
<p>特点：</p>
<ul>
<li>组件简洁大方、代码规范精简、界面自定义性强</li>
<li>Bootstrap 是基于 HTML5 和 CSS3 开发的，它在 jQuery 的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分 jQuery 插件</li>
<li>Bootstrap 中包含了丰富的 Web 组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站</li>
</ul>
<p>优点：</p>
<ul>
<li>有自己的生态圈，不断的更新迭代</li>
<li>提供了一套简洁、直观、强悍的组件</li>
<li>标准化的 HTML+CSS 编码规范</li>
<li>让开发更简单，提高了开发效率</li>
<li>扩展性强，虽然界面组件样式已经定义好了，我们还可以自定义，修改默认样式</li>
</ul>
<p>版本：</p>
<ul>
<li>2.x.x 停止维护<ul>
<li>优点：兼容性好 IE678</li>
<li>缺点：代码不够简洁、功能不够完善</li>
</ul>
</li>
<li>3.x.x <strong>目前使用最多（H5C3 很多东西）</strong><ul>
<li>优点：稳定，偏向于开发响应式布局，移动设备优先的 WEB 项目</li>
<li>缺点：放弃了 IE67，对 IE8 支持但是界面效果不友好</li>
</ul>
</li>
<li>4.x.x 测试阶段</li>
</ul>
<h2 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h2><p>!&gt; 但凡看到 <code>role属性</code> <code>aria-*的属性</code> <code>class=&#39;sr-only&#39;的标签</code> 都可以直接删除，因为是给屏幕阅读器用的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>bootstrap基本模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 bootstrap 的核心样式文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;lib/bootstrap/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- html5shiv 是用来解决 IE8 以下浏览器不支持 HTML5 语义化标签的问题 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- respond 是用来解决 IE8 以下浏览器不支持媒体查询的问题，注意：respond 不支持 file 协议打开 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 条件注释：IE浏览器专属 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;respond.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">  &lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- bootstrap 依赖于 jquery，因此需要在 bootstrap 之前引入jquery文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/jquery/jquery-1.12.4.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 bootstrap 的核心js文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/bootstrap/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h2><h3 id="normalize-css"><a href="#normalize-css" class="headerlink" title="normalize.css"></a>normalize.css</h3><p>Normalize.css 是一种 CSS reset 的替代方案。经过@necolas 和@jon_neal 花了几百个小时来努力研究不同浏览器的默认样式的差异，这个项目终于变成了现在这样</p>
<p><span class="exturl" data-url="aHR0cDovL25lY29sYXMuZ2l0aHViLmlvL25vcm1hbGl6ZS5jc3Mv">官网</span> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcw==">github 网址</span></p>
<p>normalize 的特点：</p>
<ul>
<li><strong>保护有用的浏览器默认样式</strong>而不是完全去掉它们</li>
<li><strong>一般化的样式</strong>：为大部分 HTML 元素提供</li>
<li><strong>修复浏览器自身的 bug</strong>并保证各浏览器的一致性</li>
<li><strong>优化 CSS 可用性</strong>：用一些小技巧</li>
</ul>
<p><code>Normalize.css</code> 支持包括手机浏览器在内的超多浏览器，同时对 HTML5 元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS93ZWJwdXNoL3AvNDk3NDA2My5odG1s">Normalize.css 与 CSS reset 区别</span></p>
<h3 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h3><p>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。默认带了 15px 的 padding 值</p>
<p><code>.container</code> 类用于固定宽度并支持响应式布局的容器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>.container-fluid</code> 类用于 100% 宽度，占据全部视口（viewport）的容器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两种容器类不能互相嵌套</p>
<h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>栅格系统，也叫网格系统，bootstrap 栅格系统把一个盒子分成 12 格</p>
<ul>
<li><p>栅格参数：<code>col-xx-yy</code></p>
<p>xx：<code>lg</code> 大屏(≥1200px)、<code>md</code> 中屏(≥992px)、<code>sm</code> 小屏(≥768px)、<code>xs</code> 超小屏(&lt;768px)</p>
<p>yy：取值范围为 1 - 12 表示占几格</p>
<p><code>col-xx-12</code>：可以省略不写</p>
</li>
<li><p>列偏移：<code>col-xx-offset-yy</code></p>
<p>xx ：lg、md、sm、xs</p>
<p>yy：取值范围为 1 - 12 表示往右偏移几格</p>
<p>列偏移：实际上是给当前元素增加了左侧的边距（margin）</p>
</li>
<li><p>多余列（column）的元素将作为一个整体单元被另起一行排列</p>
</li>
<li><p><code>.row</code>用于抵消 <code>.container</code>容器的 15px 的 padding 值，实际上是给元素添加了 margin: -15px</p>
</li>
<li><p>可以在<code>.row</code>中嵌套<code>column</code></p>
</li>
<li><p>列排序：<code>.col-md-push-*</code> 和 <code>.col-md-pull-*</code></p>
</li>
</ul>
<p>栅格系统常用类（总共 12 列）</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>例子</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>.col-xs-xx</td>
<td>.col-xs-6</td>
<td>在超小屏幕（及以上）生效</td>
</tr>
<tr>
<td>.col-sm-xx</td>
<td>.col-sm-6</td>
<td>在小屏幕（及以上）生效</td>
</tr>
<tr>
<td>.col-md-xx</td>
<td>.col-md-6</td>
<td>在中屏幕（及以上）生效</td>
</tr>
<tr>
<td>.col-lg-xx</td>
<td>.col-lg-3</td>
<td>在大屏幕及生效，占 1/4</td>
</tr>
<tr>
<td>.col-lg-xx</td>
<td>.col-lg-4</td>
<td>在大屏幕及生效，占 1/3</td>
</tr>
<tr>
<td>.col-lg-xx</td>
<td>.col-lg-5</td>
<td>在大屏幕及生效，占 1/2</td>
</tr>
</tbody></table>
<p>【案例：列嵌套.html】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-4&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 栅格系统无处不在，只要父盒子有宽度，就可以使用栅格系统 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>【案例：列偏移.html】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 .col-md-offset-* 类可以将列向右侧偏移--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- col-lg-offset-3:在大屏下，这个div将向右侧偏移3个单位 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-6 col-lg-offset-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><p>标题：h1 到 h6 标签、<code>.h1</code> 到 <code>.h6</code> 类、 <code>&lt;small&gt;</code> 标签或 <code>.small</code> 类用来标记副标题</p>
<p>文本：<code>&lt;mark&gt;</code>标记、<code>&lt;del&gt;</code>删除、<code>&lt;s&gt;</code>无用文本、<code>&lt;ins&gt;</code>插入文本、<code>&lt;u&gt;</code>下划线文本、 <code>.small</code> 类或<code>&lt;small&gt;</code> 小号文本、<code>&lt;strong&gt;</code>着重</p>
<p>对齐：<code>text-left</code>、<code>text-center</code>、<code>text-right</code>、<code>text-justify</code>、<code>text-nowrap</code></p>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p><code>&lt;a&gt;</code>、<code>&lt;button&gt;</code> 或 <code>&lt;input&gt;</code></p>
<p>预定义样式：btn、btn-default、btn-primary(蓝)、btn-success(绿)、btn-info(浅蓝)、btn-warning(橙)、btn-danger(红)、btn-link(链接)</p>
<p>尺寸：btn-lg(大)、(默认)、btn-sm(小)、btn-xs(超小)<br>btn-block (块元素 100%宽度)</p>
<p>激活状态：active</p>
<p>禁用状态：button 元素 添加 <code>disabled</code> 属性、链接<code>&lt;a&gt;</code>元素添加 <code>.disabled</code> 类（建议通过 JavaScript 代码来禁止链接的原始功能）</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>响应式图片：<code>img-responsive</code></p>
<p>实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性</p>
<p>图片形状：<code>img-rounded</code>、<code>img-circle</code>、<code>img-thumbnail</code></p>
<h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><p>文本颜色：<code>text-muted</code>、<code>text-muted</code>、<code>text-primary</code>、<code>text-success</code>、<code>text-info</code>、<code>text-warning</code>、<code>text-danger</code></p>
<p>背景颜色：<code>bg-primary</code>、<code>bg-success</code>、<code>bg-info</code>、<code>bg-warning</code>、<code>bg-danger</code></p>
<p>关闭按钮：<code>&lt;button type=&quot;button&quot; class=&quot;close&quot;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;</code></p>
<p>三角符号：<code>&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</code></p>
<p>快速浮动：<code>pull-left</code>、<code>pull-right</code></p>
<p>让内容块居中：<code>&lt;div class=&quot;center-block&quot;&gt;...&lt;/div&gt;</code></p>
<p>清除浮动：<code>clearfix</code></p>
<p>显示隐藏内容：<code>show</code>、<code>hidden</code>、<code>invisible</code></p>
<h3 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	            超小屏 小屏幕 中等屏幕 大屏幕桌面</span><br><span class="line">.visible-xs-*	可见   隐藏   隐藏	  隐藏</span><br><span class="line">.visible-sm-*	隐藏   可见   隐藏	  隐藏</span><br><span class="line">.visible-md-*	隐藏   隐藏   可见	  隐藏</span><br><span class="line">.visible-lg-*	隐藏   隐藏   隐藏	  可见</span><br><span class="line"></span><br><span class="line">.hidden-xs	  隐藏	 可见	  可见	  可见</span><br><span class="line">.hidden-sm	  可见	 隐藏	  可见	  可见</span><br><span class="line">.hidden-md	  可见	 可见	  隐藏	  可见</span><br><span class="line">.hidden-lg    可见	 可见	  可见	  隐藏</span><br></pre></td></tr></table></figure>

<p><code>*</code> -&gt; block inline inline-block</p>
<p>推荐使用 hidden 相关的属性</p>
<h2 id="bootstrap-validator-插件"><a href="#bootstrap-validator-插件" class="headerlink" title="bootstrap-validator 插件"></a>bootstrap-validator 插件</h2><p>基于 bootstrap 的前端校验插件</p>
<p><span class="exturl" data-url="aHR0cDovL2Jvb3RzdHJhcHZhbGlkYXRvci52b3RpbnRzZXYucnUvYXBp">http://bootstrapvalidator.votintsev.ru/api</span></p>
<h3 id="引包"><a href="#引包" class="headerlink" title="引包"></a>引包</h3><p>引入 css 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;lib/bootstrap/css/bootstrap.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;lib/bootstrap-validator/css/bootstrapValidator.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入 js 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/jquery/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/bootstrap/js/bootstrap.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/bootstrap-validator/js/bootstrapValidator.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化表单校验插件"><a href="#初始化表单校验插件" class="headerlink" title="初始化表单校验插件"></a>初始化表单校验插件</h3><p>bootstrap-validator 插件会在表单提交的时候进行校验，如果校验成功了，表单会继续提交，但是如果校验失败了，就会阻止表单的提交</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用表单校验插件</span></span><br><span class="line">$(formSelector).bootstrapValidator(&#123;</span><br><span class="line">  <span class="comment">// 1. 指定不校验的类型，默认为[&#x27;:disabled&#x27;, &#x27;:hidden&#x27;, &#x27;:not(:visible)&#x27;],可以不设置</span></span><br><span class="line">  <span class="attr">excluded</span>: [], <span class="comment">// 全部校验</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 指定校验时的图标显示，默认是bootstrap风格</span></span><br><span class="line">  <span class="attr">feedbackIcons</span>: &#123;</span><br><span class="line">    <span class="attr">valid</span>: <span class="string">&#x27;glyphicon glyphicon-ok&#x27;</span>,</span><br><span class="line">    <span class="attr">invalid</span>: <span class="string">&#x27;glyphicon glyphicon-remove&#x27;</span>,</span><br><span class="line">    <span class="attr">validating</span>: <span class="string">&#x27;glyphicon glyphicon-refresh&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 指定校验字段</span></span><br><span class="line">  <span class="attr">fields</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: &#123;</span><br><span class="line">      <span class="comment">// 设置校验规则</span></span><br><span class="line">      <span class="attr">validators</span>: &#123;</span><br><span class="line">        <span class="comment">// 不能为空</span></span><br><span class="line">        <span class="attr">notEmpty</span>: &#123;</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">stringLength</span>: &#123;</span><br><span class="line">          <span class="attr">min</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">max</span>: <span class="number">12</span>,</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 正则校验</span></span><br><span class="line">        <span class="attr">regexp</span>: &#123;</span><br><span class="line">          <span class="attr">regexp</span>: <span class="regexp">/^[a-zA-Z0-9_\.]+$/</span>,</span><br><span class="line">          message: <span class="string">&#x27;用户名由数字字母下划线和.组成&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="attr">callback</span>: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">password</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="注册表单校验成功的事件"><a href="#注册表单校验成功的事件" class="headerlink" title="注册表单校验成功的事件"></a>注册表单校验成功的事件</h3><p>当表单校验成功时，会触发<code>success.form.bv</code>事件，此时会提交表单，通常我们需要禁止表单的自动提交，使用 ajax 进行表单的提交</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#form&#x27;</span>).on(<span class="string">&#x27;success.form.bv&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="comment">// 使用ajax提交逻辑</span></span><br><span class="line">  $.ajax(&#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="获取-validator-实例-对象"><a href="#获取-validator-实例-对象" class="headerlink" title="获取 validator 实例(对象)"></a>获取 validator 实例(对象)</h3><p>当我们初始化好表单校验插件时，我们可以通过以下方法来获取表单校验的 validator 实例，通过 validator 实例调用一些方法来完成某些功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取表单校验实例</span></span><br><span class="line"><span class="keyword">var</span> validator = $(<span class="string">&#x27;#form&#x27;</span>).data(<span class="string">&#x27;bootstrapValidator&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用表单校验实例可以调用一些常用的方法</span></span><br><span class="line">validator.methodName(params)</span><br></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h4><p>重置表单中设置过校验的内容，将隐藏所有错误提示和图标</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重置表单，隐藏所有的错误提示和图标 传入参数 true 会将内容也清空</span></span><br><span class="line">validator.resetForm()</span><br></pre></td></tr></table></figure>

<h4 id="更新字段的状态"><a href="#更新字段的状态" class="headerlink" title="更新字段的状态"></a>更新字段的状态</h4><p>BootstrapValidator 在用户输入内容的时候，会做校验，当调用 bootstrap 的插件的方法可以手动会改变字段值的状态</p>
<p><code>validator.updateStatus(field*, status*, validator)</code></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>field</code></td>
<td>String|jQuery</td>
<td>The field name or field element</td>
</tr>
<tr>
<td><code>status</code></td>
<td>String</td>
<td>Can be <code>NOT_VALIDATED</code>, <code>VALIDATING</code>, <code>INVALID</code> or <code>VALID</code></td>
</tr>
<tr>
<td><code>validator</code></td>
<td>String</td>
<td>The validator name. If <code>null</code>, the method updates validity result for all validators</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/389.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/389.html" class="post-title-link" itemprop="url">移动 web</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-12-11" itemprop="dateCreated datePublished" datetime="2018-12-11T22:05:45+00:00">2018-12-11</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="移动-web-基础"><a href="#移动-web-基础" class="headerlink" title="移动 web 基础"></a>移动 web 基础</h1><h2 id="移动端开发现状"><a href="#移动端开发现状" class="headerlink" title="移动端开发现状"></a>移动端开发现状</h2><ul>
<li>移动 web 开发指的是需要适配移动设备的网页开发</li>
<li>移动 web 开发与 pc 端 web 开发没有本质的区别，使用的还是 HTML/CSS/JavaScript 的技术</li>
<li>移动 web 开发与 pc 端 web 开发的区别是什么？</li>
</ul>
<p>移动端的浏览器与 pc 端不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">谷歌浏览器 苹果浏览器、 UC浏览器 QQ浏览器 欧朋浏览器 百度手机浏览器  360安全浏览器  搜狗浏览器  猎豹浏览器等</span><br><span class="line">国内的手机浏览器都是根据webkit内核修改过来的，国内没有自主研发的内核，国内的操作系统也是基于Android系统修改的。</span><br><span class="line"></span><br><span class="line">因此在移动端，css3 属性只需要加 webkit 前缀即可</span><br></pre></td></tr></table></figure>

<p>移动端设备尺寸不一样(尺寸非常多，碎片化很严重)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Android： <span class="number">320</span>*<span class="number">480</span> <span class="number">480</span>*<span class="number">800</span>  <span class="number">540</span>*<span class="number">960</span> <span class="number">720</span>*<span class="number">1280</span> <span class="number">1080</span>*<span class="number">1920</span> 2k屏 4k屏</span><br><span class="line">iphpne：  <span class="number">640</span>*<span class="number">960</span> <span class="number">640</span>*<span class="number">1136</span> <span class="number">750</span>*<span class="number">1334</span> <span class="number">1242</span>*<span class="number">2208</span></span><br></pre></td></tr></table></figure>

<h2 id="移动端开发分类"><a href="#移动端开发分类" class="headerlink" title="移动端开发分类"></a>移动端开发分类</h2><ul>
<li>原生 app（native app）</li>
<li>混合 app（Hybrid app）</li>
<li>web 应用（webApp）</li>
</ul>
<p><strong>原生 app（native app）</strong></p>
<blockquote>
<p>原生 app 是基于操作系统的开发，比如安卓，ios，windows phone,他们只能在各自的操作系统上运行。</p>
</blockquote>
<p>优点：</p>
<ol>
<li>可以访问操作系统，获取更多的资源（gps，摄像头，传感器，麦克风等）</li>
<li>速度快，性能高，用户体验好</li>
<li>可以离线使用</li>
</ol>
<p>缺点：</p>
<ol>
<li>开发成本高</li>
<li>需要安装和更新，更新与发布需要审核。</li>
</ol>
<p><strong>Web App</strong></p>
<blockquote>
<p>Web 应用使用 H5C3 开发页面，为浏览器设计的基于 web 的应用，可以在各种智能设备的手机浏览器上运行。不需要安装即可运行。</p>
</blockquote>
<p>优点：</p>
<ol>
<li>支持设备广泛</li>
<li>开发成本低（使用）</li>
<li>可以随时上线与更新，无需审核</li>
</ol>
<p>缺点：</p>
<ol>
<li>用户体验极度依赖网速</li>
<li>要求联网</li>
<li>无法获取手机的资源（gps，摄像头）</li>
</ol>
<p><strong>混合 app（Hybrid App）</strong></p>
<blockquote>
<p>Hybrid App 是指介于 web-app、native-app 这两者之间的 app,它虽然看上去是一个 Native App，但只有一个 UI WebView，里面访问的是一个 Web App。（淘宝、京东、手机百度）</p>
</blockquote>
<p>Hybird App 说白了就是使用了 Native app 的壳，里面其实还是 HTML5 页面</p>
<p>优点：</p>
<ol>
<li>开发成本和难度更低，兼容多个平台</li>
<li>也可以访问手机的操作系统资源。</li>
<li>更新维护更方便</li>
</ol>
<p>缺点：</p>
<ol>
<li>用户体验相比原生 app 稍差</li>
<li>性能依赖于网速</li>
</ol>
<p>总结：</p>
<p>三种开发各有优缺点，具体用什么需要根据实际情况而定，比如预算，app 注重功能还是内容等</p>
<h2 id="屏幕与分辨率"><a href="#屏幕与分辨率" class="headerlink" title="屏幕与分辨率"></a>屏幕与分辨率</h2><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMTc1Mzg1NQ==">理解设备像素、设备独立像素和 css 像素</span></p>
<blockquote>
<p>移动设备与 PC 设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面</p>
</blockquote>
<p>屏幕尺寸</p>
<p>通常我们所指的屏幕<code>尺寸</code>，实际上指的是屏幕对角线的长度（一般用英寸来度量）</p>
<p><code>1英寸 = 2.54厘米</code></p>
<p>屏幕分辨率</p>
<p>分辨率则一般用像素来度量，表示屏幕水平和垂直方向的像素数，例如 1920*1080 指的是屏幕垂直方向和水平方向分别有 1920 和 1080 个像素点而构成</p>
<p><code>像素</code>：指计算机显示设备中的最小单位，即一个像素点的大小。每一个像素点可以理解为就是屏幕上的一个发光点</p>
<p>像素密度 ppi</p>
<p><code>PPI (Pixels Per Inch)</code>表示屏幕每英寸的像素数</p>
<p>PPI 值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙</p>
<h2 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a>设备像素</h2><blockquote>
<p>设备像素 (device pixels）也叫物理像素</p>
</blockquote>
<p>设备像素指的是显示器上的真实像素，每个像素的大小是屏幕固有的属性，屏幕出厂以后就不会改变了</p>
<p>设备分辨率描述的就是这个显示器的宽和高分别是多少个设备像素</p>
<p>设备像素和设备分辨率交给操作系统来管理，浏览器不知道、也不需要知道设备分辨率的大小，浏览器只需要知道<strong>逻辑分辨率</strong>就可以了</p>
<h2 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h2><blockquote>
<p>设备独立像素（Device Independent Pixels）也叫逻辑像素、设备无关像素。在 IOS 设备上叫<code>PT</code>，Android 设备上叫<code>DP</code>，在 css 中，叫<code>PX</code></p>
</blockquote>
<p>为了能够保证 <code>图像内容在不同的 PPI 设备看上去大小应该差不多</code> ，操作系统定义了一个单位：设备独立像素，用设备独立像素定义的尺寸，不管屏幕的参数如何，都能以合适的大小显示（这也是设备独立像素名字的由来）</p>
<p>对于那些像素密度高的屏幕，操作系统将多个设备像素划分为一个逻辑像素。屏幕的像素密度越高，就需要更多的设备像素来显示一个设备独立像素。至于将多少设备像素划分为一个逻辑像素，这由操作系统决定</p>
<p>获取设备的像素比</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.devicePixelRatio <span class="comment">// 物理像素 与 css 像素的比值 DPR</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>screen.width/height</code>得到的屏幕宽度和高度就是逻辑分辨率（单位：设备独立像素）</p>
<h2 id="css-像素与缩放"><a href="#css-像素与缩放" class="headerlink" title="css 像素与缩放"></a>css 像素与缩放</h2><p>在缩放比例为 100% 的情况下，一个 css 像素大小等于一个设备独立像素</p>
<p>缩放页面的时候，元素的 css 像素数量不会改变，改变的只是每个 css 像素的大小</p>
<p>缩放比例 = css 像素边长 / 设备独立像素边长</p>
<p>如果原本元素宽度为 128 个设备独立像素，那么缩放 200% 以后元素宽度为 256 个设备独立像素（css 像素宽度始终是 128）</p>
<p>桌面浏览器上缩放机制是 page zoom，缩放会导致 CSS 像素边长的改变，从而导致 window.devicePixelRatio 的改变</p>
<p>在移动端缩放机制是 pinch zoom，计算 window.devicePixelRatio 时，不考虑 pinch zoom 对 CSS 像素尺寸的影响，因此 window.devicePixelRatio 不会随缩放而改变</p>
<h2 id="2-倍图与-3-倍图"><a href="#2-倍图与-3-倍图" class="headerlink" title="2 倍图与 3 倍图"></a>2 倍图与 3 倍图</h2><blockquote>
<p>以后同学在工作的过程中，从 UI 那拿到的设计图通常都是 640 的设计图或者是 750 的设计图</p>
</blockquote>
<p>把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度</p>
<p>设备像素比 devicePixelRatio：即像素的压缩比例</p>
<p><strong>结论 ：在移动端为了在高清屏手机上显示得更加细腻，通常会使用更大的图片，比如 2 倍图或者 3 倍图</strong></p>
<h2 id="视口-viewport"><a href="#视口-viewport" class="headerlink" title="视口 viewport"></a>视口 viewport</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题：一个电脑上的网站，在手机端访问，效果是什么样的？</span><br><span class="line"></span><br><span class="line">iPhone5 的设备宽度只有 320px，一张宽度为 640px 的图片在手机端访问，显示的效果是什么？</span><br><span class="line"></span><br><span class="line">1. 在手机端，html的 大小都是 980px，为什么？</span><br><span class="line">这主要是历史原因导致的，因为在移动设备刚流行的时候，网站大多都是pc端的，pc端的页面宽度一般都比较大，移动设备的宽度比较小，如果pc端页面直接在移动端显示的话，页面就会错乱。为了解决这个问题，移动端html的大小直接就定死成了980px（因为早起的pc端网站版心就是980px居多）</span><br><span class="line"></span><br><span class="line">2. 视口</span><br><span class="line">在 pc 端，html 的大小默认是继承了浏览器的宽度，即浏览器多宽，html 的大小就是多宽，但是在移动端，多出来了一个视口的概念（乔布斯）,视口说白了就是介于浏览器与 html 之间的一个东西，视口的宽度默认定死了 980px，因此 html 的宽度默认就是 980px，视口的特点是能够根据设备的宽度进行缩放</span><br><span class="line"></span><br><span class="line">3. 视口设置</span><br><span class="line">对于现在的移动端页面来说，视口默认为 980px 肯定不合适，因为设备宽度不够的话，视口会进行缩放，导致页面展示效果不好看</span><br></pre></td></tr></table></figure>

<p><strong>视口参数设置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// width 设置视口的宽度</span></span><br><span class="line"><span class="comment">// width=device-width   设置视口宽度为设备的宽度（常用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initial-scale 设置初始缩放比例</span></span><br><span class="line"><span class="comment">// initial-scale=1.0  表示不缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user-scalable 设置是否允许用户缩放</span></span><br><span class="line"><span class="comment">// user-scalable=no  不允许用户缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum-scale  设置允许的最大缩放比例</span></span><br><span class="line"><span class="comment">// maximum-scale=1.0  可以不设置，因为都禁止用户缩放了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// minimum-scale 设置允许最小缩放比</span></span><br><span class="line"><span class="comment">// minimum-scale=1.0  不设置，因为都禁用用户缩放了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准写法：</span></span><br><span class="line"><span class="comment">// 快捷键：  meta:vp + tab键</span></span><br><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="移动端调试问题"><a href="#移动端调试问题" class="headerlink" title="移动端调试问题"></a>移动端调试问题</h2><ol>
<li>模拟器调试</li>
<li>真机调试：使用手机进行访问。</li>
</ol>
<p>手机设备五花八门，屏幕尺寸都大不一样，尤其是安卓端，给我们的页面预览带来了一些麻烦。在实际工作中，作为开发者不可能有足够的设备让我们去测试（<strong>除了测试部门</strong> ），即便有，效率也特别的低，因此开发者一般都是通过浏览器的手机模拟器来模拟不同的设备。</p>
<h1 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h1><p><strong>移动端的特点</strong></p>
<ul>
<li>手机端的兼容性问题比 PC 端小很多，因为手机端的浏览器版本比较新</li>
<li>手机端屏幕比较小，能够放的内容比较少。</li>
</ul>
<p>问题：布局的时候怎么解决屏幕大小不一致的问题？</p>
<ul>
<li>PC 端，固定版心，让所有分辨率的电脑的版心都是一样的，比如京东</li>
<li>移动端：移动端无法设置版心，因为移动端的设备屏幕本身就小，设置版心不合适。因此移动端大多会采用流式布局（百分比布局）</li>
</ul>
<p><strong>流式布局</strong>，也叫百分比布局，是移动端开发中经常使用的布局方式之一。</p>
<p>流式布局的特征：</p>
<ul>
<li>宽度自适应，高度写死，并不是百分百还原设计图</li>
<li>图标都是固定死大小的，包括字体等也是固定死的。并不是所有的东西都是自适应的。</li>
<li>一些大的图片，设置宽度为百分比自适应即可，随着屏幕大小进行变化</li>
</ul>
<p><strong>流式布局无法做到所有设备都非常逼真的还原设计图，有些设备显示效果不是特别的好看。但是流式布局是移动端非常常用的一种布局方式，比较简单，需要掌握（携程、京东)</strong></p>
<p><strong>最后一天会学习 rem 布局，配合 less 非常的方便，并且能够实现完全的自适应，包括字体以及图标等</strong></p>
<p>经典的流式布局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 左侧固定，右侧自适应</span><br><span class="line">2. 右侧固定，左侧自适应</span><br><span class="line">3. 两侧固定，中间自适应（圣杯布局，双飞翼布局）</span><br><span class="line">4. 等分布局</span><br></pre></td></tr></table></figure>

<h1 id="touch-事件"><a href="#touch-事件" class="headerlink" title="touch 事件"></a>touch 事件</h1><p>移动端新增了 4 个与手指触摸相关的事件</p>
<ul>
<li><code>touchstart</code>: 手指放到屏幕上时触发</li>
<li><code>touchmove</code>: 手指在屏幕上滑动式触发（会触发多次）</li>
<li><code>touchend</code>: 手指离开屏幕时触发</li>
<li><code>touchcancel</code>: 系统取消 touch 事件的时候触发，比如电话</li>
</ul>
<p>每个触摸事件被触发后，会生成一个 event 对象，event 对象中<code>changedTouches</code>会记录手指滑动的信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">e.touches <span class="comment">// 当前屏幕上的手指</span></span><br><span class="line">e.targetTouches <span class="comment">// 当前dom元素上的手指。</span></span><br><span class="line">e.changedTouches <span class="comment">// 触摸时发生改变的手指(重点)(如手指离开屏幕)</span></span><br></pre></td></tr></table></figure>

<p>这些列表里的每次触摸由 touch 对象组成，touch 对象里包含着触摸信息，主要属性如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e.changedTouches[0].clientX</span></span><br><span class="line">clientX / clientY <span class="comment">// 触摸点相对浏览器窗口的位置</span></span><br><span class="line">pageX / pageY <span class="comment">// 触摸点相对于页面的位置</span></span><br></pre></td></tr></table></figure>

<p>!&gt; 使用 jquery 注册 touch 类事件时，获取手指使用 <code>e.originalEvent.touchs[0]</code> ，因为 jq 对事件对象进行了封装</p>
<p>【案例：jdm-滑动轮播图】</p>
<p>【案例：jdm-区域滚动】</p>
<h2 id="iscroll-插件使用"><a href="#iscroll-插件使用" class="headerlink" title="iscroll 插件使用"></a>iscroll 插件使用</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1YmlxL2lzY3JvbGw=">https://github.com/cubiq/iscroll</span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5tYW1pY29kZS5jb20vaW5mby1kZXRhaWwtMzMxODI3Lmh0bWw=">iscroll 参考文档</span></p>
<p><strong>注意</strong>：使用 iscroll 需要满足的条件</p>
<ol>
<li>父盒子嵌套了子盒子（一个）</li>
<li>如果有多个子盒子，所以我们需要使用一个盒子把所有的子盒子包裹起来</li>
<li>如果有图片，我们需要保证图片加载完成，如果有浮动，需要清除浮动，为了保证子盒子的高度获取的是正确的</li>
<li>子盒子大小一定要超过父盒子的大小</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用：box为父盒子</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> IScroll(box, &#123;</span><br><span class="line">  <span class="attr">scrollX</span>: <span class="literal">false</span>, <span class="comment">// 横向滚动</span></span><br><span class="line">  <span class="attr">scrollY</span>: <span class="literal">true</span> <span class="comment">// 纵向滚动</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="zepto-框架"><a href="#zepto-框架" class="headerlink" title="zepto 框架"></a>zepto 框架</h1><blockquote>
<p><strong>Zepto</strong>是一个轻量级的<strong>针对现代高级浏览器的 JavaScript 库， <strong>它与 jquery</strong>有着类似的 api</strong>。 如果你会用 jquery，那么你也会用 zepto</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hZHJvYmJ5L3plcHRv">github 地址</span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3plcHRvanNfYXBpLw==">中文文档</span></p>
<h2 id="zepto-与-jquery-的区别"><a href="#zepto-与-jquery-的区别" class="headerlink" title="zepto 与 jquery 的区别"></a>zepto 与 jquery 的区别</h2><ul>
<li>jquery 针对 pc 端，主要用于解决浏览器兼容性问题，zepto 主要针对移动端</li>
<li>zepto 比 jquery 轻量，文件体积更小</li>
<li>zepto 封装了一些移动端的手势事件</li>
</ul>
<h2 id="zepto-的基本使用"><a href="#zepto-的基本使用" class="headerlink" title="zepto 的基本使用"></a>zepto 的基本使用</h2><p>zepto 的使用与 jquery 基本一致，zepto 是分模块的，需要某个功能，就需要引入某个 zepto 的文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;zepto/zepto.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;zepto/event.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;zepto/fx.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">&#x27;.box&#x27;</span>).addClass(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  $(<span class="string">&#x27;button&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.box&#x27;</span>).animate(&#123; <span class="attr">width</span>: <span class="number">500</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="zepto-的定制"><a href="#zepto-的定制" class="headerlink" title="zepto 的定制"></a>zepto 的定制</h2><p>安装 Nodejs 环境</p>
<p>1、下载 zepto.js</p>
<p>2、解压缩</p>
<p>3、cmd 命令行进入解压缩后的目录</p>
<p>4、执行<code>npm install</code>命令</p>
<p>5、编辑 make 文件的<code>41行</code>，添加自定义模块并保存</p>
<p>7、然后执行命令 <code>npm run-script dist</code></p>
<p>8、查看目录 dist 即构建好的 zepto.js</p>
<h2 id="zepto-手势事件"><a href="#zepto-手势事件" class="headerlink" title="zepto 手势事件"></a>zepto 手势事件</h2><p>zepto 中根据<code>touchstart touchmove touchend</code>封装了一些常用的手势事件，这些事件都是基于 touchstart touchmove touchend 封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tap <span class="comment">// 轻触事件,用于替代移动端的click事件，因为click事件在老版本中会有300ms的延迟</span></span><br><span class="line">swipe <span class="comment">//手指滑动时触发</span></span><br><span class="line">swipeLeft <span class="comment">//左滑</span></span><br><span class="line">swipeRight <span class="comment">//右滑</span></span><br><span class="line">swipeUp <span class="comment">//上滑</span></span><br><span class="line">swipeDown <span class="comment">//下滑</span></span><br></pre></td></tr></table></figure>

<h1 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h1><h2 id="什么是响应式布局"><a href="#什么是响应式布局" class="headerlink" title="什么是响应式布局"></a>什么是响应式布局</h2><blockquote>
<p>响应式布局（respond layout）是 Ethan Marcotte 在 2010 年 5 月份提出的一个概念，简而言之，就是<strong>一个网站能够兼容多个终端（手机、平板、pc 电脑、手表）</strong> ——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的</p>
</blockquote>
<p><strong>为什么要有响应式布局？</strong></p>
<ul>
<li>在移动互联日益成熟的时候，在 PC 端开发的网页已经无法满足移动设备的要求</li>
<li>通常的做法是针对移动端单独做一套特定的版本</li>
<li>如果终端越来越多，那么需要开发的版本就会越来越多（大屏设备的普及）</li>
<li><strong>响应式布局</strong> ：一个网站能够兼容多个终端（节约开发成本）</li>
</ul>
<p><strong>优点：</strong></p>
<p>面对不同分辨率设备灵活性强</p>
<p>能够快捷解决多设备显示适应问题</p>
<p>**缺点： **</p>
<p>兼容各种设备工作量大，效率低下</p>
<p>代码累赘，会出现隐藏无用的元素，加载时间加长</p>
<p>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</p>
<p>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</p>
<p>响应式开发现状：</p>
<ul>
<li>如果已经存在 PC 的网站了，那么一般不会使用响应式开发，而是针对移动端再开发一套系统（比如京东、淘宝）</li>
<li>在<strong>新建站点</strong> 上采用响应式开发的越来越多</li>
<li>在国内，响应式开发还不是特别的流行。但响应式开发是大势所趋，会越来越流行</li>
</ul>
<h2 id="响应式开发与移动-web-开发的比较"><a href="#响应式开发与移动-web-开发的比较" class="headerlink" title="响应式开发与移动 web 开发的比较"></a>响应式开发与移动 web 开发的比较</h2><table>
<thead>
<tr>
<th>开发方式</th>
<th>移动 web 开发+pc 开发</th>
<th>响应式开发</th>
</tr>
</thead>
<tbody><tr>
<td>引用场景</td>
<td>一般已经有了 PC 端网站，只需要端独开发移动端网站即可</td>
<td>针对一些新建网站，并且要求适配移动端</td>
</tr>
<tr>
<td>开发</td>
<td>针对性强，开发效率高</td>
<td>兼容各种终端，效率低</td>
</tr>
<tr>
<td>适配</td>
<td>只能适配移动端或者 PC 端，pad 上体验比较差</td>
<td>可以适配各种终端</td>
</tr>
<tr>
<td>效率</td>
<td>代码简介，加载快</td>
<td>代码相对复杂，加载慢</td>
</tr>
</tbody></table>
<h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><blockquote>
<p>媒体查询（Media Query）是 CSS3 提出来的一个新的属性，通过媒体查询可以查询到 screen 的宽度，从而指定某个宽度区间的网页布局</p>
</blockquote>
<h2 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>宽度范围</th>
</tr>
</thead>
<tbody><tr>
<td>大屏设备</td>
<td>&gt;1200px</td>
</tr>
<tr>
<td>中屏设备</td>
<td>992px~1200px</td>
</tr>
<tr>
<td>小屏设备</td>
<td>768px~992px</td>
</tr>
<tr>
<td>超小屏设备</td>
<td>&lt; 768px</td>
</tr>
</tbody></table>
<h2 id="媒体查询的使用"><a href="#媒体查询的使用" class="headerlink" title="媒体查询的使用"></a>媒体查询的使用</h2><p>需求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  大屏设备(&gt;1200px)   版心：1170px   背景色：红色</span></span><br><span class="line"><span class="comment">  中屏设备(992-1200)  版心：970px    背景色：蓝色</span></span><br><span class="line"><span class="comment">  小屏设备(768-992)   版心：750px    背景色：黄色</span></span><br><span class="line"><span class="comment">  超小屏设备(&lt;768px)  版心：100%     背景色：绿色</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>响应式开发的原理：使用媒体查询实现不同终端的布局和样式的切换</p>
<p>媒体查询语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查询屏幕 */</span></span><br><span class="line"><span class="comment">/* screen 和第一个 and 可以省略 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> 条件 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 条件的写法 */</span></span><br><span class="line"><span class="comment">/* min-width: 只要屏幕宽度超过这个值的设备样式就能生效 */</span></span><br><span class="line"><span class="comment">/* max-width: 只要屏幕宽度小于这个值的设备样式就能生效 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1170px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">992px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">992px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="bootstrap-框架"><a href="#bootstrap-框架" class="headerlink" title="bootstrap 框架"></a>bootstrap 框架</h1><p><strong>【项目：微金所】</strong></p>
<h1 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h1><h2 id="rem-是什么？"><a href="#rem-是什么？" class="headerlink" title="rem 是什么？"></a>rem 是什么？</h2><p><code>rem</code>（font size of the root element）是指相对于<code>根元素</code>的字体大小的单位。它就是一个相对单位。</p>
<p><code>em</code>（font size of the element）是指相对于 <code>当前元素的字体大小</code> 的单位。它也是一个相对单位。</p>
<p>它们之间其实很相似，只不过计算的规则一个是依赖根元素，一个是当前元素计算。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.em</span> &#123;</span><br><span class="line">  <span class="comment">/* em 的计算方式参照的当前元素的 font-size，如果不设置，默认继承自父盒子 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* rem 的计算方式参照的是 html 的 font-size */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.rem</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么要用-rem？"><a href="#为什么要用-rem？" class="headerlink" title="为什么要用 rem？"></a>为什么要用 rem？</h2><blockquote>
<p>rem 的主要目的就是解决用于不同屏幕的适配问题。rem 能够等比例的适配所有的屏幕。</p>
</blockquote>
<p>由于市面上手机种类繁多，导致移动端的屏幕种类非常的混乱，比如有常见的<code>320px 360px 375px 384px 480px 640px</code>等。在开发中，美工一般只会提供 750px 或者是 640px 的设计稿，这就要求我们通过一张设计稿能够适配所有的屏幕。通常解决方案如下：</p>
<ul>
<li>流式布局：虽然可以让各种屏幕都适配，但是显示效果不是非常的友好，因为只有几个尺寸的手机能够完美的显示出来视觉设计师和交互最想要的效果。但是目前使用流式布局的公司非常多，比如 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYW1hem9uLmNuLw==">亚马逊</span> 、<span class="exturl" data-url="aHR0cHM6Ly9tLmpkLmNvbS8=">京东</span> 、<span class="exturl" data-url="aHR0cHM6Ly9tLmN0cmlwLmNvbS8=">携程</span></li>
<li>响应式布局：响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是<strong>工作大，维护性难</strong> 。所以一般都是中小型的门户或者博客类站点会采用响应式的方法从 PC 端页面到移动端页面以及 web app 直接一步到位，因为这样反而可以节约成本。</li>
<li>rem 布局：rem 能够适配所有的屏幕，与 less 配合使用效果会更好。目前使用 rem 布局的有：<span class="exturl" data-url="aHR0cHM6Ly9tLnRhb2Jhby5jb20v">淘宝</span> 、 <span class="exturl" data-url="aHR0cHM6Ly9tLnN1bmluZy5jb20v">苏宁</span></li>
</ul>
<h2 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h2><p>因为 rem 的基准点是根元素 html 的字体大小，因此我们只需要设置不同屏幕的 html 的 font-size 大小不一样就可以达到不同屏幕的适配了。</p>
<h3 id="rem-配合媒体查询"><a href="#rem-配合媒体查询" class="headerlink" title="rem 配合媒体查询"></a>rem 配合媒体查询</h3><p>使用 rem 配合媒体查询可以适配多个终端</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span>(min-width: <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="comment">/* 基准值 / 设计图的大小  = 某个屏幕的font-size / 屏幕的宽度 */</span></span><br><span class="line">    <span class="comment">/* 100/750 = x/370 */</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>优点：使用媒体查询适配，速度快。</p>
<p>缺点：适配多个终端时，需要添加响应的代码。</p>
<h3 id="rem-配合-javascript"><a href="#rem-配合-javascript" class="headerlink" title="rem 配合 javascript"></a>rem 配合 javascript</h3><p>通过 javascript 获取可视区的宽度，计算 font-size 的值，也可以适配多个终端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据屏幕的大小动态设置 html的 font-size</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">responsive</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> uiWidth = <span class="number">750</span> <span class="comment">// 设计图宽度</span></span><br><span class="line">  <span class="keyword">var</span> base = <span class="number">100</span> <span class="comment">// 设计图中1rem的大小</span></span><br><span class="line">  <span class="comment">// 当前屏幕的大小</span></span><br><span class="line">  <span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth</span><br><span class="line">  <span class="keyword">if</span>(pageWidth &gt;= <span class="number">750</span>) &#123;</span><br><span class="line">    pageWidth = <span class="number">750</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pageWidth &lt;= <span class="number">320</span>) &#123;</span><br><span class="line">    pageWidth = <span class="number">320</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 说白了就是把一个屏幕分成了 7.5 rem</span></span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.fontSize = (base / uiWidth * pageWidth).toFixed(<span class="number">2</span>) + ’px‘</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：直接适配所有的终端</p>
<p>缺点：必须在页面加载之前设置 html 的 font-size 值，不然会出现文字大小调动的情况。</p>
<h3 id="rem-配合-flexible-插件"><a href="#rem-配合-flexible-插件" class="headerlink" title="rem 配合 flexible 插件"></a>rem 配合 flexible 插件</h3><ul>
<li><p>flexible 插件基准值（base）是设计图的 1/10</p>
</li>
<li><p>使用 flexible</p>
</li>
</ul>
<ol>
<li><p>在 header 中引入 flexible.js 这个文件</p>
</li>
<li><p>根据设计图能够确定基准值， 配合 px2rem 插件 ，需要设置一个 rootFontSize</p>
</li>
</ol>
<p>【案例：苏宁易购】</p>
<h1 id="swiper-插件"><a href="#swiper-插件" class="headerlink" title="swiper 插件"></a>swiper 插件</h1><blockquote>
<p>Swiper 是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5zd2lwZXIuY29tLmNuLw==">swiper 中文网</span></p>
<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="comment">/* 取消链接高亮, 移动端特有的样式  */</span></span><br><span class="line">  -webkit-tap-highlight-<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/400.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/400.html" class="post-title-link" itemprop="url">浏览器的工作原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-11-30" itemprop="dateCreated datePublished" datetime="2018-11-30T22:14:52+00:00">2018-11-30</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h2><p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102203825.png"></p>
<ul>
<li>用户界面－ 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</li>
<li>浏览器引擎－ 用来查询及操作渲染引擎的接口</li>
<li>渲染引擎（浏览器内核）－ 用来显示请求的内容，例如，如果请求内容为 html，它负责解析 html 及 css，并将解析后的结果显示出来</li>
<li>网络－ 用来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作</li>
<li>UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</li>
<li>JS 解释器－ 用来解释执行 JS 代码</li>
<li>数据存储－ 属于持久层，浏览器需要在硬盘中保存类似 cookie 的各种数据，HTML5 定义了 Storage 技术，这是一种轻量级完整的客户端存储技术</li>
</ul>
<h2 id="主流的渲染引擎"><a href="#主流的渲染引擎" class="headerlink" title="主流的渲染引擎"></a>主流的渲染引擎</h2><blockquote>
<p>浏览器的渲染引擎也叫排版引擎，或者是<strong>浏览器内核</strong></p>
</blockquote>
<p>主流的 渲染引擎 有</p>
<ul>
<li><strong>Chrome 浏览器</strong>: Blink 引擎（WebKit 的一个分支）。</li>
<li><strong>Safari 浏览器</strong>: WebKit 引擎，windows 版本 2008 年 3 月 18 日推出正式版，但苹果已于 2012 年 7 月 25 日停止开发 Windows 版的 Safari。</li>
<li><strong>FireFox 浏览器</strong>: Gecko 引擎。</li>
<li><strong>Opera 浏览器</strong>: Blink 引擎(早期版使用 Presto 引擎）。</li>
<li><strong>Internet Explorer 浏览器</strong>: Trident 引擎。</li>
<li><strong>Microsoft Edge 浏览器</strong>: EdgeHTML 引擎（Trident 的一个分支）。</li>
</ul>
<h2 id="渲染引擎工作原理"><a href="#渲染引擎工作原理" class="headerlink" title="渲染引擎工作原理"></a>渲染引擎工作原理</h2><p>渲染引擎解析的基本流程：</p>
<ol>
<li><p>解析 HTML 构建 <code>Dom树</code>，同时解析所有的 css 样式，构建 css 规则。DOM 是 W3C 组织推荐的处理可扩展置标语言的标准编程接口。</p>
</li>
<li><p>根据 DOM 树和 css 规则合并构建 <code>渲染树</code></p>
<ul>
<li>DOM 树上的节点没有样式的，渲染树的节点有样式的</li>
<li>渲染树上的节点都是需要渲染的，所以渲染树上没有像<code>head</code>标签 或 <code>display: none</code>这样的元素，但是它们在 Dom 树中</li>
</ul>
</li>
<li><p>对渲染树进行布局，定位坐标和大小、确定是否换行、确定 position、overflow、z-index 等等，这个过程叫<code>layout</code> 或 <code>reflow</code>。</p>
</li>
<li><p>绘制渲染树，调用操作系统底层 API(UI Backend)进行绘图操作。</p>
</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102203846.png"></p>
<p><strong>webkit 内核工作流程</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102203907.png"></p>
<p><strong>gecko 内核工作流程</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102203924.jpeg"></p>
<p>结论：浏览器能够解析 HTML 文件，并且显示到页面中。所以我们写的文件能够使用浏览器打开并且能够看到效果。</p>
<h1 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h1><h2 id="重绘与回流-1"><a href="#重绘与回流-1" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><p><code>回流(reflow)</code>: 又叫重排，当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。</p>
<p><code>重绘(repaint)</code>：当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。</p>
<ol>
<li>每个页面至少需要一次回流+重绘</li>
<li>回流必将引起重绘</li>
</ol>
<p>回流什么时候发生？</p>
<p>1、添加或者删除可见的 DOM 元素</p>
<p>2、元素位置改变</p>
<p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p>
<p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变</p>
<p>5、页面渲染初始化</p>
<p>6、浏览器窗口尺寸改变——resize 事件发生时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style</span><br><span class="line">s.padding = <span class="string">&#x27;2px&#x27;</span> <span class="comment">// 回流+重绘</span></span><br><span class="line">s.border = <span class="string">&#x27;1px solid red&#x27;</span> <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">&#x27;blue&#x27;</span> <span class="comment">// 再一次重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">&#x27;#ccc&#x27;</span> <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">&#x27;14px&#x27;</span> <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="comment">// 添加node，再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;abc!&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="聪明的浏览器"><a href="#聪明的浏览器" class="headerlink" title="聪明的浏览器"></a>聪明的浏览器</h2><blockquote>
<p>从上个实例代码中可以看到几行简单的 JS 代码就引起了 6 次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句 JS 操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
</blockquote>
<p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前 flush 队列，这样浏览器的优化可能就起不到作用了。当你向浏览器请求一些 style 信息的时候，就会让浏览器 flush 队列，比如：</p>
<ol>
<li><p>offsetTop, offsetLeft, offsetWidth, offsetHeight</p>
</li>
<li><p>scrollTop/Left/Width/Height</p>
</li>
<li><p>clientTop/Left/Width/Height</p>
</li>
<li><p>width,height</p>
</li>
<li><p>请求了 getComputedStyle(), 或者 IE 的 currentStyle</p>
</li>
</ol>
<h2 id="如何性能优化"><a href="#如何性能优化" class="headerlink" title="如何性能优化"></a>如何性能优化</h2><blockquote>
<p>减少回流与重绘的次数，就需要简单对渲染树的操作</p>
</blockquote>
<ol>
<li>直接使用 <code>className</code> 修改样式，少用 style 设置样式</li>
<li>让要操作的元素进行”离线处理”，处理完后一起更新<ul>
<li>使用 <code>DocumentFragment</code> 进行缓存操作，引发一次回流和重绘</li>
<li>使用 <code>display:none</code> 技术，只引发两次回流和重绘</li>
</ul>
</li>
<li>将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow</li>
<li><strong>完成功能是前提，在完成功能的情况下想着优化代码</strong></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/395.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/395.html" class="post-title-link" itemprop="url">HTML5</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-11-23" itemprop="dateCreated datePublished" datetime="2018-11-23T22:10:49+00:00">2018-11-23</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是-HTML5"><a href="#什么是-HTML5" class="headerlink" title="什么是 HTML5"></a>什么是 HTML5</h2><blockquote>
<p>HTML5 并不仅仅是作为 <strong>HTML 标记语言的一个最新版本</strong>， 更重要的是它<strong>制定了 web 应用开发的一系列标准</strong>，成为第一个将 web 作为应用开发平台的 HTML 语言。</p>
</blockquote>
<p>HTML5 定义了一系列新元素，如 <strong>新语义标签、多媒体标</strong> 签等，可以帮助开发者开发更加丰富的应用，同时有令人眼花缭乱的 css3，还提供了一些 Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用，制作 webApp，甚至结合 Canvas 我们可开发网页游戏</p>
<p>我们日常讨论的 H5 其实指的是一个泛称，它是由<strong>HTML5+CSS3+javascript</strong> 等技术组合而成的一个应用开发平台</p>
<h2 id="HTML5-的历史"><a href="#HTML5-的历史" class="headerlink" title="HTML5 的历史"></a>HTML5 的历史</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. WHATWG: Web Hypertext Application Technology Working。 WHATWG成立的原因是W3C意图放弃HTML，而力图发展XML技术</span><br><span class="line">2. HTML5 的第一份正式草案已于2008年1月22日公布</span><br><span class="line">3. 2014年10月29日，万维网联盟宣布，经过接近8年的艰苦努力，该标准规范终于制定完成</span><br></pre></td></tr></table></figure>

<p>思考：问什么 HTML5 在 2008 年就发布草案了，到 2014 年才火起来？</p>
<p>因为移动端的推动，HTML 在老的浏览器上兼容性很严重，并且 HTML5 很多新特性其实就是为移动端而出现的，可以说<strong>HTML5 是为移动端而生的</strong></p>
<h1 id="HTML5-语义化标签"><a href="#HTML5-语义化标签" class="headerlink" title="HTML5 语义化标签"></a>HTML5 语义化标签</h1><h2 id="常用语义化标签"><a href="#常用语义化标签" class="headerlink" title="常用语义化标签"></a>常用语义化标签</h2><blockquote>
<p>在 HTML5 之前，我们布局大多使用 div，但是 div 并没有语义化，HTML5 推出了一系列的语义化标签，可以用来表示 header、footer 等。</p>
</blockquote>
<p>HTML5 新的语义化标签</p>
<p><code>header</code> 头部、<code>nav</code> 导航、<code>footer</code> 底部、<code>aside</code> 侧边栏、<code>article</code> 文章、<code>section</code> 区块、<code>main</code> 主体区域</p>
<p>本质上新语义标签与<code>&lt;div&gt;</code>、<code>&lt;span&gt;</code>没有区别，只是其具有语义性，使用时除了在 HTML 结构上需要注意外，其它和普通标签的使用无任何差别，<code>&lt;nav&gt;</code>完全可以理解成<code>&lt;div class=&quot;nav&quot;&gt;</code>。不要好奇，它只是一个标签！就是增加了语义性，更加利于 SEO 的优化。</p>
<p>html5 还推出了一些其他的标签：<span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vdGFncy9pbmRleC5hc3A=">http://www.w3school.com.cn/tags/index.asp</span></p>
<h2 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h2><p>IE678 不识别这个标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">&#x27;header&#x27;</span>) <span class="comment">// 创建这个标签即可让IE678识别</span></span><br><span class="line"><span class="comment">// 创建的标签默认是行内样式。</span></span><br><span class="line"><span class="comment">// 还需给标签加一个 display:block 的属性。</span></span><br></pre></td></tr></table></figure>

<p>借助 <code>html5shiv.js</code></p>
<blockquote>
<p>我们每次都要去创建标签，并且还需要设置 display：block 属性，非常麻烦，因此我们可以引入一个第三方 js 文件，这个 js 文件的功能就是创建元素和设置 display 属性。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if lte IE 8] &gt;  // lte ==&gt; 小于等于</span></span><br><span class="line"><span class="comment">&lt;script src=&quot;js/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;! [endif] --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当 ie 浏览器的版本小于等于8的时候，才会引入 html5shiv.js --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- css hack --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 条件注释 IE独有的注释 --&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="类名操作-重点"><a href="#类名操作-重点" class="headerlink" title="类名操作(重点)"></a>类名操作(重点)</h1><blockquote>
<p>js 在 H5 中给所有的 DOM 对象新增了一个属性 classList</p>
<p>classList 是一个集合，会存储某个元素上所有的类名，使用 classList 来替代 className 操作 class 类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加类</span></span><br><span class="line">div.classList.add(<span class="string">&#x27;classname&#x27;</span>)</span><br><span class="line"><span class="comment">// 移除类</span></span><br><span class="line">div.classList.remove(<span class="string">&#x27;classname&#x27;</span>)</span><br><span class="line"><span class="comment">// 切换类</span></span><br><span class="line">div.classList.toggle(<span class="string">&#x27;classname&#x27;</span>)</span><br><span class="line"><span class="comment">// 判断类</span></span><br><span class="line">div.classList.contains(<span class="string">&#x27;classname&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>【tab 栏案例】</p>
<h1 id="自定义属性操作（重点）"><a href="#自定义属性操作（重点）" class="headerlink" title="自定义属性操作（重点）"></a>自定义属性操作（重点）</h1><blockquote>
<p>H5 规定，以后但凡给标签增加自定义属性，都应该用 <code>data-</code> 开头 (规范)</p>
<p>H5 给所有的 DOM 对象增加了一个 <code>dataset</code> 的属性，这个属性中会包含所有 data- 开头的属性</p>
</blockquote>
<ul>
<li>html 5 中操作自定义属性 <code>dataset</code> 属性</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">data-name</span>=<span class="string">&quot;zs&quot;</span> <span class="attr">data-age</span>=<span class="string">&quot;10&quot;</span> <span class="attr">data-user-name</span>=<span class="string">&quot;ls&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#box&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset) <span class="comment">// DOMStringMap &#123;name: &#x27;zs&#x27;, age: &#x27;10&#x27;, userName: &#x27;ls&#x27;&#125;</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset.name) <span class="comment">// zs</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset[<span class="string">&#x27;age&#x27;</span>]) <span class="comment">// 10</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset.userName) <span class="comment">// ls</span></span></span><br><span class="line"><span class="javascript">  box.dataset.aaBb = <span class="string">&#x27;cc&#x27;</span> <span class="comment">// 在html结构中或添加 data-aa-bb=&quot;cc&quot; 的自定义属性</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>html 中属性是忽略大小写的，相当于是小写字母，如果需要大写，应使用中划线 <code>-</code> 进行分隔，在 js 中会转换成驼峰的形式，如<code>data-user-name ==&gt; userName</code></p>
<ul>
<li>jquery 中操作自定义属性</li>
</ul>
<p>jquery 并没有把 <code>data-</code> 当成自定义属性来用，jq 中封装了 <code>data()</code> 方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">data-name</span>=<span class="string">&quot;zs&quot;</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">data-a</span>=<span class="string">&#x27;&#123;&quot;b&quot;:&quot;c&quot;&#125;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data()) <span class="comment">// &#123;id: 1, name: &quot;zs&quot;&#125;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// console.log($(&#x27;#box&#x27;).attr()) // error</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset) <span class="comment">// DOMStringMap&#123;id: &quot;1&quot;, name: &quot;zs&quot;&#125;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;id&#x27;</span>)) <span class="comment">// 1 =&gt; 获取到自定义属性</span></span></span><br><span class="line"><span class="javascript">  $(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;id&#x27;</span>, <span class="number">2</span>) <span class="comment">// 并不会修改原标签中的自定义属性</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;id&#x27;</span>)) <span class="comment">// 2 =&gt; html中data-id依然是1</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).attr(<span class="string">&#x27;data-id&#x27;</span>)) <span class="comment">// 1</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset[<span class="string">&#x27;id&#x27;</span>]) <span class="comment">// 1 =&gt; 获取到的还是原来的 data-id</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  $(<span class="string">&#x27;#box&#x27;</span>).attr(<span class="string">&#x27;data-id&#x27;</span>, <span class="number">3</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;id&#x27;</span>)) <span class="comment">// 3</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset[<span class="string">&#x27;id&#x27;</span>]) <span class="comment">// 3</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 属性里使用json语法，但通过data()设置的不能解析成对象</span></span></span><br><span class="line"><span class="javascript">  $(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;&#123;&quot;e&quot;:&quot;f&quot;&#125;&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// &#123;b: &quot;c&quot;&#125; =&gt; 对象</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;d&#x27;</span>)) <span class="comment">// &#x27;&#123;&quot;e&quot;:&quot;f&quot;&#125;&#x27;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  $(<span class="string">&#x27;#box&#x27;</span>).removeData() <span class="comment">// 删除之前通过 data() 方法设置的数据</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>!&gt; jq 的 data() 方法内部使用了缓存来实现，该方法设置的属性只能通过该方法获取，在 html 页面中看不到属性值，通过原生 dataset 属性也获取不到值</p>
<h1 id="网络状态"><a href="#网络状态" class="headerlink" title="网络状态"></a>网络状态</h1><blockquote>
<p>在移动端，我们经常需要检测设置是在线还是离线，HTML5 为此定义了一个 navigator.onLine 属性，这个属性用于检测设备是否联网。<strong>navigator.onLine</strong> 在不同浏览器中有细微的差别。</p>
</blockquote>
<h2 id="网络状态-1"><a href="#网络状态-1" class="headerlink" title="网络状态"></a>网络状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">navigator.onLine 返回用户当前的网络状况，是一个布尔值</span><br><span class="line">1. 如果浏览器连不上网(包括局域网)，就是离线状态，也就是脱机状态，会返回 false</span><br><span class="line">2. 否则就是在线状态，返回 true</span><br></pre></td></tr></table></figure>

<p><strong>注意：返回 true 不一定就是说一定能访问互联网，因为有可能连接的是局域网。但是返回 false 则表示一定连不上网。</strong></p>
<h2 id="监听网络变化"><a href="#监听网络变化" class="headerlink" title="监听网络变化"></a>监听网络变化</h2><blockquote>
<p>为了更好的确定网络是否连接，HTML5 还定义了两个事件，用于监听网络状态的变化。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网络连接时会被调用</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;online&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;online&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当网络断开时会被调用</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;offline&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;offline&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h1><blockquote>
<p>在 HTML 规范中，增加了获取用户地理信息的 API，这样使得我们可以基于用户位置开发互联网应用，即基于位置服务 LBS(Location Base Service)</p>
</blockquote>
<h2 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h2><p>HTML5 规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。<strong>在获取地理位置之前，会询问用户，只有在获得许可之后，才能获取到用户的位置信息。</strong></p>
<p>H5 提供的获取地理位置信息并不是特别的精确，会一定的误差，如果需要非常精确的定位，还是需要使用安卓或者 ios，访问基于操作系统的方法。 （小程序）</p>
<h2 id="相关的方法"><a href="#相关的方法" class="headerlink" title="相关的方法"></a>相关的方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// successCallback:获取成功后会调用,并返回一个position对象，里面包含了地理位置信息</span></span><br><span class="line"><span class="comment">// 获取失败了会调用，并返回error对象，里面包含了错误信息。</span></span><br><span class="line"><span class="comment">// 获取当前的地理位置信息</span></span><br><span class="line">navigator.geolocation.getCurrentPosition(successCallback, errorCallback)</span><br><span class="line"><span class="comment">// 重复的获取当前的地理位置信息</span></span><br><span class="line">navigator.geolocation.watchPosition(successCallback, errorCallback)</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定位成功会调用该方</span></span><br><span class="line">    <span class="comment">// 法谷歌浏览器进行了限制，看不到，可以再IE浏览器下查看</span></span><br><span class="line">    <span class="comment">// position.coords.latitude 纬度</span></span><br><span class="line">    <span class="comment">// position.coords.longitude 经度</span></span><br><span class="line">    <span class="comment">// position.coords.accuracy 精度</span></span><br><span class="line">    <span class="comment">// position.coords.altitude 海拔高度</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定位失败会调用该方法</span></span><br><span class="line">    <span class="comment">// error 是错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>苹果浏览器对 webkit 定位权限进行了修改，所有定位请求的页面必须是 https 协议的。</strong></p>
<h2 id="百度地图、高德地图、腾讯地图"><a href="#百度地图、高德地图、腾讯地图" class="headerlink" title="百度地图、高德地图、腾讯地图"></a>百度地图、高德地图、腾讯地图</h2><blockquote>
<p>仅仅获取到经纬度对于用户来说意义并不大，因为用户也不知道经度和纬度表示的是地球上的哪一个地方，因为我们可以结合百度地图，准确的将用户的位置显示出来。</p>
</blockquote>
<p>百度地图官网：<span class="exturl" data-url="aHR0cDovL2xic3l1bi5iYWlkdS5jb20v">http://lbsyun.baidu.com/</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在开发中，找到 javascript API</span><br><span class="line">2. 直接查看示例 demo</span><br><span class="line">3. 复制相应的代码，替换掉秘钥就行，秘钥只需创建一个新的应用就可以了</span><br></pre></td></tr></table></figure>

<h1 id="web-存储"><a href="#web-存储" class="headerlink" title="web 存储"></a>web 存储</h1><blockquote>
<p>在代码执行的时候，数据都是存储在内存中的，当页面关闭或者浏览器关闭的时候，内存就被释放掉了。数据只有存储在硬盘上，才不会被释放。</p>
</blockquote>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>特点：</p>
<ul>
<li>在浏览器端的存储数据的容器</li>
<li>大小 4k</li>
<li>生命周期，默认会话级别，但是可以设置过期时间</li>
<li>cookie 中的数据可以在同一个网站的页面共享</li>
<li>cookie 中的数据，在请求时会进行自动携带</li>
<li>不同浏览器的 cookie 不能共享</li>
<li>cookie 是以字符串形式存在的，这个字符串有固定的格式：key=value;key1=value1；在获取 cookie 内容时，一般需要通过正则或者字符串的方法进行处理，转换成对象，最终得到数据</li>
<li>一般用于存储 sessionId，可以实现登录状态保持 (会话保持)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;name=zhangsan&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;age=18&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;sex=23&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置过期时间</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;sex=12;max-age=3600&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取cookie</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.cookie</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<h2 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h2><blockquote>
<p>HTML5 规范提出使用 sessionStorage 和 localStorage 存储数据。设置、读取、删除操作很方便</p>
</blockquote>
<ul>
<li><p>sessionStorage 和 localStorage 特点</p>
<ul>
<li>都保存在客户端</li>
<li>大小为 5M 左右</li>
<li>使用方法相同</li>
<li>以键值对的方式，存储字符串格式的数据</li>
</ul>
</li>
<li><p>sessionStorage 和 localStorage 区别</p>
<ul>
<li>sessionStorage 生命周期默认为一个会话周期，且不能设置周期，一旦关闭浏览器，就销毁了，不能在多个窗口下共享数据</li>
<li>localStorage 永久生效，除非手动删除，可以多个窗口共享</li>
</ul>
</li>
<li><p>使用方法</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setItem(key, value) <span class="comment">// 设置存储内容</span></span><br><span class="line">getItem(key) <span class="comment">// 读取存储内容</span></span><br><span class="line">removeItem(key) <span class="comment">// 删除键值为key的存储内容</span></span><br><span class="line">clear() <span class="comment">// 清空所有存储内容（谨慎使用）</span></span><br></pre></td></tr></table></figure>

<p>存取复杂数据类型：先将复杂数据转换成 JSON 字符串 <code>JSON.stringify(obj/arr)</code> 在进行存储；使用时将 JSON 字符串转换成复杂数据类型 <code>JSON.parse( jsonStr )</code></p>
<p>【案例-换肤效果】</p>
<h2 id="Cookie-和-WebStorage-比较"><a href="#Cookie-和-WebStorage-比较" class="headerlink" title="Cookie 和 WebStorage 比较"></a>Cookie 和 WebStorage 比较</h2><p><strong>cookie</strong></p>
<ul>
<li>大小受限</li>
<li>用户可以操作（禁用）cookie，使功能受限</li>
<li>安全性较低</li>
<li>有些状态不可能保存在客户端。</li>
<li>每次访问都要传送 cookie 给服务器，浪费带宽</li>
</ul>
<p><strong>WebStorage</strong></p>
<ul>
<li>存储空间更大：cookie 为 4KB，而 WebStorage 是 5MB</li>
<li>WebStorage 不会传送到服务器，存储在本地的数据可以直接获取，速度更快，并且减少了客户端和服务器端的交互，节省了网络流量</li>
<li>对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage 会非常方便</li>
<li>安全性：WebStorage 不会随着 HTTP header 发送到服务器端，所以安全性相对于 cookie 来说比较高一些，不会担心截获，但是仍然存在伪造问题</li>
<li>WebStorage 提供了一些方法，数据操作比 cookie 方便</li>
</ul>
<h1 id="自定义播放器"><a href="#自定义播放器" class="headerlink" title="自定义播放器"></a>自定义播放器</h1><p>全屏切换 API：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// requestFullScreen 这个方法还没有标准化，需要添加私有前缀</span></span><br><span class="line">video.requestFullScreen()</span><br><span class="line">video.webkitRequestFullScreen()</span><br><span class="line">video.mozRequestFullScreen()</span><br></pre></td></tr></table></figure>

<p>video/audio 属性：</p>
<ul>
<li>currentTime: 设置或返回音频/视频中的当前播放位置（以秒计）</li>
<li>duration: 返回当前音频/视频的长度（以秒计）</li>
<li>autoplay: 默认 false 设置或返回是否在加载完成后随即播放音频/视频</li>
<li>volume: 设置或返回音频/视频的音量</li>
<li>paused: 设置或返回音频/视频是否暂停， true 指示音频/视频已暂停</li>
</ul>
<p>方法：</p>
<ul>
<li><p>load(): 重新加载音频/视频元素</p>
</li>
<li><p>play(): 开始播放音频/视频</p>
</li>
<li><p>pause(): 暂停当前播放的音频/视频</p>
</li>
</ul>
<p>事件：</p>
<ul>
<li>timeupdate: 播放进度更改时触发</li>
</ul>
<p>参考文档<br><span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vdGFncy9odG1sX3JlZl9hdWRpb192aWRlb19kb20uYXNw">http://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp</span></p>
<p>推荐：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXdlc29tZXMuY24vcmVwby92aWRlb2pzL3ZpZGVvLWpz">https://www.awesomes.cn/repo/videojs/video-js</span></p>
<h1 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h1><blockquote>
<p>通过 FileReader 对象我们可以读取本地存储的文件（用户通过 input:file 上传的文件），可以使用 File 对象来指定所要读取的文件或数据。其中 File 对象可以是来自用户在一个<code>&lt;input&gt;</code>元素上选择文件后返回的 FileList 对象，也可以来自由拖放操作生成的 DataTransfer</p>
</blockquote>
<h2 id="files"><a href="#files" class="headerlink" title="files"></a>files</h2><p>对于 file 类型的 input 框，在这个 DOM 对象中，存在一个 files 属性，这个属性是 FileList 对象，是一个伪数组，里面存储着上传的所有文件，当 input 框指定了 multiple 属性之后，就可以上传多个文件了。</p>
<p>也就是说，通过 files 这个属性，我们就可以获取到所有上传的文件。</p>
<h2 id="file-对象"><a href="#file-对象" class="headerlink" title="file 对象"></a>file 对象</h2><p>File 对象中包含了文件的最后修改时间、文件名、文件类型等信息。</p>
<h2 id="FileReader-对象"><a href="#FileReader-对象" class="headerlink" title="FileReader 对象"></a>FileReader 对象</h2><p>FileReader 是一个 HTML5 新增的对象，用于读取文件（必须通过 input:file 上传）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> file = input.files[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 创建一个fileReader对象</span></span><br><span class="line"><span class="keyword">var</span> fr = <span class="keyword">new</span> FileReader</span><br><span class="line"><span class="comment">// 读取文件的两个方法</span></span><br><span class="line">fr.readAsText(file) 以文本的方式读取文件 ,文本文件</span><br><span class="line">fr.readAsDataURL(file) 以DataURL形式读取文件，图片，视频</span><br><span class="line"><span class="comment">// 文件读取完成事件：</span></span><br><span class="line">fr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 当文件读取完成，可以通过result属性获取结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(fr.result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：图片预览</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. FileReader 是异步的</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;file&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>)</span><br><span class="line">file.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="built_in">this</span>) <span class="comment">// file 中files 属性里面存储了所有上传的文件</span></span><br><span class="line">  <span class="comment">// 这个data就是我们上传的那个文件</span></span><br><span class="line">  <span class="keyword">var</span> data = file.files[<span class="number">0</span>]</span><br><span class="line">  <span class="comment">// 1. 创建一个文件读取器</span></span><br><span class="line">  <span class="keyword">var</span> fr = <span class="keyword">new</span> FileReader()</span><br><span class="line">  <span class="comment">// 2. 让文件读取器读取整个文件</span></span><br><span class="line">  fr.readAsDataURL(data)</span><br><span class="line">  <span class="comment">// 3. 等待文件读取完</span></span><br><span class="line">  <span class="comment">// onload：文件读取完成后，就会触发</span></span><br><span class="line">  fr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 fr.result 就可以获取到最终的结果</span></span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">    img.src = fr.result</span><br><span class="line">    box.innerHTML = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    box.appendChild(img)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. URL.createObjectURL(file)  缺点： 1. 试验中  2. 同步（阻塞）</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;file&#x27;</span>)</span><br><span class="line">file.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="built_in">this</span>.files[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">var</span> result = URL.createObjectURL(data)</span><br><span class="line">  img.src = result</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/1632.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1632.html" class="post-title-link" itemprop="url">CSS3 基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-11-23" itemprop="dateCreated datePublished" datetime="2018-11-23T14:28:51+00:00">2018-11-23</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如同人类的的进化一样，CSS3 是 CSS2 的“进化”版本，在 CSS2 基础上，<strong>增强</strong>  或 <strong>新增</strong>  了许多特性， 弥补了 CSS2 的众多不足之处，使得 Web 开发变得更为高效和便捷。</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><ul>
<li>PC 端浏览器支持程度差，需要添加私有前缀</li>
<li>移动端支持优于 PC 端</li>
<li>不断改进中</li>
<li>应用相对广泛</li>
</ul>
<p>关于私有前缀：</p>
<blockquote>
<p>在标准还未确定时，部分浏览器已经根据最初草案实现了部分功能，为了与之后确定下来的标准进行兼容，所以每种浏览器使用了自己的私有前缀与标准进行区分，当标准确立后，各大浏览器将逐步支持不带前缀的 css3 新属性</p>
<p>目前已有很多私有前缀可以不写了，但为了兼容老版本的浏览器，可以仍沿用私有前缀和标准方法，逐渐过渡</p>
<p>一般来说，CSS3 主要是为移动端而生的，因此我们在移动端没必要写太多的前缀，因为移动端的 ios 和 Android 的浏览器都是 webkit 内核</p>
<p>谷歌、苹果浏览器：<code>-webkit-</code><br>火狐浏览器：<code>-moz-</code><br>IE 浏览器：<code>-ms-</code><br>欧朋浏览器：<code>-o-</code></p>
<p>一般工作中不用去加，会通过打包工具 webpack 自动添加</p>
</blockquote>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><ul>
<li>text-shadow: 文字阴影</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：text-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]*</span><br><span class="line">  &lt;shadow&gt; =&gt; &lt;length&gt;&#123;2,3&#125; &amp;&amp; &lt;color&gt;?</span><br><span class="line">text-shadow：水平偏移 垂直偏移 羽化大小 颜色</span><br><span class="line">水平偏移 垂直偏移 可以为负值，羽化大小可选且不可为负</span><br><span class="line">可以设置多组阴影值，用逗号隔开</span><br></pre></td></tr></table></figure>

<ul>
<li>box-shadow: 边框阴影</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：box-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]*</span><br><span class="line">  &lt;shadow&gt; =&gt; inset? &amp;&amp; &lt;length&gt;&#123;2,4&#125; &amp;&amp; &lt;color&gt;?</span><br><span class="line"></span><br><span class="line">box-shadow：水平偏移 垂直偏移 羽化大小 阴影外延 颜色</span><br><span class="line">水平偏移、垂直偏移、阴影外延可以为负值，羽化大小、阴影外延可选，羽化大小不允许负值</span><br><span class="line">可以设置多组阴影值，用逗号隔开</span><br><span class="line">inset：设置对象的阴影类型为内阴影。该值为空时，则对象的阴影类型为外阴影</span><br></pre></td></tr></table></figure>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>background-size</p>
<p>bakground-clip</p>
<p>background-origin</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><blockquote>
<p>linear-gradient() 指沿着某条直线朝一个方向产生的渐变效果</p>
<p>渐变实际上相当与一张图片，因为需要加给 background-image 才会生效</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最简单的渐变 颜色至少两个 方向默认从上到下 */</span></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(red, green);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设定渐变的方向 */</span></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, red, green);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 也可以设定渐变的角度 */</span></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, red, green);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设定渐变的范围 */</span></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, red <span class="number">20%</span>, green <span class="number">80%</span>)</span><br><span class="line"></span><br><span class="line">/* 每一个区间表示渐变颜色的范围 */</span><br><span class="line">background-image: <span class="built_in">linear-gradient</span>(to right, red <span class="number">20%</span>, green <span class="number">20%</span>)</span><br></pre></td></tr></table></figure>

<h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><blockquote>
<p>radial-gradient 指从一个中心点开始沿着四周产生渐变效果</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最简单的渐变 */</span></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(red, green);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定圆的半径和圆心 */</span></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(<span class="number">200px</span> at center, red, green);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定椭圆 */</span></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(<span class="number">200px</span> <span class="number">80px</span> at center, red, green);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定范围 */</span></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(<span class="number">200px</span> at center, green <span class="number">50%</span>, red <span class="number">50%</span>);</span><br></pre></td></tr></table></figure>

<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><blockquote>
<p>CSS3 中可以通过 box-sizing 来指定盒模型，即可指定为 content-box、border-box，这样我们计算盒子大小的方式就发生了改变</p>
</blockquote>
<p>可以分成两种情况：</p>
<ul>
<li>box-sizing: border-box 计算方式为 content = width – border - padding</li>
<li>box-sizing: content-box 计算方式为 content = width</li>
</ul>
<h2 id="calc-函数"><a href="#calc-函数" class="headerlink" title="calc() 函数"></a>calc() 函数</h2><p>用于动态计算长度值</p>
<ul>
<li>注意：运算符前后都需要保留一个空格，例如：<code>width: calc(100% - 10px)</code></li>
<li>任何长度值都可以使用 calc() 函数进行计算</li>
<li>calc() 函数支持 <code>+</code> 、<code>-</code>、 <code>*</code> 、<code>/</code> 运算</li>
<li>calc() 函数使用标准的数学运算优先级规则</li>
</ul>
<h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><ul>
<li>过渡的属性</li>
</ul>
<p>如果两个状态发生改变，没有过渡，效果是瞬间变化的，如果加上了过渡，那么这个过程就会有动画的效果，整个状态变化的过程是由浏览器来完成的，我们只需要关注开始状态与结束状态即可</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* transition-property：设置过渡属性 默认值为 all 表示全部*/</span></span><br><span class="line"><span class="comment">/* 多个用逗号分隔 */</span></span><br><span class="line"><span class="attribute">transition-property</span>: all;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-duration:设置过渡时间 */</span></span><br><span class="line"><span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-delay：设置过渡延时 */</span></span><br><span class="line"><span class="attribute">transition-delay</span>: <span class="number">2s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-timing-function:设置过渡的速度 */</span></span><br><span class="line"><span class="comment">/* linear(匀速)，ease(平滑)，ease-in，ease-out，ease-in-out， steps(10)(分步动画) */</span></span><br><span class="line"><span class="attribute">transition-timing-function</span>: linear;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>过渡必须要有两个状态的变化</li>
<li>过渡除了可以加到初始的状态，可以加到 hover 状态，但效果不一样，如果加到 hover 状态，回来就没有过渡了</li>
</ol>
</blockquote>
<ul>
<li>属性合写</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 属性 时间 延时 速度 */</span></span><br><span class="line"><span class="comment">/* 多个过渡用逗号隔开 */</span></span><br><span class="line"><span class="attribute">transition</span>: width <span class="number">1s</span> <span class="number">3s</span> linear, border-radius <span class="number">3s</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2D-转换"><a href="#2D-转换" class="headerlink" title="2D 转换"></a>2D 转换</h2><blockquote>
<p>transform: 转换，是 CSS3 最具颠覆性的几个特性之一，既可以用于 2D 转换，也可以用于 3D 转换</p>
<p>transform: 2D 转换，元素在平面上实现移动、旋转、缩放、斜切等操作</p>
</blockquote>
<h3 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale 缩放"></a>scale 缩放</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.5</span>); <span class="comment">/* 让宽度变化 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>); <span class="comment">/* 让高度变化，注意不能写多个transform，不然会覆盖 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>); <span class="comment">/* 让宽度和高度同时变化 */</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>scale 接收的值是倍数，因此没有单位</p>
</li>
<li><p>scale 是一个值时，宽度高度会等比例同事缩放</p>
</li>
<li><p>scale 缩放时内部内容也会缩放</p>
</li>
<li><blockquote>
<p>可以通过 transition-origin 设定缩放原点 （可以是数值或方位词 top、left…)</p>
</blockquote>
</li>
</ul>
<h3 id="translate-平移"><a href="#translate-平移" class="headerlink" title="translate 平移"></a>translate 平移</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">100px</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">100px</span>, <span class="number">100px</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50%</span>, <span class="number">50%</span>);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>translate 的值可以是 px，也可以是百分比，如果是百分比，那么参照的是<strong>自身的宽高</strong></li>
<li>translate 移动的元素并不会影响其他盒子，类似于相对定位</li>
</ul>
<h3 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>); <span class="comment">/* 旋转360度 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">360deg</span>); <span class="comment">/* 逆时针旋转360度 */</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>单位是 deg，角度，不是 px</li>
<li>正值顺时针转，负值逆时针转</li>
<li>可以通过 transition-origin 设定旋转原点</li>
</ul>
<blockquote>
<p>rotate 旋转会让坐标轴也跟着旋转</p>
</blockquote>
<h3 id="skew-斜切-变形"><a href="#skew-斜切-变形" class="headerlink" title="skew 斜切(变形)"></a>skew 斜切(变形)</h3><p>skew 在实际开发中，是用的最少的一个属性。一般来说，x 和 y 只会倾斜其中的一个</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在水平方向倾斜30deg */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewX</span>(<span class="number">30deg</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在垂直方向倾斜30deg */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewY</span>(<span class="number">30deg</span>);</span><br></pre></td></tr></table></figure>

<p>【案例：扫光效果.html】</p>
<h3 id="transform-origin-转换原点"><a href="#transform-origin-转换原点" class="headerlink" title="transform-origin 转换原点"></a>transform-origin 转换原点</h3><blockquote>
<p>通过 transform-origin 可以设置转换的中心原点</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>: center center;</span><br><span class="line"><span class="attribute">transform-origin</span>: <span class="number">40px</span> <span class="number">40px</span>;</span><br></pre></td></tr></table></figure>

<h3 id="转换合写问题"><a href="#转换合写问题" class="headerlink" title="转换合写问题"></a>转换合写问题</h3><blockquote>
<p>transform 属性只能写一个，如果写了多个会覆盖，属性的值可以写多个， 用空格隔开即可</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">800px</span>) <span class="built_in">scale</span>(<span class="number">1.5</span>) <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>transform 属性可以连写，但是顺序对效果影响的，因为它会在第一个效果的基础上执行第二个效果，然后执行第三个效果（通常会把 rotate 放后面）</li>
<li>如果对 transform 进行过度效果的时候，初始状态和结束状态要一一对应</li>
</ul>
<p>【案例：盾牌打散与合并效果.html】</p>
<h2 id="3D-转换"><a href="#3D-转换" class="headerlink" title="3D 转换"></a>3D 转换</h2><p>思考：2D 与 3D 的区别？</p>
<h3 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h3><blockquote>
<p>用 X、Y、Z 分别表示空间的 3 个维度，三条轴互相垂直。<strong>注意+Y 是向下的</strong></p>
</blockquote>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102204311.png"></p>
<h3 id="perspective-透视"><a href="#perspective-透视" class="headerlink" title="perspective 透视"></a>perspective 透视</h3><blockquote>
<p>电脑显示屏是一个 2D 的平面，因为我们看不出来旋转的方向，通过 perspective 属性，可以定义 3D 元素距视图的距离，单位是 px。</p>
<p>说白了，设置了 perspective 属性后，就有了进大远小的效果了，在视觉上，让我们能看出来 3d 的效果。</p>
<p>注意：当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">perspective</span>：<span class="number">500px</span>;</span><br></pre></td></tr></table></figure>

<p>对于我们眼睛来说，离我们越近的房子，我们会感觉到这个房子越大，离我们越远的房子，就会感觉越小，其实房子的大小都是一样的，只是在视觉上的一种不同。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102204343.png"></p>
<h3 id="rotate-旋转-1"><a href="#rotate-旋转-1" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); <span class="comment">/* 让元素在平面2D中旋转，相当于沿着Z轴旋转 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">45deg</span>); <span class="comment">/* 让元素沿着X轴转45度 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">45deg</span>); <span class="comment">/* 让元素沿着Y轴转45度 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(<span class="number">45deg</span>); <span class="comment">/* 让元素沿着Z轴转45度 */</span></span><br></pre></td></tr></table></figure>

<p>【3D 旋转.html】</p>
<h3 id="translate-平移-1"><a href="#translate-平移-1" class="headerlink" title="translate 平移"></a>translate 平移</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 沿着X轴的正方向移动45px */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">45px</span>);</span><br><span class="line"><span class="comment">/* 沿着Y轴的正方向移动45px */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">45px</span>);</span><br><span class="line"><span class="comment">/* 沿着Z轴的正方向移动45px */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">45px</span>);</span><br></pre></td></tr></table></figure>

<p>【3D 平移.html】</p>
<p>【立方体.html】</p>
<h3 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h3><p>transform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。注意这个属性只能给父元素添加</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">flat: 默认值，<span class="number">2</span>d显示</span><br><span class="line">preserve-<span class="number">3</span>d: <span class="number">3</span>d显示</span><br></pre></td></tr></table></figure>

<p>transform-style 与 perspective 区别</p>
<ul>
<li>透视：透视只是相当于设置了一个距离，辅助我们查看 3D 效果的工具</li>
<li>preserve-3d：给父盒子添加，让子元素保留 3D 的位置，说白了，只有设置了 preserve-3d，这个元素才能被称之为 3d 元素</li>
<li>一个 3d 元素可以没有 perspective，但是不能没有 transform-style</li>
</ul>
<p>【3D 导航案例.html】</p>
<p>【切割轮播图案例】</p>
<p>【3D 相册案例】</p>
<h3 id="过渡结束事件"><a href="#过渡结束事件" class="headerlink" title="过渡结束事件"></a>过渡结束事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给最后一个ul添加过渡结束事件（节流阀）</span></span><br><span class="line">uls[uls.length - <span class="number">1</span>].addEventListener(<span class="string">&#x27;transitionend&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  isCanAnimate = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><blockquote>
<p>动画可以通过设置多个节点来精确控制一个或者一组动画，常用来实现复杂的动画效果</p>
</blockquote>
<p>动画与过渡的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">过渡必须触发，需要两个状态的改变。</span><br><span class="line">动画可以一直运行下去，不需要触发。实现效果与过渡差不多</span><br></pre></td></tr></table></figure>

<p>使用一个动画的基本步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.通过 @keyframes 指定动画序列</span><br><span class="line">2.通过百分比或者 from/to 将动画分割成多个节点</span><br><span class="line">3.在各个节点中分别定义样式</span><br><span class="line">4.通过 animation 将动画应用于相应的元素</span><br></pre></td></tr></table></figure>

<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>animation 是一个复合属性，一共有 8 个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animation-name: 动画名称，由@keyframes定义的</span><br><span class="line">animation-duration: 动画的持续时间 默认0s</span><br><span class="line">animation-timing-function: 动画的过渡类型 ease(默认) linear steps</span><br><span class="line">animation-delay: 动画的延迟时间 默认0s</span><br><span class="line">animation-iteration-count: 动画的循环次数 默认1次  infinite：无限循环</span><br><span class="line">animation-direction: 设置动画在循环中的方向 normal：正向(默认) reverse(反向) alternate(往复循环)</span><br><span class="line">animation-fill-mode: 设置动画结束时的状态 none：默认 backwards：动画结束时停留在开始状态 forwards: 动画结束时停留在结束的状态</span><br><span class="line">animation-play-state: 设置动画的状态。running：运动(默认) paused：暂停</span><br></pre></td></tr></table></figure>

<h3 id="动画库的使用"><a href="#动画库的使用" class="headerlink" title="动画库的使用"></a>动画库的使用</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kYW5lZGVuLmdpdGh1Yi5pby9hbmltYXRlLmNzcy8=">https://daneden.github.io/animate.css/</span></p>
<h2 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h2><p>我们经常把网页常用的一些小的图标，做成精灵图，然后通过 background-position 去调整位置，但是这个需要引入图片，并且图片大小改变之后会失真。在 CSS3 中可以使用字体图片，即使用图标跟使用文字一样</p>
<p>优点：</p>
<p>1、将所有图标打包成字体库，减少请求</p>
<p>2、具有矢量性，可保证清晰度，可以修改文字的颜色或者样式</p>
<p>3、使用灵活，便于维护</p>
<p>阿里巴巴矢量图标：<span class="exturl" data-url="aHR0cDovL3d3dy5pY29uZm9udC5jbi8=">http://www.iconfont.cn/</span></p>
<p>Font Awesome 使用 <span class="exturl" data-url="aHR0cDovL2ZvbnRhd2Vzb21lLmRhc2hnYW1lLmNvbS8=">http://fontawesome.dashgame.com/</span></p>
<h2 id="弹性布局-伸缩布局"><a href="#弹性布局-伸缩布局" class="headerlink" title="弹性布局(伸缩布局)"></a>弹性布局(伸缩布局)</h2><blockquote>
<p>布局：其实就是调整元素在水平和垂直方向上的布局方式</p>
</blockquote>
<p>CSS3 在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。</p>
<p>当给一个盒子设置了 display：flex 之后，这个盒子就有了 <strong>主轴</strong> 和 <strong>侧轴</strong> 的概念<br>主轴：默认是水平方向向右，子元素在主轴上排列<br>侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向向下</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102204407.png"></p>
<h3 id="给容器设置的样式"><a href="#给容器设置的样式" class="headerlink" title="给容器设置的样式"></a>给容器设置的样式</h3><ul>
<li>flex-direction</li>
</ul>
<p>用来调整主轴的方向，默认是水平方向，可选值有：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">row：主轴方向为水平向右（默认）</span><br><span class="line">column：主轴方向为竖直向下</span><br><span class="line">row-reverse: 主轴方向为水平向左</span><br><span class="line">column-reverse: 主轴方向是竖直向上</span><br></pre></td></tr></table></figure>

<ul>
<li>justify-content</li>
</ul>
<p>用来设置子元素在 <strong>主轴方向的对齐方式</strong> ，可选的值有：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex</span>-start: 弹性盒子元素将向起始位置对齐</span><br><span class="line">flex-end: 弹性盒子元素将向结束位置对齐</span><br><span class="line">center: 弹性盒子元素将向行中间位置对齐</span><br><span class="line">space-between: 第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的</span><br><span class="line">space-around: 弹性盒子元素会平均地分布在行里（不会贴边）</span><br></pre></td></tr></table></figure>

<ul>
<li>align-items</li>
</ul>
<p>用于调整 <strong>侧轴的对其方式</strong> ，可选的值有：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex</span>-start：元素在侧轴的起始位置对其</span><br><span class="line"><span class="attribute">flex</span>-end：元素在侧轴的结束位置对其</span><br><span class="line">center：元素在侧轴上居中对其</span><br><span class="line">stretch：元素的高度会被拉伸到最大（不能给死高度）</span><br></pre></td></tr></table></figure>

<ul>
<li>flex-wrap</li>
</ul>
<p>控制 flex 容器是单行或者多行，默认不换行</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">nowrap：不换行（默认），会压缩子盒子的宽度</span><br><span class="line">wrap：当宽度不够的时候，会换行</span><br></pre></td></tr></table></figure>

<ul>
<li>align-content</li>
</ul>
<p>用来设置多行时侧轴的排列方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex</span>-start：各行向侧轴的起始位置堆叠</span><br><span class="line"><span class="attribute">flex</span>-end：各行向弹性盒容器的结束位置堆叠</span><br><span class="line">center：各行向弹性盒容器的中间位置堆叠</span><br><span class="line">space-between：第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布</span><br><span class="line">space-around：各行在侧轴中平均分布</span><br><span class="line">stretch：拉伸，不设置高度的情况下</span><br></pre></td></tr></table></figure>

<p>align-items 与 align-content 的区别</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">align-items</span>调整的是侧轴的对其方式，不换行一般用align-itemsalign-<span class="attribute">content</span>: 必须是多行才生效，如果单行，没有效果。换行了就用 align-content;</span><br></pre></td></tr></table></figure>

<p>!&gt; 上述属性都是给父盒子设置的，这些样式影响的是所有的子元素，接下来的几个属性是给子盒子设置的，用来单独设置子元素的样式</p>
<h3 id="给子元素设置的样式"><a href="#给子元素设置的样式" class="headerlink" title="给子元素设置的样式"></a>给子元素设置的样式</h3><ul>
<li>flex</li>
</ul>
<p>用来设置子盒子如何分配主轴剩余空间</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>order</li>
</ul>
<p>定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">order</span>: <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>align-self</li>
</ul>
<p>align-self 用于设置当前元素在侧轴的位置，是给子元素设置，优先级比 align-items 的优先级高</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">取值与 <span class="attribute">align-items</span> 的取值一样</span><br></pre></td></tr></table></figure>

<p>阮一峰的博客<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTUvMDcvZmxleC1ncmFtbWFyLmh0bWw=">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</span></p>
<p>【案例：6 面神骰】</p>
<p>【案例：携程网】</p>
<p>【案例：360 浏览器】</p>
<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><p>微调元素</p>
<ul>
<li>margin-top: - ;</li>
<li>transform: translateY();</li>
<li>position: relative; top: - ;</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">c</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>本站为个人博客，站内所有软件资源均收集自互联网，本站仅做免费分享，不出售。本站内所有软件资源仅限个人用于学习和研究目的，不得将上述内容用于商业或者非法用途，否则，一切后果请用户自负。本站内所有软件必须在下载后的24个小时之内，从您的电脑中彻底删除。本站对任何资源不提供技术支持，遇到问题请自行研究或购买正版。本站信息来自网络，版权争议与本站无关。访问和下载本站内容，说明您已同意上述条款。


    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>





  <script class="next-config" data-name="nprogress" type="application/json">{&quot;enable&quot;:true,&quot;spinner&quot;:true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{&quot;enable&quot;:true,&quot;repo&quot;:&quot;cuilongjin&#x2F;hexo-blog&quot;,&quot;issue_term&quot;:&quot;pathname&quot;,&quot;theme&quot;:&quot;github-light&quot;,&quot;label&quot;:&quot;comment&quot;}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
