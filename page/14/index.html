<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-logo.png">
  <link rel="mask-icon" href="/images/favicon-logo.png" color="#222">
  <meta name="google-site-verification" content="4ub2lNf2WEkusifo-b7xbJIm2G5xxYUczDoWOFGp-NM">
  <meta name="msvalidate.01" content="C2030D8E2452D4B39AED09488E55F2DF">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wqdy.top","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

  <meta name="description" content="分享各类资源、经验与技巧">
<meta property="og:type" content="website">
<meta property="og:title" content="我全都要">
<meta property="og:url" content="https://wqdy.top/page/14/index.html">
<meta property="og:site_name" content="我全都要">
<meta property="og:description" content="分享各类资源、经验与技巧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="c">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wqdy.top/page/14/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/14/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>我全都要</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112496567-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-112496567-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?0a902dd83e2d4f1aebaeaa0bafe307a0"></script>





<!-- google 分析 -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9068539038073295"
     crossorigin="anonymous"></script>


  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我全都要</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">搞快点</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-前端"><a href="/c/frontend/" rel="section"><i class="fab fa-html5 fa-fw"></i>前端</a></li>
        <li class="menu-item menu-item-软件"><a href="/c/software/" rel="section"><i class="fas fa-th-large fa-fw"></i>软件</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-面试"><span class="exturl" data-url="aHR0cHM6Ly9tcy53cWR5LnRvcA=="><i class="fas fa-archive fa-fw"></i>面试</span></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="c"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">c</p>
  <div class="site-description" itemprop="description">分享各类资源、经验与技巧</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1aWxvbmdqaW4=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cuilongjin"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/234.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/234.html" class="post-title-link" itemprop="url">如何注册美区 PayPal 并绑定美区 Apple ID，以及风控的解决方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2019-06-30" itemprop="dateCreated datePublished" datetime="2019-06-30T00:00:40+00:00">2019-06-30</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><span class="exturl" data-url="aHR0cDovL2pvbHNvbi54eXovMjAxOC8xMS8yMi9yZWctdXMtcHAv">原文</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/2008.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2008.html" class="post-title-link" itemprop="url">神级代码注释</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2019-06-30" itemprop="dateCreated datePublished" datetime="2019-06-30T00:00:00+00:00">2019-06-30</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><span class="exturl" data-url="aHR0cDovL3d3dy5hc2NpaXdvcmxkLmNvbS8=">http://www.asciiworld.com/</span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JsYW5rai9hd2Vzb21lLWNvbW1lbnQ=">https://github.com/Blankj/awesome-comment</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> -------------------------</span><br><span class="line">&lt; Just have fun with gist &gt;</span><br><span class="line"> -------------------------</span><br><span class="line">        \   ^__^</span><br><span class="line">         \  (oo)\_______</span><br><span class="line">            (__)\       )\/\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//When I wrote this, only God and I understood what I was doing</span><br><span class="line">//Now, God only knows</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/420.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/420.html" class="post-title-link" itemprop="url">Docker 的安装和使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2019-06-18" itemprop="dateCreated datePublished" datetime="2019-06-18T22:27:38+00:00">2019-06-18</date>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装-dcoker"><a href="#安装-dcoker" class="headerlink" title="安装 dcoker"></a>安装 dcoker</h2><h3 id="ubuntu-16-04-LTS-安装-docker"><a href="#ubuntu-16-04-LTS-安装-docker" class="headerlink" title="ubuntu 16.04 (LTS) 安装 docker"></a>ubuntu 16.04 (LTS) 安装 docker</h3><p>参考官网安装方法 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwvdWJ1bnR1Lw==">https://docs.docker.com/engine/install/ubuntu/</span></p>
<p>卸载旧版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>

<h4 id="镜像仓库方式安装"><a href="#镜像仓库方式安装" class="headerlink" title="镜像仓库方式安装"></a>镜像仓库方式安装</h4><h5 id="设置镜像仓库"><a href="#设置镜像仓库" class="headerlink" title="设置镜像仓库"></a>设置镜像仓库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 apt 软件包索引：</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># 安装软件包，以允许 apt 通过 HTTPS 使用镜像仓库：</span></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥：</span></span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># 验证密钥指纹是否为 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。</span></span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 stable 镜像仓库</span></span><br><span class="line"><span class="comment"># amd64:</span></span><br><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用国内源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更换国内软件源，推荐中国科技大学的源</span></span><br><span class="line">$ sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">$ sudo sed -i <span class="string">&#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list</span><br><span class="line">$ sudo apt update</span><br><span class="line"><span class="comment"># 安装需要的包</span></span><br><span class="line">$ sudo apt install apt-transport-https ca-certificates software-properties-common curl</span><br><span class="line"><span class="comment"># 添加 GPG 密钥，并添加 Docker-ce 软件源，这里还是以中国科技大学的 Docker-ce 源为例</span></span><br><span class="line">$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string"><span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br><span class="line"><span class="comment"># 添加成功后更新软件包缓存</span></span><br><span class="line">$ sudo apt update</span><br><span class="line"><span class="comment"># 安装 Docker-ce</span></span><br><span class="line">$ sudo apt install docker-ce</span><br></pre></td></tr></table></figure>

<h5 id="安装-DOCKER-CE"><a href="#安装-DOCKER-CE" class="headerlink" title="安装 DOCKER CE"></a>安装 DOCKER CE</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装指定版本</span></span><br><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">  docker-ce | 5:18.09.1~3-0~ubuntu-bionic | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br><span class="line">  docker-ce | 5:18.09.0~3-0~ubuntu-bionic | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.0~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br><span class="line">  docker-ce | 18.03.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure>

<p>启动 docker daemon<br>否则会报错：docker: Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?.<br>See ‘docker run –help’.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service docker start</span><br><span class="line"><span class="comment"># sudo systemctl enable docker</span></span><br><span class="line"><span class="comment"># sudo systemctl start docker</span></span><br></pre></td></tr></table></figure>

<p>验证是否正确安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<p>此命令将下载一个测试镜像并在容器中运行它。容器运行时，它将输出一条参考消息并退出</p>
<h5 id="升级-docker-ce"><a href="#升级-docker-ce" class="headerlink" title="升级 docker ce"></a>升级 docker ce</h5><p>如需升级 Docker CE，首先运行 <code>sudo apt-get update</code>，然后按照顺序执行操作，并选择您要安装的新版本</p>
<h5 id="卸载-docker-ce"><a href="#卸载-docker-ce" class="headerlink" title="卸载 docker ce"></a>卸载 docker ce</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<p>主机上的镜像、容器、存储卷、或定制配置文件不会自动删除。如需删除所有镜像、容器和存储卷，请运行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>

<h5 id="将-docker-配置为在启动时启动"><a href="#将-docker-配置为在启动时启动" class="headerlink" title="将 docker 配置为在启动时启动"></a>将 docker 配置为在启动时启动</h5><h4 id="使用脚本安装"><a href="#使用脚本安装" class="headerlink" title="使用脚本安装"></a>使用脚本安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.docker.com/ | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将用户添加到docker组，可以用非root用户使用docker</span></span><br><span class="line">$ sudo usermod -aG docker &lt;your-user&gt;</span><br></pre></td></tr></table></figure>

<p>国内的服务器可以使用如下脚本加速安装，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 阿里云的安装脚本</span></span><br><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br><span class="line"><span class="comment"># DaoCloud 的安装脚本</span></span><br><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure>

<h3 id="centos-安装-docker"><a href="#centos-安装-docker" class="headerlink" title="centos 安装 docker"></a>centos 安装 docker</h3><p>参考官网安装方法 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwvY2VudG9zLw==">https://docs.docker.com/engine/install/centos/</span></p>
<p>卸载旧版本(如果安装过旧版本的话)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<p>安装需要的软件包， yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<p>设置 yum 源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以查看所有仓库中所有 docker 版本，并选择特定版本安装</span></span><br><span class="line">$ yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line">$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Docker,设置开机启动,停止 Docker</span></span><br><span class="line">$ sudo systemctl start docker</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl stop docker</span><br></pre></td></tr></table></figure>

<p>卸载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line">$ sudo <span class="built_in">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>

<p>常见问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 报错：Requires: container-selinux &gt;= 2:2.74</span></span><br><span class="line">You could try using --skip-broken to work around the problem</span><br><span class="line"></span><br><span class="line">$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">$ yum install epel-release   <span class="comment"># 阿里云上的 epel 源</span></span><br><span class="line">$ yum makecache</span><br><span class="line">$ yum install container-selinux</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Job for docker.service failed because the control process exited with error code. See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details.</span></span><br><span class="line"></span><br><span class="line">卸载 docker 重新安装</span><br></pre></td></tr></table></figure>

<h2 id="使用-docker"><a href="#使用-docker" class="headerlink" title="使用 docker"></a>使用 docker</h2><h2 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h2><h3 id="修改-docker-源"><a href="#修改-docker-源" class="headerlink" title="修改 docker 源"></a>修改 docker 源</h3><p>修改配置文件 <code>/etc/docker/daemon.json</code>（Linux） 或者 <code>%programdata%\docker\config\daemon.json</code>（Window)</p>
<p>如果没有新建一个</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启 docker</p>
<h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><p>安装 Ubuntu 镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search ubuntu <span class="comment"># 查找 Ubuntu 镜像</span></span><br><span class="line">docker pull ubuntu <span class="comment"># 安装 Ubuntu 镜像</span></span><br><span class="line">docker images <span class="comment">#查看 docker 镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并运行 docker 容器</span></span><br><span class="line">docker run -it -d --name ubuntu_test -p 8088:80 ubuntu</span><br><span class="line"><span class="comment"># --name 自定义容器名，-p 指定端口映射，前者为虚拟机端口，后者为容器端口,成功后返回 id</span></span><br><span class="line"><span class="comment"># 多个 -p 指定多个端口映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 docker 容器  启动一个 bash 交互终端</span></span><br><span class="line">docker run -it 容器名:容器tag /bin/bash</span><br><span class="line"></span><br><span class="line">docker start container_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有启动的容器(查看所有容器加 -a)</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 id 查看容器信息</span></span><br><span class="line">docker inspect <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker(或者把容器id改为容器名，也可以进入)</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span>或容器名 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># OCI runtime exec failed: exec failed: container_linux.go:349: starting container process caused &quot;exec: \&quot;/bin/bash\&quot;: stat /bin/bash: no such file or directory&quot;: unknown</span></span><br><span class="line"><span class="comment"># 解决</span></span><br><span class="line"><span class="comment"># docker exec -it 容器id或容器名 /bin/sh</span></span><br><span class="line"><span class="comment"># docker exec -it 容器id或容器名 bash</span></span><br><span class="line"><span class="comment"># docker exec -it 容器id或容器名 sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi 删除镜像</span><br></pre></td></tr></table></figure>

<p>备份镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 制作 docker 镜像  1.0 为版本号</span></span><br><span class="line">docker commit 98 my-ubuntu:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像是否创建</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存镜像到 docker 账号中</span></span><br><span class="line"><span class="comment"># 登录进 Docker 注册中心</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送镜像</span></span><br><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br><span class="line">docker tag my-ubuntu:1.0 cuilongjin/my-ubuntu:1.0</span><br><span class="line">docker push cuilongjin/my-ubuntu:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包镜像并查看</span></span><br><span class="line">docker save -o my-ubuntu.tar my-ubuntu:1.0</span><br></pre></td></tr></table></figure>

<p>恢复容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从docker账号中拉取</span></span><br><span class="line">docker pull cuilongjin/my-ubuntu:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地</span></span><br><span class="line">docker load -i ~/my-ubuntu.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用加载的镜像去运行Docker容器</span></span><br><span class="line">docker run -d -p 80:80 my-ubuntu</span><br></pre></td></tr></table></figure>

<p><strong>docker 给已存在的容器添加或修改端口映射</strong></p>
<p>方式 1：</p>
<p>提交一个运行中的容器为镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker commit containerid foo/live</span><br></pre></td></tr></table></figure>

<p>运行镜像并添加端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 8000:80  foo/live /bin/bash</span><br></pre></td></tr></table></figure>

<p>方式 2：iptable 转发端口</p>
<p>将容器的 8000 端口映射到 docker 主机的 8001 端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iptables -t nat -A  DOCKER -p tcp --dport 5001 -j DNAT --to-destination 45.77.150.20:8000</span><br></pre></td></tr></table></figure>

<h3 id="docker-容器使用问题"><a href="#docker-容器使用问题" class="headerlink" title="docker 容器使用问题"></a>docker 容器使用问题</h3><h4 id="Centos7-docker-容器报-docker-Failed-to-get-D-Bus-connection-错误"><a href="#Centos7-docker-容器报-docker-Failed-to-get-D-Bus-connection-错误" class="headerlink" title="Centos7 docker 容器报 docker Failed to get D-Bus connection 错误"></a>Centos7 docker 容器报 docker Failed to get D-Bus connection 错误</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start nginx</span><br><span class="line">Failed to get D-Bus connection: Operation not permitted。</span><br></pre></td></tr></table></figure>

<p>原因是 dbus-daemon 没能启动</p>
<p>解决方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -d --name ubuntu_test -p 8088:80 ubuntu</span><br><span class="line">$ docker run --privileged -ti --name test1  centos /usr/sbin/init</span><br></pre></td></tr></table></figure>

<h4 id="ssh-链接-docker-容器"><a href="#ssh-链接-docker-容器" class="headerlink" title="ssh 链接 docker 容器"></a>ssh 链接 docker 容器</h4><p>进入容器</p>
<p>安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install passwd openssl openssh-server openssh-clients -y</span><br></pre></td></tr></table></figure>

<p>安装 service 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install initscripts -y</span><br></pre></td></tr></table></figure>

<p>修改密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>

<p>修改配置：</p>
<p>vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config</p>
<p>PubkeyAuthentication yes #启用公钥私钥配对认证方式<br>AuthorizedKeysFile .ssh&#x2F;authorized_keys #公钥文件路径</p>
<p>PermitRootLogin yes #root 能使用 ssh 登录</p>
<p>重启 ssh 服务，并设置开机启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service sshd restartchkconfig sshd on</span><br></pre></td></tr></table></figure>

<p>如果无法执行，可试着执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start sshd.service systemctl enable sshd.service</span><br><span class="line"></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>

<h4 id="运行-docker-exec-it-容器-x2F-bin-x2F-bash-出现如下错误"><a href="#运行-docker-exec-it-容器-x2F-bin-x2F-bash-出现如下错误" class="headerlink" title="运行 docker exec -it 容器 &#x2F;bin&#x2F;bash 出现如下错误"></a>运行 docker exec -it 容器 &#x2F;bin&#x2F;bash 出现如下错误</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OCI runtime exec failed: exec failed: container_linux.go:346: starting container process caused &quot;exec: \&quot;/bin/bash\&quot;: stat /bin/bash: no such file or directory&quot;: unknown</span><br></pre></td></tr></table></figure>

<p>解决方式：尝试使用如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it 容器 /bin/sh</span><br><span class="line">sudo docker <span class="built_in">exec</span> -it 容器 bash</span><br></pre></td></tr></table></figure>

<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>如果你想要通过 docker-compose 统一管理你的 Docker container，这里也可以安装一下</p>
<p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS9pbnN0YWxsLw==">https://docs.docker.com/compose/install/</span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.26.2/run.sh &gt; /usr/local/bin/docker-compose</span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>使用 pip 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure>

<p>运行一下 <code>docker-compose version</code> 来检测一下是否成功</p>
<h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>创建一个名为 <code>docker-compose.yml</code> 的配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">v2ray1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">v2fly/v2fly-core</span> <span class="comment"># 镜像名称</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">v2ray</span> <span class="comment"># 容器名称</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">v2ray</span> <span class="string">-config=/etc/v2ray/config.json</span> <span class="comment"># 覆盖容器启动后默认执行的命令</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># HOST:CONTAINER</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;44222:44222&#x27;</span> <span class="comment"># 端口</span></span><br><span class="line">      <span class="comment">#- &quot;127.0.0.1:8889:8889&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># HOST:CONTAINER</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config:/etc/v2ray</span> <span class="comment"># 目录</span></span><br><span class="line">      <span class="comment">#- /etc/v2ray/v2ray.crt:/etc/v2ray/v2ray.crt</span></span><br><span class="line">      <span class="comment">#- /etc/v2ray/v2ray.key:/etc/v2ray/v2ray.key</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">v2ray2:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span> <span class="comment"># context 选项可以是 Dockerfile 的文件路径，也可以是到链接到 git 仓库的 url</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">path/of/Dockerfile</span> <span class="comment"># 使用此 dockerfile 文件来构建，必须指定构建路径</span></span><br></pre></td></tr></table></figure>

<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>以下命令需要在 docker-compose.yml 所在目录下执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d <span class="comment"># 部署 v2ray</span></span><br><span class="line">docker-compose start v2ray <span class="comment"># 启动 v2ray</span></span><br><span class="line">docker-compose stop v2ray <span class="comment"># 停止 v2ray</span></span><br><span class="line">docker-compose restart v2ray <span class="comment"># 重启 v2ray</span></span><br><span class="line">docker stop v2ray &amp;&amp; docker <span class="built_in">rm</span> v2ray <span class="comment"># 删除 v2ray</span></span><br><span class="line">docker-compose pull &amp;&amp; docker-compose up -d <span class="comment"># 更新 v2ray</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/418.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/418.html" class="post-title-link" itemprop="url">移动端调试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2019-06-18" itemprop="dateCreated datePublished" datetime="2019-06-18T22:26:24+00:00">2019-06-18</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一些调试工具"><a href="#一些调试工具" class="headerlink" title="一些调试工具"></a>一些调试工具</h2><ol>
<li><p>直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法 100% 还原手机的真实情况</p>
</li>
<li><p>chrome <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL3JlbW90ZS1kZWJ1Z2dpbmc=">远程调试功能</span></p>
<p><code>chrome://inspect/#devices</code></p>
<p>需要连接数据线，其次是设置比较繁琐，而且还限制了 android 手机。对于 IOS 的调试则可能要使用 Safari 的另一套工具</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9wZW9wbGUuYXBhY2hlLm9yZy9+cG11ZWxsci93ZWlucmUvZG9jcy9sYXRlc3Qv">weinre</span>：远程调试，在 PC 上生成一个像 chrome 开发工具一样的调试器，需要手动引入 js</p>
</li>
<li><p>Eruda、vConsole：在移动端页面上生成一个调试器，调试信息会挡住操作元素，查看复杂数据结构的 log 不方便，需要手动引入 js</p>
</li>
<li><p>安装各种虚拟机 sdk，在电脑上进行手机调试。能比较真实模拟手机，但是安装繁琐，操作不方便，无法模拟真实的手势操作</p>
</li>
</ol>
<h2 id="Eruda"><a href="#Eruda" class="headerlink" title="Eruda"></a>Eruda</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpcmlsaXJpL2VydWRh">https://github.com/liriliri/eruda</span></p>
<p>Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获 XHR 请求、显示本地存储和 Cookie 信息等等。</p>
<ol>
<li>按钮拖拽，面板透明度大小设置。</li>
<li>Console 面板：捕获 Console 日志，支持 log、error、info、warn、dir、time&#x2F;timeEnd、clear、count、assert、table；支持占位符，包括%c 自定义样式输出；支持按日志类型及正则表达式过滤；支持快捷命令加载 underscore、jQuery 库；支持 JavaScript 脚本执行。</li>
<li>Elements 面板：查看标签内容及属性；查看应用在 Dom 上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看 Dom 上绑定的各类事件。</li>
<li>Network 面板：捕获请求，查看发送数据、返回头、返回内容等信息。</li>
<li>Resources 面板：查看并清除 localStorage、sessionStorage 及 cookie；查看页面加载脚本及样式文件；查看页面加载图片。</li>
<li>Sources 面板：查看页面源码；格式化 html，css，js 代码及 json 数据。</li>
<li>Info 面板：输出 URL 及 User Agent；支持自定义输出内容。</li>
<li>Snippets 面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。</li>
</ol>
<p>使用</p>
<p>通过 CDN 使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.bootcss.com/eruda/1.5.2/eruda.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  eruda.init()</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过 npm 安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install eruda --save</span><br></pre></td></tr></table></figure>

<p>在页面中加载脚本：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;node_modules/eruda/eruda.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  eruda.init()</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Js 文件对于移动端来说略重（gzip 后大概 100kb）。建议通过 url 参数来控制是否加载调试器，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> src = <span class="string">&#x27;node_modules/eruda/eruda.min.js&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/eruda=true/</span>.<span class="title function_">test</span>(<span class="variable language_">window</span>.<span class="property">location</span>) &amp;&amp; <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;active-eruda&#x27;</span>) != <span class="string">&#x27;true&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;scr&#x27;</span> + <span class="string">&#x27;ipt src=&quot;&#x27;</span> + src + <span class="string">&#x27;&quot;&gt;&lt;/scr&#x27;</span> + <span class="string">&#x27;ipt&gt;&#x27;</span>)</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;scr&#x27;</span> + <span class="string">&#x27;ipt&gt;eruda.init();&lt;/scr&#x27;</span> + <span class="string">&#x27;ipt&gt;&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>初始化时可以传入配置：</p>
<ul>
<li>container：用于插件初始化的 Dom 元素，如果不设置，默认创建 div 作为容器直接置于 html 根结点下面</li>
<li>tool：指定要初始化哪些面板，默认加载所有</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(el)</span><br><span class="line"></span><br><span class="line">eruda.<span class="title function_">init</span>(&#123;</span><br><span class="line">  <span class="attr">container</span>: el,</span><br><span class="line">  <span class="attr">tool</span>: [<span class="string">&#x27;console&#x27;</span>, <span class="string">&#x27;elements&#x27;</span>],</span><br><span class="line">  <span class="attr">useShadowDom</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="vConsole"><a href="#vConsole" class="headerlink" title="vConsole"></a>vConsole</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvdkNvbnNvbGU=">https://github.com/Tencent/vConsole</span></p>
<p>一个轻量、可拓展、针对手机网页的前端开发者调试面板</p>
<p>特性</p>
<ul>
<li>查看 console 日志</li>
<li>查看网络请求</li>
<li>查看页面 element 结构</li>
<li>查看 Cookies、localStorage 和 SessionStorage</li>
<li>手动执行 JS 命令行</li>
<li>自定义插件</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvdkNvbnNvbGUvYmxvYi9kZXYvZG9jL3R1dG9yaWFsX0NOLm1k">使用说明</span></p>
<p>下载 vConsole 的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvdkNvbnNvbGUvcmVsZWFzZXMvbGF0ZXN0">最新版本</span>（不要直接下载 dev 分支下的 <code>dist/vconsole.min.js</code>），复制 <code>dist/vconsole.min.js</code> 到项目中：</p>
<p>在 HTML 中引入 vConsole 模块</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;dist/vconsole.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> vConsole = <span class="keyword">new</span> <span class="title class_">VConsole</span>()</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 vue 项目中：使用 npm 安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vconsole</span><br></pre></td></tr></table></figure>

<p>在 main.js 中引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VConsole</span> <span class="keyword">from</span> <span class="string">&#x27;vconsole&#x27;</span></span><br><span class="line"><span class="keyword">const</span> isDebug = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 本地开发调试注入 vConsole</span></span><br><span class="line"><span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">VConsole</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="weinre"><a href="#weinre" class="headerlink" title="weinre"></a>weinre</h2><p><span class="exturl" data-url="aHR0cDovL3Blb3BsZS5hcGFjaGUub3JnL35wbXVlbGxyL3dlaW5yZS9kb2NzL2xhdGVzdC9Ib21lLmh0bWw=">http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html</span></p>
<ol>
<li>Element： 查看&#x2F;修改 dom，查看&#x2F;修改 dom CSS</li>
<li>Resources：查看&#x2F;修改 localStorage, sessionStorage</li>
<li>Network：查看网络请求</li>
<li>Timeline：</li>
<li>Console：查看控制台输出</li>
</ol>
<p>不能做 JS 调试</p>
<p>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install -g weinre</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 weinre 服务</span></span><br><span class="line">weinre --boundHost 192.168.3.44 --httpPort 8888</span><br><span class="line"></span><br><span class="line">启动调试客户端</span><br><span class="line">在浏览器中打开 <span class="string">&#x27;http://192.168.3.44:8888&#x27;</span> 即可启动调试客户端</span><br><span class="line"></span><br><span class="line">在需要调试的页面中添加如下</span><br><span class="line">&lt;script src=<span class="string">&quot;http://192.168.3.44:8888/target/target-script-min.js#anonymous&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="spy-debugger"><a href="#spy-debugger" class="headerlink" title="spy-debugger"></a>spy-debugger</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3d1Y2hhbmdtaW5nL3NweS1kZWJ1Z2dlcg==">https://github.com/wuchangming/spy-debugger</span></p>
<p>微信调试，各种 WebView 样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP&#x2F;HTTPS，无需 USB 连接设备</p>
<p>spy-debugger 集成了<code>weinre</code>，简化了<code>weinre</code>需要给每个调试的页面添加 js 代码。原理是拦截所有 html 页面请求注入<code>weinre</code>所需要的 js 代码。让页面调试更加方便</p>
<p>1、页面调试＋抓包<br>2、操作简单，无需 USB 连接设备<br>3、<strong>支持 HTTPS</strong><br>4、<code>spy-debugger</code>内部集成了<a target="_blank" rel="noopener" href="http://people.apache.org/~pmuellr/weinre/docs/latest/"><code>weinre</code></a>、<a target="_blank" rel="noopener" href="https://github.com/wuchangming/node-mitmproxy"><code>node-mitmproxy</code></a>、<a target="_blank" rel="noopener" href="https://github.com/alibaba/anyproxy"><code>AnyProxy</code></a>。<br>5、自动忽略原生 App 发起的 https 请求，只拦截 webview 发起的 https 请求。对使用了 SSL pinning 技术的原生 App 不造成任何影响。<br>6、可以配合其它代理工具一起使用(默认使用 AnyProxy) <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3d1Y2hhbmdtaW5nL3NweS1kZWJ1Z2dlciMlRTglQUUlQkUlRTclQkQlQUUlRTUlQTQlOTYlRTklODMlQTglRTQlQkIlQTMlRTclOTAlODYlRTklQkIlOTglRTglQUUlQTQlRTQlQkQlQkYlRTclOTQlQThhbnlwcm94eQ==">(设置外部代理)</span></p>
<p>基本使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install spy-debugger -g</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">spy-debugger</span><br><span class="line"><span class="comment">#设置手机的HTTP代理</span></span><br><span class="line">代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)</span><br><span class="line"><span class="comment"># 手机安装证书</span></span><br><span class="line">手机浏览器访问 http://s.xxx</span><br><span class="line">设置-&gt;通用-&gt;描述文件与设备管理-&gt;找到node-mitmproxy CA（安装）</span><br><span class="line">设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到node-mitmproxy CA（打开）</span><br></pre></td></tr></table></figure>

<p>自定义选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义端口</span></span><br><span class="line">spy-debugger -p 8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置页面内容为可编辑模式</span></span><br><span class="line">spy-debugger -w <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否只拦截浏览器发起的https请求(默认： true)</span></span><br><span class="line">spy-debugger -b <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许weinre监控iframe加载的页面(默认： false)</span></span><br><span class="line">spy-debugger -i <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 HTTP 缓存(默认： false)</span></span><br><span class="line">spy-debugger -c <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="m-console"><a href="#m-console" class="headerlink" title="m-console"></a>m-console</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z3b24vbS1jb25zb2xl">https://github.com/fwon/m-console</span></p>
<p>手机远程调试工具，手机通过代理连接上 PC 后，可以在 PC 版浏览器打印 log 和错误日志</p>
<p>需要手动给每个调试的页面添加 js 代码</p>
<h2 id="DebugGap-VIDE"><a href="#DebugGap-VIDE" class="headerlink" title="DebugGap-VIDE"></a>DebugGap-VIDE</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGVidWdnYXAuY29tL2RlYnVnX3dlYnZpZXcuaHRtbA==">https://www.debuggap.com/debug_webview.html</span></p>
<h2 id="Mobile-Debug"><a href="#Mobile-Debug" class="headerlink" title="Mobile Debug"></a>Mobile Debug</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubW9iaWxlZGVidWcuY29tLw==">https://www.mobiledebug.com/</span></p>
<h2 id="whistle"><a href="#whistle" class="headerlink" title="whistle"></a>whistle</h2><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNjA1ODg3NT91dG1fc291cmNlPXRhZy1uZXdlc3Q=">https://segmentfault.com/a/1190000016058875?utm_source=tag-newest</span><br><span class="exturl" data-url="aHR0cDovL3dwcm94eS5vcmcvd2hpc3RsZS8=">http://wproxy.org/whistle/</span></p>
<h2 id="chii"><a href="#chii" class="headerlink" title="chii"></a>chii</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpcmlsaXJpL2NoaWk=">https://github.com/liriliri/chii</span></p>
<h2 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h2><p>AnyProxy<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvYW55cHJveHk=">https://github.com/alibaba/anyproxy</span><br>Zan Proxy<br><span class="exturl" data-url="aHR0cHM6Ly95b3V6YW4uZ2l0aHViLmlvL3phbi1wcm94eS8=">https://youzan.github.io/zan-proxy/</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/2010.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2010.html" class="post-title-link" itemprop="url">Vue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2019-01-08" itemprop="dateCreated datePublished" datetime="2019-01-08T18:00:00+00:00">2019-01-08</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <date title="修改时间：2019-03-22">2019-03-22</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy1zbG90cy5odG1s">插槽</span></p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcv">vue 中文网</span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZQ==">github 下载地址</span></p>
</li>
<li><p>Vue.js (读音 &#x2F;vju:&#x2F; view)</p>
</li>
<li><p>渐进式 JavaScript 框架</p>
<ul>
<li><p>渐进式：小型项目使用 vue 就够了，随着页面的复杂程度提高，就要学习 vue-rouer 来管理更多的页面，再随着项目的数据越来越多，管理数据也变得麻烦起来了，就开始使用 vuex 来管理数据</p>
</li>
<li><p>框架 : 一整套的解决方案</p>
</li>
</ul>
</li>
</ul>
<h2 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h2><h3 id="库-Library-，代表-jquery"><a href="#库-Library-，代表-jquery" class="headerlink" title="库(Library) ，代表 : jquery"></a>库(Library) ，代表 : jquery</h3><ul>
<li>库就是一系列函数的集合，我们开发人员在使用库的时候，想要完成什么样的功能，就调用库中提供的某个方法</li>
</ul>
<p>比如：想要添加样式，就调用 jquery 中的 .css() &#x2F; .addClass()</p>
<ul>
<li>库起到了一个辅助的作用，在使用库的是时候，是由开发人员说了算，也是由开发人员起主导作用</li>
</ul>
<h3 id="框架-Framework-，代表-vue"><a href="#框架-Framework-，代表-vue" class="headerlink" title="框架 (Framework)，代表 : vue"></a>框架 (Framework)，代表 : vue</h3><ul>
<li><p>在使用框架的时候，是由框架说了算，由框架起到了主导作用</p>
</li>
<li><p>框架是一套完整的解决方案，框架中制定了一套规则，使用框架的时候，只需要按照规则把代码放到合适的地方，然后框架会在合适的时机，主动调用开发人员的代码</p>
</li>
</ul>
<p>比如 : 想用 vue 组件里遍历就得使用 v-for，使用 for 不行</p>
<h3 id="主要区别：控制反转"><a href="#主要区别：控制反转" class="headerlink" title="主要区别：控制反转"></a>主要区别：控制反转</h3><blockquote>
<p>也就是 : 谁起到了主导作用</p>
</blockquote>
<ul>
<li><p>使用库的时候：开发人员起主导作用</p>
</li>
<li><p>使用框架的时候：框架起到了主导作用</p>
</li>
<li><p>从体量上看，框架一般比库大</p>
</li>
<li><p>会发现使用框架的时候，会受到很多限制</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjA3ODM1OT9ncm91cF9pZD04MzA4MDE4MDA0MDY5MTcxMjA=">我们所说的前端框架与库的区别？</span></p>
</li>
</ul>
<h2 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC + MVVM"></a>MVC + MVVM</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ol>
<li><p>MVC 是一种软件架构模式，也有人叫做设计模式</p>
</li>
<li><p>M : Model 数据模型 (专门用来操作数据，数据的 CRUD)</p>
</li>
<li><p>V : View 视图 (对于前端来说就是页面)</p>
</li>
<li><p>C : Controller 控制器 (是视图和数据模型沟通的桥梁，用于处理业务逻辑)</p>
</li>
</ol>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><blockquote>
<p>Vue 使用的是 MVVM 模式</p>
</blockquote>
<ul>
<li><p>MVVM &#x3D;&#x3D;&#x3D;&gt; M &#x2F; V &#x2F; VM</p>
</li>
<li><p>M : model 数据层</p>
</li>
<li><p>V : view 视图层</p>
</li>
<li><p>VM : ViewModel 视图模型</p>
</li>
<li><p>核心 : M &lt;&#x3D;&#x3D;&#x3D;&gt; VM &lt;&#x3D;&#x3D;&#x3D;&gt; V</p>
</li>
</ul>
<h3 id="MVVM-优势"><a href="#MVVM-优势" class="headerlink" title="MVVM 优势"></a>MVVM 优势</h3><ul>
<li><p>MVC 模式将应用程序划为三个部分，实现职责分离</p>
<ul>
<li><p>但是，在前端中，经常要通过 js 代码来进行一些逻辑操作，最终还要把这些逻辑操作展示页面中，也需要<code>频繁的操作DOM</code></p>
</li>
<li><p>比如 : ajax 请求、添加、修改、设置样式、动画</p>
</li>
</ul>
</li>
<li><p>MVVM 的思想通过 <code>数据双向绑定</code> 让数据自动的双向同步</p>
<ul>
<li><p>V (修改视图) –&gt; M</p>
</li>
<li><p>M (修改数据) –&gt; V</p>
</li>
</ul>
</li>
<li><p>采用的是 : <strong>数据驱动视图</strong>的思想，<strong>数据是核心</strong>。不要再想着怎么操作 DOM，而是想着如何操作数据</p>
</li>
</ul>
<h3 id="Vue-中的-MVVM"><a href="#Vue-中的-MVVM" class="headerlink" title="Vue 中的 MVVM"></a>Vue 中的 MVVM</h3><ul>
<li>注意 : 不推荐直接手动操作 DOM</li>
</ul>
<blockquote>
<p>每个人操作 DOM 的方法不一样，会造成性能不一样<br>官网 : 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例</p>
</blockquote>
<h2 id="Vue-基本使用"><a href="#Vue-基本使用" class="headerlink" title="Vue 基本使用"></a>Vue 基本使用</h2><ol>
<li><p>安装 : <code>npm i vue</code></p>
</li>
<li><p>导入 : <code>&lt;script src=&#39;./vue.js&#39;&gt;&lt;/script&gt;</code></p>
</li>
<li><p>实例化 vue</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="comment">// 指定 vue 管理的边界，不能是 body 或 html 节点</span></span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 提供视图中需要的数据</span></span><br><span class="line">  <span class="comment">// 视图可以直接使用 data 中的数据</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>使用 vm 表示 vue 实例</p>
<p>Vue 构造函数首字母大写</p>
<p>参数是一个对象</p>
<p>id&#x3D;’#app’，其他也可以</p>
<p>边界外无法使用 msg</p>
<h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. &#123;&#123;&#125;&#125; : mustache 语法，小胡子语法，插值表达式</span><br><span class="line">2. 作用 : 使用`&#123;&#123;&#125;&#125;` 从`data`中获取数据，并展示在模板中</span><br><span class="line">3. 说明 : `&#123;&#123;&#125;&#125;` 中只能出现 js 表达式</span><br><span class="line">4. `&#123;&#123;&#125;&#125;` 语法不能作用在 HTML 元素的属性上</span><br></pre></td></tr></table></figure>

<p>表达式 (有返回值的)：</p>
<ul>
<li>基本的数据类型 <code>1 &#39;abc&#39; false [] &#123;&#125;</code></li>
<li>数据类型 和 运算符结合在一起<code>1+2 arr.join(&#39;-&#39;) true ? 123 : 321</code></li>
</ul>
<p>语句： <code>if 语句 for 语句</code></p>
<h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><h3 id="input-v-model"><a href="#input-v-model" class="headerlink" title="input + v-model"></a>input + v-model</h3><p>v-model 指令：数据双向绑定的指令</p>
<ul>
<li>作用：把 data 中的 num 值 和 input 上的值绑定到一起，一方的值发生了改变，另 一方也会跟着改变</li>
<li>注意：v-model 只能用在表单控件上（input checkbox 等）</li>
</ul>
<h3 id="数据双向绑定的原理"><a href="#数据双向绑定的原理" class="headerlink" title="数据双向绑定的原理"></a>数据双向绑定的原理</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> temp</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置属性时会触发该函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置&#x27;</span>, newVal)</span><br><span class="line">    temp = newVal</span><br><span class="line">    input.<span class="property">value</span> = newVal</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取属性时会触发该函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">input.<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(this.value)</span></span><br><span class="line">  obj.<span class="property">name</span> = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h3><p>检测变化注意：受现代 JavaScript 的限制 (而且 <code>Object.observe</code> 也已经被废弃)，Vue <strong>不能检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化过程，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 转换它，这样才能让它是响应的</p>
<p><strong>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性</strong>，可以使用 <code>Vue.set(object, key, value)</code> 方法将响应属性添加到嵌套的对象上，或者创建一个包含原对象属性和新属性的对象替换掉原对象</p>
<h3 id="列表渲染数组更新检测"><a href="#列表渲染数组更新检测" class="headerlink" title="列表渲染数组更新检测"></a>列表渲染数组更新检测</h3><p>数组的方法可以触发视图更新：方法如下：</p>
<p><code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>splice()</code>、<code>sort()</code>、<code>reverse()</code></p>
<p>替换数组</p>
<p>用一个含有相同元素的数组去替换原来的数组并不会导致 Vue 丢弃现有 DOM 并重新渲染整个列表</p>
<p>注意：由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p>
<ol>
<li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ol>
<p>解决第一类问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(vm.<span class="property">items</span>, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.<span class="property">items</span>.<span class="title function_">splice</span>(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure>

<p>解决第二类问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.<span class="property">items</span>.<span class="title function_">splice</span>(newLength)</span><br></pre></td></tr></table></figure>

<h2 id="指令学习"><a href="#指令学习" class="headerlink" title="指令学习"></a>指令学习</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li>指令：就是一个特殊的标记，起一个辅助作用，使 html 具备原来没有的功能</li>
<li>vue 中所有的指令都是以 <code>v-</code> 开头的，比如 : v-model v-bind v-if v-for 等等</li>
</ul>
<h3 id="v-model-常用"><a href="#v-model-常用" class="headerlink" title="v-model (常用)"></a>v-model (常用)</h3><blockquote>
<p>说明：用在<code>表单</code>元素中，用来实现<code>数据双向绑定</code> (input checkbox 等等)<br>作用：将 <code>数据</code> 和 <code>文本框的值</code> 绑定到一起，任何一方发生改变，都会引起对方的改变<br>注意：v-model 在不同类型的表单元素中作用不同<br><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> 的初始值而总是将 Vue 实例的数据作为数据来源</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 文本输入框 绑定的是值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;num&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 多选框  绑定的选中状态 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isChecked&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">isChecked</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-text-和-v-html"><a href="#v-text-和-v-html" class="headerlink" title="v-text 和 v-html"></a>v-text 和 v-html</h3><blockquote>
<p>说明 : 设置文本内容</p>
</blockquote>
<p>v-text : 相当于之前的 innerText</p>
<p>v-html : 相当于之前的 innerHTML，会解析 html 标签，（已经废弃三大括号的插值）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">&quot;msg1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-html</span>=<span class="string">&quot;msg2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">msg1</span>: <span class="string">&#x27;&lt;a href=&quot;#&quot;&gt;haha&lt;/a&gt;&#x27;</span>,</span><br><span class="line">    <span class="attr">msg2</span>: <span class="string">&#x27;&lt;a href=&quot;#&quot;&gt;haha&lt;/a&gt;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-bind-常用"><a href="#v-bind-常用" class="headerlink" title="v-bind (常用)"></a>v-bind (常用)</h3><blockquote>
<p>说明：动态绑定数据 (单向)<br>出现原因：在 HTML 属性中，无法使用插值表达式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;href&quot;</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-bind 可以直接省略 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;href&quot;</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-bind：</span></span><br><span class="line"><span class="comment">// 说明：动态数据绑定 (单向)，因为html的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据, 需要使用 v-bind</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">href</span>: <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="v-bind-和-v-model-的区别"><a href="#v-bind-和-v-model-的区别" class="headerlink" title="v-bind 和 v-model 的区别"></a>v-bind 和 v-model 的区别</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-model 数据双向绑定 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--场景：表单元素中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isChecked1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  v-bind 数据动态绑定 (单向) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--场景：主要用在属性中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:checked</span>=<span class="string">&quot;isChecked2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 操作样式 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1. 动态添加类，但不符合 vue 数据是核心的思想 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 2. class 值是一个对象 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性名为类名 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性值为布尔值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;red: isRed, fz: isFz&#125;&quot;</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 3. style --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;backgroundColor: &#x27;red&#x27;, fontSize: fz + &#x27;px&#x27;&#125;&quot;</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-bind :</span></span><br><span class="line"><span class="comment">// 说明 : 动态数据绑定 (单向)，因为 html 的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据 , 需要使用 v-bind</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">href</span>: <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其他操作</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;red&#x27;, &#x27;fz&#x27;]&quot;</span>&gt;</span>heheheh<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ===&gt; &lt;div class=&quot;red fz&quot;&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 多个样式对象写成数组的形式，如果有相同样式后面会覆盖前面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[&#123;red: true&#125;, &#x27;fz&#x27;]&quot;</span>&gt;</span>hehehe<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ===&gt; &lt;div class=&quot;red fz&quot;&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><blockquote>
<p>注册事件&#x2F;绑定事件</p>
</blockquote>
<ol>
<li><p>v-on:click 绑定了一个 click 事件</p>
</li>
<li><p>缩写 : @click&#x3D;’fn’</p>
</li>
<li><p>函数写在 <code>methods</code> 里面</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;fn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 简写 @ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fn1&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 传参 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fn2(123)&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-on 注册事件</span></span><br><span class="line"><span class="comment">// v-on:click =&gt; 绑定点击事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 事件函数写在 methods 中</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    fn () &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;haha&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn1 () &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;haha&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn2 (ref) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(ref)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>函数里面的 this 指的就是 vm 实例</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span> === vm <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">msg</span> <span class="comment">// 获取数据</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">&#x27;XXX&#x27;</span> <span class="comment">// 修改数据</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>事件对象 $event</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定事件对象的时候, 没有添加小括号，此时，直接在方法中，通过参数 e 就可以获取到事件对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果绑定事件的地方,事件函数有()  @click=&#x27;fn()&#x27; 则需要通过 $event 获取 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fn1($event, 123)&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    fn (e) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn1 (e, ref) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(ref)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>遍历数据，为数据中的每一项生成一个指令所在的标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1: 最常用 遍历数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list1&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125; - &#123;&#123; index &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2: 遍历元素是对象的数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list2&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125; - id:&#123;&#123; item.id &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3: 遍历对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- item 是 属性值，key 是属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, key) in obj&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;-&#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4: 生成10个h1 （item是1-10）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">&quot;item in 10&quot;</span>&gt;</span>我是h1 &#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="headerlink" title="v-if 和 v-show"></a>v-if 和 v-show</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>我是h1 v-if<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>我是h1 v-show<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>v-if 和 v-show 都可以切换元素的显示与隐藏，不同的是 v-if 通过创建删除节点来控制元素的显示与隐藏， v-show 的元素始终会被渲染并保留在 DOM 中，只是简单地切换元素的 CSS 属性 <code>display</code>，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code></p>
<p>使用场景 :</p>
<ul>
<li>v-if 因为要不断的创建和删除来切换显示与隐藏，所以性能不高</li>
<li>v-if：切换次数不频繁的时候</li>
<li>v-show：切换次数频繁的时候</li>
</ul>
<h3 id="v-else-if-和-v-else"><a href="#v-else-if-和-v-else" class="headerlink" title="v-else-if 和 v-else"></a>v-else-if 和 v-else</h3><p>v-else：两种情况的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;num &gt; 40&quot;</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>v-else-if：三种以上情况</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;num &gt;= 40&quot;</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">&quot;num &gt;= 30 &amp;&amp; num &lt; 40&quot;</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>作用：告诉 vue 这个标签中的内容只需要解析一次，即便是数据再发送改变，这个标签中的内容也不会被更新</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>带 onece 的 &#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>作用：告诉 vue 这段节点中没有指令或表达式，不需要解析，从而，提升性能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span>带 v-pre &#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><p>使用遮盖</p>
<ul>
<li>给要遮盖的元素添加一个 v-cloak 指令：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用属性选择器，添加样式：<code>[v-cloak] &#123; display: none &#125;</code></p>
</li>
<li><p>vue 会在解析模板后将 v-cloak 指令从页面中移除，移除指令的时候，差值表达式已经变为对应的数据</p>
</li>
</ul>
<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符</p>
<p>Vue 为最常用的按键提供了别名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>全部的按键别名：</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
<p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>
<h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">&quot;clear&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>这些修饰符会限制处理函数仅响应特定的鼠标按钮</p>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  message () &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>，只有跟计算属性相关的数据发生了改变，计算属性才会重新计算</p>
<p>注意点:</p>
<p>计算属性必须返回一个值</p>
<p>计算属性只能当属性用，不能当方法用</p>
<p>不能和 data 中的属性名重名</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。它的工作方式类似于一个属性，所以你需要用 <code>v-bind</code> 来绑定动态值</p>
<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code>，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升</p>
<ul>
<li><code>就地复用</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; item.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据 --&gt;</span></span><br><span class="line">data: &#123;list: [&#123;id: 1, name: &#x27;zs&#x27;&#125;, &#123;id: 2, name: &#x27;ls&#x27;&#125;, &#123;id: 3, name: &#x27;ww&#x27;&#125;]</span><br><span class="line"><span class="comment">&lt;!-- 演示  --&gt;</span></span><br><span class="line">vm.list.unshift(&#123;id:4, name:&#x27;zl&#x27;&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 key<ul>
<li>如果数组的元素是一个对象，使用对象里固定属性，一般情况下，对象里都有 id</li>
<li>如果数组的元素是一个简单类型，不是一个对象，就可以取索引作为 key</li>
</ul>
</li>
</ul>
<h2 id="异步-DOM-更新"><a href="#异步-DOM-更新" class="headerlink" title="异步 DOM 更新"></a>异步 DOM 更新</h2><ol>
<li>Vue 中采用了 <code>异步DOM更新</code> 的机制</li>
<li>数据发生改变后，vue 没有立即将数据的改变更新到视图中，而是等到数据不再变化的时候 一次性的将数据的改变更新到视图中</li>
</ol>
<p>为什么是异步 DOM 更新?</p>
<ul>
<li>性能的考虑</li>
<li>因为对于前端来说，修改数据进行 DOM 操作是常有的事情，如果频繁操作 DOM，会严重影响页面的加载性能</li>
<li>DOM 操作这是前端的性能的瓶颈</li>
<li>比如 : for (let i &#x3D; 1; i &lt; 10000; i++&gt;) 如果同步 就要重新渲染 1000 次</li>
</ul>
<p>验证异步 DOM 更新：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过dom来获取count的值</span></span><br><span class="line"><span class="comment">// this.$el ==&gt; vue 边界元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">children</span>[<span class="number">0</span>].<span class="property">innerText</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">children</span>[<span class="number">0</span>].<span class="property">innerText</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>需求：在数据更新后，立即获取到更新后的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// DOM 更新后，会执行 this.$nextTick() 的回调函数，所以能拿到值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">children</span>[<span class="number">0</span>].<span class="property">innerText</span>) <span class="comment">// 100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="监听-watch"><a href="#监听-watch" class="headerlink" title="监听 watch"></a>监听 watch</h2><p>vue 中可以通过 watch 配置项来监听 vue 实例中数据的变化</p>
<p>基本使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//  监听</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="comment">// 监听 num 属性的数据变化</span></span><br><span class="line">  <span class="comment">// 作用: 只要 num 的值发生变化，这个方法就会被调用</span></span><br><span class="line">  <span class="comment">// 第一个参数: 新值</span></span><br><span class="line">  <span class="comment">// 第二个参数: 旧值</span></span><br><span class="line">  num (newVal, oldVal) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;新:&#x27;</span>, newVal)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;旧:&#x27;</span>, oldVal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="comment">// 监听对象</span></span><br><span class="line">  obj (newVal) &#123;</span><br><span class="line">    <span class="comment">// 虽然 obj 中的属性值发生改变了，但 obj 引用的地址没有发生改变，所以不会触发事件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听对象的属性</span></span><br><span class="line">  <span class="comment">// 从对象的角度来监听的</span></span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="comment">// 深度监听 监听对象里面的属性</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 页面刚进入立即触发监听，以表达式的当前值触发回调</span></span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 对象里的属性值发生变化，调用 handler 方法</span></span><br><span class="line">    handler (newVal) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">`obj.age 值变化了，新值：<span class="subst">$&#123;newVal.age&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 从属性的角度来监听</span></span><br><span class="line">  <span class="string">&#x27;obj.age&#x27;</span> (newVal) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">`obj.age 值变化了，新值：<span class="subst">$&#123;newVal&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用案例：需求 : 监听文本框字符个数，并显示格式验证码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;val&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;isTrue&quot;</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;请输入 6-12 位&#x27;</span>,</span><br><span class="line">  <span class="attr">isTrue</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  val (newVal) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^[0-9a-zA-z]&#123;6,12&#125;$/</span>.<span class="title function_">test</span>(newVal)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isTrue</span> = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isTrue</span> = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><ul>
<li>所有的 vue 组件，都是 vue 实例，一个组件对应一个实例，并且接收相同的选项对象（一些根实例特有的选项除外）</li>
<li>实例生命周期也叫做：组件生命周期</li>
<li>声明周期图：<a href="/zh-cn/_vue/Vue%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE">01</a></li>
</ul>
<h3 id="生命周期介绍"><a href="#生命周期介绍" class="headerlink" title="生命周期介绍"></a>生命周期介绍</h3><p><span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvYXBpLyMlRTklODAlODklRTklQTElQjktJUU3JTk0JTlGJUU1JTkxJUJEJUU1JTkxJUE4JUU2JTlDJTlGJUU5JTkyJUE5JUU1JUFEJTkw">vue 生命周期钩子函数</span></p>
<ul>
<li>简单说：一个组件（实例）从开始到最后消化所经历的各种状态，就是一个组件的生命周期</li>
<li>生命周期钩子函数的定义：从组件被创建，到组件挂在到页面上运行，再到页面关闭组件被销毁，这三个阶段总是伴随着组件的各种事件，这些事件，统称为组件的生命周期函数（简称 : 钩子函数）</li>
<li>开发人员可以通过 vue 提供的钩子函数，让我们写的代码参与到 vue 的生命周期里面来，让我们的代码在合适的阶段起到相应的作用</li>
</ul>
<p>注意：</p>
<ul>
<li>vue 在执行过程中会 <strong>自动调用</strong> <code>生命周期钩子函数</code>，我们只需要提供这些钩子函数即可</li>
<li>钩子函数的名称都是 vue 中规定好的</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODg3OTk2Ng==">vue 实例生命周期 参考 1</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODAxMDY2Ng==">vue 实例生命周期 参考 2</span></p>
<h3 id="钩子函数-beforeCreate"><a href="#钩子函数-beforeCreate" class="headerlink" title="钩子函数 - beforeCreate"></a>钩子函数 - beforeCreate</h3><ul>
<li>在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用</li>
<li>此时组件的选项还未挂载，因此无法访问 methods，data，computed 上的方法或数据</li>
<li>使用场景 : 几乎不用</li>
</ul>
<h3 id="钩子函数-created-掌握"><a href="#钩子函数-created-掌握" class="headerlink" title="钩子函数 - created (掌握)"></a>钩子函数 - created (掌握)</h3><ul>
<li>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch&#x2F;event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见</li>
<li>可以调用 methods 中的方法、改变 data 中的数据，并且修改可以通过 vue 的响应式绑定体现在页面上、获取 computed 中的计算属性等</li>
<li>使用场景：发送 ajax、本地存储获取数据</li>
</ul>
<h3 id="钩子函数-beforeMounted"><a href="#钩子函数-beforeMounted" class="headerlink" title="钩子函数 - beforeMounted()"></a>钩子函数 - beforeMounted()</h3><ul>
<li>在挂载开始之前被调用（挂载：DOM 渲染）</li>
</ul>
<h3 id="钩子函数-mounted-掌握"><a href="#钩子函数-mounted-掌握" class="headerlink" title="钩子函数 - mounted() (掌握)"></a>钩子函数 - mounted() (掌握)</h3><ul>
<li><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</li>
<li>这个周期可以获取 DOM</li>
<li>指令的生效在 mounted 周期之前</li>
<li>在这个周期内，对 data 的改变可以生效。但是要进下一轮的 DOM 更新，DOM 上的数据才会更新</li>
<li>使用场景：发送 ajax、操作 DOM</li>
</ul>
<h3 id="钩子函数-beforeUpdate"><a href="#钩子函数-beforeUpdate" class="headerlink" title="钩子函数 - beforeUpdate()"></a>钩子函数 - beforeUpdate()</h3><ul>
<li><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p>
</li>
<li><p>此处获取的数据是更新后的数据，但是获取页面中的 DOM 元素是更新之前的</p>
<blockquote>
<p>小提示 : 打印 this.$el ，打开小三角是之后的，是因为打印是有监听的功能，展示的是后面更改之后的</p>
</blockquote>
</li>
</ul>
<h3 id="钩子函数-updated"><a href="#钩子函数-updated" class="headerlink" title="钩子函数 - updated()"></a>钩子函数 - updated()</h3><ul>
<li>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子</li>
<li>组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作</li>
<li>应该避免在此期间更改状态。如果要相应状态改变，通常最好使用 <strong>计算属性</strong> 或 <strong>watcher</strong> 取而代之</li>
</ul>
<h3 id="钩子函数-beforeDestroy"><a href="#钩子函数-beforeDestroy" class="headerlink" title="钩子函数 - beforeDestroy()"></a>钩子函数 - beforeDestroy()</h3><ul>
<li>实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">timerId</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果当组件销毁了,还不清除定时器会出现性能问题</span></span><br><span class="line"> <span class="comment">// 在浏览器中可以尝试销毁 vm.$destroy()</span></span><br><span class="line"> <span class="comment">// 最后销毁</span></span><br><span class="line">beforeDestroy () &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timerId</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="钩子函数-destroyed"><a href="#钩子函数-destroyed" class="headerlink" title="钩子函数 - destroyed()"></a>钩子函数 - destroyed()</h3><ul>
<li>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
<h2 id="使用接口的形式发送数据"><a href="#使用接口的形式发送数据" class="headerlink" title="使用接口的形式发送数据"></a>使用接口的形式发送数据</h2><h3 id="json-server-提供假数据接口"><a href="#json-server-提供假数据接口" class="headerlink" title="json-server 提供假数据接口"></a>json-server 提供假数据接口</h3><ul>
<li>作用：根据指定的 JSON 文件，提供假数据接口</li>
<li>地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cGljb2RlL2pzb24tc2VydmVy">json-server</span></li>
<li>使用步骤</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 全局安装 json-<span class="attr">server</span>: <span class="string">`npm i -g json-server`</span></span><br><span class="line"><span class="number">2.</span> 准备一个json数据</span><br><span class="line"><span class="number">3.</span> 执行：<span class="string">`json-server data.json`</span></span><br><span class="line"></span><br><span class="line">data.<span class="property">json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;todos&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>REST API 格式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 查询：<span class="variable constant_">GET</span></span><br><span class="line"><span class="number">2.</span> 添加：<span class="variable constant_">POST</span></span><br><span class="line"><span class="number">3.</span> 删除：<span class="variable constant_">DELETE</span></span><br><span class="line"><span class="number">4.</span> 更新：</span><br><span class="line">	<span class="variable constant_">PUT</span>：需要将对象里的所有属性提交</span><br><span class="line">  <span class="title function_">PATCH</span>(打补丁)：只需要提交需要修改的属性</span><br></pre></td></tr></table></figure>

<ul>
<li>具体接口<ul>
<li>查询全部数据 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3RvZG9z">http://localhost:3000/todos</span><br>查询指定数据 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3RvZG9zLzI=">http://localhost:3000/todos/2</span></li>
<li>添加一个对象 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3RvZG9z">http://localhost:3000/todos</span><br>POST<br>id 会自动帮我们添加</li>
<li>更新数据 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3RvZG9zLzM=">http://localhost:3000/todos/3</span><br>PUT 或者 PATCH<br>PUT 需要提供该对象的所有数据<br>PATCH 只需要提供要修改的数据即可</li>
<li>删除数据<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3RvZG9zLzM=">http://localhost:3000/todos/3</span><br>DELETE</li>
</ul>
</li>
<li>可以借助 <code>postman</code> 测试接口</li>
</ul>
<h3 id="axios-发送请求"><a href="#axios-发送请求" class="headerlink" title="axios 发送请求"></a>axios 发送请求</h3><ul>
<li><strong>作用</strong> : 一个专门用来发送 ajax 请求的库, 可以在浏览器或者 node.js 中使用</li>
<li><strong>使用步骤</strong><ul>
<li>本地安装 axios : <code>npm i -g axios</code></li>
<li>导入 axios</li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9z">axios 使用说明</span></li>
<li><strong>GTE 方式发送请求</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:3000/todoList/1&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取到数据了：&#x27;</span>, res.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">axios</span><br><span class="line">  .<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:3000/todoList&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取到数据了：&#x27;</span>, res.<span class="property">data</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>POST 方式发送请求</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// post 请求</span></span><br><span class="line">axios</span><br><span class="line">  <span class="comment">// 第一个参数：表示接口地址</span></span><br><span class="line">  <span class="comment">// 第二个参数：表示接口需要的参数</span></span><br><span class="line">  .<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:3000/todoList&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;haha&#x27;</span>,</span><br><span class="line">    <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><strong>概念 :</strong></p>
<ul>
<li>vue 中的过滤器(filter)：<strong>数据格式化</strong>，让数据按照我们规定的格式输出</li>
<li>比如 : 对于日期来说，将日期格式化转化为 <code>年-月-日 小时:分:秒</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">显示：2019-01-11T10:11:19.566Z 不是我们想要的 我们想要的：2019-01-11 18-11-53</span><br></pre></td></tr></table></figure>

<p><strong>全局过滤器 和 局部过滤器</strong></p>
<ul>
<li>全局方式创建的过滤器，在任何一个 Vue 实例中都可以使用 (一般情况下，为了项目方便管理，都是一个 vue 实例)</li>
<li>局部创建的过滤器只能在当前 vue 实例中使用</li>
<li>全局过滤器应在 Vue 实例创建之前创建</li>
</ul>
<p><strong>注册全局过滤器</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：过滤器的名字</span></span><br><span class="line"><span class="comment">// 第二个参数：是一个回调函数，只要使用过滤器的时候，这个回调函数就会执行，res =&gt; 原始数据</span></span><br><span class="line"><span class="comment">// 必须要有返回值：通过回调函数的返回值得到格式化后的数据</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;date&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注册局部过滤器</strong></p>
<p>在 vm 的配置项里写一个 <code>filters</code>，对应的是一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters</span>: &#123;</span><br><span class="line">  date (res) &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>moment 插件</strong></p>
<ul>
<li><p><span class="exturl" data-url="aHR0cDovL21vbWVudGpzLmNuLw==">moment</span></p>
</li>
<li><p>使用：<code>npm i moment</code></p>
</li>
<li><p>日期 &#x3D;&gt; 指定格式<code>moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;)</code></p>
</li>
<li><p>时间戳 &#x3D;&gt; 指定格式<code>moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;)</code></p>
</li>
<li><p>&#96;&#96;&#96;js<br>Vue.filter(‘dataFilter’, res &#x3D;&gt; {<br>  return moment(res).format(‘YYYY-MM-DD HH-mm-ss’)<br>})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**使用过滤器**</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;!-- data: 原始数据  dataFilter: 过滤器名称  |：管道--&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123; date | dataFilter &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;dataFilter&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">moment</span>(res).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH-mm-ss&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部</span></span><br><span class="line"><span class="attr">filters</span>: &#123;</span><br><span class="line">  date (res, format = <span class="string">&#x27;YYYY-MM-DD&#x27;</span>, arg) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">moment</span>(res).<span class="title function_">format</span>(format)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数问题</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date | dateFilter(&#x27;YYYY-MM-DD HH-mm-ss&#x27;, 888) &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;dateFilter&#x27;</span>, <span class="function">(<span class="params">res, format = <span class="string">&#x27;YYYY-MM-DD&#x27;</span>, arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// res: 原始数据</span></span><br><span class="line">  <span class="comment">// format：dateFilter 中的第一个参数，等号后面为默认值</span></span><br><span class="line">  <span class="comment">// arg: dateFilter 中的第二个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg) <span class="comment">// 888</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">moment</span>(res).<span class="title function_">format</span>(format)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote>
<p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常 <strong>可复用</strong> 的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</p>
</blockquote>
<p><img data-src="/vue/components.png" alt="组件化图释"></p>
<ul>
<li>注册组件的两种方式：全局组件、局部组件</li>
<li>Vue 实例中的配置项（如：methods、filters、watch、computed、directives、生命周期钩子函数）都可以在组件中使用</li>
</ul>
<h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><ul>
<li>说明：全局组件在所有的 vue 实例中都可以使用</li>
<li>注意：<ul>
<li>注册全局组件应放在 vm 实例之前</li>
<li>模板只允许有一个根节点</li>
<li>组件中的 <code>data</code> 必须是函数，并且要返回一个对象</li>
<li>组件复用时如果 data 为对象，所有复用的组件的 data 指向同一片内存空间，一个组件被修改了会影响其他组件，这不是我们想要的</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;A custom component!&lt;/p&gt;&#x27;</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;注意：组件的data必须是一个函数！！！&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给组件指定返回值</span></span><br><span class="line"><span class="comment">// 组件名称为 One</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">One</span> = <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;A custom component!&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 可以简写为 ==&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">One</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;A custom component!&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用：以自定义元素的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hello</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 渲染结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><ul>
<li>局部组件是在某一个具体的 vue 实例（组件）中定义的，只能在当前 vue 实例（组件）中使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 局部组件</span></span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="comment">// 子组件 com-a</span></span><br><span class="line">    <span class="string">&#x27;com-a&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">`&lt;h1&gt;局部组件：&#123;&#123; num &#125;&#125;&lt;/h1&gt;`</span>,</span><br><span class="line">      data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">num</span>: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><ul>
<li>组件是一个独立、封闭的个体</li>
<li>也就是说：组件中的数据默认情况下，只能在组件内部使用，无法直接在组件外部使用</li>
<li>可以将 vue 实例看做一个组件</li>
<li>对于组件之间需要相互使用彼此的情况，应该使用 <strong>组件通讯机制</strong> 来解决</li>
<li>组件通讯的三种情况 :<ul>
<li>父组件将数据传递给子组件(父 -&gt; 子)</li>
<li>子组件将数据传递给父组件 (子 &#x3D;&gt; 父)</li>
<li>非父子组件(兄弟组件)</li>
</ul>
</li>
</ul>
<h4 id="父组件到子组件"><a href="#父组件到子组件" class="headerlink" title="父组件到子组件"></a>父组件到子组件</h4><ul>
<li>将要传递的数据，通过属性传递给子组件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">&quot;pmsg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>子组件通过 <code>props</code> 配置项来指定要接收的数据，props 是一个数组<ul>
<li>在使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名代替</li>
<li>如果使用字符串模板，那么这个限制就不存在了</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;msg&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>传递过来的 <code>props</code> 属性的用法与 <code>data</code> 属性的用法相同</li>
<li>子组件不能直接修改父组件传过来的数据，可以将父组件传过来的值保存在一个临时变量中</li>
<li>如果 props 传过来的数据为引用类型，只要不是重新赋值，修改数据不会报错，但不推荐这样做</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一步：将你要传递的数据,作为属性传递给子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hello</span> <span class="attr">:num</span>=<span class="string">&quot;pnum&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二部：子组件通过 props 配置项来指定要接收的数据</span></span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;num&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="子组件到父组件"><a href="#子组件到父组件" class="headerlink" title="子组件到父组件"></a>子组件到父组件</h4><ul>
<li>方式：父组件给子组件传递一个函数，由子组件调用这个函数</li>
<li>说明：借助 vue 中的自定义事件(v-on:cunstomFn&#x3D;”fn”)</li>
<li><code>$emit()</code>：触发事件</li>
<li>第一步：父组件了里准备一个方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">pnum</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    pfn (num) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">pnum</span> += num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步：把这个方法作为事件传递给子组件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello</span> @<span class="attr">fn</span>=<span class="string">&quot;pfn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或</span></span><br><span class="line"><span class="comment">&lt;hello @fn=&quot;num += $event&quot;&gt;&lt;/hello&gt;</span></span><br><span class="line"><span class="comment">$event 为传过来的参数</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第三步：子组件调用父组件传过来的方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;button @click=&#x27;click&#x27;&gt;按钮&lt;/button&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">num</span>: <span class="number">5</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    click () &#123;</span><br><span class="line">      <span class="comment">// 第一个参数：表示要触发的自定义事件名称，也就是 @fn</span></span><br><span class="line">      <span class="comment">// 第二个参数：表示要传递给父组件的数据</span></span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;fn&#x27;</span>, <span class="variable language_">this</span>.<span class="property">num</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="非父子组件通讯"><a href="#非父子组件通讯" class="headerlink" title="非父子组件通讯"></a>非父子组件通讯</h4><ul>
<li><p>是通过 <code>事件总线 (event bus 公交车) 机制</code> 来实现的</p>
</li>
<li><p>事件总线：实际上就是一个 <code>空 Vue 实例</code></p>
</li>
<li><p>可以实现任意两个组件之间的通讯而不管两个组件到底有什么样的层级关系</p>
</li>
<li><p><code>$emit()</code>：发送数据</p>
</li>
<li><p><code>$on()</code>：接收数据</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步：实例化事件总线 bus</span></span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发组件 A 中的事件</span></span><br><span class="line">bus.$emit(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件 B 创建的钩子中监听事件</span></span><br><span class="line">bus.$on(<span class="string">&#x27;id&#x27;</span>, <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>示例：组件 A —&gt; 组件 B</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com-a</span>&gt;</span><span class="tag">&lt;/<span class="name">com-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com-b</span>&gt;</span><span class="tag">&lt;/<span class="name">com-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步：实例化事件总线 bus</span></span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 A</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;com-a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;h1 @click=&quot;click&quot;&gt;组件A&lt;/h1&gt;`</span>,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    click () &#123;</span><br><span class="line">      <span class="comment">// 第二部：发送数据</span></span><br><span class="line">      bus.$emit(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;你好&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 B</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;com-b&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;h1&gt;组件B&lt;/h1&gt;`</span>,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="comment">// 第三步：接收数据</span></span><br><span class="line">    bus.$on(<span class="string">&#x27;hello&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收到数据&#x27;</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>[开关灯案例]</p>
<h3 id="单向数据流-组件与组件之间"><a href="#单向数据流-组件与组件之间" class="headerlink" title="单向数据流(组件与组件之间)"></a>单向数据流(组件与组件之间)</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个<code>单向下行绑定</code>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>当 todo-head 中的 todoName 设置数据后回车添加到 todoList，todoList 的长度就会发生变化，然后就会根据(组件与组件之间的)单向数据流，把数据单向下流到子组件中<br>而且必须是通过 props 往下传递的才可以</p>
<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p><code>vm.$refs</code> 一个对象，持有已注册过 ref 的所有子组件 ( HTML 元素)</p>
<ul>
<li>使用 :</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML元素 中，添加ref属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;div&quot;</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在JS中通过 $refs.属性 来获取</span></span><br><span class="line"><span class="comment">// 在 mounted 函数中使用</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;child&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;h1&gt;组件A&lt;/h1&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">num</span>: <span class="number">100</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    fn () &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">div</span>) <span class="comment">// div 标签</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">child</span>) <span class="comment">// child 组件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果获取的是一个子组件，那么通过 ref 就能获取到子组件中的 <code>data</code> 和 <code>methods</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">child</span>.<span class="property">num</span>) <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">child</span>.<span class="property">fn</span>) <span class="comment">// fn</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一般在第三方的组件中， 可能会用到这个功能</li>
</ul>
<h2 id="单页面应用程序"><a href="#单页面应用程序" class="headerlink" title="单页面应用程序"></a>单页面应用程序</h2><p>SPA : <strong>Single Page Application</strong> 单页面应用程序</p>
<p>MPA : <strong>Multiple Page Application</strong> 多页面应用程序</p>
<ul>
<li>单页 web 应用，就是只有一个 web 页面的应用，是加载单个 HTML 页面，并在用户与应用程序交互时动态更新该页面的 web 应用程序</li>
</ul>
<ul>
<li>区别<ul>
<li>对于传统的多页面应用程序来说，每次请求服务器返回的都是一个完整的页面</li>
<li>对于单页应用程序来说，只有第一次会加载页面，以后的每次请求，仅仅是获取必要的数据，然后由页面中 js 解析获取的数据展示在页面中</li>
</ul>
</li>
</ul>
<ul>
<li>优势 :<ul>
<li>减少了请求体积，加快页面响应速度，降低了对服务器的压力</li>
<li>更好的用户体验，让用户在 web app 感受 native app 的流畅</li>
</ul>
</li>
</ul>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul>
<li><strong>路由</strong> : 是浏览器 URL 中的<code>哈希值</code>( # hash) 与 <code>展示视图内容</code> 之间的<code>对应规则</code><ul>
<li>在 web App 中，通过一个页面来展示和管理整个应用的功能。SPA 往往是功能复杂的应用，为了有效管理所有视图内容，前端路由应运而生。简单来说，路由就是一套映射规则(一对一的对应规则)，由开发人员制定规则。当 URL 中的哈希值( <code>#</code> hash) 发生改变后，路由会根据制定好的规则，展示对应的视图内容。</li>
</ul>
</li>
<li><strong>vue 中的路由</strong>；是 <strong>hash</strong> 和 <strong>component</strong> 的对应关系，一个哈希值对应一个组件</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装路由 : <code>npm i vue-router</code></p>
<p>引入路由</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/vue-router/dist/vue-router.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>详细使用步骤</p>
<ul>
<li>实例路由对象并挂载到 vue 实例 上</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由实例 与 Vue 实例 关联到一起</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>()</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>入口 (#哈希值)</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">方式1 : url地址为入口 输入url地址改变哈希值</span></span><br><span class="line"><span class="comment">router.html#/one</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方式2 : router-link+to</span></span><br><span class="line"><span class="comment">to 属性：实际上就是哈希值，将来要参与路由规则中进行与组件匹配</span></span><br><span class="line"><span class="comment">router-link 标签最终会转化为 a 标签，to 属性转化为 a 标签的 href 属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/one&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/two&quot;</span>&gt;</span>Tow<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注册组件并设置返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">One</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Two</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置规则</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path : 路由路径</span></span><br><span class="line"><span class="comment">// component : 将来要展示的路由组件</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/one&#x27;</span>, <span class="attr">component</span>: <span class="title class_">One</span> &#125;, &#123; <span class="attr">path</span>: <span class="string">&#x27;/two&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Two</span> &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>出口</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  出口：组件要展示的地方--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>示例 ：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 入口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可以直接通过url地址访问路由 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- to 属性：路由匹配路径</span></span><br><span class="line"><span class="comment">router-link 最终会转化为 a 标签</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/one&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/two&quot;</span>&gt;</span>Tow<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 5. 出口 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 注册组件并设置返回值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">One</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Two</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实例化路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 4. 配置路由规则，路由和实例一一对应</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/one&#x27;</span>, <span class="attr">component</span>: <span class="title class_">One</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/two&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Two</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 2. 将路由挂载到 vue 实例上，让 vue 和路由关联在一起</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>多出口情况</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 多个出口的形式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">One</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Two</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 配置路由规则，一个路由对应多个实例</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="comment">// conponents 为一个对象</span></span><br><span class="line">      <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="comment">// key 为出口的 name 属性值</span></span><br><span class="line">        <span class="comment">// value 为组件实例</span></span><br><span class="line">        <span class="attr">one</span>: <span class="title class_">One</span>,</span><br><span class="line">        <span class="attr">two</span>: <span class="title class_">Two</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="入口菜单高亮处理"><a href="#入口菜单高亮处理" class="headerlink" title="入口菜单高亮处理"></a>入口菜单高亮处理</h3><p>点击导航会给链接添加两个类名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/one&quot;</span> <span class="attr">class</span>=<span class="string">&quot;router-link-exact-active router-link-active&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/two&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改方式 1：直接修改类的内容</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.router-link-exact-active</span>,</span><br><span class="line"><span class="selector-class">.router-link-active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰方式 2：给默认高亮类名设置别名，别名为已经定义好样式的类名 (推荐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改默认高亮的a标签的类名</span></span><br><span class="line">  <span class="attr">linkActiveClass</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="精确匹配和模糊匹配"><a href="#精确匹配和模糊匹配" class="headerlink" title="精确匹配和模糊匹配"></a>精确匹配和模糊匹配</h3><ul>
<li>精确匹配：router-link-exact-active 类名 : 只有当浏览器地址栏中的哈希值 与 router-link 的 to 属性值完全匹配才会添加该类</li>
<li>模糊匹配：router-link-active 类名 : 只要浏览器地址栏中的哈希值包含 router-link 的 to 属性值就会添加该类名</li>
<li>解决办法：加个 exact</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span> <span class="attr">exact</span>&gt;</span></span><br><span class="line">  One</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：精确匹配和模糊匹配，只对添加类名这个机制有效，与路由的匹配规则无关</li>
</ul>
<h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><p>入口</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 入口  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/detail/1&quot;</span>&gt;</span>手机1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/detail/2&quot;</span>&gt;</span>手机2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/detail/3&quot;</span>&gt;</span>手机3<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>传参</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yb3V0ZXIudnVlanMub3JnL3poL2d1aWRlL2Vzc2VudGlhbHMvZHluYW1pYy1tYXRjaGluZy5odG1sIyVFNSU4QSVBOCVFNiU4MCU4MSVFOCVCNyVBRiVFNyU5NCVCMSVFNSU4QyVCOSVFOSU4NSU4RA==">动态路由匹配</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Detail</span> = <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;detail&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">  <span class="comment">// 方式1：手动一个一个配置</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/detail/1&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Detail</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/detail/2&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Detail</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/detail/3&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Detail</span> &#125;，</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确的方式：把传过去的 1/2/3 当成参数</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/detail/:id?&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Detail</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>?</code> 代表参数可传可不传，即可识别的路径包括：<code>detail</code>、<code>detail/1</code>、<code>detail2</code>、<code>detail3</code></p>
<p>获取参数的三种正确方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $route =&gt; 路由配置对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Detail</span> = <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;detail&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 方式1：组件中直接读取</span></span><br><span class="line">  <span class="comment">// $route.path 为路由路径</span></span><br><span class="line">  <span class="comment">// $route.params.id 为路由参数</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 方式2：js直接读取</span></span><br><span class="line">    <span class="comment">// 打印只会打印一次，因为组件是复用的，每次进来钩子函数只会执行一次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// #/detail/2?name=zs</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$route</span>) <span class="comment">// 路由配置对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">path</span>) <span class="comment">// #/detail/2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>) <span class="comment">// &#123;id: &quot;2&quot;&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>) <span class="comment">// &#123;name: &#x27;zs&#x27;&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">id</span>) <span class="comment">// 2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 方式3：监听路由的参数变化(因为不是 data 中的数据，不需要深度监听)</span></span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// to：新值</span></span><br><span class="line">    <span class="comment">// from：旧值</span></span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(to.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9yb3V0ZXIudnVlanMub3JnL3poL2d1aWRlL2Vzc2VudGlhbHMvbmF2aWdhdGlvbi5odG1sIyVFNyVCQyU5NiVFNyVBOCU4QiVFNSVCQyU4RiVFNyU5QSU4NCVFNSVBRiVCQyVFOCU4OCVBQQ==">编程式导航</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.<span class="title function_">push</span>(<span class="string">&#x27;/user&#x27;</span>) <span class="comment">// -&gt; /user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象, path为路由的path属性值</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span> &#125;) <span class="comment">// -&gt; /user</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由，name 为路由的 name 属性值</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 如果提供了 path，params 会被忽略</span></span><br><span class="line"><span class="comment">// 这里的 params 不生效</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125;&#125;) <span class="comment">// -&gt; /register?plan=private</span></span><br><span class="line"></span><br><span class="line"><span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id?&#x27;</span>, name=<span class="string">&#x27;user&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span> &#125;]</span><br></pre></td></tr></table></figure>

<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p><code>redirect</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 / 重定向到 /home</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><h3 id="vue-是单文件组件"><a href="#vue-是单文件组件" class="headerlink" title="vue 是单文件组件"></a>vue 是单文件组件</h3><p>后缀为 .vue 的文件</p>
<p>单文件组件，无法直接在浏览器中使用，必须经过 webpack 这种打包工具处理后，才能在浏览器中使用</p>
<p>单文件组件的三个组成部分</p>
<ul>
<li>template (模板结构)</li>
<li>script 组件的代码逻辑</li>
<li>style 样式</li>
</ul>
<h3 id="脚手架介绍"><a href="#脚手架介绍" class="headerlink" title="脚手架介绍"></a>脚手架介绍</h3><p><strong>vue-cli</strong> 是 vue 的脚手架工具</p>
<p>因为 webpack 配置繁琐，阻止一批想用 vue 但是不会 webpack 的开发人员</p>
<p>vue-cli 提供了一条命令，我们直接通过这条命令就可以快速的生成一个 vue 项目 (<code>vue init XX</code>)，项目的基本结构、以及 webpack 配置项 <strong>全部配置</strong> 好了</p>
<p><span class="exturl" data-url="aHR0cHM6Ly92dWUtbG9hZGVyLnZ1ZWpzLm9yZy96aC8=">Vue Loader</span> 手动配置置 <code>webpack</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbGkudnVlanMub3JnL3poLw==">Vue CLI3</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly92dWVqcy10ZW1wbGF0ZXMuZ2l0aHViLmlvL3dlYnBhY2sv">Vue webpack 配置</span></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>安装：<code>npm i -g vue-cli</code></p>
<p>初始化 vue 项目：<code>vue init webpack 项目名称</code></p>
<p>进入到项目根目录运行项目：<code>npm run dev</code></p>
<p>项目安装过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">? <span class="title class_">Project</span> name demo</span><br><span class="line">? <span class="title class_">Project</span> description A <span class="title class_">Vue</span>.<span class="property">js</span> project</span><br><span class="line">? <span class="title class_">Author</span></span><br><span class="line">? <span class="title class_">Vue</span> build standalone  =&gt; 运行时+编译</span><br><span class="line">? <span class="title class_">Install</span> vue-router? <span class="title class_">Yes</span></span><br><span class="line">? <span class="title class_">Use</span> <span class="title class_">ESLint</span> to lint your code? <span class="title class_">Yes</span>? <span class="title class_">Pick</span> an <span class="title class_">ESLint</span> preset <span class="title class_">Standard</span></span><br><span class="line">? <span class="title class_">Set</span> up unit tests <span class="title class_">No</span></span><br><span class="line">? <span class="title class_">Setup</span> e2e tests <span class="keyword">with</span> <span class="title class_">Nightwatch</span>? <span class="title class_">No</span></span><br></pre></td></tr></table></figure>

<h4 id="项目目录介绍"><a href="#项目目录介绍" class="headerlink" title="项目目录介绍"></a>项目目录介绍</h4><p><span class="exturl" data-url="aHR0cHM6Ly92dWVqcy10ZW1wbGF0ZXMuZ2l0aHViLmlvL3dlYnBhY2svc3RydWN0dXJlLmh0bWw=">https://vuejs-templates.github.io/webpack/structure.html</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── build/                      # webpack config files</span><br><span class="line">├── config/index.js             # main project config</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.js                 # app entry file</span><br><span class="line">│   ├── App.vue                 # main app component</span><br><span class="line">│   ├── components/             # ui components</span><br><span class="line">│   └── assets/                 # module assets (processed by webpack)</span><br><span class="line">├── static/                     # pure static assets (directly copied)</span><br><span class="line">├── test/</span><br><span class="line">│   └── unit/                   # unit tests</span><br><span class="line">│   └── e2e/                    # e2e tests</span><br><span class="line">├── .babelrc                    # babel config</span><br><span class="line">├── .editorconfig               # settings for your editor</span><br><span class="line">├── .eslintrc.js                # eslint config</span><br><span class="line">├── .eslintignore               # eslint ignore rules</span><br><span class="line">├── .gitignore                  # sensible defaults for gitignore</span><br><span class="line">├── .postcssrc.js               # postcss config</span><br><span class="line">├── index.html                  # index.html template</span><br><span class="line">├── package.json                # build scripts and dependencies</span><br><span class="line">└── README.md                   # Default README file</span><br></pre></td></tr></table></figure>

<ul>
<li>build 和 config 不要动，都是一些配置好的，还有一些他们之间的约定</li>
<li>.gitkeep：static 为预留的文件夹，空文件夹默认不会上传到 github，添加这个文件让 static 文件夹被 git 上传</li>
<li><code>.editorconfig</code> 编译器配置，需要安装 vscode 插件：Editorconfig</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">charset = utf-8   utf-8 格式编码</span><br><span class="line">indent_style = space   空格和tab都可以缩进</span><br><span class="line">indent_size = 2    缩进为2个</span><br><span class="line">end_of_line = lf  回车换行</span><br><span class="line">insert_final_newline = true   结束最后一行+一个空白</span><br><span class="line">trim_trailing_whitespace = true   开头去除空白</span><br></pre></td></tr></table></figure>

<ul>
<li><code>eslint</code> 校验<ul>
<li>忽略文件中有这个 &#x3D;&gt; &#x2F;*.js &#x3D;&gt; 意思是根目录下的.js 文件不校验,,但是发现根目录就没有.js 文件</li>
<li><code>/* eslint-disable no-new */</code> eslint 忽略 no-new 规则</li>
<li><code>/* eslint-disable */</code> 也可以</li>
<li>如果去掉,就会提示你 不要以 new 开头</li>
<li>可以前面给个变量 var vm &#x3D; new Vue()</li>
<li>但是又提示没有用,还要打印一下,其实这个赋值是没有意义的</li>
<li>不要去掉.这是 eslint 的<code>不校验下一行代码</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFuZGFyZGpzLmNvbS9yZWFkbWUtemhjbi5odG1s">standard 代码规范</span></li>
</ul>
</li>
<li>postcssrc 处理 less css 等</li>
<li>src<ul>
<li>assets 静态资源</li>
<li>components 组件</li>
<li>router 路由</li>
<li>App.vue 根组件 &#x3D;&gt; 指定路由出口</li>
<li>脚手架之后，所有的组件都将渲染到 app.vue 中</li>
<li>vm 中的 #app 还是 index.html 中的 #app， app.vue 中的会覆盖前者<br>可以通过分别添加 title 属性验证一下</li>
<li><code>&lt;router-view/&gt;</code> 路由出口要写在 app.vue 组件模板中</li>
<li>main.js<ul>
<li>入口 js 文件</li>
<li>作用：创建 vue 实例，导入其他组件并挂在到 vue 实例上</li>
<li><code>Vue.config.productionTip = false</code> 不要打印提示</li>
</ul>
</li>
<li>route&#x2F;index.js：路由<ul>
<li><code>@</code>：build&#x2F; webpack.base.config.js &#x3D;&gt; <code>&#39;@&#39;: resolve(&#39;src&#39;)</code></li>
<li>如果在一个模块化工程中使用它，必须要通过 <code>Vue.use()</code> 明确地安装路由功能</li>
<li><code>https://router.vuejs.org/zh/installation.html</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="两种编译模式"><a href="#两种编译模式" class="headerlink" title="两种编译模式"></a>两种编译模式</h3><p>完整版和运行时版</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUvaW5zdGFsbGF0aW9uLmh0bWwjJUU1JUFGJUI5JUU0JUI4JThEJUU1JTkwJThDJUU2JTlFJTg0JUU1JUJCJUJBJUU3JTg5JTg4JUU2JTlDJUFDJUU3JTlBJTg0JUU4JUE3JUEzJUU5JTg3JThB">参考官网</span></p>
<p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码</p>
<p>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切</p>
<ul>
<li>使用 完整版 (包含编译器)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">App</span> &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>只使用运行时</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>查看编译模式：build &#x3D;&gt; webpack.base.config.js &#x3D;&gt; <code>&#39;vue\$&#39;: &#39;vue/dist/vue.esm.js&#39;,</code></p>
<h3 id="手动配置路由"><a href="#手动配置路由" class="headerlink" title="手动配置路由"></a>手动配置路由</h3><p>安装路由 <code>npm i vue-router</code></p>
<p>准备工作：创建一个文件夹 router&#x2F;router.js</p>
<p>具体配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* router.js */</span></span><br><span class="line"><span class="comment">// 引入路由</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/home/Home&#x27;</span>   (template + script + style)</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/login/Login&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把路由当成插件安装</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由，配置路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// 路由规则</span></span><br><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    path : <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component : <span class="title class_">Home</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path : <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    component : <span class="title class_">Login</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main.js 中绑定路由</span></span><br><span class="line">router</span><br><span class="line"></span><br><span class="line">在跟组件 <span class="title class_">App</span>.<span class="property">vue</span> 下配置出口</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.js */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="comment">// 绑定路由</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置出口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="编辑器配置插件"><a href="#编辑器配置插件" class="headerlink" title="编辑器配置插件"></a>编辑器配置插件</h3><ul>
<li><p><code>vetur</code>：vue 单文件组件的高亮</p>
</li>
<li><p>eslint</p>
<ul>
<li>关闭 <strong>eslint</strong>：打开 config&#x2F;index.js，将 26 行 : <code>dev.useEslint</code>设置为 false，重启项目 ( npm run dev)</li>
</ul>
</li>
<li><p><code>Prettier</code>：格式化插件</p>
</li>
</ul>
<h2 id="TODOMVC-案例"><a href="#TODOMVC-案例" class="headerlink" title="TODOMVC 案例"></a>TODOMVC 案例</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li><span class="exturl" data-url="aHR0cDovL3RvZG9tdmMuY29tL2V4YW1wbGVzL3Z1ZS8=">Vue-TodoMVC</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rhc3RlanMvdG9kb212Yy1hcHAtdGVtcGxhdGU=">下载模板地址</span> <code>git clone https://github.com/tastejs/todomvc-app-template.git</code></li>
<li>安装依赖包 : <code>npm i</code></li>
<li>安装 vue : <code>npm i vue</code></li>
<li>开始 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1aWxvbmdqaW4vdG9kb212Yy1hcHAtdGVtcGxhdGUvdHJlZS9tYXN0ZXI=">https://github.com/cuilongjin/todomvc-app-template/tree/master</span></li>
</ol>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><ul>
<li>渲染任务列表：<code>&lt;label&gt;&#123;&#123; item.name &#125;&#125;&lt;/label&gt;</code></li>
<li>任务完成 : <code>:class=&quot;&#123; completed : item.done &#125;&quot;</code></li>
<li>多选框选中状态 : <code>v-model=&#39;item.done&#39;</code></li>
</ul>
<h3 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h3><ul>
<li>获取文本输入框的内容 (关键点)<ul>
<li>把 input 通过 v-model 双向数据绑定 &#x3D;&#x3D; todoName</li>
<li>@keyup.enter 触发事件 addTodo &#x3D;&gt; 拿到 todoName 的值</li>
<li>判断文本框不能为空</li>
<li>按回车添加任务</li>
</ul>
</li>
<li>对象{done: false, id: , name : todoName}<ul>
<li>获取数组里最后一个元素的 id+1</li>
<li>如果数组之前一个元素都没有 , id &#x3D; 1</li>
</ul>
</li>
<li>将对象添加进数组</li>
<li>添加完，清除文本框内容</li>
</ul>
<h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><ul>
<li>传索引<br><code>this.todoList.splice(index, 1)</code></li>
<li>传 id</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 id  找到对应的元素索引</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">todoList</span>.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> === id)</span><br><span class="line"><span class="comment">// 根据索引删除</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">todoList</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>传 id 过滤</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传过来一个 id, 过滤出来不等于这个 id 的元素，重新赋值给 todoList</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">todoList</span> = <span class="variable language_">this</span>.<span class="property">todoList</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> !== id)</span><br></pre></td></tr></table></figure>

<h3 id="编辑任务"><a href="#编辑任务" class="headerlink" title="编辑任务"></a>编辑任务</h3><ul>
<li><p>显示<code>编辑框</code> ( editing : true) (难点)</p>
<ul>
<li>在 data 中添加一个 editId : -1</li>
<li>在 :class<br>editing: item.id &#x3D;&#x3D;&#x3D; editId</li>
<li>双击 : 接收过来双击元素的 id<br>this.editId &#x3D; id</li>
<li>关键点 :<br>vue 中 data 中的数据一旦发生改变，当前页面的指令和表达式都会重新计算</li>
</ul>
</li>
<li><p>读取内容<br><code>&lt;input class=&quot;edit&quot; v-model=&quot;item.name&quot;&gt;</code></p>
</li>
<li><p>回车隐藏编辑框</p>
</li>
</ul>
<h3 id="底部的显示与隐藏"><a href="#底部的显示与隐藏" class="headerlink" title="底部的显示与隐藏"></a>底部的显示与隐藏</h3><ul>
<li>v-if&#x2F;v-show</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件部分</span></span><br><span class="line">&lt;footer <span class="keyword">class</span>=<span class="string">&quot;footer&quot;</span> v-show=<span class="string">&quot;isFooter()&quot;</span>&gt;</span><br><span class="line"><span class="comment">// js</span></span><br><span class="line">  <span class="title function_">isFooter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">todoList</span>.<span class="property">length</span> &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>因为 vue 中 data 的数据发送了改变，当前页面中的指令和表达式都会重新计算，所以只要文本框里的内容发生改变，todoName 也会发送改变，isFooter 会一直被调用，性能不好。我们需要的是数组列表的个数改变才会影响底部的变化，所以需要用到计算属性</p>
</li>
<li><p>计算属性</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isFooter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="comment">// 计算属性 判断底部是否显示</span></span><br><span class="line">  <span class="comment">// 1. 计算属性只会跟着相关属性的值发生变化而变化</span></span><br><span class="line">  <span class="comment">// 2. 一定要有返回值</span></span><br><span class="line">  <span class="comment">// 3. 一定要写在 computed 里面</span></span><br><span class="line">  <span class="comment">// 4. 写起来像一个方法，用起来像一个属性</span></span><br><span class="line">  isFooter () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">todoList</span>.<span class="property">length</span> &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/410.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/410.html" class="post-title-link" itemprop="url">【es6】Promise</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2019-01-08" itemprop="dateCreated datePublished" datetime="2019-01-08T22:21:49+00:00">2019-01-08</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>Promise 是<code>异步编程</code>的一种解决方案，它允许你以一种同步的方式编写异步代码</li>
<li><code>promise</code>：承诺、保证</li>
<li><span class="exturl" data-url="aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8jZG9jcy9wcm9taXNl">ES6 - Promise</span></li>
<li>JS 是通过回调函数来实现异步编程的，当异步操作多了以后，就会产生回调嵌套回调的问题，这就是<code>回调地狱</code></li>
<li>Promise 方式：将异步操作以同步操作的方式表达出来，避免了层层嵌套的回调函数</li>
<li>Promise 新建后立即执行</li>
</ul>
<h2 id="封装一个-Promise"><a href="#封装一个-Promise" class="headerlink" title="封装一个 Promise"></a>封装一个 Promise</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按序读取文件：a -&gt; b -&gt; c</span></span><br><span class="line"><span class="comment">// 按顺序读取 a b c 文件</span></span><br><span class="line"><span class="comment">// 以前</span></span><br><span class="line"><span class="comment">// 读取 a 文件</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./a&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取错误&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 b 文件</span></span><br><span class="line">  fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./b&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取错误&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 c 文件</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./a&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取错误&#x27;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Promise</span></span><br><span class="line"><span class="comment">// 封装</span></span><br><span class="line"><span class="comment">// Promise 是一个构造函数</span></span><br><span class="line"><span class="comment">// 通过 new 创建 Promise 的实例对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="comment">// 实例化 Promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve 表示成功，异步操作成功调用</span></span><br><span class="line">    <span class="comment">// reject  表示失败，异步操作失败调用</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(path, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 读取错误，调用 reject()</span></span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">reject</span>(err)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读取成功 调用 resolve</span></span><br><span class="line">      <span class="title function_">resolve</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 Promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFile</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFile</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="promise-的三个状态"><a href="#promise-的三个状态" class="headerlink" title="promise 的三个状态"></a>promise 的三个状态</h2><ul>
<li><p>pending : 等待 (等待成功或者失败去调用)</p>
</li>
<li><p>fulfilled : 成功调用(resolve)</p>
</li>
<li><p>rejected : 失败调用(reject)</p>
</li>
</ul>
<h2 id="then、catch-和-finally"><a href="#then、catch-和-finally" class="headerlink" title="then、catch 和 finally"></a>then、catch 和 finally</h2><ul>
<li>说明：获取异步操作的结果</li>
<li><code>then()</code> ：用于获取异步操作成功时的结果 -&gt; <code>resolve</code></li>
<li><code>catch()</code>：用于获取异步操作失败时的结果 -&gt; <code>reject</code></li>
<li><code>finally()</code>：方法用于指定不管 Promise 对象最后状态如何，都会执行的操作，finally方法的回调函数不接受任何参数</li>
<li>说明：<code>then()</code>方法可以有多个，按照先后顺序执行，通过回调函数返回值传递数据给下一个 then</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p</span><br><span class="line">  <span class="comment">// onfullfilled 执行</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件a的内容为：&#x27;</span>, value)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// onrejected 执行</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件读取失败：&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------- 或者 -----------</span></span><br><span class="line"><span class="comment">// then 中传两个参数</span></span><br><span class="line"><span class="comment">// then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数</span></span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line">  <span class="comment">// onfullfilled 执行</span></span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; &#125;,</span><br><span class="line">  <span class="comment">// onrejected 执行</span></span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="all-和-race"><a href="#all-和-race" class="headerlink" title="all 和 race"></a>all 和 race</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9hbGw=">MDN-Promise.all()</span><br><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9yYWNl">MDN-Promise.race()</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;成功1&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;成功2&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">1500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 p1，p2 请求完成</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// [&#x27;成功1&#x27;, &#x27;成功2&#x27;]</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有一个请求被 reject，就会进入 catch 回调</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error) <span class="comment">// &#x27;失败&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 始终返回最快的那一个异步，不管resolve还是reject</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// &#x27;成功1&#x27;</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p3]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// &#x27;成功1&#x27;</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([p2, p3]).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error) <span class="comment">// &#x27;失败&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><ul>
<li>异步编程终极方案</li>
</ul>
<ul>
<li>async &#x2F; await 用同步编写代码的方式 处理异步操作的一个方案</li>
<li>async：修饰 (修饰一个内部有异步操作的函数) 格式 : async + 函数 (里面有异步操作的函数)</li>
<li>await : 等待 (等上一个异步操作完成啊 , 修饰 一个结果是 promise 的)异步操作 格式 : await + 异步操作(结果 promise 对象)</li>
<li>async 和 await 是成对出现的，await 只能在 async 函数中使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步封装</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 实例化 promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(path, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 操作错误 调用 =&gt;  reject  =&gt; catch</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 操作成功  调用 =&gt; resolve =&gt; then</span></span><br><span class="line">      <span class="title function_">resolve</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 2. 返回 promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：使用 (async/await)</span></span><br><span class="line"><span class="comment">// async + 函数 (里面有异步操作的函数)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// await + 异步操作(结果promise对象)</span></span><br><span class="line">  <span class="comment">// 读取a文件</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;./data/a1.txt&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res1)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 b 文件</span></span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;./data/b.txt&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 c 文件</span></span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;./data/c.txt&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(b)</span><br><span class="line">    &#125;, a)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1000</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res1)</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">5000</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">3000</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn()</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">1000</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">sleep</span>(<span class="number">5000</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">sleep</span>(<span class="number">3000</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">sleep</span>(<span class="number">1000</span>, <span class="string">&#x27;a&#x27;</span>), <span class="title function_">sleep</span>(<span class="number">5000</span>, <span class="string">&#x27;b&#x27;</span>)])</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">sleep</span>(<span class="number">1000</span>, <span class="string">&#x27;a&#x27;</span>), <span class="title function_">sleep</span>(<span class="number">5000</span>, <span class="string">&#x27;b&#x27;</span>)])</span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f)</span><br></pre></td></tr></table></figure>

<p>上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>)</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br></pre></td></tr></table></figure>

<p>用async函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">.<span class="title function_">then</span>(...)</span><br><span class="line">.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure>

<p>Promise.try方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">try</span>(f)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>)</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure>


<h2 id="new-Promise-和-Promise-resolve"><a href="#new-Promise-和-Promise-resolve" class="headerlink" title="new Promise 和 Promise.resolve()"></a>new Promise 和 Promise.resolve()</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/429.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/429.html" class="post-title-link" itemprop="url">Webpack</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2019-01-05" itemprop="dateCreated datePublished" datetime="2019-01-05T22:33:14+00:00">2019-01-05</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy8=">webpack 官网</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcv">webpack 中文网</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1aWxvbmdqaW4vd2VicGFjay1jb25maWcv">webpack 配置文件</span></li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>webpack 是一个现代 JavaScript 应用程序的模块打包器（module bundler）</p>
<p>webpack 是一个模块化方案（预编译）</p>
<p>webpack 获取具有依赖关系的模块，并生成表示这些模块的静态资源</p>
<p>webpack 的两个特点：模块化、打包</p>
<p>四个核心概念：<strong>入口(entry)<strong>、</strong>输出(output)<strong>、</strong>加载器(loader)<strong>、</strong>插件(plugins)</strong></p>
<p>模块化方案：webpack 和 requirejs（通过编写代码的方式将前端的功能，划分成独立的模块）<br>browserify 是与 webpack 相似的模块化打包工具</p>
<h3 id="webpack-起源"><a href="#webpack-起源" class="headerlink" title="webpack 起源"></a>webpack 起源</h3><ul>
<li>webpack 解决了现存模块打包器的两个痛点：<ul>
<li>Code Spliting - 代码分离</li>
<li>静态资源的模块化处理方案</li>
</ul>
</li>
</ul>
<h3 id="webpack-与模块"><a href="#webpack-与模块" class="headerlink" title="webpack 与模块"></a>webpack 与模块</h3><ul>
<li><p><span class="exturl" data-url="aHR0cDovL3poYW9kYS5uZXQvd2VicGFjay1oYW5kYm9vay9tb2R1bGUtc3lzdGVtLmh0bWw=">前端模块系统的演进</span></p>
</li>
<li><p>在 webpack 看来：所有的<strong>静态资源都是模块</strong></p>
</li>
<li><p>webpack 模块能够识别以下等形式的模块之间的依赖：</p>
<ul>
<li><p>ES2015 <code>import</code> <code>export</code></p>
</li>
<li><p>CommonJS <code>require()</code> <code>module.exports</code></p>
</li>
<li><p>AMD <code>define</code> 和 <code>require</code></p>
</li>
<li><p>css&#x2F;sass&#x2F;less 文件中的 <code>@import</code></p>
</li>
<li><p>图片连接，比如：样式 <code>url(...)</code> 或 HTML <code>&lt;img src=...&gt;</code></p>
</li>
<li><p>字体等</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>在 webpack 提供的模块化环境中<ul>
<li>想要加载一个 JS 文件，只需要 require(‘a.js’)</li>
<li>想要加载一个 CSS 文件，只需要 require(‘css&#x2F;index.css’)</li>
<li>想要加载一个图片文件，只需要 require(‘images&#x2F;a.png’)</li>
</ul>
</li>
</ul>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzQyZTExNTE1YzEwZiM=">入门 Webpack，看这篇就够了</span></li>
</ul>
<h3 id="webpack-打包原理："><a href="#webpack-打包原理：" class="headerlink" title="webpack 打包原理："></a>webpack 打包原理：</h3><p>​ 入口文件： main.js</p>
<p>​ webpack 从入口出发，递归分析项目中所有的依赖项（模块），使用 loader 来处理对应的模块最终，打包生成一个 bundle.js 文件。</p>
<p>​ 如果配置了 webpack 中的 代码分离（Code Spliting），webpack 会根据 分离点 将这个模块生成一个独立的 JS 文件</p>
<p>​ 还可以通过配置，将 CSS 、 图片、 字体 等文件，从 bundle.js 中抽离为独立的文件</p>
<h2 id="webpack-的基本使用"><a href="#webpack-的基本使用" class="headerlink" title="webpack 的基本使用"></a>webpack 的基本使用</h2><p>安装：<code>npm i -D webpack webpack-cli</code></p>
<p>webpack：是 webpack 工具的核心包</p>
<p>webpack-cli：提供了一些在终端中使用的命令</p>
<p>-D(–save-dev)：表示项目开发期间的依赖</p>
<p>webpack 的两种使用方式：命令行、配置文件（<code>webpack.config.js</code>）</p>
<h3 id="命令行使用说明"><a href="#命令行使用说明" class="headerlink" title="命令行使用说明"></a>命令行使用说明</h3><ul>
<li><code>package.json</code>中的<code>scripts</code>中可以存放一些 bash 命令，这些 bash 命令可以通过 <code>npm run 命令名称</code> 来执行</li>
<li>注意：npm 在执行 scripts 中的命令的时候，是在电脑系统后台默认开启一个 bash，将当前目录下的<code>./node_modules/.bin</code>这个文件夹临时加入了系统环境变量</li>
<li>使用方式：<code>npm run build</code></li>
<li>设置开发状态： <code>mode</code> 如果没有设置 mode 配置项，webpack 会默认提供开发环境(production)</li>
<li>在入口文件中可以使用 <code>import</code> 引入 js css less 等文件</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// webpack 是 webpack-cli 提供的命令</span></span><br><span class="line">  <span class="comment">// src/js/main.js 为入口文件</span></span><br><span class="line">  <span class="comment">// --output dist/bundle.js 为出口文件</span></span><br><span class="line">  <span class="comment">// --mode development 生产环境</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  <span class="attr">&quot;build1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack src/js/main.js --output dist/bundle.js --mode development&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置文件方式（推荐）"><a href="#配置文件方式（推荐）" class="headerlink" title="配置文件方式（推荐）"></a>配置文件方式（推荐）</h3><p>项目<code>根目录</code>下创建一个 <code>webpack.config.js</code>文件，运行 <code>webpack</code> 命令时的默认配置文件</p>
<p>指定其他文件：<code>--config webpack.XX.js</code></p>
<p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;build&quot;: &quot;webpack&quot;</code></p>
<p>执行命令 : <code>npm run build</code></p>
<p>示例代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 是基于 node的 , 所以配置文件符合 node 方式书写配置</span></span><br><span class="line"><span class="comment">// 注意 : 不要再这个文件中使用ES6的的模块化 import语法</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  <span class="attr">entry</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./src/js/main.js&#x27;</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出口</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 出口目录</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>安装：<code>npm i -D webpack-dev-server</code></p>
<p>作用：配合 webpack，创建开发环境（启动服务器、监视文件变化、自动编译、刷新浏览器等），提高开发效率</p>
<p>注意：无法直接在终端中执行 <code>webpack-dev-server</code>，需要在 <code>package.json</code> 配置 <code>scripts</code> 后使用</p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul>
<li><code>webpack-dev-server</code>将打包好的文件存储在内存中，提高编译和加载速度，效率更高（不会生成 dist 目录）</li>
<li>在内存中出口目录为项目根目录（命令行中的提示：<code>webpack output is served from /</code>）<ul>
<li>在<code>index.html</code>页面中引入文件不需要加<code>dist</code></li>
</ul>
</li>
</ul>
<h3 id="CLI-配置"><a href="#CLI-配置" class="headerlink" title="CLI 配置"></a>CLI 配置</h3><ul>
<li><code>--contentBase</code> ：告诉服务器在哪个目录中提供服务（可以理解为：打开哪个目录中的 index.html）<ul>
<li><code>--contentBase ./src</code>：当前目录下的 src 文件夹</li>
</ul>
</li>
<li><code>--open true</code> ：自动打开浏览器</li>
<li><code>--port 3000</code> ：指定端口号</li>
<li><code>--hot</code> ：热更新，只加载修改的文件(按需加载修改的内容)，而非全部加载</li>
<li><code>--progress</code>：显示进度条</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server --contentBase src --open --port 8888 --hot&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;dev&quot;: &quot;webpack-dev-server --hot&quot;</code></p>
<p>执行命令 : <code>npm run dev</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --hot 热更新写在命令行里，不然的话还要配其他插件麻烦</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">// hot: true,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">// api 表示当前项目请求的 key</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="comment">// 代理服务器路径</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;/api&#x27;</span> &#125;, <span class="comment">// 重写路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求 localhost:8080/api/.. 会被代理到 http://www.baidu.com/api/..</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// plugins: [</span></span><br><span class="line">  <span class="comment">//   new webpack.HotModuleReplacementPlugin()</span></span><br><span class="line">  <span class="comment">// ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="html-webpack-plugin-插件"><a href="#html-webpack-plugin-插件" class="headerlink" title="html-webpack-plugin 插件"></a>html-webpack-plugin 插件</h2><ul>
<li>安装：<code>npm i -D html-webpack-plugin</code></li>
<li>作用：根据模板，在内存中自动生成 html 页面，并自动引入<code>bundle.js</code>、<code>css</code>等文件</li>
</ul>
<p>配置文件配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 html-webpack-plugin 插件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 配置插件</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin 配置</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 模板页面路径</span></span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src/index.html&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打包非-js-文件"><a href="#打包非-js-文件" class="headerlink" title="打包非 js 文件"></a>打包非 js 文件</h2><p>webpack 默认只能处理 js 文件，非 js(css、less、图片、字体等)处理不了，借助 loader 加载器</p>
<h3 id="处理-css-文件"><a href="#处理-css-文件" class="headerlink" title="处理 css 文件"></a>处理 css 文件</h3><p>在 <code>main.js</code>中引入 css 文件 <code>import &#39;../css/main.css&#39;</code></p>
<p>安装 : <code>npm i -D style-loader css-loader</code></p>
<p>在 <code>webpack.config.js</code> 中，添加个新的配置项 <code>module</code></p>
<p>在 <code>module</code> 中添加 <code>loader</code> 来处理 <code>css</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理 css</span></span><br><span class="line">      <span class="comment">// 注意点 use 执行loader 顺序 从右往左</span></span><br><span class="line">      <span class="comment">// css-loader: 读取css文件内容，将其转化为一个模块</span></span><br><span class="line">      <span class="comment">// style-loader: 拿到模块, 创建一个style标签，插入页面中</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理-less-文件"><a href="#处理-less-文件" class="headerlink" title="处理 less 文件"></a>处理 less 文件</h3><p>在 <code>main.js</code>中引入 less 文件 <code>import &#39;../css/main.less&#39;</code></p>
<p>安装 : <code>npm i -D less-loader less style-loader css-loader</code></p>
<p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理 <code>less</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">//处理 css</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理图片文件"><a href="#处理图片文件" class="headerlink" title="处理图片文件"></a>处理图片文件</h3><p>安装 : <code>npm i -D url-loader file-loader</code></p>
<p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理图片</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png)$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="comment">//  图片大小 &lt;= 10000 =&gt; 转化为base64</span></span><br><span class="line">              <span class="comment">//  图片大小 &gt;= 10000 =&gt; 不会转base64 内部调用 file-loader 加载图片</span></span><br><span class="line">              <span class="attr">limit</span>: <span class="number">10000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>url-loader</strong> 默认会将图片转化为 base64 编码格式，目的：提高性能</p>
<p><strong>file-loader</strong> 在处理图片时，会对文件进行重命名</p>
<p>base64 编码格式的图片说明：</p>
<ul>
<li>精灵图：将一些小图片合并为一张图片，减少请求次数，提高性能</li>
<li>字体图标：直接将一些小的图片,合并到字体文件中，并且不会失真</li>
<li>base64：是一种编码格式,能够将图片、文字等常见的文件，转化为 base64 格式，这种字符串格式浏览器能够识别并且读取显示到页面中</li>
<li>base64 是一个字符串，也可以直接被内嵌到页面中，或者 css 中</li>
<li>注意：大图片不适合用 base64 处理，只有小的图标才适合 base64 处理</li>
</ul>
<h3 id="处理字体文件"><a href="#处理字体文件" class="headerlink" title="处理字体文件"></a>处理字体文件</h3><p>在 <strong>main.js</strong> 中引入 css 文件 <code>import &#39;../css/iconfont/iconfont.css&#39;</code></p>
<p>在 webpack.config.js 中配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理字体图标</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(svg|woff|woff2|ttf|eot)$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;url-loader&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理-ES6-语法"><a href="#处理-ES6-语法" class="headerlink" title="处理 ES6 语法"></a>处理 ES6 语法</h3><ol>
<li>现在的项目都是使用 ES6 开发的，但是这些新的 ES6 语法，并不是所有的浏览器都支持，所以就需要有一个工具，帮我们转成 es5 语法，这个就是：babel</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvLw==">babel</span></li>
<li>Babel is a JavaScript compiler. &#x3D;&#x3D;&gt; babel 是一个 JavaScript 编译器</li>
<li>webpack 只能处理 import &#x2F; export 这个 es6 模块化语法，而其他的 js 新语法，应该使用 babel 来处理</li>
</ol>
<p>babel 的使用 :</p>
<ul>
<li>安装： <code>npm i -D babel-core babel-loader@7</code><ul>
<li>babel-core 是 babel 的核心包</li>
<li>babel-loader 加载 js 文件，并将 js 代码内容交给 babel-core 解析为 es5 低版本的 js</li>
</ul>
</li>
</ul>
<ul>
<li>安装：<code>npm i -D babel-preset-env babel-preset-stage-2</code><ul>
<li>babel-preset-env：表示能够解析 es2015、es2016、es2017、es2018 这些标准的语法</li>
<li>babel-preset-stage-2：用来解析还没有被采纳为标准的语法</li>
<li><code>babel-polyfill与babel-plugin-transform-runtime</code> 也是做兼容处理的,以前都是用这个，兼容更早的</li>
</ul>
</li>
</ul>
<ul>
<li>配置 : 在 webpack.config.js 中添加一个 loader</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理 ES6 语法</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="comment">// 设置忽略 node-modules 文件夹</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node-modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在项目根目录中创建 babel 的配置文件，叫：<code>.babelrc</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;env&quot;,</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  -----------</span><br><span class="line">  // 暂时不用</span><br><span class="line">  // 如果未来某一天真的用到了polify</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-runtime&quot;, &#123;</span><br><span class="line">      &quot;helpers&quot;: false,</span><br><span class="line">      &quot;polyfill&quot;: true,</span><br><span class="line">      &quot;regenerator&quot;: true,</span><br><span class="line">      &quot;moduleName&quot;: &quot;babel-runtime&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="项目打包上线"><a href="#项目打包上线" class="headerlink" title="项目打包上线"></a>项目打包上线</h2><p>执行 : <code>npm run build</code> 对项目进行打包，生成 dist 文件</p>
<p>模拟本地服务器 : 安装 : <code>npm i -g http-server</code></p>
<p>把 dist 文件里的内容放到服务器里即可，直接运行<code>http-server</code></p>
<h2 id="webpack-和-gulp-区别"><a href="#webpack-和-gulp-区别" class="headerlink" title="webpack 和 gulp 区别"></a>webpack 和 gulp 区别</h2><ol>
<li>Gulp 侧重于前端开发的整个过程的控制管理（像是流水线），我们可以通过给 gulp 配置不通的 task（通过 Gulp 中的 gulp.task() 方法配置，比如启动 server、sass&#x2F;less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程</li>
<li>Webpack 也称之为模块打包机 ，由此也可以看出 Webpack 更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js 文件、css 文件等）都可以看成模块，最初 Webpack 本身就是为前端 JS 代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack 是通过 loader（加载器）和 plugins（插件）对资源进行处理的</li>
<li>gulp 是构建工具，Webpack 是 js 模块化的解决方案</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/409.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/409.html" class="post-title-link" itemprop="url">nodejs 基本使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-12-29" itemprop="dateCreated datePublished" datetime="2018-12-29T22:21:15+00:00">2018-12-29</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="nodejs-基本介绍"><a href="#nodejs-基本介绍" class="headerlink" title="nodejs 基本介绍"></a>nodejs 基本介绍</h1><h2 id="为什么要学习-nodejs"><a href="#为什么要学习-nodejs" class="headerlink" title="为什么要学习 nodejs"></a>为什么要学习 nodejs</h2><ol>
<li>降低编程语言切换的成本(nodejs 实质上用的还是 javascript)</li>
<li>NodeJS 是前端项目的基础设施，前端项目中用到的大量工具 (大前端)</li>
<li>nodejs 在处理高并发上有得天独厚的优势(利用 nodejs 做中间层)</li>
<li>对于前端工程师，面试时对于 nodejs 有一定的要求</li>
</ol>
<h2 id="node-js-是什么？"><a href="#node-js-是什么？" class="headerlink" title="node.js 是什么？"></a>node.js 是什么？</h2><p>node.js，也叫作 node，或者 nodejs，指的都是一个平台</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnLw==">node.js 官方网站</span></li>
<li><span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi8=">node.js 中文网</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbm9kZWpzLm9yZy8=">node.js 中文社区</span></li>
</ol>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，nodejs 允许 javascript 代码运行在服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. nodejs不是一门新的编程语言，nodejs是在服务端运行javascript的运行环境</span><br><span class="line">2. 运行环境：写得程序想要运行必须要有对应的运行环境</span><br><span class="line">	php代码必须要有apache服务器</span><br><span class="line">	在web端，浏览器就是javascript的运行环境</span><br><span class="line">	在node端，nodejs就是javascript的运行环境</span><br><span class="line">2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。</span><br><span class="line">3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎</span><br></pre></td></tr></table></figure>

<p><strong>nodejs 的本质：不是一门新的编程语言，nodejs 是 javascript 运行在服务端的运行环境，编程语言还是 javascript</strong></p>
<h2 id="nodejs-与浏览器的区别"><a href="#nodejs-与浏览器的区别" class="headerlink" title="nodejs 与浏览器的区别"></a>nodejs 与浏览器的区别</h2><p>相同点：nodejs 与浏览器都是 js 的运行环境，都能够解析 js 程序。对于 ECMAScript 语法来说，在 nodejs 和浏览器中都能运行</p>
<p>不同点：nodejs 无法使用 DOM 和 BOM 的操作，浏览器无法执行 nodejs 中的文件操作等功能</p>
<h2 id="nodejs-可以干什么？"><a href="#nodejs-可以干什么？" class="headerlink" title="nodejs 可以干什么？"></a>nodejs 可以干什么？</h2><ol>
<li>开发服务端程序</li>
<li>开发命令行工具（CLI），比如 npm，webpack，gulp，less，sass 等</li>
<li>开发桌面应用程序（借助 node-webkit、electron 等框架实现）</li>
</ol>
<h1 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h1><h2 id="nodejs-版本"><a href="#nodejs-版本" class="headerlink" title="nodejs 版本"></a>nodejs 版本</h2><p>下载地址</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkLw==">当前版本</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL3JlbGVhc2VzLw==">历史版本</span></li>
</ul>
<p>官网术语解释</p>
<ul>
<li>LTS 版本：Long-term Support 版本，长期支持版，即稳定版。</li>
<li>Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入</li>
</ul>
<p>查看 node 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<h1 id="运行-nodejs-程序"><a href="#运行-nodejs-程序" class="headerlink" title="运行 nodejs 程序"></a>运行 nodejs 程序</h1><h2 id="方式一：使用-node-执行-js-文件"><a href="#方式一：使用-node-执行-js-文件" class="headerlink" title="方式一：使用 node 执行 js 文件"></a>方式一：使用 node 执行 js 文件</h2><ul>
<li><p>创建 js 文件 <code>helloworld.js</code></p>
</li>
<li><p>写 nodejs 的内容：<code>console.log(&#39;hello nodejs&#39;)</code></p>
</li>
<li><p>打开命令窗口 <code>cmd</code></p>
<ul>
<li>shift 加右键打开命令窗口，执行 <code>node 文件名.js</code>即可</li>
</ul>
</li>
<li><p>执行命令：<code>node helloworld.js</code></p>
</li>
</ul>
<p>注意：在 nodejs 中是无法使用 DOM 和 BOM 的内容的，因此<code>document</code>， <code>window</code>等内容是无法使用的</p>
<h2 id="方式二：REPL-介绍"><a href="#方式二：REPL-介绍" class="headerlink" title="方式二：REPL 介绍"></a>方式二：REPL 介绍</h2><ol>
<li>REPL 全称: Read-Eval-Print-Loop（交互式解释器）<ul>
<li>R 读取 - 读取用户输入，解析输入了 Javascript 数据结构并存储在内存中</li>
<li>E 执行 - 执行输入的数据结构</li>
<li>P 打印 - 输出结果</li>
<li>L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出</li>
</ul>
</li>
<li>在 REPL 中编写程序 （类似于浏览器开发人员工具中的控制台功能）<ul>
<li>直接在控制台输入 <code>node</code> 命令进入 REPL 环境</li>
</ul>
</li>
<li>按两次 Control + C 退出 REPL 界面 或者 输入 <code>.exit</code> 退出 REPL 界面<ul>
<li>按住 control 键不要放开, 然后按两下 c 键</li>
</ul>
</li>
</ol>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>当要求系统运行一个<strong>程序</strong> 而没有告诉它程序所在的完整路径时</p>
<ol>
<li>首先在<strong>当前目录</strong>中查找和该字符串匹配的可执行文件</li>
<li>进入用户 path 环境变量查找</li>
<li>进入系统 path 环境变量查找</li>
</ol>
<p>配置环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到环境变量：计算机 --右键--&gt; 属性 --&gt; 高级系统设置 --&gt; 高级 --&gt; 环境变量</span><br></pre></td></tr></table></figure>

<h1 id="global-模块-全局变量"><a href="#global-模块-全局变量" class="headerlink" title="global 模块-全局变量"></a>global 模块-全局变量</h1><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>
<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 <code>global</code>，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>
<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
<p><strong>常用的 global 属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">console</span>: 用于打印日志</span><br><span class="line"><span class="built_in">setTimeout</span>/<span class="attr">clearTimeout</span>: 设置清除延时器</span><br><span class="line"><span class="built_in">setInterval</span>/<span class="attr">clearInterval</span>: 设置清除定时器</span><br><span class="line"></span><br><span class="line"><span class="attr">__dirname</span>: 当前文件的路径，不包括文件名</span><br><span class="line">__filename：当前文件的路径，包括文件名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与模块化相关的，模块化的时候会用到</span></span><br><span class="line"><span class="built_in">require</span></span><br><span class="line"><span class="built_in">exports</span></span><br><span class="line"><span class="variable language_">module</span></span><br></pre></td></tr></table></figure>

<h1 id="fs-模块"><a href="#fs-模块" class="headerlink" title="fs 模块"></a>fs 模块</h1><blockquote>
<p>fs 模块是 nodejs 中最常用的一个模块，因此掌握 fs 模块非常的有必要，fs 模块的方法非常多，用到了哪个查哪个即可。</p>
<p>文档地址：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbA==">http://nodejs.cn/api/fs.html</span></p>
</blockquote>
<p>在 nodejs 中，提供了 fs 模块，这是 node 的核心模块</p>
<p>注意：</p>
<ol>
<li>除了 global 模块中的内容可以直接使用，其他模块都是需要加载的。</li>
<li>fs 模块不是全局的，不能直接使用。因此需要导入才能使用。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><blockquote>
<p>语法：fs.readFile(file[, options], callback)</p>
</blockquote>
<p>方式一：不传编码参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件路径</span></span><br><span class="line"><span class="comment">// 参数2：读取文件的回调函数</span></span><br><span class="line"><span class="comment">// 回调函数参数1：错误对象，如果读取失败，err 会包含错误信息，如果读取成功，err 是 null</span></span><br><span class="line"><span class="comment">// 回调函数参数2：读取成功后的数据（是一个Buffer对象）</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;data.txt&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>()) <span class="comment">// 将Buffer对象转换成字符串</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>方式二：传编码参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件的路径</span></span><br><span class="line"><span class="comment">// 参数2：编码，如果设置了，返回一个字符串，如果没有设置，会返回一个buffer对象</span></span><br><span class="line"><span class="comment">// 参数3：回调函数</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>关于 Buffer 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Buffer对象是Nodejs用于处理二进制数据的</span><br><span class="line">2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制</span><br><span class="line">3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象</span><br><span class="line">4. Buffer对象可以调用toString()方法转换成字符串</span><br></pre></td></tr></table></figure>

<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><blockquote>
<p>语法：fs.writeFile(file, data[, options], callback)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件路径(如果文件不存在，会自动创建)</span></span><br><span class="line"><span class="comment">// 参数2：写入的文件内容（注意：写入的内容会覆盖以前的内容）</span></span><br><span class="line"><span class="comment">// 参数3：写文件后的回调函数</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入文件失败&#x27;</span>, err)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入文件成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>写文件的时候，会把原来的内容给覆盖掉</li>
</ol>
<blockquote>
<p>语法：fs.appendFile(path, data[, options], callback)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：追加的文件名(如果文件不存在，会自动创建)</span></span><br><span class="line"><span class="comment">// 参数2：追加的文件内容</span></span><br><span class="line"><span class="comment">// 参数3：追加文件后的回调函数</span></span><br><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;我是追加的内容&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;追加文件内容失败&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;追加文件内容成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>思考：如果没有 appendFile，通过 readFile 与 writeFile 应该怎么实现？</p>
<h2 id="文件同步与异步的说明"><a href="#文件同步与异步的说明" class="headerlink" title="文件同步与异步的说明"></a>文件同步与异步的说明</h2><blockquote>
<p>fs 中所有的文件操作，都提供了异步和同步两种方式</p>
</blockquote>
<p>异步方式：不会阻塞代码的执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件失败&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;222&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>同步方式：会阻塞代码的执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步方式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>)</span><br><span class="line"><span class="keyword">const</span> result = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>)</span><br></pre></td></tr></table></figure>

<p>总结：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。</p>
<h2 id="其他-api（了解）"><a href="#其他-api（了解）" class="headerlink" title="其他 api（了解）"></a>其他 api（了解）</h2><p>方法有很多，但是用起来都非常的简单，学会查文档</p>
<p>文档：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbA==">http://nodejs.cn/api/fs.html</span></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>fs.readFile(path, callback)</code></td>
<td>读取文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.readFileSync(path)</code></td>
<td>读取文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.writeFile(path, data, callback)</code></td>
<td>写入文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.writeFileSync(path, data)</code></td>
<td>写入文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.appendFile(path, data, callback)</code></td>
<td>追加文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.appendFileSync(path, data)</code></td>
<td>追加文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.rename(oldPath, newPath, callback)</code></td>
<td>重命名文件（异步）</td>
</tr>
<tr>
<td><code>fs.renameSync(oldPath, newPath)</code></td>
<td>重命名文件（同步）</td>
</tr>
<tr>
<td><code>fs.unlink(path, callback)</code></td>
<td>删除文件（异步）</td>
</tr>
<tr>
<td><code>fs.unlinkSync(path)</code></td>
<td>删除文件（同步）</td>
</tr>
<tr>
<td><code>fs.mkdir(path, mode, callback)</code></td>
<td>创建文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.mkdirSync(path, mode)</code></td>
<td>创建文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.rmdir(path, callback)</code></td>
<td>删除文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.rmdirSync(path)</code></td>
<td>删除文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.readdir(path, option, callback)</code></td>
<td>读取文件夹内容（异步）</td>
</tr>
<tr>
<td><code>fs.readdirSync(path, option)</code></td>
<td>读取文件夹内容（同步）</td>
</tr>
<tr>
<td><code>fs.stat(path, callback)</code></td>
<td>查看文件状态（异步）</td>
</tr>
<tr>
<td><code>fs.statSync(path)</code></td>
<td>查看文件状态（同步）</td>
</tr>
</tbody></table>
<h1 id="path-模块"><a href="#path-模块" class="headerlink" title="path 模块"></a>path 模块</h1><h2 id="路径操作的问题"><a href="#路径操作的问题" class="headerlink" title="路径操作的问题"></a>路径操作的问题</h2><p>在读写文件的时候，文件路径可以写相对路径或者绝对路径</p>
<p>data.txt 是相对路径，读取当前目录下的 data.txt，相对路径相对的是指向 node 命令的路径</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果node命令不是在当前目录下执行就会报错，在当前执行node命令的目录下查找data.txt，找不到</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件失败&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>相对路径：相对于执行 node 命令的路径</p>
<p>推荐使用绝对路径：<code>__dirname</code>: 当前文件的目录，<code>__filename</code>: 当前文件的目录，包含文件名</p>
<h2 id="path-模块的常用方法"><a href="#path-模块的常用方法" class="headerlink" title="path 模块的常用方法"></a>path 模块的常用方法</h2><blockquote>
<p>关于路径，在 linux 系统中，路径分隔符使用的是<code>/</code>，但是在 windows 系统中，路径使用的<code>\</code></p>
</blockquote>
<p>在我们拼写路径的时候会带来很多的麻烦，经常会出现 windows 下写的代码，在 linux 操作系统下执行不了，path 模块就是为了解决这个问题而存在的。</p>
<p>常用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.<span class="title function_">join</span>() <span class="comment">// 拼接路径，返回拼接后的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// windows系统下</span></span><br><span class="line">path.<span class="title function_">join</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;gg&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abc\def\gg\a.html&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// linux系统下</span></span><br><span class="line">path.<span class="title function_">join</span>(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;def&#x27;</span>,<span class="string">&#x27;gg&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abc/def/gg/index.html&#x27;</span></span><br><span class="line"></span><br><span class="line">【优化读写文件的代码】</span><br><span class="line"></span><br><span class="line">其他方法:</span><br><span class="line">path.<span class="title function_">basename</span>(path[, ext])	返回文件的最后一部分</span><br><span class="line">path.<span class="title function_">dirname</span>(path)	返回路径的目录名</span><br><span class="line">path.<span class="title function_">extname</span>(path)	获取路径的扩展名(后缀名)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> temp = <span class="string">&#x27;abc\\def\\gg\\a.html&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(temp)) <span class="comment">//a.html</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">dirname</span>(temp)) <span class="comment">//abc\def\gg</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">extname</span>(temp)) <span class="comment">//.html</span></span><br></pre></td></tr></table></figure>

<h2 id="path-模块其他-api（了解）"><a href="#path-模块其他-api（了解）" class="headerlink" title="path 模块其他 api（了解）"></a>path 模块其他 api（了解）</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>path.basename(path[, ext])</code></td>
<td>返回文件的最后一部分</td>
</tr>
<tr>
<td><code>path.dirname(path)</code></td>
<td>返回路径的目录名</td>
</tr>
<tr>
<td><code>path.extname(path)</code></td>
<td>获取路径的扩展名</td>
</tr>
<tr>
<td><code>path.isAbsolute(path)</code></td>
<td>判断目录是否是绝对路径</td>
</tr>
<tr>
<td><code>path.join([...paths])</code></td>
<td>将所有的 path 片段拼接成一个规范的路径</td>
</tr>
<tr>
<td><code>path.normalize(path)</code></td>
<td>规范化路径</td>
</tr>
<tr>
<td><code>path.parse(path)</code></td>
<td>将一个路径解析成一个 path 对象</td>
</tr>
<tr>
<td><code>path.format(pathObj)</code></td>
<td>讲一个 path 对象解析成一个规范的路径</td>
</tr>
</tbody></table>
<h1 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h1><h2 id="创建服务器基本步骤"><a href="#创建服务器基本步骤" class="headerlink" title="创建服务器基本步骤"></a>创建服务器基本步骤</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入http模块，http模块是node的核心模块，作用是用来创建 http 服务器的</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 服务器处理请求</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我接收到请求了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 启动服务器，监听某个端口</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9999</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器启动成功了, 请访问： http://localhost:9999&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>详细说明</p>
<ol>
<li>给服务器注册 request 事件，只要服务器接收到了客户端的请求，就会触发 request 事件</li>
<li>request 事件有两个参数，req 表示请求对象，可以获取所有与请求相关的信息，res 是响应对象，可以获取所有与响应相关的信息</li>
<li>服务器监听的端口范围为：1-65535 之间，推荐使用 3000 以上的端口，因为 3000 以下的端口一般留给系统使用</li>
</ol>
<h2 id="request-对象详解"><a href="#request-对象详解" class="headerlink" title="request 对象详解"></a>request 对象详解</h2><p>文档地址：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJz">http://nodejs.cn/api/http.html#http_message_headers</span></p>
<p>常见属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">headers</span>: 所有的请求头信息</span><br><span class="line">method：请求的方式</span><br><span class="line">rawHeaders：所有的请求头信息（数组的方式）</span><br><span class="line">url：请求的地址（url地址的路径部分）</span><br><span class="line">	请求 <span class="attr">http</span>:<span class="comment">//127.0.0.1:3000/index 获取到的是：/index</span></span><br><span class="line">	请求 <span class="attr">http</span>:<span class="comment">//127.0.0.1:3000 获取到的是：/</span></span><br></pre></td></tr></table></figure>

<p>注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个<code>favicon.ico</code>的请求</p>
<p>小结：request 对象中，常用的就是 method 和 url 两个参数</p>
<h2 id="response-对象详解"><a href="#response-对象详解" class="headerlink" title="response 对象详解"></a>response 对象详解</h2><p>文档地址：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvaHR0cC5odG1sI2h0dHBfY2xhc3NfaHR0cF9zZXJ2ZXJyZXNwb25zZQ==">http://nodejs.cn/api/http.html#http_class_http_serverresponse</span></p>
<p>常见的属性和方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.<span class="title function_">write</span>(data): 给浏览器发送响应体，可以调用多次，从而提供连续的响应体</span><br><span class="line">res.<span class="title function_">end</span>()：通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成</span><br><span class="line">res.<span class="title function_">end</span>(data)：结束请求，并且响应一段内容，相当于res.<span class="title function_">write</span>(data) + res.<span class="title function_">end</span>()</span><br><span class="line">res.<span class="property">statusCode</span>: 响应的的状态码 <span class="number">200</span> <span class="number">404</span> <span class="number">500</span></span><br><span class="line">res.<span class="property">statusMessage</span>: 响应的状态信息（不能有中文）， 如果不设置会根据statusCode自动设置</span><br><span class="line">res.<span class="title function_">setHeader</span>(name, value)：设置响应头信息，比如<span class="string">&#x27;content-type&#x27;</span>，<span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line">res.<span class="title function_">writeHead</span>(statusCode, statusMessage, options)：设置响应头，同时可以设置状态码和状态信息</span><br><span class="line">	options 是对象，写响应头的键值对</span><br></pre></td></tr></table></figure>

<p><strong>注意：必须先设置响应头，才能设置响应主体。</strong></p>
<ul>
<li><p>注意：浏览器中输入的 URL 地址，仅仅是一个标识，可以不与服务器中的文件路径一致。也就是说：返回什么内容是由服务端的逻辑决定</p>
</li>
<li><p>路由 : url 标示和对应文件&#x2F;数据的一一对应关系</p>
</li>
</ul>
<h2 id="模拟-Apache-服务器"><a href="#模拟-Apache-服务器" class="headerlink" title="模拟 Apache 服务器"></a>模拟 Apache 服务器</h2><ul>
<li>根据 <code>req.url</code> 读取不同的页面内容，返回给浏览器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求: 简单模仿apache服务器，浏览器发送127.0.0.1:8888/index.html</span></span><br><span class="line"><span class="comment">// 对应的返回www文件夹下面的index.html的内容</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"><span class="comment">// 监听请求</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 根据不同请求输出不同响应数据</span></span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">url</span> === <span class="string">&#x27;/&#x27;</span> || req.<span class="property">url</span> === <span class="string">&#x27;/i&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取www下面的index.html</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">    fs.<span class="title function_">readFile</span>(filename, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件读取失败&#x27;</span>)</span><br><span class="line">      <span class="comment">// 服务器响应文件</span></span><br><span class="line">      res.<span class="property">statusCode</span> = <span class="number">200</span></span><br><span class="line">      res.<span class="property">statusMessage</span> = <span class="string">&#x27;ok&#x27;</span></span><br><span class="line">      res.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>)</span><br><span class="line">      res.<span class="title function_">end</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="property">url</span> === <span class="string">&#x27;/l&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取list.html</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;list.html&#x27;</span>)</span><br><span class="line">    fs.<span class="title function_">readFile</span>(filename, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件读取失败&#x27;</span>)</span><br><span class="line">      <span class="comment">// 服务器响应文件</span></span><br><span class="line">      res.<span class="title function_">writeHead</span>(<span class="number">200</span>, <span class="string">&#x27;OOOOOOK&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      res.<span class="title function_">end</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回浏览器, 未找到资源</span></span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">404</span>, <span class="string">&#x27;NOT FOUND&#x27;</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;404 ,资源未找到&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 开启服务器</span></span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8888</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器开启了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="MIME-类型"><a href="#MIME-类型" class="headerlink" title="MIME 类型"></a>MIME 类型</h2><ul>
<li>MIME(Multipurpose Internet Mail Extensions)多用途 Internet 邮件扩展类型 是一种表示文档性质和格式的标准化方式</li>
<li>浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的 MIME 类型附加到响应对象的头部是非常重要的</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9NSU1FX1R5cGVz">MIME 类型</span></li>
</ul>
<h2 id="mime-模块"><a href="#mime-模块" class="headerlink" title="mime 模块"></a>mime 模块</h2><ul>
<li>作用：获取文件的 MIME 类型</li>
<li>安装：<code>npm i mime</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mime = <span class="built_in">require</span>(<span class="string">&#x27;mime&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路径对应的 MIME 类型</span></span><br><span class="line">mime.<span class="title function_">getType</span>(<span class="string">&#x27;txt&#x27;</span>) <span class="comment">// &#x27;text/plain&#x27;</span></span><br><span class="line"><span class="comment">// 根据 MIME 获取到文件后缀名</span></span><br><span class="line">mime.<span class="title function_">getExtension</span>(<span class="string">&#x27;text/plain&#x27;</span>) <span class="comment">// &#x27;txt&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="nodemon-自动重启"><a href="#nodemon-自动重启" class="headerlink" title="nodemon 自动重启"></a>nodemon 自动重启</h1><ul>
<li>作用：监听到 js 文件修改后，自动重启 node 程序</li>
<li>安装：<code>npm i -g nodemon</code></li>
<li>使用：<code>nodemon app.js</code> 运行 node 程序</li>
</ul>
<h1 id="hacknews-案例"><a href="#hacknews-案例" class="headerlink" title="hacknews 案例"></a>hacknews 案例</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS8=">Hacker News 示例</span></li>
<li>路由（route）：就是一套映射规则，根据 url 地址分配到对应的处理程序</li>
</ul>
<h2 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h2><ul>
<li>1 新闻列表页 - &#x2F;index get</li>
<li>2 新闻详情页 - &#x2F;details get</li>
<li>3 新闻添加页 - &#x2F;submit get</li>
<li>4 新闻添加请求 - &#x2F;add post</li>
</ul>
<h2 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art-template 模板引擎"></a>art-template 模板引擎</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hdWkuZ2l0aHViLmlvL2FydC10ZW1wbGF0ZS96aC1jbi9kb2NzLw==">文档</span></li>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install art-template</span><br></pre></td></tr></table></figure>

<ul>
<li>核心方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于模板路径渲染模板</span></span><br><span class="line"><span class="comment">// 参数1：文件的路径</span></span><br><span class="line"><span class="comment">// 参数2：数据</span></span><br><span class="line"><span class="comment">// 返回值：返回渲染后的内容</span></span><br><span class="line"><span class="comment">// template(filename, data)</span></span><br><span class="line"><span class="keyword">let</span> html = <span class="title function_">template</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;pages&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>), &#123; <span class="attr">name</span>: <span class="string">&#x27;大吉大利，今晚吃鸡&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意点：文件的路径必须是绝对路径</strong>；会将整个 html 当做模板返回</p>
<h2 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a>url 模块</h2><ul>
<li>说明：用于 URL 处理与解析</li>
<li>注意：通过 url 拿到的查询参数都是字符串格式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入url模块</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 URL 字符串并返回一个 URL 对象</span></span><br><span class="line"><span class="comment">// 第一个参数：表示要解析的URL字符串</span></span><br><span class="line"><span class="comment">// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象</span></span><br><span class="line"><span class="keyword">var</span> ret = url.<span class="title function_">parse</span>(<span class="string">&#x27;http://localhost:3000/details?id=1&amp;name=jack&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret.<span class="property">query</span>) <span class="comment">// &#123;id: &#x27;1&#x27;, name: &#x27;jack&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="querystring-模块"><a href="#querystring-模块" class="headerlink" title="querystring 模块"></a>querystring 模块</h2><ul>
<li>用于解析与格式化 URL 查询字符串</li>
<li>注意：只在专门处理查询字符串时使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo=bar&amp;abc=xyz&amp;abc=123</span></span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将查询参数转化为对象</span></span><br><span class="line"><span class="comment">// 第一个参数: 要解析的 URL 查询字符串</span></span><br><span class="line">querystring.<span class="title function_">parse</span>(<span class="string">&#x27;foo=bar&amp;abc=xyz&#x27;</span>) <span class="comment">// &#123;foo: &#x27;bar&#x27;, abc: &#x27;xyz&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="服务端重定向"><a href="#服务端重定向" class="headerlink" title="服务端重定向"></a>服务端重定向</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9TdGF0dXM=">HTTP 状态码说明</span></li>
<li><span class="exturl" data-url="aHR0cDovL3NodWFpLmJlL2FyY2hpdmVzLzMwMS0zMDItcmVkaXJlY3Rpb24v">301 和 302</span></li>
<li>说明：服务端可以通过 HTTP 状态码让浏览器中的页面重定向</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.<span class="title function_">writeHead</span>(<span class="number">302</span>, &#123;</span><br><span class="line">  <span class="title class_">Location</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">res.<span class="title function_">end</span>()</span><br></pre></td></tr></table></figure>

<h2 id="POST-请求参数的处理"><a href="#POST-请求参数的处理" class="headerlink" title="POST 请求参数的处理"></a>POST 请求参数的处理</h2><ul>
<li>说明：POST 请求可以发送大量数据，没有大小限制</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受POST参数</span></span><br><span class="line"><span class="keyword">var</span> postData = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// data事件：用来接受客户端发送过来的POST请求数据</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">  result += chunk</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// end事件：当POST数据接收完毕时，触发</span></span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cosnole.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="模块化改造-hackerNews"><a href="#模块化改造-hackerNews" class="headerlink" title="模块化改造 hackerNews"></a>模块化改造 hackerNews</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/398.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/398.html" class="post-title-link" itemprop="url">防抖和节流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-12-12" itemprop="dateCreated datePublished" datetime="2018-12-12T22:13:29+00:00">2018-12-12</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>防抖和节流都是为了解决<strong>短时间内大量触发某函数</strong>而导致的<strong>性能问题，</strong>比如触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象</p>
</blockquote>
<h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>在事件被触发 n 秒后再执行回调函数，如果在这 n 秒内又被触发，则重新计时（只会触发最后一次）</p>
<p>应用场景</p>
<ul>
<li><p>用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询 ajax 请求，这样可以有效减少请求次数，节约请求资源</p>
</li>
<li><p>window 的 resize、scroll 事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次</p>
</li>
</ul>
<h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p>规定一个单位时间 n，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内事件被触发多次，只有一次能生效（每 n 秒触发一次）</p>
<p>应用场景</p>
<ul>
<li><p>鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次</p>
</li>
<li><p>在页面的无限加载场景下，需要用户在滚动页面时，每隔一段时间发一次 ajax 请求，而不是在用户停下滚动页面操作时才去请求数据</p>
</li>
<li><p>监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断</p>
</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>防抖的作用是将多个连续的<code>debounced</code>调用合并为一次<code>callback</code>调用。防抖是基于最近次 <code>debounced</code> 调用来重置 <code>waitTime</code>，如果<code>debounced</code>事件触发间隔小于 <code>waitTime</code>，<code>callback</code>就不会执行；</p>
<p>节流的作用是限制<code>callback</code>调用的频率（每<code>waitTime</code>调用一次）。是基于上次 <code>callback</code> 调用来计算 <code>waitTime</code> 的，不管<code>callback</code> 事件触发有多频繁，只要距离上次 <code>callback</code> 调用超过了 <code>waitTime</code>，就一定会进行下次 <code>callback</code> 调用。</p>
<p>– 原理：</p>
<p>防抖是 <code>debounced</code> 维护了一个计时器，规定在 <code>waitTime</code> 时间后触发 <code>callback</code>，但是在 <code>waitTime</code> 时间内再次触发 <code>debounced</code> 的话，会清除当前的 timer 然后重新计时，这样一来，只有最后一次<code>debounced</code> 操作才能触发 <code>callback</code>；</p>
<p>节流是通过判断是否到达一定时间 (<code>waitTime</code>) 来再次触发 <code>callback</code> ， <code>func</code> 在 <code>waitTime</code> 时间内不能被再次触发。</p>
<p>实现</p>
<p>throttle-debounce 插件 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdGhyb3R0bGUtZGVib3VuY2U=">https://www.npmjs.com/package/throttle-debounce</span></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">input.<span class="property">oninput</span> = <span class="title function_">throttle</span>(<span class="number">1000</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">debounce</span>(<span class="number">1000</span>, b)</span><br><span class="line">a.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">delay, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> lastExec = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> elapsed = <span class="title class_">Number</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()) - lastExec</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">exec</span>(<span class="params"></span>) &#123;</span><br><span class="line">      callback.<span class="title function_">apply</span>(self, args)</span><br><span class="line">      lastExec = <span class="title class_">Number</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt; delay) &#123;</span><br><span class="line">      <span class="title function_">exec</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">exec</span>()</span><br><span class="line">      &#125;, delay - elapsed)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">delay, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">exec</span>(<span class="params"></span>) &#123;</span><br><span class="line">      callback.<span class="title function_">apply</span>(self, args)</span><br><span class="line">      lastExec = <span class="title class_">Number</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">exec</span>()</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/425.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/425.html" class="post-title-link" itemprop="url">LESS 基本使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-12-11" itemprop="dateCreated datePublished" datetime="2018-12-11T22:30:46+00:00">2018-12-11</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Less-简介"><a href="#Less-简介" class="headerlink" title="Less 简介"></a>Less 简介</h2><blockquote>
<p><strong><em>Less</em>  是一门 CSS 预处理语言（预先处理）,它扩展了 CSS 语言，增加了变量、Mixin、函数等特性</strong></p>
<p>浏览器不直接识别 less 文件，浏览器只识别 css 文件，所以我们写了 less 文件之后，我们需要预先把 less 文件转换成 css 文件。</p>
</blockquote>
<p>本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。</p>
<p><strong>less 仅仅是写 css 的另一种方式，写出来的 less 文件浏览器也不识别，所以啊，我们写完了 less 文件，还需要通过 less 解析器解析成 css，最终浏览器引入的还是 css 文件。</strong></p>
<p>学习网站：</p>
<p><span class="exturl" data-url="aHR0cDovL2xlc3Njc3Mub3JnLw==">官网 http://lesscss.org/</span><br><span class="exturl" data-url="aHR0cDovL2xlc3Njc3MuY24v">中文网 http://lesscss.cn/</span></p>
<h2 id="less-的编译"><a href="#less-的编译" class="headerlink" title="less 的编译"></a>less 的编译</h2><blockquote>
<p>如何把 less 文件变成 css 文件</p>
</blockquote>
<h3 id="使用打包工具"><a href="#使用打包工具" class="headerlink" title="使用打包工具"></a>使用打包工具</h3><p><code>gulp</code></p>
<p><code>webpack</code></p>
<h3 id="使用考拉"><a href="#使用考拉" class="headerlink" title="使用考拉"></a>使用考拉</h3><blockquote>
<p>koala 是一个前端预处理器语言（less&#x2F;sass）图形编译工具，支持 Less、Sass、Compass、CoffeeScript，帮助 web 开发者更高效地使用它们进行开发。跨平台运行，完美兼容 windows、linux、mac。</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cDovL2tvYWxhLWFwcC5jb20vaW5kZXgtemguaHRtbA==">考拉官网</span></p>
<p>使用步骤：</p>
<ol>
<li>把<code>less</code>文件夹拖进去</li>
<li>会在当前目录生成一个<code>css</code>目录</li>
</ol>
<p>优点：不用 node 环境，不用 less 环境，koala 内置了</p>
<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>easy less</p>
<h2 id="Less-语法"><a href="#Less-语法" class="headerlink" title="Less 语法"></a>Less 语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>注释</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是CSS中的注释，因此会编译到css中 */</span></span><br><span class="line"><span class="comment">// 这是less的注释，css不能识别这个注释， 最后不会编译到css文件</span></span><br></pre></td></tr></table></figure>

<p><strong>变量</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @变量名: 变量值;</span></span><br><span class="line"><span class="variable">@color:</span> <span class="number">#ccc</span>;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mixin-函数"><a href="#mixin-函数" class="headerlink" title="mixin 函数"></a>mixin 函数</h3><p><strong>混入函数</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数：不带参数</span></span><br><span class="line"><span class="selector-class">.btn</span>() &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="selector-class">.btn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数：带参数</span></span><br><span class="line"><span class="selector-class">.btn_border</span>(<span class="variable">@width</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@width</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="comment">// 如果函数定义了参数，调用的时候必须传入参数，否则会报错</span></span><br><span class="line">  <span class="selector-class">.btn_border</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数：带参数默认值</span></span><br><span class="line"><span class="selector-class">.btn_border</span>(<span class="variable">@width</span>: <span class="number">1px</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@width</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="comment">// 因为有默认值，所以不会报错</span></span><br><span class="line">  <span class="selector-class">.btn_border</span>();</span><br><span class="line">  <span class="selector-class">.btn_border</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：定义兼容多浏览器的圆角</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.border_radius</span>(<span class="variable">@value</span>: <span class="number">5px</span>) &#123;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.border_radius</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><blockquote>
<p>我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。</p>
</blockquote>
<ul>
<li>使用伪类的时候 可以使用<code>&amp;</code> 表示自己</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="comment">// 子代</span></span><br><span class="line">  <span class="selector-class">.son1</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后代</span></span><br><span class="line">  &gt; <span class="selector-class">.son2</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交集： &amp; 表示本身</span></span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-class">.now</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后缀名</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;variable&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;maxin&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>模块化的思想，分模块进行管理这些 less 文件，最终只需要使用 import 将 less 引入到一起即可</p>
<h3 id="函数（运算）"><a href="#函数（运算）" class="headerlink" title="函数（运算）"></a>函数（运算）</h3><blockquote>
<p>在我们的 CSS 中充斥着大量的数值型的 value，less 可以直接支持运算，也提供了一系列的函数提供给我们使用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: round(100%/6, 2);</span><br><span class="line">  height: 100px + 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cDovL3d3dy4xMDI0aS5jb20vZGVtby9sZXNzL3JlZmVyZW5jZS5odG1s">http://www.1024i.com/demo/less/reference.html</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">c</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>本站为个人博客，站内所有软件资源均收集自互联网，本站仅做免费分享，不出售。本站内所有软件资源仅限个人用于学习和研究目的，不得将上述内容用于商业或者非法用途，否则，一切后果请用户自负。本站内所有软件必须在下载后的24个小时之内，从您的电脑中彻底删除。本站对任何资源不提供技术支持，遇到问题请自行研究或购买正版。本站信息来自网络，版权争议与本站无关。访问和下载本站内容，说明您已同意上述条款。


    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"cuilongjin/hexo-blog","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
