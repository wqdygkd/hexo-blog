<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-logo.png">
  <link rel="mask-icon" href="/images/favicon-logo.png" color="#222">
  <meta name="google-site-verification" content="4ub2lNf2WEkusifo-b7xbJIm2G5xxYUczDoWOFGp-NM">
  <meta name="msvalidate.01" content="C2030D8E2452D4B39AED09488E55F2DF">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wqdy.top","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}};
  </script>
<meta name="description" content="分享各类资源、经验与技巧">
<meta property="og:type" content="website">
<meta property="og:title" content="我全都要">
<meta property="og:url" content="https://wqdy.top/page/13/index.html">
<meta property="og:site_name" content="我全都要">
<meta property="og:description" content="分享各类资源、经验与技巧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="c">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wqdy.top/page/13/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

<!-- google 分析 -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
    (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-9068539038073295",
        enable_page_level_ads: true
    });
</script>

<script>
  let a = '🍏 🍎 🍐 🍊 🍋 🍌 🍉 🍇 🍓 🍈 🍒 🍑 🍍 🥭 🥥 🥝 🍅 🍆 🥑 🥦 🥒 🥬 🌶 🌽 🥕 🥔 🍠 🥐 🍞 🥖 🥨 🥯 🧀 🥚 🍳 🥞 🥓 🥩 🍗 🍖 🌭 🍔 🍟 🍕 🥪 🥙 🌮 🌯 🥗 🥘 🥫 🍝 🍜 🍲 🍛 🍣 🍱 🥟 🍤 🍙 🍚 🍘 🍥 🥮 🥠 🍢 🍡 🍧 🍨 🍦 🥧 🍰 🎂 🍮 🍭 🍬 🍫 🍿 🧂 🍩 🍪 🌰 🥜 🍯 🥛 🍼 ☕️ 🍵 🥤 🍶 🍺 🍻 🥂 🍷 🥃 🍸 🍹 🍾 🥄 🍴 🍽 🥣 🥡 🥢 🌵 🎄 🌲 🌳 🌴 🌱 🌿 ☘️ 🍀 🎍 🎋 🍃 🍂 🍁 🍄 🌾 💐 🌷 🌹 🥀 🌺 🌸 🌼 🌻 😀 😁 😂 🤣 😃 😄 😅 😆 😉 😊 😋 😎 😍 😘 🥰 😗 😙 😚 ☺️ 🙂 🤗 🤩 🤔 🤨 😐 😑 😶 🙄 😏 😣 😥 😮 🤐 😯 😪 😫 😴 😌 😛 😜 😝 🤤 😒 😓 😔 😕 🙃 🤑 😲 ☹️ 🙁 😖 😞 😟 😤 😢 😭 😦 😧 😨 😩 🤯 😬 😰 😱 🥵 🥶 😳 🤪 😵 😡 😠 🤬 😷 🤒 🤕 🤢 🤮 🤧 😇 🤠 🤡 🥳 🥴 🥺 🤥 🤫 🤭 🧐 🤓 😈 👿 👹 👺 💀 👻 👽 🤖 💩 😺 😸 😹 😻 😼 😽 🙀 😿 😾'
  document.addEventListener('visibilitychange', function() {
    if (document.visibilityState == 'hidden') {
      normal_title = document.title
      document.title = a.split(' ')[parseInt(Math.random() * 235)]
    } else document.title = normal_title
  })
</script>

<title>我全都要</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112496567-1"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-112496567-1');
      }
    </script>

  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4cf9aa5b4589576262198ad166b18a05";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我全都要</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">搞快点</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="c"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">c</p>
  <div class="site-description" itemprop="description">分享各类资源、经验与技巧</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">146</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">75</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cuilongjin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cuilongjin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </section>
      </div>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/390.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/390.html" class="post-title-link" itemprop="url">bootstrap 框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-11 22:06:47" itemprop="dateCreated datePublished" datetime="2018-12-11T22:06:47+00:00">2018-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷</p>
<p><a target="_blank" rel="noopener" href="http://www.bootcss.com/">bootstrap 中文网</a></p>
<p>特点：</p>
<ul>
<li>组件简洁大方、代码规范精简、界面自定义性强</li>
<li>Bootstrap 是基于 HTML5 和 CSS3 开发的，它在 jQuery 的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分 jQuery 插件</li>
<li>Bootstrap 中包含了丰富的 Web 组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站</li>
</ul>
<p>优点：</p>
<ul>
<li>有自己的生态圈，不断的更新迭代</li>
<li>提供了一套简洁、直观、强悍的组件</li>
<li>标准化的 HTML+CSS 编码规范</li>
<li>让开发更简单，提高了开发效率</li>
<li>扩展性强，虽然界面组件样式已经定义好了，我们还可以自定义，修改默认样式</li>
</ul>
<p>版本：</p>
<ul>
<li>2.x.x 停止维护<ul>
<li>优点：兼容性好 IE678</li>
<li>缺点：代码不够简洁、功能不够完善</li>
</ul>
</li>
<li>3.x.x <strong>目前使用最多（H5C3 很多东西）</strong><ul>
<li>优点：稳定，偏向于开发响应式布局，移动设备优先的 WEB 项目</li>
<li>缺点：放弃了 IE67，对 IE8 支持但是界面效果不友好</li>
</ul>
</li>
<li>4.x.x 测试阶段</li>
</ul>
<h2 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h2><p>!&gt; 但凡看到 <code>role属性</code> <code>aria-*的属性</code> <code>class=&#39;sr-only&#39;的标签</code> 都可以直接删除，因为是给屏幕阅读器用的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>bootstrap基本模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 bootstrap 的核心样式文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;lib/bootstrap/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- html5shiv 是用来解决 IE8 以下浏览器不支持 HTML5 语义化标签的问题 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- respond 是用来解决 IE8 以下浏览器不支持媒体查询的问题，注意：respond 不支持 file 协议打开 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 条件注释：IE浏览器专属 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;respond.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">  &lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- bootstrap 依赖于 jquery，因此需要在 bootstrap 之前引入jquery文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/jquery/jquery-1.12.4.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 bootstrap 的核心js文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/bootstrap/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h2><h3 id="normalize-css"><a href="#normalize-css" class="headerlink" title="normalize.css"></a>normalize.css</h3><p>Normalize.css 是一种 CSS reset 的替代方案。经过@necolas 和@jon_neal 花了几百个小时来努力研究不同浏览器的默认样式的差异，这个项目终于变成了现在这样</p>
<p><a target="_blank" rel="noopener" href="http://necolas.github.io/normalize.css/">官网</a> <a target="_blank" rel="noopener" href="https://github.com/necolas/normalize.css">github 网址</a></p>
<p>normalize 的特点：</p>
<ul>
<li><strong>保护有用的浏览器默认样式</strong>而不是完全去掉它们</li>
<li><strong>一般化的样式</strong>：为大部分 HTML 元素提供</li>
<li><strong>修复浏览器自身的 bug</strong>并保证各浏览器的一致性</li>
<li><strong>优化 CSS 可用性</strong>：用一些小技巧</li>
</ul>
<p><code>Normalize.css</code> 支持包括手机浏览器在内的超多浏览器，同时对 HTML5 元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/webpush/p/4974063.html">Normalize.css 与 CSS reset 区别</a></p>
<h3 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h3><p>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。默认带了 15px 的 padding 值</p>
<p><code>.container</code> 类用于固定宽度并支持响应式布局的容器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>.container-fluid</code> 类用于 100% 宽度，占据全部视口（viewport）的容器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这两种容器类不能互相嵌套</p>
<h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>栅格系统，也叫网格系统，bootstrap 栅格系统把一个盒子分成 12 格</p>
<ul>
<li><p>栅格参数：<code>col-xx-yy</code></p>
<p>xx：<code>lg</code> 大屏(≥1200px)、<code>md</code> 中屏(≥992px)、<code>sm</code> 小屏(≥768px)、<code>xs</code> 超小屏(&lt;768px)</p>
<p>yy：取值范围为 1 - 12 表示占几格</p>
<p><code>col-xx-12</code>：可以省略不写</p>
</li>
<li><p>列偏移：<code>col-xx-offset-yy</code></p>
<p>xx ：lg、md、sm、xs</p>
<p>yy：取值范围为 1 - 12 表示往右偏移几格</p>
<p>列偏移：实际上是给当前元素增加了左侧的边距（margin）</p>
</li>
<li><p>多余列（column）的元素将作为一个整体单元被另起一行排列</p>
</li>
<li><p><code>.row</code>用于抵消 <code>.container</code>容器的 15px 的 padding 值，实际上是给元素添加了 margin: -15px</p>
</li>
<li><p>可以在<code>.row</code>中嵌套<code>column</code></p>
</li>
<li><p>列排序：<code>.col-md-push-*</code> 和 <code>.col-md-pull-*</code></p>
</li>
</ul>
<p>栅格系统常用类（总共 12 列）</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>例子</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>.col-xs-xx</td>
<td>.col-xs-6</td>
<td>在超小屏幕（及以上）生效</td>
</tr>
<tr>
<td>.col-sm-xx</td>
<td>.col-sm-6</td>
<td>在小屏幕（及以上）生效</td>
</tr>
<tr>
<td>.col-md-xx</td>
<td>.col-md-6</td>
<td>在中屏幕（及以上）生效</td>
</tr>
<tr>
<td>.col-lg-xx</td>
<td>.col-lg-3</td>
<td>在大屏幕及生效，占 1/4</td>
</tr>
<tr>
<td>.col-lg-xx</td>
<td>.col-lg-4</td>
<td>在大屏幕及生效，占 1/3</td>
</tr>
<tr>
<td>.col-lg-xx</td>
<td>.col-lg-5</td>
<td>在大屏幕及生效，占 1/2</td>
</tr>
</tbody></table>
<p>【案例：列嵌套.html】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-4&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 栅格系统无处不在，只要父盒子有宽度，就可以使用栅格系统 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>【案例：列偏移.html】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 .col-md-offset-* 类可以将列向右侧偏移--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- col-lg-offset-3:在大屏下，这个div将向右侧偏移3个单位 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-6 col-lg-offset-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><p>标题：h1 到 h6 标签、<code>.h1</code> 到 <code>.h6</code> 类、 <code>&lt;small&gt;</code> 标签或 <code>.small</code> 类用来标记副标题</p>
<p>文本：<code>&lt;mark&gt;</code>标记、<code>&lt;del&gt;</code>删除、<code>&lt;s&gt;</code>无用文本、<code>&lt;ins&gt;</code>插入文本、<code>&lt;u&gt;</code>下划线文本、 <code>.small</code> 类或<code>&lt;small&gt;</code> 小号文本、<code>&lt;strong&gt;</code>着重</p>
<p>对齐：<code>text-left</code>、<code>text-center</code>、<code>text-right</code>、<code>text-justify</code>、<code>text-nowrap</code></p>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p><code>&lt;a&gt;</code>、<code>&lt;button&gt;</code> 或 <code>&lt;input&gt;</code></p>
<p>预定义样式：btn、btn-default、btn-primary(蓝)、btn-success(绿)、btn-info(浅蓝)、btn-warning(橙)、btn-danger(红)、btn-link(链接)</p>
<p>尺寸：btn-lg(大)、(默认)、btn-sm(小)、btn-xs(超小)<br>btn-block (块元素 100%宽度)</p>
<p>激活状态：active</p>
<p>禁用状态：button 元素 添加 <code>disabled</code> 属性、链接<code>&lt;a&gt;</code>元素添加 <code>.disabled</code> 类（建议通过 JavaScript 代码来禁止链接的原始功能）</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>响应式图片：<code>img-responsive</code></p>
<p>实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性</p>
<p>图片形状：<code>img-rounded</code>、<code>img-circle</code>、<code>img-thumbnail</code></p>
<h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><p>文本颜色：<code>text-muted</code>、<code>text-muted</code>、<code>text-primary</code>、<code>text-success</code>、<code>text-info</code>、<code>text-warning</code>、<code>text-danger</code></p>
<p>背景颜色：<code>bg-primary</code>、<code>bg-success</code>、<code>bg-info</code>、<code>bg-warning</code>、<code>bg-danger</code></p>
<p>关闭按钮：<code>&lt;button type=&quot;button&quot; class=&quot;close&quot;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;</code></p>
<p>三角符号：<code>&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</code></p>
<p>快速浮动：<code>pull-left</code>、<code>pull-right</code></p>
<p>让内容块居中：<code>&lt;div class=&quot;center-block&quot;&gt;...&lt;/div&gt;</code></p>
<p>清除浮动：<code>clearfix</code></p>
<p>显示隐藏内容：<code>show</code>、<code>hidden</code>、<code>invisible</code></p>
<h3 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	            超小屏 小屏幕 中等屏幕 大屏幕桌面</span><br><span class="line">.visible-xs-*	可见   隐藏   隐藏	  隐藏</span><br><span class="line">.visible-sm-*	隐藏   可见   隐藏	  隐藏</span><br><span class="line">.visible-md-*	隐藏   隐藏   可见	  隐藏</span><br><span class="line">.visible-lg-*	隐藏   隐藏   隐藏	  可见</span><br><span class="line"></span><br><span class="line">.hidden-xs	  隐藏	 可见	  可见	  可见</span><br><span class="line">.hidden-sm	  可见	 隐藏	  可见	  可见</span><br><span class="line">.hidden-md	  可见	 可见	  隐藏	  可见</span><br><span class="line">.hidden-lg    可见	 可见	  可见	  隐藏</span><br></pre></td></tr></table></figure>
<p><code>*</code> -&gt; block inline inline-block</p>
<p>推荐使用 hidden 相关的属性</p>
<h2 id="bootstrap-validator-插件"><a href="#bootstrap-validator-插件" class="headerlink" title="bootstrap-validator 插件"></a>bootstrap-validator 插件</h2><p>基于 bootstrap 的前端校验插件</p>
<p><a target="_blank" rel="noopener" href="http://bootstrapvalidator.votintsev.ru/api">http://bootstrapvalidator.votintsev.ru/api</a></p>
<h3 id="引包"><a href="#引包" class="headerlink" title="引包"></a>引包</h3><p>引入 css 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;lib/bootstrap/css/bootstrap.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;lib/bootstrap-validator/css/bootstrapValidator.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>引入 js 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/jquery/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/bootstrap/js/bootstrap.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/bootstrap-validator/js/bootstrapValidator.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="初始化表单校验插件"><a href="#初始化表单校验插件" class="headerlink" title="初始化表单校验插件"></a>初始化表单校验插件</h3><p>bootstrap-validator 插件会在表单提交的时候进行校验，如果校验成功了，表单会继续提交，但是如果校验失败了，就会阻止表单的提交</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用表单校验插件</span></span><br><span class="line">$(formSelector).bootstrapValidator(&#123;</span><br><span class="line">  <span class="comment">// 1. 指定不校验的类型，默认为[&#x27;:disabled&#x27;, &#x27;:hidden&#x27;, &#x27;:not(:visible)&#x27;],可以不设置</span></span><br><span class="line">  excluded: [], <span class="comment">// 全部校验</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 指定校验时的图标显示，默认是bootstrap风格</span></span><br><span class="line">  feedbackIcons: &#123;</span><br><span class="line">    valid: <span class="string">&#x27;glyphicon glyphicon-ok&#x27;</span>,</span><br><span class="line">    invalid: <span class="string">&#x27;glyphicon glyphicon-remove&#x27;</span>,</span><br><span class="line">    validating: <span class="string">&#x27;glyphicon glyphicon-refresh&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 指定校验字段</span></span><br><span class="line">  fields: &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      <span class="comment">// 设置校验规则</span></span><br><span class="line">      validators: &#123;</span><br><span class="line">        <span class="comment">// 不能为空</span></span><br><span class="line">        notEmpty: &#123;</span><br><span class="line">          message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        stringLength: &#123;</span><br><span class="line">          min: <span class="number">6</span>,</span><br><span class="line">          max: <span class="number">12</span>,</span><br><span class="line">          message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 正则校验</span></span><br><span class="line">        regexp: &#123;</span><br><span class="line">          regexp: <span class="regexp">/^[a-zA-Z0-9_\.]+$/</span>,</span><br><span class="line">          message: <span class="string">&#x27;用户名由数字字母下划线和.组成&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        callback: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    password: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="注册表单校验成功的事件"><a href="#注册表单校验成功的事件" class="headerlink" title="注册表单校验成功的事件"></a>注册表单校验成功的事件</h3><p>当表单校验成功时，会触发<code>success.form.bv</code>事件，此时会提交表单，通常我们需要禁止表单的自动提交，使用 ajax 进行表单的提交</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#form&#x27;</span>).on(<span class="string">&#x27;success.form.bv&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="comment">// 使用ajax提交逻辑</span></span><br><span class="line">  $.ajax(&#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="获取-validator-实例-对象"><a href="#获取-validator-实例-对象" class="headerlink" title="获取 validator 实例(对象)"></a>获取 validator 实例(对象)</h3><p>当我们初始化好表单校验插件时，我们可以通过以下方法来获取表单校验的 validator 实例，通过 validator 实例调用一些方法来完成某些功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取表单校验实例</span></span><br><span class="line"><span class="keyword">var</span> validator = $(<span class="string">&#x27;#form&#x27;</span>).data(<span class="string">&#x27;bootstrapValidator&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用表单校验实例可以调用一些常用的方法</span></span><br><span class="line">validator.methodName(params)</span><br></pre></td></tr></table></figure>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h4><p>重置表单中设置过校验的内容，将隐藏所有错误提示和图标</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重置表单，隐藏所有的错误提示和图标 传入参数 true 会将内容也清空</span></span><br><span class="line">validator.resetForm()</span><br></pre></td></tr></table></figure>
<h4 id="更新字段的状态"><a href="#更新字段的状态" class="headerlink" title="更新字段的状态"></a>更新字段的状态</h4><p>BootstrapValidator 在用户输入内容的时候，会做校验，当调用 bootstrap 的插件的方法可以手动会改变字段值的状态</p>
<p><code>validator.updateStatus(field*, status*, validator)</code></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>field</code></td>
<td>String|jQuery</td>
<td>The field name or field element</td>
</tr>
<tr>
<td><code>status</code></td>
<td>String</td>
<td>Can be <code>NOT_VALIDATED</code>, <code>VALIDATING</code>, <code>INVALID</code> or <code>VALID</code></td>
</tr>
<tr>
<td><code>validator</code></td>
<td>String</td>
<td>The validator name. If <code>null</code>, the method updates validity result for all validators</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/389.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/389.html" class="post-title-link" itemprop="url">移动 web</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-11 22:05:45" itemprop="dateCreated datePublished" datetime="2018-12-11T22:05:45+00:00">2018-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="移动-web-基础"><a href="#移动-web-基础" class="headerlink" title="移动 web 基础"></a>移动 web 基础</h1><h2 id="移动端开发现状"><a href="#移动端开发现状" class="headerlink" title="移动端开发现状"></a>移动端开发现状</h2><ul>
<li>移动 web 开发指的是需要适配移动设备的网页开发</li>
<li>移动 web 开发与 pc 端 web 开发没有本质的区别，使用的还是 HTML/CSS/JavaScript 的技术</li>
<li>移动 web 开发与 pc 端 web 开发的区别是什么？</li>
</ul>
<p>移动端的浏览器与 pc 端不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">谷歌浏览器 苹果浏览器、 UC浏览器 QQ浏览器 欧朋浏览器 百度手机浏览器  360安全浏览器  搜狗浏览器  猎豹浏览器等</span><br><span class="line">国内的手机浏览器都是根据webkit内核修改过来的，国内没有自主研发的内核，国内的操作系统也是基于Android系统修改的。</span><br><span class="line"></span><br><span class="line">因此在移动端，css3 属性只需要加 webkit 前缀即可</span><br></pre></td></tr></table></figure>
<p>移动端设备尺寸不一样(尺寸非常多，碎片化很严重)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Android： <span class="number">320</span>*<span class="number">480</span> <span class="number">480</span>*<span class="number">800</span>  <span class="number">540</span>*<span class="number">960</span> <span class="number">720</span>*<span class="number">1280</span> <span class="number">1080</span>*<span class="number">1920</span> 2k屏 4k屏</span><br><span class="line">iphpne：  <span class="number">640</span>*<span class="number">960</span> <span class="number">640</span>*<span class="number">1136</span> <span class="number">750</span>*<span class="number">1334</span> <span class="number">1242</span>*<span class="number">2208</span></span><br></pre></td></tr></table></figure>
<h2 id="移动端开发分类"><a href="#移动端开发分类" class="headerlink" title="移动端开发分类"></a>移动端开发分类</h2><ul>
<li>原生 app（native app）</li>
<li>混合 app（Hybrid app）</li>
<li>web 应用（webApp）</li>
</ul>
<p><strong>原生 app（native app）</strong></p>
<blockquote>
<p>原生 app 是基于操作系统的开发，比如安卓，ios，windows phone,他们只能在各自的操作系统上运行。</p>
</blockquote>
<p>优点：</p>
<ol>
<li>可以访问操作系统，获取更多的资源（gps，摄像头，传感器，麦克风等）</li>
<li>速度快，性能高，用户体验好</li>
<li>可以离线使用</li>
</ol>
<p>缺点：</p>
<ol>
<li>开发成本高</li>
<li>需要安装和更新，更新与发布需要审核。</li>
</ol>
<p><strong>Web App</strong></p>
<blockquote>
<p>Web 应用使用 H5C3 开发页面，为浏览器设计的基于 web 的应用，可以在各种智能设备的手机浏览器上运行。不需要安装即可运行。</p>
</blockquote>
<p>优点：</p>
<ol>
<li>支持设备广泛</li>
<li>开发成本低（使用）</li>
<li>可以随时上线与更新，无需审核</li>
</ol>
<p>缺点：</p>
<ol>
<li>用户体验极度依赖网速</li>
<li>要求联网</li>
<li>无法获取手机的资源（gps，摄像头）</li>
</ol>
<p><strong>混合 app（Hybrid App）</strong></p>
<blockquote>
<p>Hybrid App 是指介于 web-app、native-app 这两者之间的 app,它虽然看上去是一个 Native App，但只有一个 UI WebView，里面访问的是一个 Web App。（淘宝、京东、手机百度）</p>
</blockquote>
<p>Hybird App 说白了就是使用了 Native app 的壳，里面其实还是 HTML5 页面</p>
<p>优点：</p>
<ol>
<li>开发成本和难度更低，兼容多个平台</li>
<li>也可以访问手机的操作系统资源。</li>
<li>更新维护更方便</li>
</ol>
<p>缺点：</p>
<ol>
<li>用户体验相比原生 app 稍差</li>
<li>性能依赖于网速</li>
</ol>
<p>总结：</p>
<p>三种开发各有优缺点，具体用什么需要根据实际情况而定，比如预算，app 注重功能还是内容等</p>
<h2 id="屏幕与分辨率"><a href="#屏幕与分辨率" class="headerlink" title="屏幕与分辨率"></a>屏幕与分辨率</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011753855">理解设备像素、设备独立像素和 css 像素</a></p>
<blockquote>
<p>移动设备与 PC 设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面</p>
</blockquote>
<p>屏幕尺寸</p>
<p>通常我们所指的屏幕<code>尺寸</code>，实际上指的是屏幕对角线的长度（一般用英寸来度量）</p>
<p><code>1英寸 = 2.54厘米</code></p>
<p>屏幕分辨率</p>
<p>分辨率则一般用像素来度量，表示屏幕水平和垂直方向的像素数，例如 1920*1080 指的是屏幕垂直方向和水平方向分别有 1920 和 1080 个像素点而构成</p>
<p><code>像素</code>：指计算机显示设备中的最小单位，即一个像素点的大小。每一个像素点可以理解为就是屏幕上的一个发光点</p>
<p>像素密度 ppi</p>
<p><code>PPI (Pixels Per Inch)</code>表示屏幕每英寸的像素数</p>
<p>PPI 值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙</p>
<h2 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a>设备像素</h2><blockquote>
<p>设备像素 (device pixels）也叫物理像素</p>
</blockquote>
<p>设备像素指的是显示器上的真实像素，每个像素的大小是屏幕固有的属性，屏幕出厂以后就不会改变了</p>
<p>设备分辨率描述的就是这个显示器的宽和高分别是多少个设备像素</p>
<p>设备像素和设备分辨率交给操作系统来管理，浏览器不知道、也不需要知道设备分辨率的大小，浏览器只需要知道<strong>逻辑分辨率</strong>就可以了</p>
<h2 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h2><blockquote>
<p>设备独立像素（Device Independent Pixels）也叫逻辑像素、设备无关像素。在 IOS 设备上叫<code>PT</code>，Android 设备上叫<code>DP</code>，在 css 中，叫<code>PX</code></p>
</blockquote>
<p>为了能够保证 <code>图像内容在不同的 PPI 设备看上去大小应该差不多</code> ，操作系统定义了一个单位：设备独立像素，用设备独立像素定义的尺寸，不管屏幕的参数如何，都能以合适的大小显示（这也是设备独立像素名字的由来）</p>
<p>对于那些像素密度高的屏幕，操作系统将多个设备像素划分为一个逻辑像素。屏幕的像素密度越高，就需要更多的设备像素来显示一个设备独立像素。至于将多少设备像素划分为一个逻辑像素，这由操作系统决定</p>
<p>获取设备的像素比</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.devicePixelRatio <span class="comment">// 物理像素 与 css 像素的比值 DPR</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>screen.width/height</code>得到的屏幕宽度和高度就是逻辑分辨率（单位：设备独立像素）</p>
<h2 id="css-像素与缩放"><a href="#css-像素与缩放" class="headerlink" title="css 像素与缩放"></a>css 像素与缩放</h2><p>在缩放比例为 100% 的情况下，一个 css 像素大小等于一个设备独立像素</p>
<p>缩放页面的时候，元素的 css 像素数量不会改变，改变的只是每个 css 像素的大小</p>
<p>缩放比例 = css 像素边长 / 设备独立像素边长</p>
<p>如果原本元素宽度为 128 个设备独立像素，那么缩放 200% 以后元素宽度为 256 个设备独立像素（css 像素宽度始终是 128）</p>
<p>桌面浏览器上缩放机制是 page zoom，缩放会导致 CSS 像素边长的改变，从而导致 window.devicePixelRatio 的改变</p>
<p>在移动端缩放机制是 pinch zoom，计算 window.devicePixelRatio 时，不考虑 pinch zoom 对 CSS 像素尺寸的影响，因此 window.devicePixelRatio 不会随缩放而改变</p>
<h2 id="2-倍图与-3-倍图"><a href="#2-倍图与-3-倍图" class="headerlink" title="2 倍图与 3 倍图"></a>2 倍图与 3 倍图</h2><blockquote>
<p>以后同学在工作的过程中，从 UI 那拿到的设计图通常都是 640 的设计图或者是 750 的设计图</p>
</blockquote>
<p>把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度</p>
<p>设备像素比 devicePixelRatio：即像素的压缩比例</p>
<p><strong>结论 ：在移动端为了在高清屏手机上显示得更加细腻，通常会使用更大的图片，比如 2 倍图或者 3 倍图</strong></p>
<h2 id="视口-viewport"><a href="#视口-viewport" class="headerlink" title="视口 viewport"></a>视口 viewport</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题：一个电脑上的网站，在手机端访问，效果是什么样的？</span><br><span class="line"></span><br><span class="line">iPhone5 的设备宽度只有 320px，一张宽度为 640px 的图片在手机端访问，显示的效果是什么？</span><br><span class="line"></span><br><span class="line">1. 在手机端，html的 大小都是 980px，为什么？</span><br><span class="line">这主要是历史原因导致的，因为在移动设备刚流行的时候，网站大多都是pc端的，pc端的页面宽度一般都比较大，移动设备的宽度比较小，如果pc端页面直接在移动端显示的话，页面就会错乱。为了解决这个问题，移动端html的大小直接就定死成了980px（因为早起的pc端网站版心就是980px居多）</span><br><span class="line"></span><br><span class="line">2. 视口</span><br><span class="line">在 pc 端，html 的大小默认是继承了浏览器的宽度，即浏览器多宽，html 的大小就是多宽，但是在移动端，多出来了一个视口的概念（乔布斯）,视口说白了就是介于浏览器与 html 之间的一个东西，视口的宽度默认定死了 980px，因此 html 的宽度默认就是 980px，视口的特点是能够根据设备的宽度进行缩放</span><br><span class="line"></span><br><span class="line">3. 视口设置</span><br><span class="line">对于现在的移动端页面来说，视口默认为 980px 肯定不合适，因为设备宽度不够的话，视口会进行缩放，导致页面展示效果不好看</span><br></pre></td></tr></table></figure>
<p><strong>视口参数设置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// width 设置视口的宽度</span></span><br><span class="line"><span class="comment">// width=device-width   设置视口宽度为设备的宽度（常用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initial-scale 设置初始缩放比例</span></span><br><span class="line"><span class="comment">// initial-scale=1.0  表示不缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user-scalable 设置是否允许用户缩放</span></span><br><span class="line"><span class="comment">// user-scalable=no  不允许用户缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum-scale  设置允许的最大缩放比例</span></span><br><span class="line"><span class="comment">// maximum-scale=1.0  可以不设置，因为都禁止用户缩放了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// minimum-scale 设置允许最小缩放比</span></span><br><span class="line"><span class="comment">// minimum-scale=1.0  不设置，因为都禁用用户缩放了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准写法：</span></span><br><span class="line"><span class="comment">// 快捷键：  meta:vp + tab键</span></span><br><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="移动端调试问题"><a href="#移动端调试问题" class="headerlink" title="移动端调试问题"></a>移动端调试问题</h2><ol>
<li>模拟器调试</li>
<li>真机调试：使用手机进行访问。</li>
</ol>
<p>手机设备五花八门，屏幕尺寸都大不一样，尤其是安卓端，给我们的页面预览带来了一些麻烦。在实际工作中，作为开发者不可能有足够的设备让我们去测试（<strong>除了测试部门</strong> ），即便有，效率也特别的低，因此开发者一般都是通过浏览器的手机模拟器来模拟不同的设备。</p>
<h1 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h1><p><strong>移动端的特点</strong></p>
<ul>
<li>手机端的兼容性问题比 PC 端小很多，因为手机端的浏览器版本比较新</li>
<li>手机端屏幕比较小，能够放的内容比较少。</li>
</ul>
<p>问题：布局的时候怎么解决屏幕大小不一致的问题？</p>
<ul>
<li>PC 端，固定版心，让所有分辨率的电脑的版心都是一样的，比如京东</li>
<li>移动端：移动端无法设置版心，因为移动端的设备屏幕本身就小，设置版心不合适。因此移动端大多会采用流式布局（百分比布局）</li>
</ul>
<p><strong>流式布局</strong>，也叫百分比布局，是移动端开发中经常使用的布局方式之一。</p>
<p>流式布局的特征：</p>
<ul>
<li>宽度自适应，高度写死，并不是百分百还原设计图</li>
<li>图标都是固定死大小的，包括字体等也是固定死的。并不是所有的东西都是自适应的。</li>
<li>一些大的图片，设置宽度为百分比自适应即可，随着屏幕大小进行变化</li>
</ul>
<p><strong>流式布局无法做到所有设备都非常逼真的还原设计图，有些设备显示效果不是特别的好看。但是流式布局是移动端非常常用的一种布局方式，比较简单，需要掌握（携程、京东)</strong></p>
<p><strong>最后一天会学习 rem 布局，配合 less 非常的方便，并且能够实现完全的自适应，包括字体以及图标等</strong></p>
<p>经典的流式布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 左侧固定，右侧自适应</span><br><span class="line">2. 右侧固定，左侧自适应</span><br><span class="line">3. 两侧固定，中间自适应（圣杯布局，双飞翼布局）</span><br><span class="line">4. 等分布局</span><br></pre></td></tr></table></figure>
<h1 id="touch-事件"><a href="#touch-事件" class="headerlink" title="touch 事件"></a>touch 事件</h1><p>移动端新增了 4 个与手指触摸相关的事件</p>
<ul>
<li><code>touchstart</code>: 手指放到屏幕上时触发</li>
<li><code>touchmove</code>: 手指在屏幕上滑动式触发（会触发多次）</li>
<li><code>touchend</code>: 手指离开屏幕时触发</li>
<li><code>touchcancel</code>: 系统取消 touch 事件的时候触发，比如电话</li>
</ul>
<p>每个触摸事件被触发后，会生成一个 event 对象，event 对象中<code>changedTouches</code>会记录手指滑动的信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">e.touches <span class="comment">// 当前屏幕上的手指</span></span><br><span class="line">e.targetTouches <span class="comment">// 当前dom元素上的手指。</span></span><br><span class="line">e.changedTouches <span class="comment">// 触摸时发生改变的手指(重点)(如手指离开屏幕)</span></span><br></pre></td></tr></table></figure>
<p>这些列表里的每次触摸由 touch 对象组成，touch 对象里包含着触摸信息，主要属性如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e.changedTouches[0].clientX</span></span><br><span class="line">clientX / clientY <span class="comment">// 触摸点相对浏览器窗口的位置</span></span><br><span class="line">pageX / pageY <span class="comment">// 触摸点相对于页面的位置</span></span><br></pre></td></tr></table></figure>
<p>!&gt; 使用 jquery 注册 touch 类事件时，获取手指使用 <code>e.originalEvent.touchs[0]</code> ，因为 jq 对事件对象进行了封装</p>
<p>【案例：jdm-滑动轮播图】</p>
<p>【案例：jdm-区域滚动】</p>
<h2 id="iscroll-插件使用"><a href="#iscroll-插件使用" class="headerlink" title="iscroll 插件使用"></a>iscroll 插件使用</h2><p><a target="_blank" rel="noopener" href="https://github.com/cubiq/iscroll">https://github.com/cubiq/iscroll</a></p>
<p><a target="_blank" rel="noopener" href="http://www.mamicode.com/info-detail-331827.html">iscroll 参考文档</a></p>
<p><strong>注意</strong>：使用 iscroll 需要满足的条件</p>
<ol>
<li>父盒子嵌套了子盒子（一个）</li>
<li>如果有多个子盒子，所以我们需要使用一个盒子把所有的子盒子包裹起来</li>
<li>如果有图片，我们需要保证图片加载完成，如果有浮动，需要清除浮动，为了保证子盒子的高度获取的是正确的</li>
<li>子盒子大小一定要超过父盒子的大小</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用：box为父盒子</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> IScroll(box, &#123;</span><br><span class="line">  scrollX: <span class="literal">false</span>, <span class="comment">// 横向滚动</span></span><br><span class="line">  scrollY: <span class="literal">true</span> <span class="comment">// 纵向滚动</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="zepto-框架"><a href="#zepto-框架" class="headerlink" title="zepto 框架"></a>zepto 框架</h1><blockquote>
<p><strong>Zepto</strong>是一个轻量级的<strong>针对现代高级浏览器的 JavaScript 库， **它与 jquery</strong>有着类似的 api**。 如果你会用 jquery，那么你也会用 zepto</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/madrobby/zepto">github 地址</a></p>
<p><a target="_blank" rel="noopener" href="http://www.css88.com/doc/zeptojs_api/">中文文档</a></p>
<h2 id="zepto-与-jquery-的区别"><a href="#zepto-与-jquery-的区别" class="headerlink" title="zepto 与 jquery 的区别"></a>zepto 与 jquery 的区别</h2><ul>
<li>jquery 针对 pc 端，主要用于解决浏览器兼容性问题，zepto 主要针对移动端</li>
<li>zepto 比 jquery 轻量，文件体积更小</li>
<li>zepto 封装了一些移动端的手势事件</li>
</ul>
<h2 id="zepto-的基本使用"><a href="#zepto-的基本使用" class="headerlink" title="zepto 的基本使用"></a>zepto 的基本使用</h2><p>zepto 的使用与 jquery 基本一致，zepto 是分模块的，需要某个功能，就需要引入某个 zepto 的文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;zepto/zepto.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;zepto/event.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;zepto/fx.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">&#x27;.box&#x27;</span>).addClass(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  $(<span class="string">&#x27;button&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.box&#x27;</span>).animate(&#123; <span class="attr">width</span>: <span class="number">500</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="zepto-的定制"><a href="#zepto-的定制" class="headerlink" title="zepto 的定制"></a>zepto 的定制</h2><p>安装 Nodejs 环境</p>
<p>1、下载 zepto.js</p>
<p>2、解压缩</p>
<p>3、cmd 命令行进入解压缩后的目录</p>
<p>4、执行<code>npm install</code>命令</p>
<p>5、编辑 make 文件的<code>41行</code>，添加自定义模块并保存</p>
<p>7、然后执行命令 <code>npm run-script dist</code></p>
<p>8、查看目录 dist 即构建好的 zepto.js</p>
<h2 id="zepto-手势事件"><a href="#zepto-手势事件" class="headerlink" title="zepto 手势事件"></a>zepto 手势事件</h2><p>zepto 中根据<code>touchstart touchmove touchend</code>封装了一些常用的手势事件，这些事件都是基于 touchstart touchmove touchend 封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tap <span class="comment">// 轻触事件,用于替代移动端的click事件，因为click事件在老版本中会有300ms的延迟</span></span><br><span class="line">swipe <span class="comment">//手指滑动时触发</span></span><br><span class="line">swipeLeft <span class="comment">//左滑</span></span><br><span class="line">swipeRight <span class="comment">//右滑</span></span><br><span class="line">swipeUp <span class="comment">//上滑</span></span><br><span class="line">swipeDown <span class="comment">//下滑</span></span><br></pre></td></tr></table></figure>
<h1 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h1><h2 id="什么是响应式布局"><a href="#什么是响应式布局" class="headerlink" title="什么是响应式布局"></a>什么是响应式布局</h2><blockquote>
<p>响应式布局（respond layout）是 Ethan Marcotte 在 2010 年 5 月份提出的一个概念，简而言之，就是<strong>一个网站能够兼容多个终端（手机、平板、pc 电脑、手表）</strong> ——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的</p>
</blockquote>
<p><strong>为什么要有响应式布局？</strong></p>
<ul>
<li>在移动互联日益成熟的时候，在 PC 端开发的网页已经无法满足移动设备的要求</li>
<li>通常的做法是针对移动端单独做一套特定的版本</li>
<li>如果终端越来越多，那么需要开发的版本就会越来越多（大屏设备的普及）</li>
<li><strong>响应式布局</strong> ：一个网站能够兼容多个终端（节约开发成本）</li>
</ul>
<p><strong>优点：</strong></p>
<p>面对不同分辨率设备灵活性强</p>
<p>能够快捷解决多设备显示适应问题</p>
<p>**缺点： **</p>
<p>兼容各种设备工作量大，效率低下</p>
<p>代码累赘，会出现隐藏无用的元素，加载时间加长</p>
<p>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</p>
<p>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</p>
<p>响应式开发现状：</p>
<ul>
<li>如果已经存在 PC 的网站了，那么一般不会使用响应式开发，而是针对移动端再开发一套系统（比如京东、淘宝）</li>
<li>在<strong>新建站点</strong> 上采用响应式开发的越来越多</li>
<li>在国内，响应式开发还不是特别的流行。但响应式开发是大势所趋，会越来越流行</li>
</ul>
<h2 id="响应式开发与移动-web-开发的比较"><a href="#响应式开发与移动-web-开发的比较" class="headerlink" title="响应式开发与移动 web 开发的比较"></a>响应式开发与移动 web 开发的比较</h2><table>
<thead>
<tr>
<th>开发方式</th>
<th>移动 web 开发+pc 开发</th>
<th>响应式开发</th>
</tr>
</thead>
<tbody><tr>
<td>引用场景</td>
<td>一般已经有了 PC 端网站，只需要端独开发移动端网站即可</td>
<td>针对一些新建网站，并且要求适配移动端</td>
</tr>
<tr>
<td>开发</td>
<td>针对性强，开发效率高</td>
<td>兼容各种终端，效率低</td>
</tr>
<tr>
<td>适配</td>
<td>只能适配移动端或者 PC 端，pad 上体验比较差</td>
<td>可以适配各种终端</td>
</tr>
<tr>
<td>效率</td>
<td>代码简介，加载快</td>
<td>代码相对复杂，加载慢</td>
</tr>
</tbody></table>
<h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><blockquote>
<p>媒体查询（Media Query）是 CSS3 提出来的一个新的属性，通过媒体查询可以查询到 screen 的宽度，从而指定某个宽度区间的网页布局</p>
</blockquote>
<h2 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>宽度范围</th>
</tr>
</thead>
<tbody><tr>
<td>大屏设备</td>
<td>&gt;1200px</td>
</tr>
<tr>
<td>中屏设备</td>
<td>992px~1200px</td>
</tr>
<tr>
<td>小屏设备</td>
<td>768px~992px</td>
</tr>
<tr>
<td>超小屏设备</td>
<td>&lt; 768px</td>
</tr>
</tbody></table>
<h2 id="媒体查询的使用"><a href="#媒体查询的使用" class="headerlink" title="媒体查询的使用"></a>媒体查询的使用</h2><p>需求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  大屏设备(&gt;1200px)   版心：1170px   背景色：红色</span></span><br><span class="line"><span class="comment">  中屏设备(992-1200)  版心：970px    背景色：蓝色</span></span><br><span class="line"><span class="comment">  小屏设备(768-992)   版心：750px    背景色：黄色</span></span><br><span class="line"><span class="comment">  超小屏设备(&lt;768px)  版心：100%     背景色：绿色</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<p>响应式开发的原理：使用媒体查询实现不同终端的布局和样式的切换</p>
<p>媒体查询语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查询屏幕 */</span></span><br><span class="line"><span class="comment">/* screen 和第一个 and 可以省略 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> 条件 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 条件的写法 */</span></span><br><span class="line"><span class="comment">/* min-width: 只要屏幕宽度超过这个值的设备样式就能生效 */</span></span><br><span class="line"><span class="comment">/* max-width: 只要屏幕宽度小于这个值的设备样式就能生效 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1170px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">992px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">992px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="bootstrap-框架"><a href="#bootstrap-框架" class="headerlink" title="bootstrap 框架"></a>bootstrap 框架</h1><p><strong>【项目：微金所】</strong></p>
<h1 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h1><h2 id="rem-是什么？"><a href="#rem-是什么？" class="headerlink" title="rem 是什么？"></a>rem 是什么？</h2><p><code>rem</code>（font size of the root element）是指相对于<code>根元素</code>的字体大小的单位。它就是一个相对单位。</p>
<p><code>em</code>（font size of the element）是指相对于 <code>当前元素的字体大小</code> 的单位。它也是一个相对单位。</p>
<p>它们之间其实很相似，只不过计算的规则一个是依赖根元素，一个是当前元素计算。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.em</span> &#123;</span><br><span class="line">  <span class="comment">/* em 的计算方式参照的当前元素的 font-size，如果不设置，默认继承自父盒子 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* rem 的计算方式参照的是 html 的 font-size */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.rem</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为什么要用-rem？"><a href="#为什么要用-rem？" class="headerlink" title="为什么要用 rem？"></a>为什么要用 rem？</h2><blockquote>
<p>rem 的主要目的就是解决用于不同屏幕的适配问题。rem 能够等比例的适配所有的屏幕。</p>
</blockquote>
<p>由于市面上手机种类繁多，导致移动端的屏幕种类非常的混乱，比如有常见的<code>320px 360px 375px 384px 480px 640px</code>等。在开发中，美工一般只会提供 750px 或者是 640px 的设计稿，这就要求我们通过一张设计稿能够适配所有的屏幕。通常解决方案如下：</p>
<ul>
<li>流式布局：虽然可以让各种屏幕都适配，但是显示效果不是非常的友好，因为只有几个尺寸的手机能够完美的显示出来视觉设计师和交互最想要的效果。但是目前使用流式布局的公司非常多，比如 <a target="_blank" rel="noopener" href="https://www.amazon.cn/">亚马逊</a> 、<a target="_blank" rel="noopener" href="https://m.jd.com/">京东</a> 、<a target="_blank" rel="noopener" href="https://m.ctrip.com/">携程</a></li>
<li>响应式布局：响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是<strong>工作大，维护性难</strong> 。所以一般都是中小型的门户或者博客类站点会采用响应式的方法从 PC 端页面到移动端页面以及 web app 直接一步到位，因为这样反而可以节约成本。</li>
<li>rem 布局：rem 能够适配所有的屏幕，与 less 配合使用效果会更好。目前使用 rem 布局的有：<a target="_blank" rel="noopener" href="https://m.taobao.com/">淘宝</a> 、 <a target="_blank" rel="noopener" href="https://m.suning.com/">苏宁</a></li>
</ul>
<h2 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h2><p>因为 rem 的基准点是根元素 html 的字体大小，因此我们只需要设置不同屏幕的 html 的 font-size 大小不一样就可以达到不同屏幕的适配了。</p>
<h3 id="rem-配合媒体查询"><a href="#rem-配合媒体查询" class="headerlink" title="rem 配合媒体查询"></a>rem 配合媒体查询</h3><p>使用 rem 配合媒体查询可以适配多个终端</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@media(min-width: 320px) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="comment">/* 基准值 / 设计图的大小  = 某个屏幕的font-size / 屏幕的宽度 */</span></span><br><span class="line">    <span class="comment">/* 100/750 = x/370 */</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>优点：使用媒体查询适配，速度快。</p>
<p>缺点：适配多个终端时，需要添加响应的代码。</p>
<h3 id="rem-配合-javascript"><a href="#rem-配合-javascript" class="headerlink" title="rem 配合 javascript"></a>rem 配合 javascript</h3><p>通过 javascript 获取可视区的宽度，计算 font-size 的值，也可以适配多个终端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据屏幕的大小动态设置 html的 font-size</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">responsive</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> uiWidth = <span class="number">750</span> <span class="comment">// 设计图宽度</span></span><br><span class="line">  <span class="keyword">var</span> base = <span class="number">100</span> <span class="comment">// 设计图中1rem的大小</span></span><br><span class="line">  <span class="comment">// 当前屏幕的大小</span></span><br><span class="line">  <span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth</span><br><span class="line">  <span class="keyword">if</span>(pageWidth &gt;= <span class="number">750</span>) &#123;</span><br><span class="line">    pageWidth = <span class="number">750</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pageWidth &lt;= <span class="number">320</span>) &#123;</span><br><span class="line">    pageWidth = <span class="number">320</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 说白了就是把一个屏幕分成了 7.5 rem</span></span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.fontSize = (base / uiWidth * pageWidth).toFixed(<span class="number">2</span>) + ’px‘</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：直接适配所有的终端</p>
<p>缺点：必须在页面加载之前设置 html 的 font-size 值，不然会出现文字大小调动的情况。</p>
<h3 id="rem-配合-flexible-插件"><a href="#rem-配合-flexible-插件" class="headerlink" title="rem 配合 flexible 插件"></a>rem 配合 flexible 插件</h3><ul>
<li><p>flexible 插件基准值（base）是设计图的 1/10</p>
</li>
<li><p>使用 flexible</p>
</li>
</ul>
<ol>
<li><p>在 header 中引入 flexible.js 这个文件</p>
</li>
<li><p>根据设计图能够确定基准值， 配合 px2rem 插件 ，需要设置一个 rootFontSize</p>
</li>
</ol>
<p>【案例：苏宁易购】</p>
<h1 id="swiper-插件"><a href="#swiper-插件" class="headerlink" title="swiper 插件"></a>swiper 插件</h1><blockquote>
<p>Swiper 是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://www.swiper.com.cn/">swiper 中文网</a></p>
<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="comment">/* 取消链接高亮, 移动端特有的样式  */</span></span><br><span class="line">  <span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/400.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/400.html" class="post-title-link" itemprop="url">浏览器的工作原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-30 22:14:52" itemprop="dateCreated datePublished" datetime="2018-11-30T22:14:52+00:00">2018-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h2><p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102203825.png"></p>
<ul>
<li>用户界面－ 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</li>
<li>浏览器引擎－ 用来查询及操作渲染引擎的接口</li>
<li>渲染引擎（浏览器内核）－ 用来显示请求的内容，例如，如果请求内容为 html，它负责解析 html 及 css，并将解析后的结果显示出来</li>
<li>网络－ 用来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作</li>
<li>UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</li>
<li>JS 解释器－ 用来解释执行 JS 代码</li>
<li>数据存储－ 属于持久层，浏览器需要在硬盘中保存类似 cookie 的各种数据，HTML5 定义了 Storage 技术，这是一种轻量级完整的客户端存储技术</li>
</ul>
<h2 id="主流的渲染引擎"><a href="#主流的渲染引擎" class="headerlink" title="主流的渲染引擎"></a>主流的渲染引擎</h2><blockquote>
<p>浏览器的渲染引擎也叫排版引擎，或者是<strong>浏览器内核</strong></p>
</blockquote>
<p>主流的 渲染引擎 有</p>
<ul>
<li><strong>Chrome 浏览器</strong>: Blink 引擎（WebKit 的一个分支）。</li>
<li><strong>Safari 浏览器</strong>: WebKit 引擎，windows 版本 2008 年 3 月 18 日推出正式版，但苹果已于 2012 年 7 月 25 日停止开发 Windows 版的 Safari。</li>
<li><strong>FireFox 浏览器</strong>: Gecko 引擎。</li>
<li><strong>Opera 浏览器</strong>: Blink 引擎(早期版使用 Presto 引擎）。</li>
<li><strong>Internet Explorer 浏览器</strong>: Trident 引擎。</li>
<li><strong>Microsoft Edge 浏览器</strong>: EdgeHTML 引擎（Trident 的一个分支）。</li>
</ul>
<h2 id="渲染引擎工作原理"><a href="#渲染引擎工作原理" class="headerlink" title="渲染引擎工作原理"></a>渲染引擎工作原理</h2><p>渲染引擎解析的基本流程：</p>
<ol>
<li><p>解析 HTML 构建 <code>Dom树</code>，同时解析所有的 css 样式，构建 css 规则。DOM 是 W3C 组织推荐的处理可扩展置标语言的标准编程接口。</p>
</li>
<li><p>根据 DOM 树和 css 规则合并构建 <code>渲染树</code></p>
<ul>
<li>DOM 树上的节点没有样式的，渲染树的节点有样式的</li>
<li>渲染树上的节点都是需要渲染的，所以渲染树上没有像<code>head</code>标签 或 <code>display: none</code>这样的元素，但是它们在 Dom 树中</li>
</ul>
</li>
<li><p>对渲染树进行布局，定位坐标和大小、确定是否换行、确定 position、overflow、z-index 等等，这个过程叫<code>layout</code> 或 <code>reflow</code>。</p>
</li>
<li><p>绘制渲染树，调用操作系统底层 API(UI Backend)进行绘图操作。</p>
</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102203846.png"></p>
<p><strong>webkit 内核工作流程</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102203907.png"></p>
<p><strong>gecko 内核工作流程</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102203924.jpeg"></p>
<p>结论：浏览器能够解析 HTML 文件，并且显示到页面中。所以我们写的文件能够使用浏览器打开并且能够看到效果。</p>
<h1 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h1><h2 id="重绘与回流-1"><a href="#重绘与回流-1" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><p><code>回流(reflow)</code>: 又叫重排，当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。</p>
<p><code>重绘(repaint)</code>：当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。</p>
<ol>
<li>每个页面至少需要一次回流+重绘</li>
<li>回流必将引起重绘</li>
</ol>
<p>回流什么时候发生？</p>
<p>1、添加或者删除可见的 DOM 元素</p>
<p>2、元素位置改变</p>
<p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p>
<p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变</p>
<p>5、页面渲染初始化</p>
<p>6、浏览器窗口尺寸改变——resize 事件发生时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style</span><br><span class="line">s.padding = <span class="string">&#x27;2px&#x27;</span> <span class="comment">// 回流+重绘</span></span><br><span class="line">s.border = <span class="string">&#x27;1px solid red&#x27;</span> <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">&#x27;blue&#x27;</span> <span class="comment">// 再一次重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">&#x27;#ccc&#x27;</span> <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">&#x27;14px&#x27;</span> <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="comment">// 添加node，再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;abc!&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="聪明的浏览器"><a href="#聪明的浏览器" class="headerlink" title="聪明的浏览器"></a>聪明的浏览器</h2><blockquote>
<p>从上个实例代码中可以看到几行简单的 JS 代码就引起了 6 次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句 JS 操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
</blockquote>
<p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前 flush 队列，这样浏览器的优化可能就起不到作用了。当你向浏览器请求一些 style 信息的时候，就会让浏览器 flush 队列，比如：</p>
<ol>
<li><p>offsetTop, offsetLeft, offsetWidth, offsetHeight</p>
</li>
<li><p>scrollTop/Left/Width/Height</p>
</li>
<li><p>clientTop/Left/Width/Height</p>
</li>
<li><p>width,height</p>
</li>
<li><p>请求了 getComputedStyle(), 或者 IE 的 currentStyle</p>
</li>
</ol>
<h2 id="如何性能优化"><a href="#如何性能优化" class="headerlink" title="如何性能优化"></a>如何性能优化</h2><blockquote>
<p>减少回流与重绘的次数，就需要简单对渲染树的操作</p>
</blockquote>
<ol>
<li>直接使用 <code>className</code> 修改样式，少用 style 设置样式</li>
<li>让要操作的元素进行”离线处理”，处理完后一起更新<ul>
<li>使用 <code>DocumentFragment</code> 进行缓存操作，引发一次回流和重绘</li>
<li>使用 <code>display:none</code> 技术，只引发两次回流和重绘</li>
</ul>
</li>
<li>将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow</li>
<li><strong>完成功能是前提，在完成功能的情况下想着优化代码</strong></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/395.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/395.html" class="post-title-link" itemprop="url">HTML5</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-23 22:10:49" itemprop="dateCreated datePublished" datetime="2018-11-23T22:10:49+00:00">2018-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是-HTML5"><a href="#什么是-HTML5" class="headerlink" title="什么是 HTML5"></a>什么是 HTML5</h2><blockquote>
<p>HTML5 并不仅仅是作为 <strong>HTML 标记语言的一个最新版本</strong>， 更重要的是它<strong>制定了 web 应用开发的一系列标准</strong>，成为第一个将 web 作为应用开发平台的 HTML 语言。</p>
</blockquote>
<p>HTML5 定义了一系列新元素，如 <strong>新语义标签、多媒体标</strong> 签等，可以帮助开发者开发更加丰富的应用，同时有令人眼花缭乱的 css3，还提供了一些 Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用，制作 webApp，甚至结合 Canvas 我们可开发网页游戏</p>
<p>我们日常讨论的 H5 其实指的是一个泛称，它是由<strong>HTML5+CSS3+javascript</strong> 等技术组合而成的一个应用开发平台</p>
<h2 id="HTML5-的历史"><a href="#HTML5-的历史" class="headerlink" title="HTML5 的历史"></a>HTML5 的历史</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. WHATWG: Web Hypertext Application Technology Working。 WHATWG成立的原因是W3C意图放弃HTML，而力图发展XML技术</span><br><span class="line">2. HTML5 的第一份正式草案已于2008年1月22日公布</span><br><span class="line">3. 2014年10月29日，万维网联盟宣布，经过接近8年的艰苦努力，该标准规范终于制定完成</span><br></pre></td></tr></table></figure>
<p>思考：问什么 HTML5 在 2008 年就发布草案了，到 2014 年才火起来？</p>
<p>因为移动端的推动，HTML 在老的浏览器上兼容性很严重，并且 HTML5 很多新特性其实就是为移动端而出现的，可以说<strong>HTML5 是为移动端而生的</strong></p>
<h1 id="HTML5-语义化标签"><a href="#HTML5-语义化标签" class="headerlink" title="HTML5 语义化标签"></a>HTML5 语义化标签</h1><h2 id="常用语义化标签"><a href="#常用语义化标签" class="headerlink" title="常用语义化标签"></a>常用语义化标签</h2><blockquote>
<p>在 HTML5 之前，我们布局大多使用 div，但是 div 并没有语义化，HTML5 推出了一系列的语义化标签，可以用来表示 header、footer 等。</p>
</blockquote>
<p>HTML5 新的语义化标签</p>
<p><code>header</code> 头部、<code>nav</code> 导航、<code>footer</code> 底部、<code>aside</code> 侧边栏、<code>article</code> 文章、<code>section</code> 区块、<code>main</code> 主体区域</p>
<p>本质上新语义标签与<code>&lt;div&gt;</code>、<code>&lt;span&gt;</code>没有区别，只是其具有语义性，使用时除了在 HTML 结构上需要注意外，其它和普通标签的使用无任何差别，<code>&lt;nav&gt;</code>完全可以理解成<code>&lt;div class=&quot;nav&quot;&gt;</code>。不要好奇，它只是一个标签！就是增加了语义性，更加利于 SEO 的优化。</p>
<p>html5 还推出了一些其他的标签：<a target="_blank" rel="noopener" href="http://www.w3school.com.cn/tags/index.asp">http://www.w3school.com.cn/tags/index.asp</a></p>
<h2 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h2><p>IE678 不识别这个标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">&#x27;header&#x27;</span>) <span class="comment">// 创建这个标签即可让IE678识别</span></span><br><span class="line"><span class="comment">// 创建的标签默认是行内样式。</span></span><br><span class="line"><span class="comment">// 还需给标签加一个 display:block 的属性。</span></span><br></pre></td></tr></table></figure>
<p>借助 <code>html5shiv.js</code></p>
<blockquote>
<p>我们每次都要去创建标签，并且还需要设置 display：block 属性，非常麻烦，因此我们可以引入一个第三方 js 文件，这个 js 文件的功能就是创建元素和设置 display 属性。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if lte IE 8] &gt;  // lte ==&gt; 小于等于</span></span><br><span class="line"><span class="comment">&lt;script src=&quot;js/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;! [endif] --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当 ie 浏览器的版本小于等于8的时候，才会引入 html5shiv.js --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- css hack --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 条件注释 IE独有的注释 --&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="类名操作-重点"><a href="#类名操作-重点" class="headerlink" title="类名操作(重点)"></a>类名操作(重点)</h1><blockquote>
<p>js 在 H5 中给所有的 DOM 对象新增了一个属性 classList</p>
<p>classList 是一个集合，会存储某个元素上所有的类名，使用 classList 来替代 className 操作 class 类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加类</span></span><br><span class="line">div.classList.add(<span class="string">&#x27;classname&#x27;</span>)</span><br><span class="line"><span class="comment">// 移除类</span></span><br><span class="line">div.classList.remove(<span class="string">&#x27;classname&#x27;</span>)</span><br><span class="line"><span class="comment">// 切换类</span></span><br><span class="line">div.classList.toggle(<span class="string">&#x27;classname&#x27;</span>)</span><br><span class="line"><span class="comment">// 判断类</span></span><br><span class="line">div.classList.contains(<span class="string">&#x27;classname&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>【tab 栏案例】</p>
<h1 id="自定义属性操作（重点）"><a href="#自定义属性操作（重点）" class="headerlink" title="自定义属性操作（重点）"></a>自定义属性操作（重点）</h1><blockquote>
<p>H5 规定，以后但凡给标签增加自定义属性，都应该用 <code>data-</code> 开头 (规范)</p>
<p>H5 给所有的 DOM 对象增加了一个 <code>dataset</code> 的属性，这个属性中会包含所有 data- 开头的属性</p>
</blockquote>
<ul>
<li>html 5 中操作自定义属性 <code>dataset</code> 属性</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">data-name</span>=<span class="string">&quot;zs&quot;</span> <span class="attr">data-age</span>=<span class="string">&quot;10&quot;</span> <span class="attr">data-user-name</span>=<span class="string">&quot;ls&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#box&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset) <span class="comment">// DOMStringMap &#123;name: &#x27;zs&#x27;, age: &#x27;10&#x27;, userName: &#x27;ls&#x27;&#125;</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset.name) <span class="comment">// zs</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset[<span class="string">&#x27;age&#x27;</span>]) <span class="comment">// 10</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset.userName) <span class="comment">// ls</span></span></span><br><span class="line"><span class="javascript">  box.dataset.aaBb = <span class="string">&#x27;cc&#x27;</span> <span class="comment">// 在html结构中或添加 data-aa-bb=&quot;cc&quot; 的自定义属性</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>html 中属性是忽略大小写的，相当于是小写字母，如果需要大写，应使用中划线 <code>-</code> 进行分隔，在 js 中会转换成驼峰的形式，如<code>data-user-name ==&gt; userName</code></p>
<ul>
<li>jquery 中操作自定义属性</li>
</ul>
<p>jquery 并没有把 <code>data-</code> 当成自定义属性来用，jq 中封装了 <code>data()</code> 方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">data-name</span>=<span class="string">&quot;zs&quot;</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">data-a</span>=<span class="string">&#x27;&#123;&quot;b&quot;:&quot;c&quot;&#125;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data()) <span class="comment">// &#123;id: 1, name: &quot;zs&quot;&#125;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// console.log($(&#x27;#box&#x27;).attr()) // error</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset) <span class="comment">// DOMStringMap&#123;id: &quot;1&quot;, name: &quot;zs&quot;&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;id&#x27;</span>)) <span class="comment">// 1 =&gt; 获取到自定义属性</span></span></span><br><span class="line"><span class="javascript">  $(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;id&#x27;</span>, <span class="number">2</span>) <span class="comment">// 并不会修改原标签中的自定义属性</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;id&#x27;</span>)) <span class="comment">// 2 =&gt; html中data-id依然是1</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).attr(<span class="string">&#x27;data-id&#x27;</span>)) <span class="comment">// 1</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset[<span class="string">&#x27;id&#x27;</span>]) <span class="comment">// 1 =&gt; 获取到的还是原来的 data-id</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  $(<span class="string">&#x27;#box&#x27;</span>).attr(<span class="string">&#x27;data-id&#x27;</span>, <span class="number">3</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;id&#x27;</span>)) <span class="comment">// 3</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(box.dataset[<span class="string">&#x27;id&#x27;</span>]) <span class="comment">// 3</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 属性里使用json语法，但通过data()设置的不能解析成对象</span></span></span><br><span class="line"><span class="javascript">  $(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;&#123;&quot;e&quot;:&quot;f&quot;&#125;&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// &#123;b: &quot;c&quot;&#125; =&gt; 对象</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log($(<span class="string">&#x27;#box&#x27;</span>).data(<span class="string">&#x27;d&#x27;</span>)) <span class="comment">// &#x27;&#123;&quot;e&quot;:&quot;f&quot;&#125;&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  $(<span class="string">&#x27;#box&#x27;</span>).removeData() <span class="comment">// 删除之前通过 data() 方法设置的数据</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>!&gt; jq 的 data() 方法内部使用了缓存来实现，该方法设置的属性只能通过该方法获取，在 html 页面中看不到属性值，通过原生 dataset 属性也获取不到值</p>
<h1 id="网络状态"><a href="#网络状态" class="headerlink" title="网络状态"></a>网络状态</h1><blockquote>
<p>在移动端，我们经常需要检测设置是在线还是离线，HTML5 为此定义了一个 navigator.onLine 属性，这个属性用于检测设备是否联网。<strong>navigator.onLine</strong> 在不同浏览器中有细微的差别。</p>
</blockquote>
<h2 id="网络状态-1"><a href="#网络状态-1" class="headerlink" title="网络状态"></a>网络状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">navigator.onLine 返回用户当前的网络状况，是一个布尔值</span><br><span class="line">1. 如果浏览器连不上网(包括局域网)，就是离线状态，也就是脱机状态，会返回 false</span><br><span class="line">2. 否则就是在线状态，返回 true</span><br></pre></td></tr></table></figure>
<p><strong>注意：返回 true 不一定就是说一定能访问互联网，因为有可能连接的是局域网。但是返回 false 则表示一定连不上网。</strong></p>
<h2 id="监听网络变化"><a href="#监听网络变化" class="headerlink" title="监听网络变化"></a>监听网络变化</h2><blockquote>
<p>为了更好的确定网络是否连接，HTML5 还定义了两个事件，用于监听网络状态的变化。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网络连接时会被调用</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;online&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;online&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当网络断开时会被调用</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;offline&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;offline&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h1><blockquote>
<p>在 HTML 规范中，增加了获取用户地理信息的 API，这样使得我们可以基于用户位置开发互联网应用，即基于位置服务 LBS(Location Base Service)</p>
</blockquote>
<h2 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h2><p>HTML5 规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。<strong>在获取地理位置之前，会询问用户，只有在获得许可之后，才能获取到用户的位置信息。</strong></p>
<p>H5 提供的获取地理位置信息并不是特别的精确，会一定的误差，如果需要非常精确的定位，还是需要使用安卓或者 ios，访问基于操作系统的方法。 （小程序）</p>
<h2 id="相关的方法"><a href="#相关的方法" class="headerlink" title="相关的方法"></a>相关的方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// successCallback:获取成功后会调用,并返回一个position对象，里面包含了地理位置信息</span></span><br><span class="line"><span class="comment">// 获取失败了会调用，并返回error对象，里面包含了错误信息。</span></span><br><span class="line"><span class="comment">// 获取当前的地理位置信息</span></span><br><span class="line">navigator.geolocation.getCurrentPosition(successCallback, errorCallback)</span><br><span class="line"><span class="comment">// 重复的获取当前的地理位置信息</span></span><br><span class="line">navigator.geolocation.watchPosition(successCallback, errorCallback)</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定位成功会调用该方</span></span><br><span class="line">    <span class="comment">// 法谷歌浏览器进行了限制，看不到，可以再IE浏览器下查看</span></span><br><span class="line">    <span class="comment">// position.coords.latitude 纬度</span></span><br><span class="line">    <span class="comment">// position.coords.longitude 经度</span></span><br><span class="line">    <span class="comment">// position.coords.accuracy 精度</span></span><br><span class="line">    <span class="comment">// position.coords.altitude 海拔高度</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定位失败会调用该方法</span></span><br><span class="line">    <span class="comment">// error 是错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>苹果浏览器对 webkit 定位权限进行了修改，所有定位请求的页面必须是 https 协议的。</strong></p>
<h2 id="百度地图、高德地图、腾讯地图"><a href="#百度地图、高德地图、腾讯地图" class="headerlink" title="百度地图、高德地图、腾讯地图"></a>百度地图、高德地图、腾讯地图</h2><blockquote>
<p>仅仅获取到经纬度对于用户来说意义并不大，因为用户也不知道经度和纬度表示的是地球上的哪一个地方，因为我们可以结合百度地图，准确的将用户的位置显示出来。</p>
</blockquote>
<p>百度地图官网：<a target="_blank" rel="noopener" href="http://lbsyun.baidu.com/">http://lbsyun.baidu.com/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 在开发中，找到 javascript API</span><br><span class="line">2. 直接查看示例 demo</span><br><span class="line">3. 复制相应的代码，替换掉秘钥就行，秘钥只需创建一个新的应用就可以了</span><br></pre></td></tr></table></figure>
<h1 id="web-存储"><a href="#web-存储" class="headerlink" title="web 存储"></a>web 存储</h1><blockquote>
<p>在代码执行的时候，数据都是存储在内存中的，当页面关闭或者浏览器关闭的时候，内存就被释放掉了。数据只有存储在硬盘上，才不会被释放。</p>
</blockquote>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>特点：</p>
<ul>
<li>在浏览器端的存储数据的容器</li>
<li>大小 4k</li>
<li>生命周期，默认会话级别，但是可以设置过期时间</li>
<li>cookie 中的数据可以在同一个网站的页面共享</li>
<li>cookie 中的数据，在请求时会进行自动携带</li>
<li>不同浏览器的 cookie 不能共享</li>
<li>cookie 是以字符串形式存在的，这个字符串有固定的格式：key=value;key1=value1；在获取 cookie 内容时，一般需要通过正则或者字符串的方法进行处理，转换成对象，最终得到数据</li>
<li>一般用于存储 sessionId，可以实现登录状态保持 (会话保持)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;name=zhangsan&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;age=18&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;sex=23&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置过期时间</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;sex=12;max-age=3600&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取cookie</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.cookie</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<h2 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h2><blockquote>
<p>HTML5 规范提出使用 sessionStorage 和 localStorage 存储数据。设置、读取、删除操作很方便</p>
</blockquote>
<ul>
<li><p>sessionStorage 和 localStorage 特点</p>
<ul>
<li>都保存在客户端</li>
<li>大小为 5M 左右</li>
<li>使用方法相同</li>
<li>以键值对的方式，存储字符串格式的数据</li>
</ul>
</li>
<li><p>sessionStorage 和 localStorage 区别</p>
<ul>
<li>sessionStorage 生命周期默认为一个会话周期，且不能设置周期，一旦关闭浏览器，就销毁了，不能在多个窗口下共享数据</li>
<li>localStorage 永久生效，除非手动删除，可以多个窗口共享</li>
</ul>
</li>
<li><p>使用方法</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setItem(key, value) <span class="comment">// 设置存储内容</span></span><br><span class="line">getItem(key) <span class="comment">// 读取存储内容</span></span><br><span class="line">removeItem(key) <span class="comment">// 删除键值为key的存储内容</span></span><br><span class="line">clear() <span class="comment">// 清空所有存储内容（谨慎使用）</span></span><br></pre></td></tr></table></figure>
<p>存取复杂数据类型：先将复杂数据转换成 JSON 字符串 <code>JSON.stringify(obj/arr)</code> 在进行存储；使用时将 JSON 字符串转换成复杂数据类型 <code>JSON.parse( jsonStr )</code></p>
<p>【案例-换肤效果】</p>
<h2 id="Cookie-和-WebStorage-比较"><a href="#Cookie-和-WebStorage-比较" class="headerlink" title="Cookie 和 WebStorage 比较"></a>Cookie 和 WebStorage 比较</h2><p><strong>cookie</strong></p>
<ul>
<li>大小受限</li>
<li>用户可以操作（禁用）cookie，使功能受限</li>
<li>安全性较低</li>
<li>有些状态不可能保存在客户端。</li>
<li>每次访问都要传送 cookie 给服务器，浪费带宽</li>
</ul>
<p><strong>WebStorage</strong></p>
<ul>
<li>存储空间更大：cookie 为 4KB，而 WebStorage 是 5MB</li>
<li>WebStorage 不会传送到服务器，存储在本地的数据可以直接获取，速度更快，并且减少了客户端和服务器端的交互，节省了网络流量</li>
<li>对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage 会非常方便</li>
<li>安全性：WebStorage 不会随着 HTTP header 发送到服务器端，所以安全性相对于 cookie 来说比较高一些，不会担心截获，但是仍然存在伪造问题</li>
<li>WebStorage 提供了一些方法，数据操作比 cookie 方便</li>
</ul>
<h1 id="自定义播放器"><a href="#自定义播放器" class="headerlink" title="自定义播放器"></a>自定义播放器</h1><p>全屏切换 API：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// requestFullScreen 这个方法还没有标准化，需要添加私有前缀</span></span><br><span class="line">video.requestFullScreen()</span><br><span class="line">video.webkitRequestFullScreen()</span><br><span class="line">video.mozRequestFullScreen()</span><br></pre></td></tr></table></figure>
<p>video/audio 属性：</p>
<ul>
<li>currentTime: 设置或返回音频/视频中的当前播放位置（以秒计）</li>
<li>duration: 返回当前音频/视频的长度（以秒计）</li>
<li>autoplay: 默认 false 设置或返回是否在加载完成后随即播放音频/视频</li>
<li>volume: 设置或返回音频/视频的音量</li>
<li>paused: 设置或返回音频/视频是否暂停， true 指示音频/视频已暂停</li>
</ul>
<p>方法：</p>
<ul>
<li><p>load(): 重新加载音频/视频元素</p>
</li>
<li><p>play(): 开始播放音频/视频</p>
</li>
<li><p>pause(): 暂停当前播放的音频/视频</p>
</li>
</ul>
<p>事件：</p>
<ul>
<li>timeupdate: 播放进度更改时触发</li>
</ul>
<p>参考文档<br><a target="_blank" rel="noopener" href="http://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp">http://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp</a></p>
<p>推荐：<a target="_blank" rel="noopener" href="https://www.awesomes.cn/repo/videojs/video-js">https://www.awesomes.cn/repo/videojs/video-js</a></p>
<h1 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h1><blockquote>
<p>通过 FileReader 对象我们可以读取本地存储的文件（用户通过 input:file 上传的文件），可以使用 File 对象来指定所要读取的文件或数据。其中 File 对象可以是来自用户在一个<code>&lt;input&gt;</code>元素上选择文件后返回的 FileList 对象，也可以来自由拖放操作生成的 DataTransfer</p>
</blockquote>
<h2 id="files"><a href="#files" class="headerlink" title="files"></a>files</h2><p>对于 file 类型的 input 框，在这个 DOM 对象中，存在一个 files 属性，这个属性是 FileList 对象，是一个伪数组，里面存储着上传的所有文件，当 input 框指定了 multiple 属性之后，就可以上传多个文件了。</p>
<p>也就是说，通过 files 这个属性，我们就可以获取到所有上传的文件。</p>
<h2 id="file-对象"><a href="#file-对象" class="headerlink" title="file 对象"></a>file 对象</h2><p>File 对象中包含了文件的最后修改时间、文件名、文件类型等信息。</p>
<h2 id="FileReader-对象"><a href="#FileReader-对象" class="headerlink" title="FileReader 对象"></a>FileReader 对象</h2><p>FileReader 是一个 HTML5 新增的对象，用于读取文件（必须通过 input:file 上传）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> file = input.files[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 创建一个fileReader对象</span></span><br><span class="line"><span class="keyword">var</span> fr = <span class="keyword">new</span> FileReader</span><br><span class="line"><span class="comment">// 读取文件的两个方法</span></span><br><span class="line">fr.readAsText(file) 以文本的方式读取文件 ,文本文件</span><br><span class="line">fr.readAsDataURL(file) 以DataURL形式读取文件，图片，视频</span><br><span class="line"><span class="comment">// 文件读取完成事件：</span></span><br><span class="line">fr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 当文件读取完成，可以通过result属性获取结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(fr.result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例：图片预览</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. FileReader 是异步的</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;file&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>)</span><br><span class="line">file.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="built_in">this</span>) <span class="comment">// file 中files 属性里面存储了所有上传的文件</span></span><br><span class="line">  <span class="comment">// 这个data就是我们上传的那个文件</span></span><br><span class="line">  <span class="keyword">var</span> data = file.files[<span class="number">0</span>]</span><br><span class="line">  <span class="comment">// 1. 创建一个文件读取器</span></span><br><span class="line">  <span class="keyword">var</span> fr = <span class="keyword">new</span> FileReader()</span><br><span class="line">  <span class="comment">// 2. 让文件读取器读取整个文件</span></span><br><span class="line">  fr.readAsDataURL(data)</span><br><span class="line">  <span class="comment">// 3. 等待文件读取完</span></span><br><span class="line">  <span class="comment">// onload：文件读取完成后，就会触发</span></span><br><span class="line">  fr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 fr.result 就可以获取到最终的结果</span></span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">    img.src = fr.result</span><br><span class="line">    box.innerHTML = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    box.appendChild(img)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. URL.createObjectURL(file)  缺点： 1. 试验中  2. 同步（阻塞）</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;file&#x27;</span>)</span><br><span class="line">file.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="built_in">this</span>.files[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">var</span> result = URL.createObjectURL(data)</span><br><span class="line">  img.src = result</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/1632.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1632.html" class="post-title-link" itemprop="url">CSS3 基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-23 14:28:51" itemprop="dateCreated datePublished" datetime="2018-11-23T14:28:51+00:00">2018-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如同人类的的进化一样，CSS3 是 CSS2 的“进化”版本，在 CSS2 基础上，<strong>增强</strong>  或 <strong>新增</strong>  了许多特性， 弥补了 CSS2 的众多不足之处，使得 Web 开发变得更为高效和便捷。</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><ul>
<li>PC 端浏览器支持程度差，需要添加私有前缀</li>
<li>移动端支持优于 PC 端</li>
<li>不断改进中</li>
<li>应用相对广泛</li>
</ul>
<p>关于私有前缀：</p>
<blockquote>
<p>在标准还未确定时，部分浏览器已经根据最初草案实现了部分功能，为了与之后确定下来的标准进行兼容，所以每种浏览器使用了自己的私有前缀与标准进行区分，当标准确立后，各大浏览器将逐步支持不带前缀的 css3 新属性</p>
<p>目前已有很多私有前缀可以不写了，但为了兼容老版本的浏览器，可以仍沿用私有前缀和标准方法，逐渐过渡</p>
<p>一般来说，CSS3 主要是为移动端而生的，因此我们在移动端没必要写太多的前缀，因为移动端的 ios 和 Android 的浏览器都是 webkit 内核</p>
<p>谷歌、苹果浏览器：<code>-webkit-</code><br>火狐浏览器：<code>-moz-</code><br>IE 浏览器：<code>-ms-</code><br>欧朋浏览器：<code>-o-</code></p>
<p>一般工作中不用去加，会通过打包工具 webpack 自动添加</p>
</blockquote>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><ul>
<li>text-shadow: 文字阴影</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：text-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]*</span><br><span class="line">  &lt;shadow&gt; &#x3D;&gt; &lt;length&gt;&#123;2,3&#125; &amp;&amp; &lt;color&gt;?</span><br><span class="line">text-shadow：水平偏移 垂直偏移 羽化大小 颜色</span><br><span class="line">水平偏移 垂直偏移 可以为负值，羽化大小可选且不可为负</span><br><span class="line">可以设置多组阴影值，用逗号隔开</span><br></pre></td></tr></table></figure>
<ul>
<li>box-shadow: 边框阴影</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：box-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]*</span><br><span class="line">  &lt;shadow&gt; &#x3D;&gt; inset? &amp;&amp; &lt;length&gt;&#123;2,4&#125; &amp;&amp; &lt;color&gt;?</span><br><span class="line"></span><br><span class="line">box-shadow：水平偏移 垂直偏移 羽化大小 阴影外延 颜色</span><br><span class="line">水平偏移、垂直偏移、阴影外延可以为负值，羽化大小、阴影外延可选，羽化大小不允许负值</span><br><span class="line">可以设置多组阴影值，用逗号隔开</span><br><span class="line">inset：设置对象的阴影类型为内阴影。该值为空时，则对象的阴影类型为外阴影</span><br></pre></td></tr></table></figure>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>background-size</p>
<p>bakground-clip</p>
<p>background-origin</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><blockquote>
<p>linear-gradient() 指沿着某条直线朝一个方向产生的渐变效果</p>
<p>渐变实际上相当与一张图片，因为需要加给 background-image 才会生效</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最简单的渐变 颜色至少两个 方向默认从上到下 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设定渐变的方向 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 也可以设定渐变的角度 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(45<span class="selector-tag">deg</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设定渐变的范围 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span> 20%, <span class="selector-tag">green</span> 80%)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每一个区间表示渐变颜色的范围 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span> 20%, <span class="selector-tag">green</span> 20%)</span><br></pre></td></tr></table></figure>
<h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><blockquote>
<p>radial-gradient 指从一个中心点开始沿着四周产生渐变效果</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最简单的渐变 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定圆的半径和圆心 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(200<span class="selector-tag">px</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定椭圆 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(200<span class="selector-tag">px</span> 80<span class="selector-tag">px</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定范围 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(200<span class="selector-tag">px</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>, <span class="selector-tag">green</span> 50%, <span class="selector-tag">red</span> 50%);</span><br></pre></td></tr></table></figure>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><blockquote>
<p>CSS3 中可以通过 box-sizing 来指定盒模型，即可指定为 content-box、border-box，这样我们计算盒子大小的方式就发生了改变</p>
</blockquote>
<p>可以分成两种情况：</p>
<ul>
<li>box-sizing: border-box 计算方式为 content = width – border - padding</li>
<li>box-sizing: content-box 计算方式为 content = width</li>
</ul>
<h2 id="calc-函数"><a href="#calc-函数" class="headerlink" title="calc() 函数"></a>calc() 函数</h2><p>用于动态计算长度值</p>
<ul>
<li>注意：运算符前后都需要保留一个空格，例如：<code>width: calc(100% - 10px)</code></li>
<li>任何长度值都可以使用 calc() 函数进行计算</li>
<li>calc() 函数支持 <code>+</code> 、<code>-</code>、 <code>*</code> 、<code>/</code> 运算</li>
<li>calc() 函数使用标准的数学运算优先级规则</li>
</ul>
<h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><ul>
<li>过渡的属性</li>
</ul>
<p>如果两个状态发生改变，没有过渡，效果是瞬间变化的，如果加上了过渡，那么这个过程就会有动画的效果，整个状态变化的过程是由浏览器来完成的，我们只需要关注开始状态与结束状态即可</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* transition-property：设置过渡属性 默认值为 all 表示全部*/</span></span><br><span class="line"><span class="comment">/* 多个用逗号分隔 */</span></span><br><span class="line"><span class="selector-tag">transition-property</span>: <span class="selector-tag">all</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-duration:设置过渡时间 */</span></span><br><span class="line"><span class="selector-tag">transition-duration</span>: 1<span class="selector-tag">s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-delay：设置过渡延时 */</span></span><br><span class="line"><span class="selector-tag">transition-delay</span>: 2<span class="selector-tag">s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-timing-function:设置过渡的速度 */</span></span><br><span class="line"><span class="comment">/* linear(匀速)，ease(平滑)，ease-in，ease-out，ease-in-out， steps(10)(分步动画) */</span></span><br><span class="line"><span class="selector-tag">transition-timing-function</span>: <span class="selector-tag">linear</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li>过渡必须要有两个状态的变化</li>
<li>过渡除了可以加到初始的状态，可以加到 hover 状态，但效果不一样，如果加到 hover 状态，回来就没有过渡了</li>
</ol>
</blockquote>
<ul>
<li>属性合写</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 属性 时间 延时 速度 */</span></span><br><span class="line"><span class="comment">/* 多个过渡用逗号隔开 */</span></span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">width</span> 1<span class="selector-tag">s</span> 3<span class="selector-tag">s</span> <span class="selector-tag">linear</span>, <span class="selector-tag">border-radius</span> 3<span class="selector-tag">s</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2D-转换"><a href="#2D-转换" class="headerlink" title="2D 转换"></a>2D 转换</h2><blockquote>
<p>transform: 转换，是 CSS3 最具颠覆性的几个特性之一，既可以用于 2D 转换，也可以用于 3D 转换</p>
<p>transform: 2D 转换，元素在平面上实现移动、旋转、缩放、斜切等操作</p>
</blockquote>
<h3 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale 缩放"></a>scale 缩放</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleX</span>(0.5); <span class="comment">/* 让宽度变化 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleY</span>(0.5); <span class="comment">/* 让高度变化，注意不能写多个transform，不然会覆盖 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0.5); <span class="comment">/* 让宽度和高度同时变化 */</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>scale 接收的值是倍数，因此没有单位</p>
</li>
<li><p>scale 是一个值时，宽度高度会等比例同事缩放</p>
</li>
<li><p>scale 缩放时内部内容也会缩放</p>
</li>
<li><blockquote>
<p>可以通过 transition-origin 设定缩放原点 （可以是数值或方位词 top、left…)</p>
</blockquote>
</li>
</ul>
<h3 id="translate-平移"><a href="#translate-平移" class="headerlink" title="translate 平移"></a>translate 平移</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(100<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateY</span>(100<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(100<span class="selector-tag">px</span>, 100<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(50%, 50%);</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>translate 的值可以是 px，也可以是百分比，如果是百分比，那么参照的是<strong>自身的宽高</strong></li>
<li>translate 移动的元素并不会影响其他盒子，类似于相对定位</li>
</ul>
<h3 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(360<span class="selector-tag">deg</span>); <span class="comment">/* 旋转360度 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-360deg</span>); <span class="comment">/* 逆时针旋转360度 */</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>单位是 deg，角度，不是 px</li>
<li>正值顺时针转，负值逆时针转</li>
<li>可以通过 transition-origin 设定旋转原点</li>
</ul>
<blockquote>
<p>rotate 旋转会让坐标轴也跟着旋转</p>
</blockquote>
<h3 id="skew-斜切-变形"><a href="#skew-斜切-变形" class="headerlink" title="skew 斜切(变形)"></a>skew 斜切(变形)</h3><p>skew 在实际开发中，是用的最少的一个属性。一般来说，x 和 y 只会倾斜其中的一个</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在水平方向倾斜30deg */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skewX</span>(30<span class="selector-tag">deg</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在垂直方向倾斜30deg */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skewY</span>(30<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure>
<p>【案例：扫光效果.html】</p>
<h3 id="transform-origin-转换原点"><a href="#transform-origin-转换原点" class="headerlink" title="transform-origin 转换原点"></a>transform-origin 转换原点</h3><blockquote>
<p>通过 transform-origin 可以设置转换的中心原点</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform-origin</span>: <span class="selector-tag">center</span> <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">transform-origin</span>: 40<span class="selector-tag">px</span> 40<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<h3 id="转换合写问题"><a href="#转换合写问题" class="headerlink" title="转换合写问题"></a>转换合写问题</h3><blockquote>
<p>transform 属性只能写一个，如果写了多个会覆盖，属性的值可以写多个， 用空格隔开即可</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(800<span class="selector-tag">px</span>) <span class="selector-tag">scale</span>(1.5) <span class="selector-tag">rotate</span>(360<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>transform 属性可以连写，但是顺序对效果影响的，因为它会在第一个效果的基础上执行第二个效果，然后执行第三个效果（通常会把 rotate 放后面）</li>
<li>如果对 transform 进行过度效果的时候，初始状态和结束状态要一一对应</li>
</ul>
<p>【案例：盾牌打散与合并效果.html】</p>
<h2 id="3D-转换"><a href="#3D-转换" class="headerlink" title="3D 转换"></a>3D 转换</h2><p>思考：2D 与 3D 的区别？</p>
<h3 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h3><blockquote>
<p>用 X、Y、Z 分别表示空间的 3 个维度，三条轴互相垂直。<strong>注意+Y 是向下的</strong></p>
</blockquote>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102204311.png"></p>
<h3 id="perspective-透视"><a href="#perspective-透视" class="headerlink" title="perspective 透视"></a>perspective 透视</h3><blockquote>
<p>电脑显示屏是一个 2D 的平面，因为我们看不出来旋转的方向，通过 perspective 属性，可以定义 3D 元素距视图的距离，单位是 px。</p>
<p>说白了，设置了 perspective 属性后，就有了进大远小的效果了，在视觉上，让我们能看出来 3d 的效果。</p>
<p>注意：当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">perspective</span>：500<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p>对于我们眼睛来说，离我们越近的房子，我们会感觉到这个房子越大，离我们越远的房子，就会感觉越小，其实房子的大小都是一样的，只是在视觉上的一种不同。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102204343.png"></p>
<h3 id="rotate-旋转-1"><a href="#rotate-旋转-1" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素在平面2D中旋转，相当于沿着Z轴旋转 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateX</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素沿着X轴转45度 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateY</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素沿着Y轴转45度 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateZ</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素沿着Z轴转45度 */</span></span><br></pre></td></tr></table></figure>
<p>【3D 旋转.html】</p>
<h3 id="translate-平移-1"><a href="#translate-平移-1" class="headerlink" title="translate 平移"></a>translate 平移</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 沿着X轴的正方向移动45px */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(45<span class="selector-tag">px</span>);</span><br><span class="line"><span class="comment">/* 沿着Y轴的正方向移动45px */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateY</span>(45<span class="selector-tag">px</span>);</span><br><span class="line"><span class="comment">/* 沿着Z轴的正方向移动45px */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateZ</span>(45<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure>
<p>【3D 平移.html】</p>
<p>【立方体.html】</p>
<h3 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h3><p>transform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。注意这个属性只能给父元素添加</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flat</span>: 默认值，2<span class="selector-tag">d</span>显示</span><br><span class="line"><span class="selector-tag">preserve-3d</span>: 3<span class="selector-tag">d</span>显示</span><br></pre></td></tr></table></figure>
<p>transform-style 与 perspective 区别</p>
<ul>
<li>透视：透视只是相当于设置了一个距离，辅助我们查看 3D 效果的工具</li>
<li>preserve-3d：给父盒子添加，让子元素保留 3D 的位置，说白了，只有设置了 preserve-3d，这个元素才能被称之为 3d 元素</li>
<li>一个 3d 元素可以没有 perspective，但是不能没有 transform-style</li>
</ul>
<p>【3D 导航案例.html】</p>
<p>【切割轮播图案例】</p>
<p>【3D 相册案例】</p>
<h3 id="过渡结束事件"><a href="#过渡结束事件" class="headerlink" title="过渡结束事件"></a>过渡结束事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给最后一个ul添加过渡结束事件（节流阀）</span></span><br><span class="line">uls[uls.length - <span class="number">1</span>].addEventListener(<span class="string">&#x27;transitionend&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  isCanAnimate = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><blockquote>
<p>动画可以通过设置多个节点来精确控制一个或者一组动画，常用来实现复杂的动画效果</p>
</blockquote>
<p>动画与过渡的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">过渡必须触发，需要两个状态的改变。</span><br><span class="line">动画可以一直运行下去，不需要触发。实现效果与过渡差不多</span><br></pre></td></tr></table></figure>
<p>使用一个动画的基本步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.通过 @keyframes 指定动画序列</span><br><span class="line">2.通过百分比或者 from&#x2F;to 将动画分割成多个节点</span><br><span class="line">3.在各个节点中分别定义样式</span><br><span class="line">4.通过 animation 将动画应用于相应的元素</span><br></pre></td></tr></table></figure>
<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>animation 是一个复合属性，一共有 8 个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animation-name: 动画名称，由@keyframes定义的</span><br><span class="line">animation-duration: 动画的持续时间 默认0s</span><br><span class="line">animation-timing-function: 动画的过渡类型 ease(默认) linear steps</span><br><span class="line">animation-delay: 动画的延迟时间 默认0s</span><br><span class="line">animation-iteration-count: 动画的循环次数 默认1次  infinite：无限循环</span><br><span class="line">animation-direction: 设置动画在循环中的方向 normal：正向(默认) reverse(反向) alternate(往复循环)</span><br><span class="line">animation-fill-mode: 设置动画结束时的状态 none：默认 backwards：动画结束时停留在开始状态 forwards: 动画结束时停留在结束的状态</span><br><span class="line">animation-play-state: 设置动画的状态。running：运动(默认) paused：暂停</span><br></pre></td></tr></table></figure>
<h3 id="动画库的使用"><a href="#动画库的使用" class="headerlink" title="动画库的使用"></a>动画库的使用</h3><p><a target="_blank" rel="noopener" href="https://daneden.github.io/animate.css/">https://daneden.github.io/animate.css/</a></p>
<h2 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h2><p>我们经常把网页常用的一些小的图标，做成精灵图，然后通过 background-position 去调整位置，但是这个需要引入图片，并且图片大小改变之后会失真。在 CSS3 中可以使用字体图片，即使用图标跟使用文字一样</p>
<p>优点：</p>
<p>1、将所有图标打包成字体库，减少请求</p>
<p>2、具有矢量性，可保证清晰度，可以修改文字的颜色或者样式</p>
<p>3、使用灵活，便于维护</p>
<p>阿里巴巴矢量图标：<a target="_blank" rel="noopener" href="http://www.iconfont.cn/">http://www.iconfont.cn/</a></p>
<p>Font Awesome 使用 <a target="_blank" rel="noopener" href="http://fontawesome.dashgame.com/">http://fontawesome.dashgame.com/</a></p>
<h2 id="弹性布局-伸缩布局"><a href="#弹性布局-伸缩布局" class="headerlink" title="弹性布局(伸缩布局)"></a>弹性布局(伸缩布局)</h2><blockquote>
<p>布局：其实就是调整元素在水平和垂直方向上的布局方式</p>
</blockquote>
<p>CSS3 在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。</p>
<p>当给一个盒子设置了 display：flex 之后，这个盒子就有了 <strong>主轴</strong> 和 <strong>侧轴</strong> 的概念<br>主轴：默认是水平方向向右，子元素在主轴上排列<br>侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向向下</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102204407.png"></p>
<h3 id="给容器设置的样式"><a href="#给容器设置的样式" class="headerlink" title="给容器设置的样式"></a>给容器设置的样式</h3><ul>
<li>flex-direction</li>
</ul>
<p>用来调整主轴的方向，默认是水平方向，可选值有：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">row</span>：主轴方向为水平向右（默认）</span><br><span class="line"><span class="selector-tag">column</span>：主轴方向为竖直向下</span><br><span class="line"><span class="selector-tag">row-reverse</span>: 主轴方向为水平向左</span><br><span class="line"><span class="selector-tag">column-reverse</span>: 主轴方向是竖直向上</span><br></pre></td></tr></table></figure>
<ul>
<li>justify-content</li>
</ul>
<p>用来设置子元素在 <strong>主轴方向的对齐方式</strong> ，可选的值有：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-start</span>: 弹性盒子元素将向起始位置对齐</span><br><span class="line"><span class="selector-tag">flex-end</span>: 弹性盒子元素将向结束位置对齐</span><br><span class="line"><span class="selector-tag">center</span>: 弹性盒子元素将向行中间位置对齐</span><br><span class="line"><span class="selector-tag">space-between</span>: 第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的</span><br><span class="line"><span class="selector-tag">space-around</span>: 弹性盒子元素会平均地分布在行里（不会贴边）</span><br></pre></td></tr></table></figure>
<ul>
<li>align-items</li>
</ul>
<p>用于调整 <strong>侧轴的对其方式</strong> ，可选的值有：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-start</span>：元素在侧轴的起始位置对其</span><br><span class="line"><span class="selector-tag">flex-end</span>：元素在侧轴的结束位置对其</span><br><span class="line"><span class="selector-tag">center</span>：元素在侧轴上居中对其</span><br><span class="line"><span class="selector-tag">stretch</span>：元素的高度会被拉伸到最大（不能给死高度）</span><br></pre></td></tr></table></figure>
<ul>
<li>flex-wrap</li>
</ul>
<p>控制 flex 容器是单行或者多行，默认不换行</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nowrap</span>：不换行（默认），会压缩子盒子的宽度</span><br><span class="line"><span class="selector-tag">wrap</span>：当宽度不够的时候，会换行</span><br></pre></td></tr></table></figure>
<ul>
<li>align-content</li>
</ul>
<p>用来设置多行时侧轴的排列方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-start</span>：各行向侧轴的起始位置堆叠</span><br><span class="line"><span class="selector-tag">flex-end</span>：各行向弹性盒容器的结束位置堆叠</span><br><span class="line"><span class="selector-tag">center</span>：各行向弹性盒容器的中间位置堆叠</span><br><span class="line"><span class="selector-tag">space-between</span>：第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布</span><br><span class="line"><span class="selector-tag">space-around</span>：各行在侧轴中平均分布</span><br><span class="line"><span class="selector-tag">stretch</span>：拉伸，不设置高度的情况下</span><br></pre></td></tr></table></figure>
<p>align-items 与 align-content 的区别</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">align-items</span>调整的是侧轴的对其方式，不换行一般用<span class="selector-tag">align-itemsalign-content</span>: 必须是多行才生效，如果单行，没有效果。换行了就用 <span class="selector-tag">align-content</span>;</span><br></pre></td></tr></table></figure>
<p>!&gt; 上述属性都是给父盒子设置的，这些样式影响的是所有的子元素，接下来的几个属性是给子盒子设置的，用来单独设置子元素的样式</p>
<h3 id="给子元素设置的样式"><a href="#给子元素设置的样式" class="headerlink" title="给子元素设置的样式"></a>给子元素设置的样式</h3><ul>
<li>flex</li>
</ul>
<p>用来设置子盒子如何分配主轴剩余空间</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: 1;</span><br></pre></td></tr></table></figure>
<ul>
<li>order</li>
</ul>
<p>定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">order</span>: 1;</span><br></pre></td></tr></table></figure>
<ul>
<li>align-self</li>
</ul>
<p>align-self 用于设置当前元素在侧轴的位置，是给子元素设置，优先级比 align-items 的优先级高</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">取值与 <span class="selector-tag">align-items</span> 的取值一样</span><br></pre></td></tr></table></figure>
<p>阮一峰的博客<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
<p>【案例：6 面神骰】</p>
<p>【案例：携程网】</p>
<p>【案例：360 浏览器】</p>
<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><p>微调元素</p>
<ul>
<li>margin-top: - ;</li>
<li>transform: translateY();</li>
<li>position: relative; top: - ;</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/416.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/416.html" class="post-title-link" itemprop="url">编码规范及配置 ESLint</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-15 22:25:23" itemprop="dateCreated datePublished" datetime="2018-11-15T22:25:23+00:00">2018-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/airbnb/javascript">Airbnb JavaScript Style Guide</a></p>
<p><a target="_blank" rel="noopener" href="https://google.github.io/styleguide/jsguide">Google JavaScript Style Guide</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/standard/standard">JavaScript Standard Style Guide</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://cn.eslint.org/">ESLint</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20298345/answer/49551142">JavaScript 语句后应该加分号么？</a></p>
<h2 id="Vue-ESLint-Prettier"><a href="#Vue-ESLint-Prettier" class="headerlink" title="Vue + ESLint + Prettier"></a><code>Vue + ESLint + Prettier</code></h2><p>[vue 官方风格指南(<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/style-guide/)]">https://cn.vuejs.org/v2/style-guide/)]</a></p>
<h3 id="安装-node"><a href="#安装-node" class="headerlink" title="安装 node"></a>安装 <code>node</code></h3><p><a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p>
<h3 id="配置-ESlint"><a href="#配置-ESlint" class="headerlink" title="配置 ESlint"></a>配置 <code>ESlint</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install eslint -g</span><br><span class="line">$ npm install eslint-plugin-html -g</span><br><span class="line"></span><br><span class="line">$ eslint -v</span><br><span class="line">$ eslint --init</span><br><span class="line"></span><br><span class="line"><span class="comment"># google 标准</span></span><br><span class="line"><span class="comment"># $ npm install eslint-config-google -g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># airbnb 标准</span></span><br><span class="line"><span class="comment"># $ npm install eslint-config-airbnb eslint-plugin-jsx-a11y eslint-plugin-import eslint-plugin-react -g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># standard 标准</span></span><br><span class="line">$ npm install eslint-plugin-standard eslint-config-standard eslint-plugin-node eslint-plugin-promise -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># vue</span></span><br><span class="line">$ npm install eslint-plugin-vue -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># es6 语法支持</span></span><br><span class="line">$ npm install babel-eslint vue-eslint-parser -g</span><br></pre></td></tr></table></figure>
<p><code>.eslintrc.json</code> 文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// plugin与extend的区别：extend提供的是eslint现有规则的一系列预设</span></span><br><span class="line">  <span class="comment">// 而plugin则提供了除预设之外的自定义规则，当你在eslint的规则里找不到合适的的时候</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span>: [<span class="string">&quot;google&quot;</span>, <span class="string">&quot;plugin: vue/essential&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [<span class="string">&quot;html&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;valid-jsdoc&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;require-jsdoc&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;no-var&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;vars-on-top&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;eqeqeq&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;space-before-function-paren&quot;</span>: [<span class="number">2</span>, <span class="string">&quot;always&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;semi&quot;</span>: [<span class="number">2</span>, <span class="string">&quot;never&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;comma-dangle&quot;</span>: [<span class="number">2</span>, <span class="string">&quot;never&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;linebreak-style&quot;</span>: [<span class="number">2</span>, <span class="string">&quot;unix&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;no-invalid-this&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;max-len&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;prefer-const&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;arrow-parens&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;extends&quot;</span>: [<span class="string">&quot;standard&quot;</span>, <span class="string">&quot;plugin:vue/essential&quot;</span>],</span><br><span class="line">  <span class="comment">// &quot;extends&quot;: [&quot;standard&quot;, &quot;plugin:vue/recommended&quot;],</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [<span class="string">&quot;html&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;parser&quot;</span>: <span class="string">&quot;vue-eslint-parser&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;parser&quot;</span>: <span class="string">&quot;babel-eslint&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ecmaVersion&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;env&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;browser&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;node&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;no-new&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;no-undef&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;no-unused-vars&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;space-before-function-paren&quot;</span>: [<span class="number">2</span>, <span class="string">&quot;always&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;eqeqeq&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;handle-callback-err&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;no-useless-escape&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;new-cap&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;vue/name-property-casing&quot;</span>: <span class="number">0</span> <span class="comment">// vue</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vscode 插件安装 <code>ESLint</code></p>
<p>vscode 配置 <code>User Settings</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;javascript.validate.enable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;typescript.validate.enable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;eslint.nodePath&quot;</span>: <span class="string">&quot;C:\\Program Files\\nodejs\\node.exe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;eslint.options&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;configFile&quot;</span>: <span class="string">&quot;C:/Users/C/.vscode/.eslintrc.json&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;eslint.alwaysShowStatus&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;eslint.autoFixOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;eslint.validate&quot;</span>: [<span class="string">&quot;javascript&quot;</span>, <span class="string">&quot;javascriptreact&quot;</span>, &#123; <span class="attr">&quot;language&quot;</span>: <span class="string">&quot;html&quot;</span>, <span class="attr">&quot;autoFix&quot;</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">&quot;language&quot;</span>: <span class="string">&quot;vue&quot;</span>, <span class="attr">&quot;autoFix&quot;</span>: <span class="literal">true</span> &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置-prettier"><a href="#配置-prettier" class="headerlink" title="配置 prettier"></a>配置 prettier</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install prettier -g</span><br><span class="line">$ npm install eslint-plugin-prettier -g</span><br></pre></td></tr></table></figure>
<p>vscode 插件安装 <code>prettier</code></p>
<p>vscode 配置 <code>User Settings</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 禁用默认html格式化</span></span><br><span class="line">  <span class="attr">&quot;html.format.enable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;prettier.semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;prettier.jsxSingleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;prettier.eslintIntegration&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;prettier.htmlWhitespaceSensitivity&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line">  <span class="comment">// 标签换行长度</span></span><br><span class="line">  <span class="attr">&quot;prettier.printWidth&quot;</span>: <span class="number">800</span>,</span><br><span class="line">  <span class="attr">&quot;prettier.bracketSpacing&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vuter</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;vetur.format.defaultFormatter.js&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">  <span class="comment">// HTML Default Formatter</span></span><br><span class="line">  <span class="attr">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="string">&quot;prettyhtml&quot;</span></span><br><span class="line">  <span class="string">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;prettyhtml&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;printWidth&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">      <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;wrapAttributes&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;sortAttributes&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置-eslint-校验-typescript"><a href="#配置-eslint-校验-typescript" class="headerlink" title="配置 eslint 校验 typescript"></a>配置 eslint 校验 typescript</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-config-alloy -g</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/AlloyTeam/eslint-config-alloy/">https://github.com/AlloyTeam/eslint-config-alloy/</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;extends&quot;</span>: [<span class="string">&quot;standard&quot;</span>, <span class="string">&quot;alloy&quot;</span>, <span class="string">&quot;alloy/typescript&quot;</span>, <span class="string">&quot;plugin:vue/essential&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [<span class="string">&quot;html&quot;</span>, <span class="string">&quot;typescript&quot;</span>],</span><br><span class="line">  <span class="comment">// &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,</span></span><br><span class="line">  <span class="attr">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;parser&quot;</span>: <span class="string">&quot;@typescript-eslint/parser&quot;</span>,</span><br><span class="line">    <span class="comment">// &quot;parser&quot;: &quot;babel-eslint&quot;,</span></span><br><span class="line">    <span class="attr">&quot;ecmaVersion&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;env&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;browser&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;node&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;commonjs&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;no-new&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;no-undef&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;no-unused-vars&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;no-var&quot;</span>: [<span class="number">0</span>, <span class="string">&quot;always&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;space-before-function-paren&quot;</span>: [<span class="number">2</span>, <span class="string">&quot;always&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;typescript/class-name-casing&quot;</span>: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ESLint-规则列表"><a href="#ESLint-规则列表" class="headerlink" title="ESLint 规则列表"></a>ESLint 规则列表</h2><p><code>.eslintrc.json</code> 规则值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;off&quot;或者0    &#x2F;&#x2F; 关闭规则关闭</span><br><span class="line">&quot;warn&quot;或者1   &#x2F;&#x2F; 在打开的规则作为警告（不影响退出代码）</span><br><span class="line">&quot;error&quot;或者2  &#x2F;&#x2F; 把规则作为一个错误（退出代码触发时为1</span><br></pre></td></tr></table></figure>
<p>忽略检测警告</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 忽略检测下一行</span></span><br><span class="line"><span class="comment">/* eslint-disable-next-line */</span></span><br><span class="line"><span class="comment">// 忽略当前整个文件</span></span><br><span class="line"><span class="comment">/* eslint-disable */</span></span><br><span class="line"><span class="comment">// 忽略 no-new 规则</span></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://eslint.org/docs/rules/">规则列表 https://eslint.org/docs/rules/</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;rules&quot;: &#123;</span><br><span class="line">  &quot;no-alert&quot;: 0,//禁止使用alert confirm prompt</span><br><span class="line">  &quot;no-array-constructor&quot;: 2,//禁止使用数组构造器</span><br><span class="line">  &quot;no-bitwise&quot;: 0,//禁止使用按位运算符</span><br><span class="line">  &quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee</span><br><span class="line">  &quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名</span><br><span class="line">  &quot;no-class-assign&quot;: 2,//禁止给类赋值</span><br><span class="line">  &quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句</span><br><span class="line">  &quot;no-console&quot;: 2,//禁止使用console</span><br><span class="line">  &quot;no-const-assign&quot;: 2,//禁止修改const声明的变量</span><br><span class="line">  &quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1)</span><br><span class="line">  &quot;no-continue&quot;: 0,//禁止使用continue</span><br><span class="line">  &quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符</span><br><span class="line">  &quot;no-debugger&quot;: 2,//禁止使用debugger</span><br><span class="line">  &quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符</span><br><span class="line">  &quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/</span><br><span class="line">  &quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;</span><br><span class="line">  &quot;no-dupe-args&quot;: 2,//函数参数不能重复</span><br><span class="line">  &quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复</span><br><span class="line">  &quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句</span><br><span class="line">  &quot;no-empty&quot;: 2,//块语句中的内容不能为空</span><br><span class="line">  &quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空</span><br><span class="line">  &quot;no-empty-label&quot;: 2,//禁止使用空label</span><br><span class="line">  &quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符</span><br><span class="line">  &quot;no-eval&quot;: 1,//禁止使用eval</span><br><span class="line">  &quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值</span><br><span class="line">  &quot;no-extend-native&quot;: 2,//禁止扩展native对象</span><br><span class="line">  &quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定</span><br><span class="line">  &quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换</span><br><span class="line">  &quot;no-extra-parens&quot;: 2,//禁止非必要的括号</span><br><span class="line">  &quot;no-extra-semi&quot;: 2,//禁止多余的冒号</span><br><span class="line">  &quot;no-fallthrough&quot;: 1,//禁止switch穿透</span><br><span class="line">  &quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3.</span><br><span class="line">  &quot;no-func-assign&quot;: 2,//禁止重复的函数声明</span><br><span class="line">  &quot;no-implicit-coercion&quot;: 1,//禁止隐式转换</span><br><span class="line">  &quot;no-implied-eval&quot;: 2,//禁止使用隐式eval</span><br><span class="line">  &quot;no-inline-comments&quot;: 0,//禁止行内备注</span><br><span class="line">  &quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数）</span><br><span class="line">  &quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式</span><br><span class="line">  &quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量</span><br><span class="line">  &quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格</span><br><span class="line">  &quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性</span><br><span class="line">  &quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同</span><br><span class="line">  &quot;no-labels&quot;: 2,//禁止标签声明</span><br><span class="line">  &quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块</span><br><span class="line">  &quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句</span><br><span class="line">  &quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）</span><br><span class="line">  &quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型</span><br><span class="line">  &quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格</span><br><span class="line">  &quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格</span><br><span class="line">  &quot;no-multi-spaces&quot;: 1,//不能用多余的空格</span><br><span class="line">  &quot;no-multi-str&quot;: 2,//字符串不能用\换行</span><br><span class="line">  &quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行</span><br><span class="line">  &quot;no-native-reassign&quot;: 2,//不能重写native对象</span><br><span class="line">  &quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有!</span><br><span class="line">  &quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算</span><br><span class="line">  &quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值</span><br><span class="line">  &quot;no-new-func&quot;: 1,//禁止使用new Function</span><br><span class="line">  &quot;no-new-object&quot;: 2,//禁止使用new Object()</span><br><span class="line">  &quot;no-new-require&quot;: 2,//禁止使用new require</span><br><span class="line">  &quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number</span><br><span class="line">  &quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON()</span><br><span class="line">  &quot;no-octal&quot;: 2,//禁止使用八进制数字</span><br><span class="line">  &quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列</span><br><span class="line">  &quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值</span><br><span class="line">  &quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接</span><br><span class="line">  &quot;no-plusplus&quot;: 0,//禁止使用++，--</span><br><span class="line">  &quot;no-process-env&quot;: 0,//禁止使用process.env</span><br><span class="line">  &quot;no-process-exit&quot;: 0,//禁止使用process.exit()</span><br><span class="line">  &quot;no-proto&quot;: 2,//禁止使用__proto__属性</span><br><span class="line">  &quot;no-redeclare&quot;: 2,//禁止重复声明变量</span><br><span class="line">  &quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/</span><br><span class="line">  &quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错</span><br><span class="line">  &quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式</span><br><span class="line">  &quot;no-script-url&quot;: 0,//禁止使用javascript:void(0)</span><br><span class="line">  &quot;no-self-compare&quot;: 2,//不能比较自身</span><br><span class="line">  &quot;no-sequences&quot;: 0,//禁止使用逗号运算符</span><br><span class="line">  &quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名</span><br><span class="line">  &quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用</span><br><span class="line">  &quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格</span><br><span class="line">  &quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2]</span><br><span class="line">  &quot;no-sync&quot;: 0,//nodejs 禁止同步方法</span><br><span class="line">  &quot;no-ternary&quot;: 0,//禁止使用三目运算符</span><br><span class="line">  &quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格</span><br><span class="line">  &quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super</span><br><span class="line">  &quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;;</span><br><span class="line">  &quot;no-undef&quot;: 1,//不能有未定义的变量</span><br><span class="line">  &quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined</span><br><span class="line">  &quot;no-undefined&quot;: 2,//不能使用undefined</span><br><span class="line">  &quot;no-unexpected-multiline&quot;: 2,//避免多行表达式</span><br><span class="line">  &quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾</span><br><span class="line">  &quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;</span><br><span class="line">  &quot;no-unreachable&quot;: 2,//不能有无法执行的代码</span><br><span class="line">  &quot;no-unused-expressions&quot;: 2,//禁止无用的表达式</span><br><span class="line">  &quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数</span><br><span class="line">  &quot;no-use-before-define&quot;: 2,//未定义前不能使用</span><br><span class="line">  &quot;no-useless-call&quot;: 2,//禁止不必要的call和apply</span><br><span class="line">  &quot;no-void&quot;: 2,//禁用void操作符</span><br><span class="line">  &quot;no-var&quot;: 0,//禁用var，用let和const代替</span><br><span class="line">  &quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注</span><br><span class="line">  &quot;no-with&quot;: 2,//禁用with</span><br><span class="line">  &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格</span><br><span class="line">  &quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来</span><br><span class="line">  &quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号</span><br><span class="line">  &quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter</span><br><span class="line">  &quot;block-scoped-var&quot;: 0,//块语句中使用var</span><br><span class="line">  &quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格</span><br><span class="line">  &quot;callback-return&quot;: 1,//避免多次调用回调什么的</span><br><span class="line">  &quot;camelcase&quot;: 2,//强制驼峰法命名</span><br><span class="line">  &quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号</span><br><span class="line">  &quot;comma-spacing&quot;: 0,//逗号前后的空格</span><br><span class="line">  &quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾</span><br><span class="line">  &quot;complexity&quot;: [0, 11],//循环复杂度</span><br><span class="line">  &quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的</span><br><span class="line">  &quot;consistent-return&quot;: 0,//return 后面是否允许省略</span><br><span class="line">  &quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名</span><br><span class="line">  &quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super</span><br><span class="line">  &quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125;</span><br><span class="line">  &quot;default-case&quot;: 2,//switch语句最后必须有default</span><br><span class="line">  &quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾</span><br><span class="line">  &quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号</span><br><span class="line">  &quot;eol-last&quot;: 0,//文件以单一的换行符结束</span><br><span class="line">  &quot;eqeqeq&quot;: 2,//必须使用全等</span><br><span class="line">  &quot;func-names&quot;: 0,//函数表达式必须有名字</span><br><span class="line">  &quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式</span><br><span class="line">  &quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格</span><br><span class="line">  &quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤</span><br><span class="line">  &quot;handle-callback-err&quot;: 0,//nodejs 处理错误</span><br><span class="line">  &quot;id-length&quot;: 0,//变量名长度</span><br><span class="line">  &quot;indent&quot;: [2, 4],//缩进风格</span><br><span class="line">  &quot;init-declarations&quot;: 0,//声明时必须赋初值</span><br><span class="line">  &quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格</span><br><span class="line">  &quot;lines-around-comment&quot;: 0,//行前/行后备注</span><br><span class="line">  &quot;max-depth&quot;: [0, 4],//嵌套块深度</span><br><span class="line">  &quot;max-len&quot;: [0, 80, 4],//字符串最大长度</span><br><span class="line">  &quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度</span><br><span class="line">  &quot;max-params&quot;: [0, 3],//函数最多只能有3个参数</span><br><span class="line">  &quot;max-statements&quot;: [0, 10],//函数内最多有几个声明</span><br><span class="line">  &quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用</span><br><span class="line">  &quot;new-parens&quot;: 2,//new时必须加小括号</span><br><span class="line">  &quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行</span><br><span class="line">  &quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格</span><br><span class="line">  &quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法</span><br><span class="line">  &quot;one-var&quot;: 1,//连续声明</span><br><span class="line">  &quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的</span><br><span class="line">  &quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首</span><br><span class="line">  &quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行</span><br><span class="line">  &quot;prefer-const&quot;: 0,//首选const</span><br><span class="line">  &quot;prefer-spread&quot;: 0,//首选展开运算</span><br><span class="line">  &quot;prefer-reflect&quot;: 0,//首选Reflect的方法</span><br><span class="line">  &quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &#x27;&#x27;</span><br><span class="line">  &quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号</span><br><span class="line">  &quot;radix&quot;: 2,//parseInt必须指定第二个参数</span><br><span class="line">  &quot;id-match&quot;: 0,//命名检测</span><br><span class="line">  &quot;require-yield&quot;: 0,//生成器函数必须有yield</span><br><span class="line">  &quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾</span><br><span class="line">  &quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格</span><br><span class="line">  &quot;sort-vars&quot;: 0,//变量声明时排序</span><br><span class="line">  &quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格</span><br><span class="line">  &quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格</span><br><span class="line">  &quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格</span><br><span class="line">  &quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格</span><br><span class="line">  &quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格</span><br><span class="line">  &quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格</span><br><span class="line">  &quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格</span><br><span class="line">  &quot;spaced-comment&quot;: 0,//注释风格要不要有空格什么的</span><br><span class="line">  &quot;strict&quot;: 2,//使用严格模式</span><br><span class="line">  &quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN()</span><br><span class="line">  &quot;valid-jsdoc&quot;: 0,//jsdoc规则</span><br><span class="line">  &quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值</span><br><span class="line">  &quot;vars-on-top&quot;: 2,//var必须放在作用域顶部</span><br><span class="line">  &quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格</span><br><span class="line">  &quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来</span><br><span class="line">  &quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/396.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/396.html" class="post-title-link" itemprop="url">遍历总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-04 22:11:35" itemprop="dateCreated datePublished" datetime="2018-11-04T22:11:35+00:00">2018-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原生-js-中-for-语句"><a href="#原生-js-中-for-语句" class="headerlink" title="原生 js 中 for 语句"></a>原生 js 中 for 语句</h1><blockquote>
<p>循环 、遍历数组</p>
</blockquote>
<p><span class='red'>可使用 continue 跳出当前循环， break 跳出整个循环</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="comment">// 1. for循环使用分号分隔</span></span><br><span class="line"><span class="comment">// 2. for循环有2个分号，两个分号不能少</span></span><br><span class="line"><span class="keyword">for</span> (初始化语句; 判断语句; 自增语句) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历函数的参数(arguments)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="原生-js-中数组的-forEach-方法"><a href="#原生-js-中数组的-forEach-方法" class="headerlink" title="原生 js 中数组的 forEach 方法"></a>原生 js 中数组的 forEach 方法</h1><blockquote>
<p>遍历数组</p>
</blockquote>
<p><span class="red">不能用 break continue 语句跳出整个循环</span><br><span class="red">可使用 return 语句跳出当前循环</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="comment">// array.forEach (function(item, index, arr), thisArg)</span></span><br><span class="line"><span class="comment">// item 必需。数组中正在处理的当前元素</span></span><br><span class="line"><span class="comment">// index 可选。数组中正在处理的当前元素的索引</span></span><br><span class="line"><span class="comment">// arr 可选。forEach()方法正在操作的数组，就是当前数组</span></span><br><span class="line"><span class="comment">// thisArg 可选。当执行回调函数时用作this的值</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 返回值: undefined</span></span><br><span class="line"><span class="comment">// 不支持 return 操作输出，return 只用于控制循环是否跳出当前循环</span></span><br></pre></td></tr></table></figure>
<h1 id="原生-js-中-for…in-语句"><a href="#原生-js-中-for…in-语句" class="headerlink" title="原生 js 中 for…in 语句"></a>原生 js 中 for…in 语句</h1><blockquote>
<p>遍历对象</p>
</blockquote>
<p>支持 <code>break</code>, <code>continue</code> 跳出循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key) <span class="comment">// 键</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj[key]) <span class="comment">// 值</span></span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27;==&#x27;</span> + obj[key])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in 操作符：判断对象能否访问到该属性（不管这个属性是自己提供的，还是从原型上继承来的），如果可以访问到， 都会返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(&#x27;name&#x27; in obj) 返回布尔值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;是&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 for in 遍历数组，会产生一些问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">a.name = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index) <span class="comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>数组的索引值 index 是 String 类型</li>
<li>会将 expando 属性也遍历出来</li>
<li>在某些情况下，在遍历数组元素时顺序是任意的</li>
</ol>
<p><span class="red">for-in 语法是被设计来遍历普通的“键值对”对象的，不适合用在数组上</span></p>
<h1 id="es6-for…of-方法"><a href="#es6-for…of-方法" class="headerlink" title="es6 for…of 方法"></a>es6 for…of 方法</h1><p>遍历类数组集合(Array, Map, Set, String, Arguments)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持 <code>break</code>, <code>continue</code> 和 <code>throw</code></p>
<h1 id="for…of-与-for…in-的区别"><a href="#for…of-与-for…in-的区别" class="headerlink" title="for…of 与 for…in 的区别"></a>for…of 与 for…in 的区别</h1><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of">参考 MDN</a></p>
<p>无论是 for…in 还是 for…of 语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。</p>
<p>for…in 语句以任意顺序迭代对象的可枚举属性。</p>
<p>for…of 语句遍历可迭代对象定义要迭代的数据。</p>
<h1 id="jquery-中的-each-方法"><a href="#jquery-中的-each-方法" class="headerlink" title="jquery 中的 each 方法"></a>jquery 中的 each 方法</h1><blockquote>
<p>遍历 jQuery 对象集合，为每个匹配的元素执行一个函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：</span></span><br><span class="line">$(selector).each(<span class="function"><span class="keyword">function</span>(<span class="params">index, element</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// index 表示当前元素在所有匹配元素中的索引号</span></span><br><span class="line">  <span class="comment">// element 表示当前元素 dom 对象</span></span><br><span class="line">  <span class="comment">// this 在函数内部，this指向了element</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;li&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index, ele</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $(ele).css(&quot;backgroundColor&quot;, arr[index])</span></span><br><span class="line">  $(<span class="built_in">this</span>).css(<span class="string">&#x27;backgroundColor&#x27;</span>, arr[index])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="php-中-foreach-语句"><a href="#php-中-foreach-语句" class="headerlink" title="php 中 foreach 语句"></a>php 中 foreach 语句</h1><blockquote>
<p>用来遍历数组(关联数组和索引数组均可)。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">  <span class="comment">// $arr: 要遍历的数组</span></span><br><span class="line">  <span class="comment">// $key: 键，可以是任意变量名</span></span><br><span class="line">  <span class="comment">// $value: 值，可以是任意变量名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$value</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历关联数组</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">&quot;name&quot;</span>=&gt;<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>=&gt;<span class="number">18</span>,</span><br><span class="line">  <span class="string">&quot;sex&quot;</span>=&gt;<span class="number">20</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$k</span> . <span class="string">&quot;=&quot;</span> . <span class="variable">$v</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/1646.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1646.html" class="post-title-link" itemprop="url">ajax 笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-03 14:32:32" itemprop="dateCreated datePublished" datetime="2018-11-03T14:32:32+00:00">2018-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们使用 php 动态渲染页面时，有很多比较麻烦的地方。</p>
<ul>
<li>在前端写好页面以后，需要后台进行修改，意味这后端程序员也需要懂前端的知识，其实渲染的工作应该交给前端来做。</li>
<li>前端没有写好页面的话，后端无法开始工作，需要等待前端的页面完成之后才能开始工作，拖延项目的进度。</li>
<li>这种渲染，属于同步渲染，先获取数据, 如果数据获取的慢了, 会严重影响整个页面渲染速度, 且数据更新需要页面刷新</li>
</ul>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><blockquote>
<p>即 Asynchronous [e’sɪŋkrənəs] Javascript And XML， AJAX 不是一门新的语言，而是对现有技术的综合利用。 本质是在 HTTP 协议的基础上以异步的方式与服务器进行通信</p>
</blockquote>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p><strong>同步和异步概念：</strong></p>
<p>同步：指的就是事情要一件一件做。等做完前一件才能做后一件任务</p>
<p>异步：不受当前任务的影响，两件事情同时进行，做一件事情时，不影响另一件事情的进行</p>
<p>编程中：异步程序代码执行时不会阻塞其它程序代码执行，从而提升整体执行效率</p>
<p><strong>网页异步应用：</strong></p>
<ol>
<li>验证你的用户名是否已经存在（一边输入，一边获取你的信息，和后台比对）。</li>
<li>百度搜索提示，及相关内容展示（一边输入，一边找出了你可能要的内容）。</li>
<li>新浪微博评论（异步加载）。</li>
</ol>
<p>XMLHttpRequest 可以以异步方式的请求数据处理程序, 可实现对网页的部分更新， 而不是刷新整个页面</p>
<h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><blockquote>
<p>浏览器内建对象，用于与服务器通信(交换数据) ， 由此我们便可实现对网页的部分更新，而不是刷新整个页面。这个请求是异步的，即在往服务器发送请求时，并不会阻碍程序的运行，浏览器会继续渲染后续的结构。</p>
</blockquote>
<h3 id="发送-get-请求"><a href="#发送-get-请求" class="headerlink" title="发送 get 请求"></a>发送 get 请求</h3><p>XMLHttpRequest 以异步的方式发送 HTTP 请求，因此在发送请求时，一样需要遵循 HTTP 协议。</p>
<p><strong>使用 XMLHttpRequest 发送 get 请求的步骤</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 XMLHttpRequest 对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置请求行</span></span><br><span class="line"><span class="comment">// 第一个参数:请求方式  get/post</span></span><br><span class="line"><span class="comment">// 第二个参数:请求的地址 需要在url后面拼上参数列表</span></span><br><span class="line"><span class="comment">// 第三个参数：true 为异步，false为同步，默认为true，设为false没有意义</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;01.php?name=zs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置请求头(get不用设置)</span></span><br><span class="line"><span class="comment">// 请求头中可以设置 Content-Type,用以说明请求主体的内容是如何编码</span></span><br><span class="line"><span class="comment">// get 请求时没有请求体,无需设置请求头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 设置请求体</span></span><br><span class="line"><span class="comment">// get 请求的请求体为空,因为参数列表拼接到 url 后面了</span></span><br><span class="line">xhr.send(<span class="literal">null</span>) <span class="comment">// 参数为 null 或什么都不写</span></span><br></pre></td></tr></table></figure>
<p>注意点 :</p>
<ul>
<li>get 请求，设置请求行时，需要把参数列表拼接到 url 后面</li>
<li>get 请求不用设置请求头，不用说明请求主体的编码方式</li>
<li>get 请求的请求体为 null</li>
</ul>
<h3 id="发送-post-请求"><a href="#发送-post-请求" class="headerlink" title="发送 post 请求"></a>发送 post 请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 XMLHttpRequest 对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置请求行 post请求的参数列表在请求体</span></span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;02.php&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置请求头, post 请求必须要设置 content-type, 标记请求体内容的解析方式</span></span><br><span class="line"><span class="comment">// 如果不设置请求头,请求能够发送出去，但是后端无法解析获取数据</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 设置请求体</span></span><br><span class="line">xhr.send(<span class="string">&#x27;name=Jepson&amp;age=18&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意点 :</p>
<ul>
<li>post 请求，设置请求行时，不拼接参数列表</li>
<li>post 必须设置请求头中的 content-type 为 <code>application/x-www-form-urlencoded</code>， 标记请求体解析方式</li>
<li>post 请求需要将参数列表设置到请求体中</li>
</ul>
<h3 id="获取响应-readyState"><a href="#获取响应-readyState" class="headerlink" title="获取响应 readyState"></a>获取响应 readyState</h3><p><code>readyState</code>：记录了 XMLHttpRequest 对象的当前状态</p>
<p>readyState 有五种可能的值：</p>
<ul>
<li>xhr.readyState = 0 时，UNSENT open 尚未调用</li>
<li>xhr.readyState = 1 时，OPENED open 已调用</li>
<li>xhr.readyState = 2 时，HEADERS_RECEIVED 接收到头信息</li>
<li>xhr.readyState = 3 时，LOADING 接收到响应主体</li>
<li><code>xhr.readyState = 4</code> 时，DONE 响应完成</li>
</ul>
<p>HTTP 响应分为 3 个部分，状态行、响应头、响应体。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给xhr注册一个 onreadystatechange 事件，当 xhr 的状态发生状态发生改变时，会触发这个事件。</span></span><br><span class="line"><span class="comment">// onreadystatechange 只会监听 2， 3， 4 的状态变化</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xhr.readyState)</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">//1. 获取状态行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;状态行:&#x27;</span> + xhr.status) <span class="comment">// 成功返回 200</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">//2. 获取响应头</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;所有的响应头:&#x27;</span> + xhr.getAllResponseHeaders())</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;指定响应头:&#x27;</span> + xhr.getResponseHeader(<span class="string">&#x27;content-type&#x27;</span>))</span><br><span class="line">      <span class="comment">//3. 获取响应体</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>【判断用户名是否存在】</p>
<p>【用户登录案例】</p>
<p>【聊天机器人案例】</p>
<h2 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h2><blockquote>
<p>浏览器端只是负责用户的交互和数据的收集以及展示，真正的数据都是存储在服务器端的。</p>
<p>我们现在通过 ajax 的确可以返回一些简单的数据（一个字符串），但是在实际开发过程中，肯定会会设计到大量的复杂类型的数据传输，比如数组、对象等，但是每个编程语言的语法都不一样。</p>
<p>因此我们会采用通过的数据交换格式（ <code>XML</code> 、<code>JSON</code> ）来进行数据的交互。</p>
</blockquote>
<h3 id="XML-了解即可"><a href="#XML-了解即可" class="headerlink" title="XML(了解即可)"></a>XML(了解即可)</h3><p><strong>什么是 XML</strong></p>
<ul>
<li>XML 指可扩展标记语言（EXtensible Markup Language）</li>
<li>XML 是一种标记语言，很类似 HTML</li>
<li>XML 的设计宗旨是传输数据，而非显示数据</li>
<li>XML 标签没有被预定义。您需要自行定义标签。</li>
</ul>
<p><strong>语法规范</strong></p>
<ul>
<li>第一行必须是版本信息</li>
<li>必须有一个根元素（有且仅有一个）</li>
<li>标签不可有空格、不可以数字或 . 开头、大小写敏感</li>
<li>不可交叉嵌套，都是双标签，如果是单标签，必须闭合</li>
<li>属性双引号（浏览器自动修正成双引号了）</li>
<li>特殊符号要使用实体</li>
<li>注释和 HTML 一样</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">desc</span>&gt;</span>路人甲<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">desc</span>&gt;</span>路人乙<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>php 获取 xml 文件的内容</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意: 如果需要返回 xml 数据, 需要将 content-type 改成 text/xml, 不然浏览器以 text/html 解析</span></span><br><span class="line">header( <span class="string">&#x27;content-type:text/xml;charset=utf-8&#x27;</span> );</span><br><span class="line"><span class="comment">// file_get_content 用于获取文件的内容</span></span><br><span class="line"><span class="comment">// 参数: 文件的路径</span></span><br><span class="line"><span class="variable">$result</span> = file_get_content( <span class="string">&quot;data.xml&quot;</span> );</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$result</span>;</span><br></pre></td></tr></table></figure>
<p><strong>js 解析 xml</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取服务端返回的 xml 数据，需要使用 xhr.responseXML，这是一个 document 对象，可以使用 DOM 中的方法查找元素。</span></span><br><span class="line"><span class="keyword">var</span> data = xhr.responseXML</span><br><span class="line"><span class="comment">// 获取所有的学生</span></span><br><span class="line"><span class="keyword">var</span> students = data.querySelectorAll(<span class="string">&#x27;student&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>缺点：虽然可以描述和传输复杂数据，但是其解析过于复杂, 并且体积较大，所以实现开发已经很少使用了</p>
<h3 id="JSON-数据"><a href="#JSON-数据" class="headerlink" title="JSON 数据"></a>JSON 数据</h3><p><code>JSON</code> (JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript 规范，采用独立于编程语言的文本格式来存储和表示数据</p>
<ul>
<li>数据在键值对中</li>
<li>数据由逗号分隔(最后一个 键值对不能带逗号)</li>
<li>花括号保存对象，方括号保存数组</li>
<li>键和值使用双引号</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="string">&#x27;Hello&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;World&#x27;</span> &#125; <span class="comment">// 这是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个 JSON 字符串，本质是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>JSON 数据在不同语言进行传输时，类型为字符串，不同的语言各自也都对应有解析方法，解析完成后就能很方便的使用了</strong></p>
<h4 id="php-处理-json"><a href="#php-处理-json" class="headerlink" title="php 处理 json"></a>php 处理 json</h4><ul>
<li>php 关联数组 ==&gt; json ( json_encode )</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// php的关联数组</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">&quot;a&quot;</span> =&gt; <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="string">&quot;b&quot;</span> =&gt; <span class="string">&quot;world&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span> =&gt; <span class="string">&quot;鹏鹏&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// json字符串</span></span><br><span class="line"><span class="variable">$json</span> = json_encode( <span class="variable">$obj</span> );</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$json</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>json ==&gt; php 对象/关联数组 ( json_decode )</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$json</span> = <span class="string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>; <span class="comment">// json字符串</span></span><br><span class="line"><span class="comment">// 第一个参数：json字符串</span></span><br><span class="line"><span class="comment">// 第二个参数：</span></span><br><span class="line"><span class="comment">// false，将json转换成对象(默认)</span></span><br><span class="line"><span class="comment">// true：将json转换成数组(推荐)</span></span><br><span class="line"><span class="variable">$obj</span> = json_decode(<span class="variable">$json</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过json文件获取到的内容就是一个json字符串。</span></span><br><span class="line"><span class="variable">$data</span> = file_get_contents(<span class="string">&quot;data.json&quot;</span>);</span><br><span class="line"><span class="comment">// 将json转换成数组</span></span><br><span class="line"><span class="variable">$result</span> = json_decode(<span class="variable">$data</span>, <span class="literal">true</span>);</span><br><span class="line">print_r(<span class="variable">$result</span>);</span><br></pre></td></tr></table></figure>
<h4 id="JS-处理-json"><a href="#JS-处理-json" class="headerlink" title="JS 处理 json"></a>JS 处理 json</h4><ul>
<li><code>JSON.stringify(obj)</code> ：JS 对象 ==&gt; JSON 字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="string">&#x27;Hello&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">JSON</span>.stringify(obj) <span class="comment">// &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>JSON.parse(obj)</code> ：JSON 字符串 ==&gt; JS 对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(json) <span class="comment">// &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>【案例：获取表格数据.html】</p>
<h2 id="兼容性处理-了解-不用处理"><a href="#兼容性处理-了解-不用处理" class="headerlink" title="兼容性处理 (了解, 不用处理)"></a>兼容性处理 (了解, 不用处理)</h2><p>现在一般最多兼容到 IE8, 这里以后见到了知道是在处理兼容性就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span> (XMLHttpRequest) &#123;</span><br><span class="line">  <span class="comment">//现代浏览器 IE7+</span></span><br><span class="line">  xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：</span></span><br><span class="line">  xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="封装-ajax-工具函数"><a href="#封装-ajax-工具函数" class="headerlink" title="封装 ajax 工具函数"></a>封装 ajax 工具函数</h2><blockquote>
<p>每次发送 ajax 请求，其实步骤都是一样的，重复了大量代码，我们完全可以封装成一个工具函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建xhr对象</span></span><br><span class="line"><span class="comment">//2. 设置请求行</span></span><br><span class="line"><span class="comment">//3. 设置请求头</span></span><br><span class="line"><span class="comment">//3. 设置请求体</span></span><br><span class="line"><span class="comment">//4. 监听响应状态</span></span><br><span class="line"><span class="comment">//5. 获取响应内容</span></span><br></pre></td></tr></table></figure>
<h3 id="参数提取"><a href="#参数提取" class="headerlink" title="参数提取"></a>参数提取</h3><table>
<thead>
<tr>
<th>参数名</th>
<th>参数类型</th>
<th>描述</th>
<th>传值</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>string</td>
<td>请求方式</td>
<td>get/post</td>
<td>只要不传 post，就是 get</td>
</tr>
<tr>
<td>url</td>
<td>string</td>
<td>请求地址</td>
<td>接口地址</td>
<td>如果不传地址，不发送请求</td>
</tr>
<tr>
<td>async</td>
<td>boolean</td>
<td>是否异步</td>
<td>true/fase</td>
<td>只要不传 false，那就是 true，异步请求</td>
</tr>
<tr>
<td>data</td>
<td>object</td>
<td>请求数据</td>
<td><code>&#123;key:value,key1:value2&#125;</code></td>
<td>需要把这个对象拼接成参数的格式 uname=hucc&amp;upass=12345</td>
</tr>
<tr>
<td>dataType</td>
<td>string</td>
<td>返回的数据类型</td>
<td>xml/json/text</td>
<td>text</td>
</tr>
<tr>
<td>success</td>
<td>function</td>
<td>响应成功时调用</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>error</td>
<td>function</td>
<td>响应失败时调用</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h3 id="参数检测"><a href="#参数检测" class="headerlink" title="参数检测"></a>参数检测</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求参数obj必须传递，否则直接不发送请求</span></span><br><span class="line"><span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果type传递的是post，那就发送post请求，否则发送get请求</span></span><br><span class="line"><span class="keyword">var</span> type = obj.type == <span class="string">&#x27;post&#x27;</span> ? <span class="string">&#x27;post&#x27;</span> : <span class="string">&#x27;get&#x27;</span></span><br><span class="line"><span class="keyword">var</span> url = obj.url</span><br><span class="line"><span class="keyword">if</span> (!url) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有当async传递了false，才会发送同步请求，不然只发送异步请求</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = obj.async == <span class="literal">false</span> ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="完整版本"><a href="#完整版本" class="headerlink" title="完整版本"></a>完整版本</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = &#123;</span><br><span class="line">  ajax: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果options参数没有传递，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (!options || <span class="keyword">typeof</span> options !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理默认参数</span></span><br><span class="line">    <span class="comment">// 如果参数不是post，那就默认为get</span></span><br><span class="line">    <span class="keyword">var</span> type = options.type === <span class="string">&#x27;post&#x27;</span> ? <span class="string">&#x27;post&#x27;</span> : <span class="string">&#x27;get&#x27;</span></span><br><span class="line">    <span class="comment">// 如果没有传url，直接返回</span></span><br><span class="line">    <span class="keyword">var</span> url = option.url</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果参数不是 false，那就默认是 true，发异步请求</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">async</span> = options.async == <span class="literal">false</span> ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 把 option.data 对象中的数据拼接成键值对的字符串</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">this</span>.getData(options.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求行</span></span><br><span class="line">    <span class="comment">// 如果是get请求，并且要上传参数，需要把参数拼接到url后面</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">      url += <span class="string">&#x27;?&#x27;</span> + data</span><br><span class="line">      data = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.open(type, url, <span class="keyword">async</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">      xhr.setRequestHeader(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置请求参数</span></span><br><span class="line">    xhr.send(data)</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="comment">//判断一下,如果dataType的值是json,就转成js对象.如果是xml,就返回dom对象,其他都是普通文本</span></span><br><span class="line">          <span class="keyword">if</span> (options.dateType === <span class="string">&#x27;json&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(xhr.responseText)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option.dataType === <span class="string">&#x27;xml&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> result = xhr.responseXML</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result = xhr.responseText</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*执行成功函数*/</span></span><br><span class="line">          options.success &amp;&amp; options.success(result)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          options.error &amp;&amp; options.error()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getData: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将obj对象转换成参数</span></span><br><span class="line">    <span class="comment">// 将对象转换成参数列表</span></span><br><span class="line">    <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      arr.push(k + <span class="string">&#x27;=&#x27;</span> + obj[k])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【登录案例】</p>
<h2 id="jQuery-中的-ajax-方法"><a href="#jQuery-中的-ajax-方法" class="headerlink" title="jQuery 中的 ajax 方法"></a>jQuery 中的 ajax 方法</h2><blockquote>
<p>jQuery 为我们提供了更强大的 Ajax 封装</p>
</blockquote>
<h3 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax"></a>$.ajax</h3><p>参数列表</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>描述</th>
<th>取值</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>接口地址</td>
<td></td>
<td>url:”02.php”</td>
</tr>
<tr>
<td>type</td>
<td>请求方式</td>
<td>get/post</td>
<td>type:”get”</td>
</tr>
<tr>
<td>timeout</td>
<td>超时时间</td>
<td>单位毫秒</td>
<td>timeout:5000</td>
</tr>
<tr>
<td>dataType</td>
<td>服务器返回的格式</td>
<td>json/xml/text(默认)</td>
<td>dataType:”json”</td>
</tr>
<tr>
<td>data</td>
<td>发送的请求数据</td>
<td>对象</td>
<td>data:{name:”zs”, age:18}</td>
</tr>
<tr>
<td>beforeSend</td>
<td>调用前的回调函数</td>
<td>function(){}</td>
<td>beforeSend:function(){ alert(1) }</td>
</tr>
<tr>
<td>success</td>
<td>成功的回调函数</td>
<td>function (data) {}</td>
<td>success:function (data) {}</td>
</tr>
<tr>
<td>error</td>
<td>失败的回调函数</td>
<td>function (error) {}</td>
<td>error:function(data) {}</td>
</tr>
<tr>
<td>complete</td>
<td>完成后的回调函数</td>
<td>function () {}</td>
<td>complete:function () {}</td>
</tr>
</tbody></table>
<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  type: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// 请求类型</span></span><br><span class="line">  url: <span class="string">&#x27;02.php&#x27;</span>, <span class="comment">// 请求地址</span></span><br><span class="line">  data: &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;, <span class="comment">// 请求数据</span></span><br><span class="line">  dataType: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// 希望接受的数据类型</span></span><br><span class="line">  timeout: <span class="number">5000</span>, <span class="comment">// 设置超时时间</span></span><br><span class="line">  beforeSend: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;发送前调用&quot;);</span></span><br><span class="line">    <span class="comment">// jq的ajax方法中beforeSend函数中如果执行了return false,那么请求就不发送了</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有 dataType:&quot;json&quot;，或后台有header(content-type: text/json)，res就是已经转换好的js对象</span></span><br><span class="line">    <span class="comment">// alert(&quot;成功时调用&quot;);</span></span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;失败时调用&quot;);</span></span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;,</span><br><span class="line">  complete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;请求完成时调用&quot;); // 不管成功失败都会执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>【案例：登录案例.html】</p>
<h2 id="接口化开发"><a href="#接口化开发" class="headerlink" title="接口化开发"></a>接口化开发</h2><p>请求地址即所谓的接口，通常我们所说的接口化开发，其实是指一个接口对应一个功能， 并且严格约束了<strong>请求参数</strong> 和<strong>响应结果</strong> 的格式，这样前后端在开发过程中，可以减少不必要的讨论， 从而并行开发，可以极大的提升开发效率，另外一个好处，当网站进行改版后，服务端接口进行调整时，并不影响到前端的功能。</p>
<h3 id="获取短信验证码"><a href="#获取短信验证码" class="headerlink" title="获取短信验证码"></a>获取短信验证码</h3><p>【案例：register】</p>
<p><strong>需求文档(产品)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">总需求：点击获取验证码按钮，向服务端发送请求, 调用服务器端短信接口, 服务器端根据传参, 调用第三方短信接口, 给手机发送验证码</span><br><span class="line"></span><br><span class="line">需求<span class="number">1</span>：格式校验</span><br><span class="line">(<span class="number">1</span>) 手机号码不能为空   如果为空提示<span class="string">&quot;手机号不能为空&quot;</span></span><br><span class="line">(<span class="number">2</span>) 手机号码格式必须正确, 提示<span class="string">&quot;请输入正确的手机号码&quot;</span></span><br><span class="line"></span><br><span class="line">需求<span class="number">2</span>：点击发送时，按钮显示为<span class="string">&quot;发送中&quot;</span>,并且不能重复提交请求</span><br><span class="line"></span><br><span class="line">需求<span class="number">3</span>：根据不同的响应结果，进行响应。</span><br><span class="line">(<span class="number">1</span>)如果接口调用成功</span><br><span class="line">  如果响应代码为<span class="number">100</span>，倒计时</span><br><span class="line">  如果响应代码为<span class="number">101</span>，提示手机号重复</span><br><span class="line">(<span class="number">2</span>)如果接口调用失败，告诉用户<span class="string">&quot;服务器繁忙，请稍候再试&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>接口文档</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">接口说明：获取短信验证码</span><br><span class="line">接口地址：getCode.php</span><br><span class="line">请求方式：get</span><br><span class="line">接口传参：mobile 手机号</span><br><span class="line">返回类型  json</span><br><span class="line">接口返回：&#123;</span><br><span class="line">			<span class="string">&quot;code&quot;</span>:<span class="string">&quot;101&quot;</span>,</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;手机号码存在&quot;</span>,</span><br><span class="line">			<span class="string">&quot;mobile&quot;</span>:<span class="string">&quot;18511249258&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">参数说明: code 当前业务逻辑的处理成功失败的标识  <span class="number">100</span>:成功   <span class="number">101</span>:手机号码存在</span><br><span class="line">		 msg  当前系统返回给前端提示</span><br><span class="line">		 mobile  当前的手机号码</span><br></pre></td></tr></table></figure>
<h3 id="注册接口"><a href="#注册接口" class="headerlink" title="注册接口"></a>注册接口</h3><p>【案例：register】</p>
<p><strong>表单序列化</strong> serialize</p>
<p>jquery 提供了一个<code>serialize()</code>方法序列化表单，说白就是将表单中带有 name 属性的所有参数拼成一个格式为<code>name=value&amp;name1=value1</code>这样的字符串。方便我们获取表单的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// serialize 方法将表单参数序列化成一个字符串。必须指定 name 属性</span></span><br><span class="line"><span class="comment">// name=pp&amp;pass=123456&amp;repass=123456&amp;mobile=15751776629&amp;code=1234</span></span><br><span class="line">$(<span class="string">&#x27;form&#x27;</span>).serialize()</span><br></pre></td></tr></table></figure>
<p>jquery 的 ajax 方法，data 参数能够直接识别表单序列化的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.post(&#123;</span><br><span class="line">  url: <span class="string">&#x27;register.php&#x27;</span>,</span><br><span class="line">  data: $(<span class="string">&#x27;form&#x27;</span>).serialize(),</span><br><span class="line">  dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(info)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>需求文档</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">注册功能</span><br><span class="line">总需求：点击注册按钮，向服务端发送请求</span><br><span class="line"></span><br><span class="line">需求<span class="number">1</span>:表单校验</span><br><span class="line">    <span class="number">1.1</span> 用户名不能为空，否则提示<span class="string">&quot;请输入用户名&quot;</span></span><br><span class="line">    <span class="number">1.2</span> 密码不能为空，否则提示<span class="string">&quot;请输入密码&quot;</span></span><br><span class="line">    <span class="number">1.3</span> 确认密码必须与密码一直，否则提示<span class="string">&quot;确认密码与密码不一致&quot;</span></span><br><span class="line">    <span class="number">1.4</span> 手机号码不能为空，否则提示<span class="string">&quot;请输入手机号码&quot;</span>;</span><br><span class="line">    <span class="number">1.5</span> 手机号码格式必须正确，否则提示<span class="string">&quot;手机号格式错误&quot;</span></span><br><span class="line">    <span class="number">1.6</span> 短信验证码必须是<span class="number">4</span>位的数字，否则提示<span class="string">&quot;验证码格式错误&quot;</span></span><br><span class="line"></span><br><span class="line">需求<span class="number">2</span>：点击注册按钮时，按钮显示为<span class="string">&quot;注册中...&quot;</span>,并且不能重复提交请求</span><br><span class="line"></span><br><span class="line">需求<span class="number">3</span>：根据不同响应结果，处理响应</span><br><span class="line">	<span class="number">3.1</span> 接口调用成功</span><br><span class="line">        <span class="number">100</span> 提示用户注册成功，3s后跳转到首页</span><br><span class="line">        <span class="number">101</span> 提示用户<span class="string">&quot;用户名已经存在&quot;</span></span><br><span class="line">        <span class="number">102</span> 提示用户<span class="string">&quot;验证码错误&quot;</span></span><br><span class="line">    <span class="number">3.2</span> 接口调用失败，提示<span class="string">&quot;服务器繁忙，请稍后再试&quot;</span>,恢复按钮的值</span><br></pre></td></tr></table></figure>
<p><strong>接口文档</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">接口说明：注册</span><br><span class="line">接口地址：register.php</span><br><span class="line">请求方式：post</span><br><span class="line">接口传参：name:用户名 pass:密码 code:验证码  mobile:手机号</span><br><span class="line">返回类型  json</span><br><span class="line">接口返回：&#123;</span><br><span class="line">			<span class="string">&quot;code&quot;</span>:<span class="string">&quot;100&quot;</span>,</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;注册成功&quot;</span>,</span><br><span class="line">			<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Jepson&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">参数说明:</span><br><span class="line">      code 当前业务逻辑的处理成功失败的标识  <span class="number">100</span>:成功  <span class="number">101</span>:用户存在 <span class="number">102</span>:验证码错误</span><br><span class="line">      msg  当前系统返回给前端提示</span><br><span class="line">      name: 注册的用户名</span><br></pre></td></tr></table></figure>
<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><blockquote>
<p>是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的 HTML 文档。</p>
</blockquote>
<h3 id="为什么要使用模板引擎"><a href="#为什么要使用模板引擎" class="headerlink" title="为什么要使用模板引擎"></a>为什么要使用模板引擎</h3><p>我们通过 ajax 获取到数据后，需要把数据渲染到页面，在学习模板引擎前，我们的做法是大量的拼接字符串，对于结构简单的页面，这么做还行 ，但是如果页面结构很复杂，使用拼串的话<strong>代码可阅读性非常的差，而且非常容易出错，后期代码维护也是相当的麻烦。</strong></p>
<p>总结来说拼串渲染两大缺点：</p>
<ol>
<li>js 中大量充斥着 html 结构拼串代码， 很冗余，可读性差</li>
<li>字符串拼接很麻烦， 且维护起来也很麻烦， 容易出错</li>
</ol>
<h3 id="常见的模板引擎"><a href="#常见的模板引擎" class="headerlink" title="常见的模板引擎"></a>常见的模板引擎</h3><p>BaiduTemplate：<a target="_blank" rel="noopener" href="http://tangram.baidu.com/BaiduTemplate/">http://tangram.baidu.com/BaiduTemplate/</a><br>velocity.js：<a target="_blank" rel="noopener" href="https://github.com/shepherdwind/velocity.js/">https://github.com/shepherdwind/velocity.js/</a><br>ArtTemplate：<a target="_blank" rel="noopener" href="https://github.com/aui/artTemplate">https://github.com/aui/artTemplate</a></p>
<p>artTemplate 是使用最广泛，效率最高的模板引擎，需要大家掌握。</p>
<h3 id="artTemplate"><a href="#artTemplate" class="headerlink" title="artTemplate"></a>artTemplate</h3><p><a target="_blank" rel="noopener" href="https://github.com/aui/art-template">github 地址</a></p>
<p><a target="_blank" rel="noopener" href="https://aui.github.io/art-template/docs/">中文 api 地址</a></p>
<h4 id="artTemplate-的基本使用"><a href="#artTemplate-的基本使用" class="headerlink" title="artTemplate 的基本使用"></a>artTemplate 的基本使用</h4><p><strong>1. 引入模板引擎的 js 文件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&#x27;template-web.js&#x27;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>2. 准备模板</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  指定了type为text/html后，这一段script标签并不会解析，也不会显示。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myTmp&quot;</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：隔壁老王<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：18<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>技能：查水表<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>描述：年轻力气壮<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3. 准备数据</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. 准备数据,数据是后台获取的，可以随时变化</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">  userName: <span class="string">&#x27;隔壁老王&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  skill: <span class="string">&#x27;查水表&#x27;</span>,</span><br><span class="line">  desc: <span class="string">&#x27;年轻气壮&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 将模板与数据进行绑定</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数：模板的id</span></span><br><span class="line"><span class="comment">//第二个参数：数据</span></span><br><span class="line"><span class="comment">//返回值：根据模板生成的字符串。</span></span><br><span class="line"><span class="keyword">var</span> html = template(<span class="string">&#x27;myTmp&#x27;</span>, json)</span><br><span class="line"><span class="built_in">console</span>.log(html)</span><br></pre></td></tr></table></figure>
<p><strong>5. 修改模板</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myTmp&quot;</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：</span><span class="template-variable">&#123;&#123;<span class="name">userName</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：</span><span class="template-variable">&#123;&#123;<span class="name">age</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>技能：</span><span class="template-variable">&#123;&#123;<span class="name">skill</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>描述：</span><span class="template-variable">&#123;&#123;<span class="name">desc</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>6. 将数据显示到页面</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">div.innerHTML = html</span><br></pre></td></tr></table></figure>
<h4 id="artTemplate-标准语法"><a href="#artTemplate-标准语法" class="headerlink" title="artTemplate 标准语法"></a>artTemplate 标准语法</h4><p><strong>if 语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;if gender=&#x27;男&#x27;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;man&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;else&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;woman&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;/if&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>each 语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  1. &#123;&#123;each data&#125;&#125;  可以通过$value 和 $index获取值和下标</span></span><br><span class="line"><span class="comment">  2. &#123;&#123;each data v i&#125;&#125;  自己指定值为v，下标为i</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">&#123;&#123;each data v i&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123;v.url&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;v.src&#125;&#125;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;v.content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果返回的数据是个数组，必须使用对象进行包裹，因为在&#123;&#123;&#125;&#125;中只写书写对象的属性。</span></span><br><span class="line"><span class="keyword">var</span> html = template(<span class="string">&#x27;navTmp&#x27;</span>, &#123; <span class="attr">data</span>: info &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="瀑布流案例"><a href="#瀑布流案例" class="headerlink" title="瀑布流案例"></a>瀑布流案例</h2><h3 id="封装-jQuery-瀑布流插件"><a href="#封装-jQuery-瀑布流插件" class="headerlink" title="封装 jQuery 瀑布流插件"></a>封装 jQuery 瀑布流插件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特点分析：</span></span><br><span class="line"><span class="comment">// 1. 跟以前将的瀑布流不一样的是，这次的瀑布流固定版心为1200px</span></span><br><span class="line"><span class="comment">// 2. 瀑布流固定摆放5列，每一列的宽度固定为232px。</span></span><br><span class="line"><span class="comment">// 思路分析：</span></span><br><span class="line"><span class="comment">// 1. 计算每一列之间的缝隙</span></span><br><span class="line"><span class="comment">// 2. 初始化一个数组，用户存储每一列的高度 [0,0,0,0,0]</span></span><br><span class="line"><span class="comment">// 3. 查找数组的最小列，每次都把图片定位到最小列的位置</span></span><br><span class="line"><span class="comment">// 4. 更新数组最小列的高度（加上定位过来的图片的高度）</span></span><br></pre></td></tr></table></figure>
<p>代码参考：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.fn.waterfall = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $box = $(<span class="built_in">this</span>)</span><br><span class="line">  <span class="keyword">var</span> $item = $box.children()</span><br><span class="line">  <span class="keyword">var</span> boxWidth = $box.width() <span class="comment">//父盒子的宽度</span></span><br><span class="line">  <span class="keyword">var</span> itemWidth = <span class="number">232</span> <span class="comment">//每个盒子固定宽度为232</span></span><br><span class="line">  <span class="keyword">var</span> columns = <span class="number">5</span> <span class="comment">//固定摆放5列</span></span><br><span class="line">  <span class="keyword">var</span> gap = (boxWidth - columns * itemWidth) / (columns - <span class="number">1</span>) <span class="comment">//缝隙的宽度 10</span></span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="comment">//初始化数组</span></span><br><span class="line">  $item.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//查找最小列</span></span><br><span class="line">    <span class="keyword">var</span> min = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> minIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (min &gt; arr[i]) &#123;</span><br><span class="line">        min = arr[i]</span><br><span class="line">        minIndex = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置位置</span></span><br><span class="line">    $(<span class="built_in">this</span>).css(&#123;</span><br><span class="line">      left: minIndex * (itemWidth + gap),</span><br><span class="line">      top: min</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//更新数组</span></span><br><span class="line">    arr[minIndex] = min + $(<span class="built_in">this</span>).outerHeight() + gap</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="瀑布流完整版"><a href="#瀑布流完整版" class="headerlink" title="瀑布流完整版"></a>瀑布流完整版</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求分析：</span></span><br><span class="line"><span class="comment">// 1. 页面刚开始，没有任何一张图片。因此需要从通过ajax获取图片</span></span><br><span class="line"><span class="comment">// 2. 使用模版引擎将获取到的数据渲染到页面</span></span><br><span class="line"><span class="comment">// 3. 因为图片路径是从服务端获取的，加载需要时间，需要等待图片加载完成后才能使用瀑布流进行布局。</span></span><br><span class="line"><span class="comment">// 4. 给window注册scroll事件，当触底时，需要动态的加载图片。</span></span><br><span class="line"><span class="comment">// 5. 加载时，显示加载中的提示信息，并且要求不能重复发送ajax请求</span></span><br><span class="line"><span class="comment">// 6. 当服务端返回图片数量为0时，提示用户没有更多数据。</span></span><br></pre></td></tr></table></figure>
<h2 id="同源与跨域"><a href="#同源与跨域" class="headerlink" title="同源与跨域"></a>同源与跨域</h2><h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h3><h4 id="同源策略的基本概念"><a href="#同源策略的基本概念" class="headerlink" title="同源策略的基本概念"></a>同源策略的基本概念</h4><blockquote>
<p>1995 年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。<br>同源策略：最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”：协议相同、域名相同、端口相同</p>
</blockquote>
<h4 id="同源策略的目的"><a href="#同源策略的目的" class="headerlink" title="同源策略的目的"></a>同源策略的目的</h4><blockquote>
<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
</blockquote>
<h4 id="同源策略的限制范围"><a href="#同源策略的限制范围" class="headerlink" title="同源策略的限制范围"></a>同源策略的限制范围</h4><blockquote>
<p>随着互联网的发展，“同源策略”越来越严格，目前，如果非同源，以下三种行为都将收到限制。</p>
</blockquote>
<ol>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 无法获得</li>
<li>AJAX 请求响应被拦截</li>
</ol>
<p>虽然这些限制是很有必要的，但是也给我们日常开发带来不好的影响。比如实际开发过程中，往往都会把服务器端架设到一台甚至是一个集群的服务器中，把客户端页面放到另外一个单独的服务器。那么这时候就会出现不同源的情况，如果我们知道两个网站都是安全的话，我们是希望两个不同源的网站之间可以相互请求数据的。这就需要使用到 <strong>跨域</strong> 。</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="jsonp-无兼容性问题"><a href="#jsonp-无兼容性问题" class="headerlink" title="jsonp( 无兼容性问题 )"></a>jsonp( 无兼容性问题 )</h4><blockquote>
<p><code>JSONP(JSON with Padding)</code> 可用于解决主流浏览器的跨域数据访问的问题。</p>
<p>原理：服务端返回一个定义好的 js 函数的调用，并且将服务器的数据以该函数参数的形式传递过来，这个方法需要前后端配合</p>
</blockquote>
<ul>
<li><code>script</code>  标签是不受同源策略的限制的，它可以载入任意地方的 JavaScript 文件。类似的还有<code>img</code>和<code>link</code>标签</li>
</ul>
<h5 id="jsonp-演化过程-1"><a href="#jsonp-演化过程-1" class="headerlink" title="jsonp 演化过程 1"></a>jsonp 演化过程 1</h5><p>php 文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">header(<span class="string">&quot;content-type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;alert(1111)&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>html 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://www.api.com/testjs.php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>原理：其实 src 的路径是什么文件不重要，无论引入 js 文件还是 php 文件，最后返回给浏览器的都是字符串，因此我们 script 标签是可以引入一个 php 文件的。</p>
<h5 id="jsonp-演化过程-2"><a href="#jsonp-演化过程-2" class="headerlink" title="jsonp 演化过程 2"></a>jsonp 演化过程 2</h5><p>php 文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">header(<span class="string">&quot;content-type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;var a = 118;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>html 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://www.api.com/testjs.php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// a打印出来了118</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(a)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>我们现在做到了一件事情，从不同源的 php 文件中获取到了数据</strong></p>
<p>缺点：获取数据的 script 标签必须写在使用的 script 标签的前面，必须保证先有数据才能对数据进行渲染。</p>
<h5 id="jsonp-演化过程-3"><a href="#jsonp-演化过程-3" class="headerlink" title="jsonp 演化过程 3"></a>jsonp 演化过程 3</h5><p>php 代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">header(<span class="string">&quot;content-type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">&quot;name&quot;</span>=&gt;<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>=&gt;<span class="number">18</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$result</span> = json_encode(<span class="variable">$arr</span>);</span><br><span class="line"><span class="comment">// 这是一段js函数的调用的代码，$result就是我们想要的数据</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;func(<span class="subst">$result</span>)&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>js 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data)</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://www.api.com/testjs.php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>缺点：后端必须知道前端声明的方法的名字，后端才能调用。</p>
<h5 id="jsonp-演化过程-4"><a href="#jsonp-演化过程-4" class="headerlink" title="jsonp 演化过程 4"></a>jsonp 演化过程 4</h5><p>php 代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">header(<span class="string">&quot;content-type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">&quot;name&quot;</span>=&gt;<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>=&gt;<span class="number">18</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$result</span> = json_encode(<span class="variable">$arr</span>);</span><br><span class="line"><span class="comment">// 这是一 段js函数的调用的代码，$result就是我们想要的数据</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&#x27;callback&#x27;</span>].<span class="string">&quot;(<span class="subst">$result</span>)&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>javascript 代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.src = <span class="string">&#x27;http://www.api.com/testjs.php?callback=fun&#x27;</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>jsonp 的原理就是 <strong>借助 script 标签 src 请求资源时，不受同源策略的限制</strong></li>
<li>在服务端返回一个函数的调用，将数据作为当前调用函数的实参</li>
<li>在浏览器端，声明一个全局函数，通过形参就可以获取到服务端返回的对应的值</li>
</ol>
<h4 id="jquery-对于-jsonp-的封装"><a href="#jquery-对于-jsonp-的封装" class="headerlink" title="jquery 对于 jsonp 的封装"></a>jquery 对于 jsonp 的封装</h4><p>!&gt; jsonp 仅支持 get 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用起来相当的简单，跟普通的get请求没有任何的区别，只需要把 dataType 固定成 jsonp 即可</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  url: <span class="string">&#x27;http://www.Jepson.com/testjs.php&#x27;</span>,</span><br><span class="line">  dataType: <span class="string">&#x27;jsonp&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    uname: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">    upass: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(info)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="XMLHttpRequest2-0"><a href="#XMLHttpRequest2-0" class="headerlink" title="XMLHttpRequest2.0"></a>XMLHttpRequest2.0</h2><blockquote>
<p>XMLHttpRequest 是一个 javascript 内置对象，使得 Javascript 可以进行异步的 HTTP 通信。2008 年 2 月，就提出了 XMLHttpRequest Level 2 草案。</p>
</blockquote>
<p>老版本的 XMLHttpRequest 的缺点：</p>
<ol>
<li>仅支持传输文本数据，无法传输二进制文件，比如图片视频等。</li>
<li>传输数据时，没有进度信息，只能提示完成与否。</li>
<li>受到了”同源策略”的限制</li>
</ol>
<p>新版本的功能：</p>
<ol>
<li>可以设置 timeout 超时时间</li>
<li>可以使用 formData 对象管理表单数据</li>
<li>允许请求不同域名下的数据（跨域）</li>
<li>支持上传二进制文件</li>
<li>可以获取数据传输的进度信息</li>
</ol>
<p><strong>注意：我们现在使用 new XMLHttpRequest 创建的对象就是 2.0 对象了，我们之前学的是 1.0 的语法，现在学习一些 2.0 的新特性即可。</strong></p>
<h3 id="timeout-设置超时"><a href="#timeout-设置超时" class="headerlink" title="timeout 设置超时"></a>timeout 设置超时</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.timeout = <span class="number">3000</span> <span class="comment">// 设置超时时间</span></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;请求超时&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="formData-管理表单数据"><a href="#formData-管理表单数据" class="headerlink" title="formData 管理表单数据"></a>formData 管理表单数据</h3><p>formData 对象类似于 jquery 的 serialize 方法，序列化表单，实现表单的异步提交</p>
<p>!&gt; 但 serialize 方法无法实现文件上传</p>
<p>使用：</p>
<ol>
<li>实例化一个 formData 对象， new FormData(form); form 就是表单元素，DOM 对象</li>
<li>formData 对象可以直接作为 xhr.send(formData) 的参数。注意此时数据是以二进制的形式进行传输。</li>
<li>formData 有一个 append 方法，可以添加参数。formData.append(“id”, “1111”);</li>
<li>这种方式只能以 <strong>post</strong> 形式传递，不需要设置请求头，浏览器会自动为我们设置一个合适的请求头。</li>
</ol>
<p>代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 使用formData必须发送post请求</span></span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;02-formData.php&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取表单元素</span></span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#myForm&#x27;</span>)</span><br><span class="line"><span class="comment">// 3. 创建form对象，可以直接作为send的参数。</span></span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData(form)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. formData可以使用append方法添加参数</span></span><br><span class="line">formData.append(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;1111&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 发送，不需要指定请求头，浏览器会自动选择合适的请求头</span></span><br><span class="line">xhr.send(formData)</span><br></pre></td></tr></table></figure>
<p>如果要获取 <code>formData</code> 中的数据，可以使用 <code>formData.get(&#39;&#39;)</code> 获取</p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote>
<p>以前，文件上传需要借助表单进行上传，但是表单上传是同步的，也就是说文件上传时，页面需要提交和刷新，用户体验不友好，xhr2.0 中的 formData 对象支持文件的异步上传。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line"><span class="comment">// 获取上传的文件，传递到后端</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;file&#x27;</span>).files[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.dir(file)</span><br><span class="line">formData.append(<span class="string">&#x27;file&#x27;</span>, file)</span><br><span class="line">xhr.send(formData)</span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;#upload&#x27;</span>).on(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// FormData 用于管理表单数据的</span></span><br><span class="line">  <span class="keyword">var</span> form = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#form1&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData(form)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送给服务器</span></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;upload.php&#x27;</span>)</span><br><span class="line">  xhr.send(formData) <span class="comment">// 直接发送 formData</span></span><br><span class="line"></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> r = xhr.responseText</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// jquery</span></span><br><span class="line">$(<span class="string">&#x27;#upload&#x27;</span>).on(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 准备要上传的数据</span></span><br><span class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">  <span class="comment">// 如果 formData 中有文件对象了，就不需要再添加了</span></span><br><span class="line">  formData.append(<span class="string">&#x27;file&#x27;</span>, <span class="built_in">this</span>.files[<span class="number">0</span>])</span><br><span class="line">  <span class="comment">// 发送 AJAX 请求，上传文件</span></span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;upload.php&#x27;</span>,</span><br><span class="line">    contentType: <span class="literal">false</span>, <span class="comment">// 设置编码类型</span></span><br><span class="line">    processData: <span class="literal">false</span>, <span class="comment">// 设置传递值方式</span></span><br><span class="line">    data: formData,</span><br><span class="line">    type: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (res.success) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>!&gt; 如果使用 <code>$.ajax</code> 发送 ， 需要添加如下两项参数<br>​ <code>contentType: false,</code> 设置编码类型<br>​ <code>processData: false,</code> 设置传递值方式</p>
<h3 id="显示文件进度信息"><a href="#显示文件进度信息" class="headerlink" title="显示文件进度信息"></a>显示文件进度信息</h3><p>xhr2.0 还支持获取上传文件的进度信息，因此我们可以根据进度信息可以实时的显示文件的上传进度。</p>
<ol>
<li>需要注册 <code>xhr.upload.onprogress = function(e)&#123;&#125;</code> 事件，用于监听文件上传的进度。注意：需要在 send 之前注册。</li>
<li>上传的进度信息会存储事件对象 e 中</li>
<li><code>e.loaded</code> 表示已上传的大小；<code>e.total</code> 表示整个文件的大小</li>
</ol>
<p>代码参考：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  inner.style.width = ((e.loaded / e.total) * <span class="number">100</span>).toFixed(<span class="number">2</span>) + <span class="string">&#x27;%&#x27;</span></span><br><span class="line">  span.innerHTML = ((e.loaded / e.total) * <span class="number">100</span>).toFixed(<span class="number">2</span>) + <span class="string">&#x27;%&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// toFixed(2) 保留两位小数</span></span><br><span class="line"></span><br><span class="line">xhr.send(formData)</span><br></pre></td></tr></table></figure>
<p>默认上传文件限制 8M，需要配置 php.ini，允许 php 上传大文件</p>
<h3 id="跨域资源共享-CORS"><a href="#跨域资源共享-CORS" class="headerlink" title="跨域资源共享(CORS)"></a>跨域资源共享(CORS)</h3><h4 id="CORS-的使用"><a href="#CORS-的使用" class="headerlink" title="CORS 的使用"></a>CORS 的使用</h4><blockquote>
<p>新版本的 XMLHttpRequest 对象，可以向不同域名的服务器发出 HTTP 请求。这叫做<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Cross-Origin_Resource_Sharing">跨域资源共享</a>（Cross-origin resource sharing，简称 CORS）。</p>
</blockquote>
<p>跨域资源共享（CORS）的前提</p>
<ul>
<li>浏览器支持这个功能( 兼容性 IE10+ )</li>
<li>服务器必须允许这种跨域</li>
</ul>
<p>服务器允许跨域的代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 允许所有的域名访问这个接口</span></span><br><span class="line">header(<span class="string">&quot;Access-Control-Allow-Origin:*&quot;</span>);</span><br><span class="line"><span class="comment">// 允许 www.abc.com 这个域名访问这个接口</span></span><br><span class="line">header(<span class="string">&quot;Access-Control-Allow-Origin:http://www.abc.com&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="CORS-的具体流程（了解）"><a href="#CORS-的具体流程（了解）" class="headerlink" title="CORS 的具体流程（了解）"></a>CORS 的具体流程（了解）</h4><ol>
<li><p>浏览器发送跨域请求</p>
</li>
<li><p>服务器端收到一个跨域请求后，在响应头中添加 Access-Control-Allow-Origin Header 资源权限配置。发送响应</p>
</li>
<li><p>浏览器收到响应后，查看是否设置了<code>header(&#39;Access-Control-Allow-Origin:请求源域名或者*&#39;);</code></p>
<p>如果当前域已经得到授权，则将结果返回给浏览器，否则浏览器忽略此次响应</p>
</li>
</ol>
<p>结论：</p>
<ol>
<li><strong>跨域行为是浏览器行为，响应是回来了, 只是浏览器安全机制做了限制, 对于跨域响应内容进行了忽略。</strong></li>
<li><strong>服务器与服务器之间是不存在跨域问题的</strong></li>
</ol>
<h4 id="jsonp-与-cors-的对比"><a href="#jsonp-与-cors-的对比" class="headerlink" title="jsonp 与 cors 的对比"></a>jsonp 与 cors 的对比</h4><ul>
<li>jsonp 兼容性好，老版本浏览器也支持，但是 jsonp 仅支持 get 请求，发送的数据量有限，使用麻烦</li>
<li>cors 需要浏览器支持 cors 功能才行。使用简单，<strong>只要服务端设置允许跨域，对于客户端来说，跟普通的 get、post 请求并没有什么区别</strong></li>
<li>跨域的安全性问题：<strong>因为跨域是需要服务端配合控制的</strong> ，也就是说不论 jsonp 还是 cors，如果没有服务端的允许，浏览器是没法做到跨域的</li>
</ul>
<p>【案例：图灵机器人】</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/1663.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1663.html" class="post-title-link" itemprop="url">PHP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-25 14:42:21" itemprop="dateCreated datePublished" datetime="2018-10-25T14:42:21+00:00">2018-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="什么是服务器？"><a href="#什么是服务器？" class="headerlink" title="什么是服务器？"></a>什么是服务器？</h3><blockquote>
<p>通过安装服务器软件，<strong>提供服务</strong> 的计算机</p>
</blockquote>
<p>服务器可以从硬件、软件(系统软件、应用软件)几个角度描述。</p>
<p>按硬件描述： 服务器就是一台超级计算机(配置很高)。<br>按操作系统划分： 在硬件上安装了什么操作系统，就可以称为该系统的服务器<br>​ 例如: linux 服务器、windows 服务器、unix 服务器等。<br>按软件划分： 在操作系统中安装了什么软件，就可以称作该软件的服务器 iis tomcat<br>​ 例如: <strong>web 服务器</strong>、数据库服务器、邮件服务器等。</p>
<h3 id="什么是-Web-服务器"><a href="#什么是-Web-服务器" class="headerlink" title="什么是 Web 服务器"></a>什么是 Web 服务器</h3><p>Web 服务器就是安装了 Web 服务软件，web 服务器的作用是能够提供网站服务的服务器。淘宝、京东、新浪等等</p>
<p>常见的 Web 软件：<br><strong>Apache</strong>、Nginx、IIS、Tomcat、Node 等。<br>Apache 服务器、Nginx 服务器、IIS 服务器、Tomcat 服务器、Node 服务器</p>
<p>Apache 是世界使用排名第一的 Web 服务器软件。我们将编写好的 html、css、js 等文件存入 apache，就能够通过网络来访问这些文件了</p>
<p>PS: web 服务器又叫做 http/httpd 服务器</p>
<h2 id="phpStudy-介绍"><a href="#phpStudy-介绍" class="headerlink" title="phpStudy 介绍"></a>phpStudy 介绍</h2><blockquote>
<p>phpStudy 是一个 PHP 调试环境的程序集成包</p>
<p>该程序包集成最新的 Apache+PHP+MySQL</p>
<p>安装 phpStudy，一定不能有中文，否则肯定启动不起来</p>
</blockquote>
<p>**注意: **将要访问的文件(html,php,img 等)，放到安装路径下的 <code>www</code> 目录下，通过浏览器就可以访问到了</p>
<h3 id="phpStudy-的错误解决"><a href="#phpStudy-的错误解决" class="headerlink" title="phpStudy 的错误解决"></a>phpStudy 的错误解决</h3><p>如果 phpStudy 启动发生错误，参数下列几点。</p>
<ul>
<li><p>一是防火墙拦截</p>
</li>
<li><p>二是 80 端口已经被别的程序占用，如 IIS 等</p>
</li>
<li><p>三是没有安装 VC9 运行库,php 和 apache 都是 VC9 编译</p>
</li>
</ul>
<h2 id="PHP-基础-重点"><a href="#PHP-基础-重点" class="headerlink" title="PHP 基础(重点)"></a>PHP 基础(重点)</h2><h3 id="PHP-简介"><a href="#PHP-简介" class="headerlink" title="PHP 简介"></a>PHP 简介</h3><p>PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。主要适用于 <strong>Web 领域的开发</strong> ，能够完成 <strong>动态网页</strong> 的制作</p>
<h3 id="PHP-特点"><a href="#PHP-特点" class="headerlink" title="PHP 特点"></a>PHP 特点</h3><ul>
<li>PHP 是目前最流行的网站开发语言（B/S 结构）之一</li>
<li>PHP 是一种在服务器端执行的嵌入 HTML 文档的脚本语言</li>
<li>支持几乎所有流行的 <strong>数据库</strong> 以及操作系统</li>
<li>源码开放、免费（free)</li>
<li>php 是世界上最好的语言</li>
</ul>
<h3 id="动态网站与静态网站-了解"><a href="#动态网站与静态网站-了解" class="headerlink" title="动态网站与静态网站(了解)"></a>动态网站与静态网站(了解)</h3><ul>
<li><p>静态网站：使用浏览器端语言进行编程，网站由静态代码（HTML,CSS,JS）组成。</p>
</li>
<li><p>动态网站  ：网页通过服务器的程序(php 等)动态生成。用户可以和服务器进行交互（可以根据用户输入的不同信息，返回不同的运行结果）</p>
</li>
</ul>
<p><strong>总结</strong></p>
<p>动态网站的 <strong>动</strong> 指的是网站 <strong>数据的动</strong> 而不是 <strong>视觉上的动</strong></p>
<h3 id="软件架构-了解"><a href="#软件架构-了解" class="headerlink" title="软件架构(了解)"></a>软件架构(了解)</h3><blockquote>
<p>软件架构可以分为 BS 架构与 CS 架构</p>
</blockquote>
<h4 id="C-S-架构"><a href="#C-S-架构" class="headerlink" title="C/S 架构"></a>C/S 架构</h4><p>Client/Server 架构，即客户端/服务器架构。需要安装对应的客户端软件，才能获取服务器的服务</p>
<p>常见的 CS 架构：QQ、LOL、微信等</p>
<p>特点：</p>
<ul>
<li><p>需要安装才能使用</p>
</li>
<li><p>性能高效，使用更加稳定和流畅</p>
</li>
</ul>
<h4 id="B-S-架构"><a href="#B-S-架构" class="headerlink" title="B/S 架构"></a>B/S 架构</h4><p>Broswer/Server 架构，即浏览器/服务器架构。随着 Internet 的兴起，无需安装专门客户端软件，通过浏览器去请求服务器</p>
<ul>
<li>不需要安装，只需要浏览器即可。</li>
<li>相比 CS 架构，性能相对较差，没有那么流畅和稳定</li>
</ul>
<h2 id="php-基本语法结构"><a href="#php-基本语法结构" class="headerlink" title="php 基本语法结构"></a>php 基本语法结构</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 避免使用中文目录和中文文件名</span></span><br><span class="line"><span class="comment">// 文件以.php后缀结尾，所有程序包含在<span class="meta">&lt;?php</span> 这里是代码 <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">// php页面无法直接打开需要运行在服务器环境当中</span></span><br><span class="line"><span class="comment">// 末尾必须加分号，不然就报错了（最后一行可以不加分号）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出中文乱码问题：如果使用 echo 输出中文，可能会乱码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment">// 解决中文乱码的问题</span></span><br><span class="line">  header(<span class="string">&quot;content-Type:text/html;charset=utf-8&quot;</span>); <span class="comment">// 返回HTML文档文本并设置编码集</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;大家好，我是一名摄影工作者&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="PHP-运行原理"><a href="#PHP-运行原理" class="headerlink" title="PHP 运行原理"></a>PHP 运行原理</h2><h3 id="HTML-运行原理"><a href="#HTML-运行原理" class="headerlink" title="HTML 运行原理"></a>HTML 运行原理</h3><p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102205640.png"></p>
<ol>
<li>在浏览器的 URL 地址栏中输入 <a target="_blank" rel="noopener" href="http://www.baidu.com/index.html">www.baidu.com/index.html</a> 地址，点回车。请求就发送给百度服务器。</li>
<li>百度服务器找到 index.html 文件，并将文件的内容返回给浏览器</li>
<li>浏览器接收到 index.html 中的内容，渲染到页面上。</li>
</ol>
<p>同理: localhost/a.html , 则会返回 本机 web 服务器根目录下 a.html 文件的内容。浏览器拿到内容后进行渲染。</p>
<h3 id="PHP-运行原理-1"><a href="#PHP-运行原理-1" class="headerlink" title="PHP 运行原理"></a>PHP 运行原理</h3><p>apache 不认识 php<br>浏览器也不认识 php</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102205658.png"></p>
<ol>
<li> 在浏览器地址栏中输入 localhost/index.php ,点回车之后。将请求发送给 apache 服务器</li>
<li> 服务器找到 index.php 文件之后，转发给 php 解释器</li>
<li> php 解释器将 index.php 文件中的 php 代码全部转为字符串，再返回给 apache</li>
<li> apache 将处理好的字符串返回给浏览器，浏览器渲染后就可以看到页面</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote>
<p>php 是一门弱类型语法，变量的类型可以随意改变。<br>变量其实就是存储数据的容器</p>
</blockquote>
<p><strong>变量的命名规则</strong></p>
<ul>
<li>不需要关键字进行声明，变量在第一次赋值的时候被创建</li>
<li>必须以 <code>$</code> 符号开始</li>
<li><code>$</code> 后面的命名规则与 js 的变量命名规则一致</li>
</ul>
<h3 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h3><p><strong>声明变量</strong></p>
<p>声明变量的时候也一定要同时赋值,否则变量无法声明成功</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量在声明的时候一定要同时赋值,否则变量无法声明成功</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&quot;呵呵&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br></pre></td></tr></table></figure>
<p><strong>删除变量 unset()</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unset</span>(<span class="variable">$name</span>); <span class="comment">// 销毁指定的变量</span></span><br></pre></td></tr></table></figure>
<p><strong>判断变量是否设置值 isset()</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">isset</span>(<span class="variable">$name</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">isset</span>(<span class="variable">$name</span>); <span class="comment">// 用 echo 打印，如果为 true 会打印出 1 ， 如果为 false 打印空</span></span><br><span class="line">var_dump(<span class="keyword">isset</span>(<span class="variable">$name</span>)); <span class="comment">// 会打印出 bool(true)/bool(false)</span></span><br></pre></td></tr></table></figure>
<p>变量未设置或者设置为 null，返回 false（认为变量没有设置），其余情况全部为 true。一般用来判断变量是否设置，因为变量未设置，无法直接使用。(变量先赋值，在使用！）</p>
<p><strong>判断变量是否为空 empty()</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">var_dump(<span class="keyword">empty</span>(<span class="variable">$name</span>)); <span class="comment">// 为空打印出 bool(true)，不为空则打印 bool(false)</span></span><br></pre></td></tr></table></figure>
<p>PHP 中认为变量的值为：<code>&quot;&quot;</code>、<code>0</code>、<code>&quot;0&quot;</code>、<code>null</code>、<code>false</code>、<code>[]</code> 时，变量虽然赋值了，但是无实际的意义，为空。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote>
<p>php 数据类型: 8 种数据类型</p>
<p>基本数据类型: 布尔, 字符串, 整数, 浮点数</p>
<p>复合数据类型:数组, 对象</p>
<p>特殊的类型:resource(资源) null</p>
</blockquote>
<h3 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h3><h4 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. echo 输出简单数据类型</span></span><br><span class="line"><span class="comment">//2. print_r 输出数据结构，一般用于输出复杂类型。</span></span><br><span class="line">print_r(<span class="variable">$arr</span>); <span class="comment">// print_r 是一个函数，不要忘记小括号</span></span><br><span class="line"><span class="comment">//3. var_dump 输出完整的数据结构，包括类型，一般用于精准调试</span></span><br><span class="line">var_dump(<span class="variable">$arr</span>);</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$str</span> = <span class="string">&quot;php是世界上是最好的语言&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>;</span><br></pre></td></tr></table></figure>
<p><strong>字符串连接符</strong></p>
<p>php 中，<code>+</code> 号只有算数的功能，并不能拼串，拼串使用 <code>.</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="string">&quot;大象&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;大家好，我是&quot;</span> . <span class="variable">$name</span> . <span class="string">&quot;，今年18岁&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>php 中的单引号与双引号</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 字符串的定义可以使用单引号，也可以使用双引号</span></span><br><span class="line"><span class="comment">//2. 双引号可以解析变量</span></span><br><span class="line"><span class="comment">//3. 单引号的性能会高于双引号（了解）</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&quot;大象&quot;</span>;</span><br><span class="line"><span class="variable">$desc</span> = <span class="string">&#x27;很帅&#x27;</span>;</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;$name 很帅&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>; <span class="comment">// $name 很帅</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;<span class="subst">$name</span> 很帅&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>; <span class="comment">// 大象 很帅</span></span><br></pre></td></tr></table></figure>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$num</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$num</span>;</span><br></pre></td></tr></table></figure>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$float</span> = <span class="number">11.11</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$float</span>;</span><br></pre></td></tr></table></figure>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$flag</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 当布尔类型值为true时，输出1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line"><span class="variable">$flag</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 当布尔类型为false时，输出空字符串</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>在 php 中，数组分为两种，<strong>索引数组</strong> 和 <strong>关联数组</strong></p>
<p>计算数组长度的方法：count(数组名)；</p>
</blockquote>
<p><strong>索引数组（类似与 JS 中的数组）</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;张飞&quot;</span>,<span class="string">&quot;赵云&quot;</span>,<span class="string">&quot;马超&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$arr</span>; <span class="comment">// Array // echo 只能打印基本数据类型</span></span><br><span class="line"><span class="comment">// 使用 print_r() 打印</span></span><br><span class="line">print_r(<span class="variable">$arr</span>); <span class="comment">// Array ([0] =&gt; 张飞 [1] =&gt; 赵云 [2] =&gt; 马超)</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$arr</span>[<span class="number">0</span>]; <span class="comment">// 张飞</span></span><br></pre></td></tr></table></figure>
<p><strong>关联数组（类似与 JS 中的对象）</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 属性名必须用引号引起来</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;name&quot;</span>=&gt;<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span>=&gt;<span class="number">18</span>);</span><br><span class="line">print_r(<span class="variable">$arr</span>); <span class="comment">// Array ( [name] =&gt; zhangsan [age] =&gt; 18 )</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$arr</span>[<span class="string">&quot;name&quot;</span>];</span><br></pre></td></tr></table></figure>
<p><strong>二维数组与多维数组</strong></p>
<p>数组中的每个元素又是一个数组<br>二维数组的存取元素，需要两次访问，依次确定行和列 <code>$arr[x][y]</code>;</p>
<blockquote>
<p>多维数组数组里面嵌套了两层以上的数组</p>
</blockquote>
<h3 id="对象-了解"><a href="#对象-了解" class="headerlink" title="对象(了解)"></a>对象(了解)</h3><blockquote>
<p>在 php 以及其他高级语言中，都有类的概念，表示一类对象，跟 js 中构造函数类似。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个类（类似js的构造函数）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="variable">$sex</span> = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$zs</span> = <span class="keyword">new</span> Person;</span><br><span class="line">print_r(<span class="variable">$zs</span>);</span><br><span class="line"><span class="comment">//打印对象的结构信息 Person Object ([name] =&gt; 小明[sex:Person:private] =&gt; 男 )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$zs</span>-&gt;name; <span class="comment">// 对象中取值用 -&gt;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$zs</span>-&gt;sex; <span class="comment">// 私有属性，无法获取</span></span><br></pre></td></tr></table></figure>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="分支结构-if-switch"><a href="#分支结构-if-switch" class="headerlink" title="分支结构(if/switch)"></a>分支结构(if/switch)</h3><p>基本上来说，所有语言的 if..else 语法都是一样</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$age</span> = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$age</span> &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;终于可以抽烟喝酒烫头了&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;哎......&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===================</span></span><br><span class="line"><span class="keyword">switch</span>(变量)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">		程序块<span class="number">1</span>；</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">		程序块<span class="number">2</span>；</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		程序块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环结构-while-for-do…while"><a href="#循环结构-while-for-do…while" class="headerlink" title="循环结构(while / for / do…while)"></a>循环结构(while / for / do…while)</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(判断表达式)&#123;</span><br><span class="line">	程序块;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(赋值表达式; 判断表达式; 步进表达式)&#123;</span><br><span class="line">	程序块;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	程序块</span><br><span class="line">&#125; <span class="keyword">while</span>(判断表达式)</span><br></pre></td></tr></table></figure>
<p><strong>遍历索引数组</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;赵六&quot;</span>, <span class="string">&quot;田七&quot;</span>, <span class="string">&quot;王八&quot;</span>);</span><br><span class="line"><span class="comment">// 获取数组的长度： count($arr)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; count(<span class="variable">$arr</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="foreach-语句结构"><a href="#foreach-语句结构" class="headerlink" title="foreach 语句结构"></a>foreach 语句结构</h3><blockquote>
<p>用来遍历数组(关联数组和索引数组均可)。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>)&#123;</span><br><span class="line">	程序体</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$value</span>)&#123;</span><br><span class="line">	程序体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>$arr</code> : 要遍历的数组</p>
<p><code>$key</code>: 键，可以是任意变量名</p>
<p><code>$value</code>: 值，可以是任意变量名</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历关联数组</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">&quot;name&quot;</span>=&gt;<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>=&gt;<span class="number">18</span>,</span><br><span class="line">  <span class="string">&quot;sex&quot;</span>=&gt;<span class="number">20</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$k</span> . <span class="string">&quot;=&quot;</span> . <span class="variable">$v</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>注意，在 php 中函数不能重复声明</p>
</blockquote>
<p>php 中函数的语法与 js 中函数的语法基本一样，不同点在于</p>
<ol>
<li>函数名大小写不敏感</li>
<li>函数的形参可以设置默认值</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    header(<span class="string">&quot;content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"><span class="variable">$name</span>=<span class="string">&quot;周杰伦&quot;</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;大家好，我是<span class="subst">$name</span>&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        [<span class="keyword">return</span> 返回值;]</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello(); <span class="comment">// 不传参数，会使用默认值</span></span><br><span class="line">    sayHello(<span class="string">&quot;大象&quot;</span>); <span class="comment">// 传参数，默认值不生效</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在 php 中函数不能重复声明</li>
<li>函数体内的变量只在函数体内有效</li>
<li>函数体外的变量只在函数体外有效</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$age</span> = <span class="number">18</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="variable">$name</span> = <span class="string">&#x27;大象&#x27;</span>;</span><br><span class="line">    	<span class="keyword">echo</span> <span class="variable">$name</span>;  <span class="comment">// 有效</span></span><br><span class="line">    	<span class="keyword">echo</span> <span class="variable">$age</span>;  <span class="comment">// 无效</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span>(<span class="params"></span>)</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$name</span>;  <span class="comment">// 无效</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$age</span>; <span class="comment">// 有效</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>保存不会发生改变的数据(如：3.1415， 路径等)时，最好使用常量。</p>
<p>常量的使用方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">define(常量名, 常量值, [是否区分大小写]);</span><br><span class="line"><span class="comment">// 默认 false 区分大小写， true 不区分大小写</span></span><br><span class="line">define(<span class="string">&quot;PI&quot;</span>, <span class="number">3.1415</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">echo</span> PI;</span><br><span class="line"><span class="keyword">echo</span> pi;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 一般在实际工作中，常量都用大写，<strong>常量不能被重新赋值</strong></p>
<h2 id="PHP-内置函数"><a href="#PHP-内置函数" class="headerlink" title="PHP 内置函数"></a>PHP 内置函数</h2><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul>
<li>max(),min() 分别返回一组数的最大值及最小值；</li>
<li>abs() 返回绝对值。</li>
<li>floor() 向下取整。</li>
<li>ceil() 向上取整。</li>
<li>round() 四舍五入。</li>
<li>rand()  返回随机整数，可以取到两端的值。</li>
</ul>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><ul>
<li><p><code>time()</code> 返回当前的时间戳 (1970 到现在的时间的秒数)</p>
</li>
<li><p><code>date(format,time)</code> 格式化一个本地时间或日期</p>
<p>格式：Y(年) m(月) d(日) H(时) i(分) s 秒</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$time</span> = time(); <span class="comment">// 获取时间戳</span></span><br><span class="line"><span class="keyword">echo</span> date(<span class="string">&#x27;Y-m-d H:i:s&#x27;</span>,<span class="variable">$time</span>); <span class="comment">// 格式化时间戳</span></span><br><span class="line"><span class="comment">// Y, m, d, H, i, s 分别代表 年 月 日 时 分 秒</span></span><br></pre></td></tr></table></figure>
<p>默认时区会不太正确, 我们在东八区, 比 0 时区会多八小时</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">路径: D:\phpStudy\php\php<span class="number">-5.4</span><span class="number">.45</span></span><br><span class="line">在php.ini里加上找到date.timezone项，设置date.timezone = <span class="string">&quot;PRC&quot;</span>，重启环境就ok了。</span><br><span class="line">PRC: 中华人民共和国</span><br></pre></td></tr></table></figure>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul>
<li><code>str_replace(查找的值，替换的值，执行替换操作的字符)</code> 字符串替换（会把符合的值全部替换）</li>
<li><code>trim(字符串);</code> 去除首尾空白字符</li>
<li><code>explode(分割符，执行分割的字符串);</code> 使用一个字符分割一个字符串，返回一个数组(类似 split)</li>
<li><code>implode(连接符，执行连接的数组);</code> 将数组根据连接符拼接成字符串(类似 join)</li>
<li><code>substr(字符串，起始索引，截取长度);</code> 截取字符串，注意中文占 3 个字节长度</li>
<li><code>strchr(字符串，标识字符);</code> 从左向右找标识字符，返回该字符后全部字符(包括该字符)</li>
<li><code>strrchr(字符串，标识字符);</code> 从右向左找标识字符，返回该字符后全部字符(包括该字符) <strong>主要用于获取后缀名</strong></li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>查找数组中是否含有指定内容</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in_array(查找的内容, 数组)   如果查找到返回 true ，查找不到返回 false</span></span><br><span class="line">result = in_array(<span class="variable">$uname</span>, <span class="variable">$arr</span>);</span><br><span class="line"><span class="comment">// 可用来判断用户名是否已存在数据库中</span></span><br></pre></td></tr></table></figure>
<p><strong>从数组中随机获取数据</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array_rand(被操作的数据, 数据长度) 返回一个随机的下标</span></span><br><span class="line"><span class="variable">$arr</span> = array_rand(<span class="variable">$results</span>, <span class="number">2</span>); <span class="comment">// 返回一个数组，随机两个下标</span></span><br><span class="line"><span class="variable">$index</span> = array_rand(<span class="variable">$results</span>, <span class="number">1</span>); <span class="comment">// 返回一个随机的下标</span></span><br><span class="line"><span class="variable">$results</span>[<span class="variable">$index</span>]; <span class="comment">// 用来随机获取数组中的一项</span></span><br></pre></td></tr></table></figure>
<h2 id="页面动态渲染"><a href="#页面动态渲染" class="headerlink" title="页面动态渲染"></a>页面动态渲染</h2><ul>
<li><p>PHP 本身支持与 HTML 混编</p>
</li>
<li><p>混编的文件后缀必须为 .php， Apache 才会调用 PHP 解析</p>
</li>
<li><p>PHP 与 HTML 混编时，服务器中的 PHP 引擎 只会执行 php 标签内部的 PHP 代码，非 PHP 的代码(PHP 标签外部的内容)直接忽略，最后会将 PHP 的执行结果和非 PHP 代码 一起返回给浏览器,由浏览器进行解析</p>
</li>
<li><p>一个 php 页面当中,可以写多个 php 语法结构,但是 php 语法结构 <strong>不能嵌套</strong></p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  header(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">  <span class="keyword">echo</span> <span class="number">2</span>+<span class="number">3</span>;</span><br><span class="line">  <span class="comment">// php的引擎 只会执行php代码块中代码，代码块外面的代码会被忽略最后 服务器会将php执行的结果和代码块外面的内容一起返回给浏览器，由浏览器进行解析</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">// 在php语法结构外面， 可以写 html ，会直接在浏览器中渲染</span></span><br><span class="line">&lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;百度一下&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h2 id="include-文件引入"><a href="#include-文件引入" class="headerlink" title="include 文件引入"></a>include 文件引入</h2><p><strong>介绍</strong>：不同的页面中有相同的代码部分，可以将其分离为单个文件。需要调用时，<strong>include 引入对应的文件即可调用</strong>。提高代码的复用率。类似于 js 中 script 标签导入, 可以用于函数复用</p>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以是html、php或其他类型的页面</span></span><br><span class="line">include | include_once   <span class="string">&quot;文件的路径&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>include 与 include_once 区别</strong></p>
<ul>
<li>include 可以重复引入文件</li>
<li>include_once 只引入一次，防止多次引入文件</li>
<li>如果文件中有函数，include 重复引入会报错，include_once 不会报错</li>
</ul>
<h2 id="PHP-数据读写到文件-数据持久化"><a href="#PHP-数据读写到文件-数据持久化" class="headerlink" title="PHP 数据读写到文件(数据持久化)"></a>PHP 数据读写到文件(数据持久化)</h2><p>程序运行过程中，数据存储在内存中的，程序结束, 数据会销毁</p>
<p>如果希望可以永久存储某些数据，可以将数据存储在硬盘上（存储在文件中）</p>
<p>将数据由内存存储到硬盘的过程，称为数据持久化；</p>
<ul>
<li><p><code>file_get_contents(path)</code>   根据路径读取文件内容, 返回一个字符串</p>
</li>
<li><p><code>file_put_contents(path,$str)</code>   将一个字符串写入到一个文件中。(只能存储字符串)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file_put_contents(<span class="keyword">string</span> <span class="variable">$file</span>, <span class="keyword">string</span> <span class="variable">$data</span>[, constants flag]);</span><br><span class="line">参数<span class="number">1</span>: 文件路径</span><br><span class="line">参数<span class="number">2</span>: 要写入文件的字符串</span><br><span class="line">参数<span class="number">3</span>: 可选参数，默认不写，新内容覆盖原文件中的内容；FILE_APPEND 是向文件中追加内容</span><br><span class="line">返回值: 写入文件的字符串长度(不用记)</span><br></pre></td></tr></table></figure>
<p>使用 <code>file_put_contents</code> 存储数组的时候，会丢失数据</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>];</span><br><span class="line"><span class="variable">$arr1</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">18</span>];</span><br><span class="line">file_put_contents(<span class="string">&quot;02-test.txt&quot;</span>, <span class="variable">$arr</span>); <span class="comment">// zslsww</span></span><br><span class="line">file_put_contents(<span class="string">&quot;02-test.txt&quot;</span>, <span class="variable">$arr1</span>); <span class="comment">// zs18</span></span><br></pre></td></tr></table></figure>
<p>把一个数组，转成一个 json 格式的字符串</p>
<ul>
<li><code>json_encode($data)</code> 将 PHP 数组转成 JSON 格式字符串。</li>
<li><code>json_decode($str,true)</code> 将 JSON 字符串, 转换为 PHP 数组。（不传 true, 有可能转完之后是个对象, 传了 true,一定是数组）</li>
</ul>
<h2 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h2><blockquote>
<p>表单（form）：表单用于收集用户输入信息，并将数据提交给服务器。是一种常见的与服务端数据交互的一种方式</p>
</blockquote>
<ol>
<li><code>action</code>: 指定表单的提交地址（如果提交到当前页面，action 可以为空）</li>
<li><code>method</code>: 指定表单的提交方式，get/post，默认 get</li>
<li><code>input</code> 的数据想要提交到后台，必须指定 name 属性，后台通过 name 属性获取值</li>
<li>想要提交表单，不能使用 <code>input:button</code> 必须使用 <code>input:submit</code></li>
</ol>
<h3 id="php-获取表单数据"><a href="#php-获取表单数据" class="headerlink" title="php 获取表单数据"></a>php 获取表单数据</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $_GET 是 PHP 系统提供的一个超全局变量，是一个数组，里面存放了表单通过 get 方式提交的数据</span></span><br><span class="line"><span class="comment">// $_POST 是 PHP 系统提供的一个超全局变量，是一个数组，里面存放了表单通过 post 方式提交的数据</span></span><br></pre></td></tr></table></figure>
<p><strong>get 与 post 的区别</strong></p>
<ul>
<li><code>get</code> 方式<br>数据会拼接在 url 地址的后面 (?username=pp&amp;password=123456)<br>地址栏有长度限制，因此 get 方式提交数据大小不会超过 4k</li>
<li><code>post</code> 方式<br>数据不会在 url 中显示，相比 get 方式，post 更安全<br>提交的数据没有大小限制，可用于文件上传</li>
</ul>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><strong>html 要求</strong></p>
<ul>
<li><p>文件上传的提交方式必须是 <code>post</code> 方式</p>
</li>
<li><p>需要给 <code>form</code> 指定 <code>enctype=&quot;multipart/form-data&quot;</code></p>
</li>
<li><p>指定 <code>name</code> 属性，后台才能获取到</p>
</li>
</ul>
<p><strong>php 相关</strong></p>
<ul>
<li>文件上传时，通过 <code>$_FILES</code> 才能获取到，这是一个二维数组。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">  [photo] =&gt; <span class="keyword">Array</span></span><br><span class="line">    (</span><br><span class="line">      [name] =&gt; <span class="number">001.</span>jpg   <span class="comment">// 文件名字</span></span><br><span class="line">      [type] =&gt; image/jpeg  <span class="comment">// 文件类型</span></span><br><span class="line">      <span class="comment">// 上传图片保存的位置</span></span><br><span class="line">      [tmp_name] =&gt; C:\Users\Jepson\AppData\Local\Temp\phpF2A0.tmp</span><br><span class="line">      [<span class="built_in">error</span>] =&gt; <span class="number">0</span>     <span class="comment">// 上传错误码, 错误码为 0 表示没有错误</span></span><br><span class="line">      [size] =&gt; <span class="number">6000</span>   <span class="comment">// 文件大小, 单位字节, 大小 6kb 左右</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上传文件时，文件会临时保存在服务器上，如果文件最终没有保存，那么临时文件会被删除，保证服务器安全。</p>
</li>
<li><p><code>sleep(10)</code> 可以让代码延迟 10 秒钟才执行。</p>
</li>
<li><p><code>move_uploaded_file($path, $newPath);</code> 可以转存临时文件，真正把文件存储起来</p>
</li>
<li><p><code>unlink(filename,context)</code> 删除文件，若成功，则返回 true，失败则返回 false</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存图片的完整代码</span></span><br><span class="line"><span class="comment">// 思路:</span></span><br><span class="line"><span class="comment">// 1. 在文件上传成功的情况下, 进行图片的保存   error == 0</span></span><br><span class="line"><span class="comment">// 2. 获取临时文件路径</span></span><br><span class="line"><span class="comment">// 3. 随机生成新的文件名, 注意文件中后缀名是不能改变的</span></span><br><span class="line"><span class="comment">// 4. 根据新的文件名, 转移临时文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;photo&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断上传是否成功</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="variable">$file</span>[<span class="string">&#x27;error&#x27;</span>] == <span class="number">0</span> ) &#123; <span class="comment">// 上传成功</span></span><br><span class="line">  <span class="comment">// 1. 获取临时文件路径</span></span><br><span class="line">  <span class="variable">$ftemp</span> = <span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 随机生成新的文件名, 后缀不能随便起, 要获取一下</span></span><br><span class="line">  <span class="variable">$name</span> = <span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">  <span class="variable">$text</span> = strrchr(<span class="variable">$name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="comment">// 为了防止重复, 生成随机的文件名以当前时间秒数+随机数组成</span></span><br><span class="line">  <span class="variable">$newName</span> = time().rand(<span class="number">10000</span>,<span class="number">99990</span>).<span class="variable">$text</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 进行转存</span></span><br><span class="line">  move_uploaded_file(<span class="variable">$ftemp</span>, <span class="string">&quot;./upload/<span class="subst">$newName</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="学生信息管理系统-1-0"><a href="#学生信息管理系统-1-0" class="headerlink" title="学生信息管理系统 1.0"></a>学生信息管理系统 1.0</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul>
<li>学生添加功能</li>
<li>展示学生信息功能</li>
<li>删除学生信息</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array_splice(数组, 开始的下标, 截取长度) 将匹配到的数据截取掉，会改变原来的数组</span></span><br><span class="line">array_splice(<span class="variable">$arr</span>, <span class="variable">$_GET</span>[<span class="string">&quot;index&quot;</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加内容到数组：将 $stuArr 添加到数组 $arr 中</span></span><br><span class="line"><span class="variable">$arr</span>[] = <span class="variable">$stuArr</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Mysql-数据库"><a href="#Mysql-数据库" class="headerlink" title="Mysql 数据库"></a>Mysql 数据库</h2><h3 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h3><p>专门用来存储、管理数据的仓库 英文：Database, DB。</p>
<h3 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h3><ul>
<li><p>关系型数据库: 基于表，表与表之间可以存在关系，可以进行多表查询的存储方式，适合较为复杂的存储</p>
<p>如: MySQL, SQL Server, oracle</p>
<p>表结构:</p>
<p>每一行代表一条数据 — <strong>记录</strong></p>
<p>每一列都是一类数据 — <strong>字段</strong></p>
<table>
<thead>
<tr>
<th><strong>订单编号</strong></th>
<th><strong>商品名称</strong></th>
<th><strong>价格</strong></th>
<th><strong>数量</strong></th>
</tr>
</thead>
<tbody><tr>
<td>100123</td>
<td>华为 mate10</td>
<td>4999</td>
<td>2</td>
</tr>
<tr>
<td>100124</td>
<td>花裙子</td>
<td>499</td>
<td>1</td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th>订单编号</th>
<th>用户</th>
<th>配送地址</th>
</tr>
</thead>
<tbody><tr>
<td>100123</td>
<td>隔壁老王</td>
<td>北京市京顺路 99 号</td>
</tr>
<tr>
<td>100124</td>
<td>隔壁老宋</td>
<td>北京市清华大学 1 号楼</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>非关系型数据库: 基于键值对的存储方式，数据之间没有耦合性，特点执行效率高</p>
<p>如：mongodb</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似对象的键值对形式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;gblw&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="number">123456</span>,</span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: <span class="number">007</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MySQL-数据库软件"><a href="#MySQL-数据库软件" class="headerlink" title="MySQL 数据库软件"></a>MySQL 数据库软件</h3></li>
</ul>
<blockquote>
<p>MySQL 数据库软件中可以有多个数据库,每一个数据库中可以有多个表</p>
</blockquote>
<h4 id="可视化工具-navicat"><a href="#可视化工具-navicat" class="headerlink" title="可视化工具 navicat"></a>可视化工具 navicat</h4><blockquote>
<p>MySQL 只是一个数据库软件，如果我们要创建数据库，或对数据库进行增删改查，刚开始可以用可视化工具来操作，让我们更加直观的了解数据库</p>
</blockquote>
<h5 id="安装-navicat"><a href="#安装-navicat" class="headerlink" title="安装 navicat"></a>安装 navicat</h5><h5 id="让-navicat-和-MySQL-建立连接"><a href="#让-navicat-和-MySQL-建立连接" class="headerlink" title="让 navicat 和 MySQL 建立连接"></a>让 navicat 和 MySQL 建立连接</h5><p>点击左上角 连接 =&gt; MySQL =&gt; 常规 =&gt; 端口 3306 =&gt;</p>
<h4 id="数据库表的操作"><a href="#数据库表的操作" class="headerlink" title="数据库表的操作"></a>数据库表的操作</h4><h5 id="数据库的数据类型"><a href="#数据库的数据类型" class="headerlink" title="数据库的数据类型"></a>数据库的数据类型</h5><blockquote>
<p>也就是数据库中可以存储的数据类型(又叫做字段类型)</p>
</blockquote>
<p><strong>字段类型</strong></p>
<ul>
<li><p>整型 <code>int</code></p>
<p>​ 存储如年龄，产品数量，编号等。</p>
</li>
<li><p>小数类型 <code>float</code> , <code>decimal</code></p>
<blockquote>
<p>重量，工资，奖金，价格等使用 decimal 类型，实现小数的精确存储,一般用来存储与钱有关的数字。3.333333331</p>
</blockquote>
</li>
<li><p>字符串型 <code>varchar(M)</code>，<code>char(M)</code></p>
<ul>
<li><p>M 为该字段可以存储的最多字符数(字节) ，如 varchar(10)最大可以存储 10 个字节</p>
</li>
<li><p>varchar 一般用来存储长度变化比较大的字符串，如文章标题，商品名称</p>
</li>
<li><p>char 存储长度比较固定的字符串，如手机号，身份证号，序列号，邮编</p>
</li>
<li><p>此外可以使用 text 类型，存储较长的字符串，无需指定字符串的具体长度</p>
</li>
</ul>
</li>
<li><p>日期时间型 <code>datetime</code>, <code>date(年月日)</code>，<code>time(时分秒)</code></p>
</li>
</ul>
<p><strong>字段约束</strong></p>
<p>字段约束: 字段数据的属性规则（特征）</p>
<ol>
<li><p><code>not null</code> 不为空，可以限制字段值不能为空</p>
</li>
<li><p><code>default</code> 默认值，可以设置字段的默认值，在没有录入时自动使用默认值填充。</p>
</li>
<li><p><code>primary key</code> 主键 ：唯一标识，不能重复，不能为空</p>
<p>设置字段为主键，主键字段的值不能重复，不能为空。而且一个数据表中只能设置一个字段为主键，作为每行记录的唯一身份信息（索引）。</p>
</li>
<li><p><code>auto_increment</code> 自动增长</p>
<p>设置字段为自动增长，默认从 1 开始自动分配编号。自增长字段必须为一个 key（索引，数据结构，便于快速查找数据，相当于书的目录），一般与 primary key 结合使用。类型必须为整型。</p>
</li>
<li><p><code>unique key</code> 不能重复</p>
<p>唯一键，设置字段的值为唯一的，可以设置多个字段为唯一键。唯一键字段的值可以为空。</p>
</li>
</ol>
<h5 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h5><blockquote>
<p>注意 创建表时，每个表必须有一个主键</p>
</blockquote>
<h2 id="SQL-操作数据库的语言"><a href="#SQL-操作数据库的语言" class="headerlink" title="SQL-操作数据库的语言"></a>SQL-操作数据库的语言</h2><blockquote>
<p>SQL：structured Query Language 结构化查询语言。</p>
</blockquote>
<ul>
<li>通过这个语言可以对数据库进行增删改查</li>
</ul>
<p>SQL 编写注意点: 注释用 <code>--</code> , 语句结束加分号 <code>;</code></p>
<h3 id="基本用法：增删改查"><a href="#基本用法：增删改查" class="headerlink" title="基本用法：增删改查"></a>基本用法：增删改查</h3><ol>
<li>插入数据 <code>insert</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- insert into 表名 (字段列表) values (值列表)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> book (name, age, sex) <span class="keyword">values</span> (<span class="string">&#x27;zs&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;m&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>修改数据 <code>update</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- update 表名 set 字段名称1=值1,字段名称2=值2,... where 条件</span></span><br><span class="line"><span class="comment">-- 如果不加条件会修改表中所有对应的字段</span></span><br><span class="line"><span class="keyword">update</span> book <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;ls&#x27;</span>, age<span class="operator">=</span><span class="string">&#x27;30&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>删除数据 <code>delete</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- delete from 表名 where 条件</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> book <span class="comment">-- 会删除所有数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> book <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>查询数据 select</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select 字段列表 from 表名</span></span><br><span class="line"><span class="keyword">select</span> name, age <span class="keyword">from</span> book <span class="comment">-- 只查询表中 name 和 author 的信息</span></span><br><span class="line"><span class="comment">-- select * from 表名 where 条件  * 表示所有字段</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> book <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> book <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;zs&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><ul>
<li><p><code>where</code> 条件</p>
<p>查询时，不添加 where 条件, 返回数据表所有行。需要添加限定条件，只返回需要的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select  字段列表 from  表名 where 条件；</span></span><br><span class="line"><span class="comment">-- 条件 : =, &gt;, &lt;, &gt;=, &lt;=, and, or</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>like</code> 模糊匹配  % 通配符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找姓张的人</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span>;​</span><br></pre></td></tr></table></figure></li>
<li><p><code>in</code> 语法：一次查询多个符合条件的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select * from 表名 where 字段 in (value1,value2,value3);</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>); <span class="comment">-- 查找name值为zs, ls, ww 的数据</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>count()</code> 获取返回数据的总条数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询满足条件数据的总条数</span></span><br><span class="line"><span class="comment">-- select count(*) from 表名 where 条件</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>order</code> 排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select * from 表名 order by  字段名称;   	  	默认升序</span></span><br><span class="line"><span class="comment">-- select * from 表名 order by  age;  -- 按照年龄来排序</span></span><br><span class="line"><span class="comment">-- select * from 表名 order by 字段名称 desc;      desc 表示降序</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>limit</code> 对结果集进行截取 一般用于取数据的前几条</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select *  from  表名  limit 截取的起始索引，截取的长度</span></span><br></pre></td></tr></table></figure></li>
<li><p>联合查询（多个表联合查询）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A <span class="keyword">join</span> 表B <span class="keyword">on</span> 表A.字段<span class="operator">=</span>表B.字段 <span class="keyword">where</span> 条件</span><br><span class="line"><span class="keyword">join</span> 将表A和表B联合起来</span><br><span class="line"><span class="keyword">on</span> 根据什么字段把表A和表B联合起来</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span>  teacher  <span class="keyword">join</span> class  <span class="keyword">on</span> class.id<span class="operator">=</span>teacher.classid;  <span class="comment">-- 老师表和班级表联合查询</span></span><br><span class="line"><span class="keyword">select</span> teacher.<span class="operator">*</span>, class.classname  <span class="keyword">from</span>  teacher  <span class="keyword">join</span> class  <span class="keyword">on</span> class.id<span class="operator">=</span>teacher.classid;   <span class="comment">-- 老师表和班级表联合查询,但只显示老师表的全部内容和班级表的名称</span></span><br><span class="line"><span class="comment">-- 注意: 多表联合查询时,字段要写明是那个表的字段 如  表.字段名</span></span><br></pre></td></tr></table></figure>
<h2 id="PHP-操作数据库"><a href="#PHP-操作数据库" class="headerlink" title="PHP 操作数据库"></a>PHP 操作数据库</h2></li>
</ul>
<h3 id="连接数据库基本步骤"><a href="#连接数据库基本步骤" class="headerlink" title="连接数据库基本步骤"></a>连接数据库基本步骤</h3><ol>
<li>连接数据库</li>
<li>准备 sql 语句</li>
<li>执行 sql 语句</li>
<li>获取执行的结果并分析</li>
<li>关闭数据库</li>
</ol>
<h3 id="操作数据库常用-API"><a href="#操作数据库常用-API" class="headerlink" title="操作数据库常用 API"></a>操作数据库常用 API</h3><ul>
<li><p><code>mysqli_connect(IP, 用户名，密码，数据库名)，端口号</code> 连接数据库</p>
</li>
<li><p><code>mysqli_query($link, $sql)</code> 执行 SQL 语句</p>
</li>
<li><p><code>mysqli_error($link);</code> 返回错误描述</p>
</li>
<li><p><code>mysqli_close($link);</code> 关闭连接</p>
</li>
<li><p><code>mysqli_fetch_assoc($res);</code> 从结果集中取得一行作为关联数组返回</p>
</li>
<li><p><code>mysqli_num_rows($res);</code> 返回结果集的行数</p>
</li>
</ul>
<h3 id="sql-操作"><a href="#sql-操作" class="headerlink" title="sql 操作"></a>sql 操作</h3><ul>
<li>使用 PHP 发送 SQL 语句前，可以先打印 SQL 语句，检查语句的正确性。</li>
<li>修改数据库的数据时, 使用变量拼接 SQL 语句=，字段的值为字符串类型时，需要在变量的两侧使用单、双引号包裹。可以将所有的字段外面都使用双引号包含。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 连接数据库</span></span><br><span class="line"><span class="comment">// mysqli_connect(ip地址, 用户名, 密码, 数据库的名称, 端口号);</span></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//    1. 连接成功, 返回一个数据库连接对象</span></span><br><span class="line"><span class="comment">//    2. 连接失败, 返回 false</span></span><br><span class="line"><span class="comment">// @ 表示错误抑制符, 可以抑制错误的输出</span></span><br><span class="line"><span class="variable">$link</span> = @ mysqli_connect(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;study&#x27;</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="comment">// var_dump($link);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果数据库连接失败</span></span><br><span class="line"><span class="keyword">if</span> ( !<span class="variable">$link</span> ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;数据库连接失败&quot;</span>；</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 程序结束, die 方法, 终止当前程序执行, 输出一段语句</span></span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&quot;数据库连接失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;数据库连接成功&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 准备 sql 语句: 删除一条数据</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;delete from stu where id = 14&quot;</span>;</span><br><span class="line"><span class="variable">$name</span> = <span class="string">&quot;gblw&quot;</span>;</span><br><span class="line"><span class="variable">$age</span> = <span class="number">31</span>;</span><br><span class="line"><span class="variable">$sq2</span> = <span class="string">&quot;insert into stu (name, age) values (&#x27;<span class="subst">$name</span>&#x27;, <span class="subst">$age</span>)&quot;</span>;</span><br><span class="line"><span class="comment">// sql 语句一般用双引号包裹</span></span><br><span class="line"><span class="comment">// 如果语句中含有拼接的变量，需要用单引号包裹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 让数据库执行 sql 语句, 并分析结果</span></span><br><span class="line"><span class="comment">// mysqli_query(数据库连接对象, 要执行的sql语句)</span></span><br><span class="line"><span class="comment">// 非查询语句：执行成功返回 true, 执行失败返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 根据结果不同做逻辑判断</span></span><br><span class="line"><span class="keyword">if</span> ( mysqli_query( <span class="variable">$link</span>, <span class="variable">$sql</span> ) ) &#123;</span><br><span class="line">    <span class="comment">// 如果删除的数据不存在，也会返回 true，</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;删除成功&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// sql 语句错误，才会返回 false</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;删除失败&quot;</span>;</span><br><span class="line">    <span class="comment">// mysqli_error 可以查看错误消息</span></span><br><span class="line">    <span class="keyword">echo</span> mysqli_error(<span class="variable">$link</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询语句： 成功返回结果集, 失败返回 false</span></span><br><span class="line"><span class="comment">// 数据查询不到也会返回结果集，只是数据条数为 0，sql 语句有错误才会返回 false</span></span><br><span class="line"><span class="variable">$res2</span> = mysqli_query( <span class="variable">$link</span>, <span class="variable">$sq2</span> );</span><br><span class="line"><span class="comment">// $res2 是返回的结果集,是一个对象，表面上看没有我们要的数据,如果我们想要数据,需要调用mysqli_fetch_assoc($res2)去获取</span></span><br><span class="line"><span class="comment">// 结果集中 field_count 表示字段数，num_rows 表示查询到的数据条数</span></span><br><span class="line"><span class="comment">// 注意: mysqli_fetch_assoc($res2)执行一次,只会从结果集中拿一条数据出来(执行几次就拿出几条数据)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 根据结果不同做逻辑判断</span></span><br><span class="line"><span class="keyword">if</span> ( !<span class="variable">$res</span> ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> mysqli_error( <span class="variable">$link</span> );</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;数据库查询失败&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mysqli_fetch_assoc 查询成功, 从结果集中取数据, 以关联数组的形式返回</span></span><br><span class="line"><span class="comment">// 一次只取一条数据, 如果没取到, 返回 null</span></span><br><span class="line"><span class="variable">$arr</span> = [];</span><br><span class="line"><span class="keyword">while</span>( <span class="variable">$row</span> = mysqli_fetch_assoc( <span class="variable">$res</span> ) ) &#123;</span><br><span class="line">    <span class="comment">// 将值推到数组中</span></span><br><span class="line">    <span class="variable">$arr</span>[] = <span class="variable">$row</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以采用 for 循环遍历</span></span><br><span class="line"><span class="comment">// mysqli_num_rows($res) 方法返回获取到的数据条数 ，</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; mysqli_num_rows(<span class="variable">$res</span>); <span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="comment">// echo $i;</span></span><br><span class="line">    <span class="variable">$arr</span>[] =  mysqli_fetch_assoc(<span class="variable">$res</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// echo &#x27;&lt;pre&gt;&#x27;;</span></span><br><span class="line"><span class="comment">// print_r($arr);</span></span><br><span class="line"><span class="comment">// echo &#x27;&lt;/pre&gt;&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 关闭数据库连接 (挂电话)</span></span><br><span class="line">mysqli_close( <span class="variable">$link</span> );</span><br></pre></td></tr></table></figure>
<h3 id="数据库工具函数的封装"><a href="#数据库工具函数的封装" class="headerlink" title="数据库工具函数的封装"></a>数据库工具函数的封装</h3><blockquote>
<p>为了提高代码的复用性，把数据增删改的操作封装成一个方法</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line">define( <span class="string">&#x27;HOST&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span> );</span><br><span class="line">define( <span class="string">&#x27;UNAME&#x27;</span>, <span class="string">&#x27;root&#x27;</span> );</span><br><span class="line">define( <span class="string">&#x27;PWD&#x27;</span>, <span class="string">&#x27;root&#x27;</span> );</span><br><span class="line">define( <span class="string">&#x27;DB&#x27;</span>, <span class="string">&#x27;test02&#x27;</span> );</span><br><span class="line">define( <span class="string">&#x27;PORT&#x27;</span>, <span class="number">3306</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非查询语句封装</span></span><br><span class="line"><span class="comment">// 封装一个执行非查询语句的方法, 提高代码的复用性</span></span><br><span class="line"><span class="comment">// 参数: $sql 要执行的 sql 语句</span></span><br><span class="line"><span class="comment">// 返回值: true / false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_exec</span>(<span class="params"> <span class="variable">$sql</span> </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 连接数据库</span></span><br><span class="line">  <span class="variable">$link</span> = @ mysqli_connect( HOST, UNAME, PWD, DB, PORT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( !<span class="variable">$link</span> ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;数据库连接失败&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 准备 sql 语句, 就是传递过来的 $sql</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 执行 sql 语句, 分析结果</span></span><br><span class="line">  <span class="keyword">if</span> ( mysqli_query( <span class="variable">$link</span>, <span class="variable">$sql</span> ) ) &#123;</span><br><span class="line">    <span class="comment">// 执行成功</span></span><br><span class="line">    mysqli_close( <span class="variable">$link</span> ); <span class="comment">// 关闭数据库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行失败</span></span><br><span class="line">    mysqli_close( <span class="variable">$link</span> ); <span class="comment">// 关闭数据库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询语句的封装</span></span><br><span class="line"><span class="comment">// 参数: $sql 要执行的 sql 语句</span></span><br><span class="line"><span class="comment">// 返回值:</span></span><br><span class="line"><span class="comment">//    (1) 成功, 返回数据(二维数组)</span></span><br><span class="line"><span class="comment">//    (2) 失败, 返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_query</span>(<span class="params"> <span class="variable">$sql</span> </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 建立连接</span></span><br><span class="line">  <span class="variable">$link</span> = @ mysqli_connect( HOST, UNAME, PWD, DB, PORT );</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="variable">$link</span> ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;数据库连接失败&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 准备 sql 语句 $sql</span></span><br><span class="line">  <span class="comment">// 3. 执行 sql 语句, 分析结果</span></span><br><span class="line">  <span class="variable">$res</span> = mysqli_query( <span class="variable">$link</span>, <span class="variable">$sql</span> );  <span class="comment">// 结果集 或者 false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="variable">$res</span> ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;获取数据失败&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> mysqli_error(<span class="variable">$link</span>);</span><br><span class="line">    mysqli_close( <span class="variable">$link</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到结果集, 将结果集的所有内容取出到数组中</span></span><br><span class="line">  <span class="variable">$arr</span> = [];</span><br><span class="line">  <span class="keyword">while</span> ( <span class="variable">$row</span> = mysqli_fetch_assoc(<span class="variable">$res</span>) ) &#123;</span><br><span class="line">    <span class="variable">$arr</span>[] = <span class="variable">$row</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mysqli_close( <span class="variable">$link</span> );</span><br><span class="line">  <span class="keyword">return</span> <span class="variable">$arr</span>; <span class="comment">// 返回结果数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="学生管理系统-2-0"><a href="#学生管理系统-2-0" class="headerlink" title="学生管理系统 2.0"></a>学生管理系统 2.0</h2><h3 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h3><ul>
<li>添加学生功能</li>
<li>展示学生列表功能</li>
<li>删除学生功能</li>
<li>查看学生详情</li>
<li>更新学生数据</li>
</ul>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p><strong>注册功能思路：</strong></p>
<ol>
<li>表单设计，点击提交按钮向服务器提交表单数据</li>
<li>在后台获取表单提交的数据，保存到数据库中<ul>
<li>先获取表单的标签的数据</li>
<li>保存上传的图片（并保存图片存储的路径）</li>
<li>将表单的数据和图片的路径一起保存到数据库中</li>
</ul>
</li>
<li>保存完成，跳转到列表页，查看新添加的数据</li>
</ol>
<p><strong>展示功能思路：</strong></p>
<ol>
<li>先从数据库中获取数据（二维数组 arr）</li>
<li>遍历二维数组，将数组中数据渲染到页面中</li>
</ol>
<p><strong>删除功能思路：</strong></p>
<ol>
<li>获取要删除数据的 id</li>
<li>根据 id 删除数据库中指定的数据</li>
<li>删除完毕，返回列表页</li>
</ol>
<p><strong>详情展示功能</strong></p>
<ol>
<li>获取要查看详情数据的 id</li>
<li>根据 id 通过联合查询，获取到需要用数据</li>
<li>把数据显示在页面中</li>
<li>点击返回按钮，可以返回到列表页</li>
</ol>
<p><strong>更新数据思路：</strong><br>更新数据的思路=先渲染再提交</p>
<ol>
<li>获取要查看详情数据的 id</li>
<li>把对应 id 的数据填充到修改页面中</li>
<li>点击修改按钮，获取表单的数据，提交给服务器</li>
<li>在服务器更新数据</li>
<li>更新完成后跳转到列表页</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">隐藏域表单：和其他表单标签一样，只是看不到而已</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;?php echo $data[&#x27;id&#x27;] ?&gt;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/1652.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1652.html" class="post-title-link" itemprop="url">javascript 高级</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-18 14:34:36" itemprop="dateCreated datePublished" datetime="2018-10-18T14:34:36+00:00">2018-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102204500.png"></p>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>Everything is object （万物皆对象）</p>
</blockquote>
<p>对象到底是什么，我们可以从两次层次来理解</p>
<p><strong>(1) 对象是具体事物的抽象</strong></p>
<p>一本书、一辆汽车、一个人都可以是对象，当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程</p>
<p>问： 书是对象吗</p>
<p><strong>(2)对象是无序键值对的集合，其属性可以包含基本值、对象或者函数</strong></p>
<p>每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型</p>
<h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p>面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想</p>
<p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务<br>因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目</p>
<p><strong>面向对象与面向过程：</strong></p>
<ul>
<li>面向过程就是亲历亲为，事无巨细，有条不紊，面向过程是解决问题的一种思维方式，（执行者的角度）<ul>
<li>关注点在于解决问题的过程（先 xx，然后 xx，在 xx）</li>
</ul>
</li>
<li>面向对象就是找一个对象，让她去做这件事情（指挥者的角度）<ul>
<li>关注点在找到能解决问题的对象上</li>
</ul>
</li>
<li>面向对象不是面向过程的替代，而是面向过程的封装</li>
</ul>
<p><strong>面向对象的特性：</strong></p>
<ul>
<li>封装性<ul>
<li>将功能的具体实现，全部封装到对象的内部，外界使用对象时，只需要关注对象提供的方法如何使用，而不需要关心对象的内部具体实现，这就是封装</li>
</ul>
</li>
<li>继承性<ul>
<li>在 js 中，继承的概念很简单，一个对象没有的一些属性和方法，另外一个对象有，拿过来用，就实现了继承</li>
<li><strong>注意：在其他语言里面，继承是类与类之间的关系，在 js 中，是对象与对象之间的关系</strong></li>
</ul>
</li>
<li>[多态性]<ul>
<li>多态是在强类型的语言中才有的；js 是弱类型语言，所以 js 不支持多态</li>
</ul>
</li>
</ul>
<h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><h3 id="内置构造函数创建"><a href="#内置构造函数创建" class="headerlink" title="内置构造函数创建"></a>内置构造函数创建</h3><p>我们可以直接通过 <code>new Object()</code> 创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 js 中，对象有动态特性，可以随时的给一个对象增加属性或者删除属性</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">person.age = <span class="number">18</span></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：麻烦，每个属性都需要添加</p>
<h3 id="对象字面量创建"><a href="#对象字面量创建" class="headerlink" title="对象字面量创建"></a>对象字面量创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：无法批量生成多个对象，代码冗余</p>
<h3 id="简单改进：工厂函数"><a href="#简单改进：工厂函数" class="headerlink" title="简单改进：工厂函数"></a>简单改进：工厂函数</h3><p>我们可以写一个函数，解决代码重复问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后生成实例对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">&#x27;ls&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>缺点：没有解决对象识别的问题，创建出来的对象都是 Object 类型的</p>
<h3 id="继续改进：自定义构造函数"><a href="#继续改进：自定义构造函数" class="headerlink" title="继续改进：自定义构造函数"></a>继续改进：自定义构造函数</h3><p>构造函数是一个函数，用于实例化对象，需要配合 new 操作符使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">p1.sayName() <span class="comment">// zs</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;ls&#x27;</span>, <span class="number">23</span>)</span><br><span class="line">p2.sayName() <span class="comment">// ls</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3><p>使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;ls&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello &#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.sayHello = sayHello</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;ls&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>缺点：会暴漏很多的函数，容易造成全局变量污染</p>
<blockquote>
<p>术语：</p>
<ol>
<li>实例（实例对象）：通过构造函数创建出来的对象，叫做实例，实例可以有多个</li>
<li>实例化：构造函数创建对象的过程</li>
<li>成员：对象的属性和方法</li>
</ol>
</blockquote>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型基本概念"><a href="#原型基本概念" class="headerlink" title="原型基本概念"></a>原型基本概念</h3><p>Javascript 规定，每一个函数都有一个 <code>prototype</code> 属性，属性值是一个对象，这个对象就叫做原型（原型对象），这个对象的所有属性和方法，都会被构造函数的实例继承</p>
<p>这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 <code>prototype</code> 对象上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(...)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(...)</span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这时所有实例的 <code>sayName()</code> 方法，其实都指向同一个内存地址</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p>任意对象都有 <code>__proto__</code> 属性，这个属性指向了构造函数的 prototype 属性，也就是原型对象</p>
<p>获取原型对象：</p>
<ul>
<li>通过 <code>构造函数.prototype</code> 可以获取</li>
<li>通过 <code>实例.__proto__</code> 可以获取（隐式原型）</li>
<li>它们指向了同一个对象 <code>构造函数.prototype === 实例.__proto__</code></li>
</ul>
<p><strong>注意：<code>__proto__</code>是浏览器的一个隐藏（私有）属性，IE 浏览器不支持，不要通过它来修改原型里的内容，如果要修改原型中的内容，使用 <code>构造函数.prototype</code> 去修改</strong></p>
<h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>默认情况下，原型对象中只包含了一个属性：constructor，constructor 属性指向了当前原型对象的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor) <span class="comment">// 构造函数本身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="comment">// p 实例对象没有constructor 属性， 该属性来源于原型上</span></span><br><span class="line"><span class="built_in">console</span>.log(p.constructor == Person.prototype.constructor) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数、实例、原型三者之间的关系"><a href="#构造函数、实例、原型三者之间的关系" class="headerlink" title="构造函数、实例、原型三者之间的关系"></a>构造函数、实例、原型三者之间的关系</h3><p>构造函数：构造函数就是一个函数，配合 new 可以新建对象</p>
<p>实例：通过构造函数实例化出来的对象我们把它叫做构造函数的实例。一个构造函数可以有很多实例</p>
<p>原型：每一个构造函数都有一个属性<code>prototype</code>，函数的 prototype 属性值就是原型。通过构造函数创建出来的实例能够直接使用原型上的属性和方法</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102204519.png"></p>
<p>原型三角关系：</p>
<ul>
<li><p>构造函数和原型：配偶关系</p>
<ul>
<li>构造函数（妈妈），通过 prototype 属性访问原型（爸爸）</li>
<li>原型通过 constructor 属性访问到构造函数</li>
</ul>
</li>
<li><p>构造函数 和 实例对象：母子关系</p>
<ul>
<li>构造函数可以创建实例对象</li>
<li>实例对象不能直接访问到构造函数</li>
</ul>
</li>
<li><p>原型 和 实例对象关系：父子关系</p>
<ul>
<li>实例对象可以直接访问到原型上的所有成员</li>
<li>实例对象可以间接的访问到构造函数（通过原型上的 constructor 属性）</li>
</ul>
</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="原型链概念"><a href="#原型链概念" class="headerlink" title="原型链概念"></a>原型链概念</h3><p>任何一个对象，都有原型对象，原型对象本身又是一个对象，所以原型对象也有自己的原型对象，这样形成的链式结构，就是原型链</p>
<p>绘制对象的原型链结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// p ==&gt; Person.prototype  ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="comment">// o ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="comment">// arr ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Math 是个内置对象，不是个构造函数</span></span><br><span class="line"><span class="comment">// Math ==&gt; Object.prototype ==&gt; null</span></span><br></pre></td></tr></table></figure>
<p>总结：Object.prototype 是原型链的尽头，Object.prototype 的原型是 null</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102204539.png"></p>
<h3 id="属性查找原则"><a href="#属性查找原则" class="headerlink" title="属性查找原则"></a>属性查找原则</h3><p><strong>属性搜索（查找）原则： 沿着原型链进行查找</strong></p>
<ol>
<li>首先在当前对象上查找是否有该属性，如果有，直接返回属性值</li>
<li>如果没有，去对象的原型上查找，如果有，直接返回属性值</li>
<li>如果也没有， 沿着原型链进行查找，直到 Object.prototype ，如果找到了，就返回属性值，如果还没有，返回 undefined</li>
</ol>
<p><strong>属性修改（设置）原则：</strong></p>
<ol>
<li>只会修改对象自身的属性</li>
<li>如果自身没有这个属性，那么就会添加这个属性，并不会修改原型中的属性</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;ls&#x27;</span>, <span class="number">19</span>)</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// p 的原型链：</span></span><br><span class="line"><span class="comment">// p ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// ls</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age) <span class="comment">// 19</span></span><br><span class="line"><span class="built_in">console</span>.log(p.gender) <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(p.sex) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.age) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// p1 对象依旧有 name 和age 属性， 只不过属性值都是 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.gender) <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sex) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">p.gender = <span class="string">&#x27;不详&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.gender) <span class="comment">// 不详</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">&#x27;ww&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// ww</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-prototype-成员介绍"><a href="#Object-prototype-成员介绍" class="headerlink" title="Object.prototype 成员介绍"></a>Object.prototype 成员介绍</h3><blockquote>
<p>任何对象的原型链上都有 Object.prototype，根据属性搜索原则(沿着原型链进行查找)，任何对象都可以访问到 Object.prototype 上的成员</p>
</blockquote>
<p>constructor：指向了构造函数 Object</p>
<h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a><code>hasOwnProperty</code></h4><p><code>hasOwnProperty()</code> 方法会返回一个布尔值，判断对象自身是否具有该属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断name属性是不是obj自己提供的</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong><code>hasOwnProperty</code> 与 <code>in</code> 的区别</strong></p>
<ol>
<li><p><code>in</code> 操作符：判断对象能否访问到该属性（不管这个属性是自己提供的，还是从原型上继承来的），如果可以访问到， 都会返回 true</p>
</li>
<li><p><code>hasOwnProperty</code>：该属性必须是自己提供，才返回 true，否则返回 false</p>
</li>
</ol>
<p><strong>hasOwnProperty 的使用场景</strong>：用在 for…in 循环中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> p) &#123;</span><br><span class="line">  <span class="comment">// 可以遍历到对象自身的属性以及对象原型链上的属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只遍历得到对象自身的属性，if 条件过滤下</span></span><br><span class="line">  <span class="comment">// if (p.hasOwnProperty(k)) &#123;</span></span><br><span class="line">  <span class="comment">// 		console.log(k)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf"></a><code>isPrototypeOf</code></h4><p><code>isPrototypeOf()</code> 方法用于测试一个对象是否存在于另一个对象的原型链上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 A 对象是否在 B 对象的原型链上</span></span><br><span class="line"><span class="comment">// 返回值：true，在原型链上  false：不在原型链上</span></span><br><span class="line">A.isPrototetypeOf(B)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="comment">// p 的原型链：</span></span><br><span class="line"><span class="comment">// p ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.isPrototypeOf(p)) <span class="comment">// false Person 是构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(p)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(p)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong><code>isPropertyOf</code> 与 <code>instanceof</code> 运算符的区别</strong></p>
<p><code>instanceof</code> 运算符用来测试一个对象的原型链中是否存在一个构造函数的 <code>prototype</code> 属性。作用和 isPrototypeOf 类似</p>
<p>语法： 实例对象 instanceof 构造函数</p>
<p>作用：构造函数的 prototype 属性是否在实例对象的原型链上</p>
<ul>
<li>A.isPrototypeOf(B) 判断 A 是否在 B 的原型链上 A： 是一个原型对象</li>
<li>B instanceof A 判断 A 的 prototype 是否在 B 的原型链上 A：是一个构造函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isPrototypeOf([])) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.isPrototypeOf([])) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>.prototype) <span class="comment">// 语法错误，instanceof 的右边是个构造函数</span></span><br></pre></td></tr></table></figure>
<h4 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title="propertyIsEnumerable"></a><code>propertyIsEnumerable</code></h4><p><code>propertyIsEnumerable()</code> 方法返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">19</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;lw&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.propertyIsEnumerable(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.propertyIsEnumerable(<span class="string">&#x27;age&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>拓展：给对象添加不可遍历的属性 : <code>Object.defineProperty()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法： Object.defineProperty(obj, prop, desc)</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// obj： 给哪个对象添加属性</span></span><br><span class="line"><span class="comment">// prop：属性， 类型是字符串</span></span><br><span class="line"><span class="comment">// desc： 属性描述符， 类型是个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作用： 定义对象的属性特征</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给obj 添加一个不可遍历的 gender 属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;gender&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="string">&#x27;female&#x27;</span>, <span class="comment">// 配置该属性的默认值</span></span><br><span class="line">  writable: <span class="literal">true</span>, <span class="comment">// 配置该属性是否可以被修改， 默认值是false， 不可修改</span></span><br><span class="line">  enumerable: <span class="literal">true</span> <span class="comment">// 配置该属性是否可遍历， 默认值是false， 不可遍历</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj.propertyIsEnumerable(<span class="string">&#x27;gender&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="toString-toLocaleString"><a href="#toString-toLocaleString" class="headerlink" title="toString/toLocaleString"></a>toString/toLocaleString</h4><p>返回对象的字符串格式</p>
<blockquote>
<p>每个内置对象的原型上都有属于自己的 toString 方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.toString()) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.toLocaleString()) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// arr ==&gt;  Array.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="comment">//           toString()         toString()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype) <span class="comment">// 含有自己的 toString 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// &#x27;1,2,3&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toLocaleString()) <span class="comment">// &#x27;1,2,3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">//  date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="comment">//           toString()          toString()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype) <span class="comment">// 含有自己的 toString 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toString()) <span class="comment">// Wed Oct 10 2018 16:00:51 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toLocaleString()) <span class="comment">// 2018/10/10 下午4:00:51 得到的是本地时间格式</span></span><br></pre></td></tr></table></figure>
<h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h4><p>语法：对象.valueOf()</p>
<p>作用： 返回对象的原始值（简单数据类型），默认的 valueOf 方法（Object.prototype 上的 valueOf 方法）只会返回对象自身；日期对象的 valueOf 方法返回的是时间戳，因为 Date 的原型链上有自己的 valueOf 方法，该 valueOf 的作用就是返回日期的时间戳</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.valueOf()) <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// arr ==&gt;  Array.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.valueOf()) <span class="comment">// arr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">// date 原型链</span></span><br><span class="line"><span class="comment">// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype) <span class="comment">// 含有 valueOf 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(date.valueOf()) <span class="comment">// 时间戳</span></span><br></pre></td></tr></table></figure>
<h4 id="valueOf-和-toString-的应用"><a href="#valueOf-和-toString-的应用" class="headerlink" title="valueOf 和 toString 的应用"></a>valueOf 和 toString 的应用</h4><p>当对象在参与运算和比较的时候，js 内部会自动的调用 valueOf 和 toString 方法</p>
<p>调用规则：</p>
<ol>
<li><p>默认先调用 vauleOf， 尝试将对象转成简单数据类型， 如果没有转成简单数据类型， 会继续在调用 toString 方法</p>
</li>
<li><p>如果 valueOf 和 toString 方法都没有转成简单数据类型，会报错</p>
</li>
</ol>
<h2 id="沙箱模式"><a href="#沙箱模式" class="headerlink" title="沙箱模式"></a>沙箱模式</h2><p>沙箱其实就是一个独立的环境，这个环境中任何的改变，都不会对外部环境产生影响</p>
<p>函数自调用一样，在自调用函数内部的变量是不会影响到外部的，因此<strong>函数自调用模式也叫沙箱模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;这是fn函数&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>代码写在自调用函数里面，减少全局污染</li>
<li>想要在外面使用 fn 函数，可将 fn 暴露到全局 <code>window.fn = fn;</code> 将 fn 函数的地址赋值给了 window 上的 fn 属性</li>
<li>一般，我们一个 js 文件只会暴露一个核心的功能（函数、方法）： 目的还是为了减少全局污染</li>
</ol>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><ul>
<li>语法：<code>&#39;use strict&#39;</code></li>
<li>作用：让 js 引擎以更加严格的模式执行 js 代码</li>
<li>最佳实践：在某个函数内部开启严格模式，而不是在全局环境中开启</li>
<li>注意：<ul>
<li>严格模式只对当前作用域起作用</li>
<li>应该<strong>在当前作用域最顶端使用<code>use strict</code>，否则严格模式无效</strong></li>
</ul>
</li>
<li>使用严格模式好处：<ul>
<li>规范</li>
<li>提高代码执行效率</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格模式应该配合沙箱模式一起使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 沙箱模式 + 严格模式：</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h3 id="严格模式规定"><a href="#严格模式规定" class="headerlink" title="严格模式规定"></a>严格模式规定</h3><ul>
<li>变量必须显示声明</li>
<li>函数参数不能重名</li>
<li>禁止使用八进制</li>
<li>不能使用保留字作为变量名称：<code>implements, interface, let, package, private, protected, public, static, yield</code></li>
<li>如果不符合上述规范，会直接报错</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>继承：子承父业</p>
</blockquote>
<p>在 js 中的继承概念非常简单，拿来主义：一个对象自己没有的属性和方法，另一个对象有，拿过来使用，就实现了继承。</p>
<p>继承的目的：让一个对象可以使用另一个对象的属性和方法。</p>
<h3 id="混入式继承（mixin）"><a href="#混入式继承（mixin）" class="headerlink" title="混入式继承（mixin）"></a>混入式继承（mixin）</h3><blockquote>
<p>把一个对象中的属性和方法拷贝到另一个对象中。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ls = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  extend: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 只拷贝对象obj自身的成员，原型链上的成员不用拷贝给this</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">      <span class="built_in">this</span>[k] = obj[k]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>一个对象可以访问构造函数的原型中的属性和方法，那么如果想要让一个对象增加某些属性和方法，</p>
<p>只需要把这些属性和方法放到原型对象中即可。这样就实现了继承, 称之为原型链继承</p>
<ul>
<li>直接给原型增加属性和方法</li>
<li>原型替换（注意：constructor）</li>
<li>mixin+原型替换</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 直接给原型增加属性和方法（麻烦）</span></span><br><span class="line">Person.prototype.color = <span class="string">&#x27;lime&#x27;</span></span><br><span class="line">Person.prototype.legs = <span class="number">2</span></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;sayHi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 原型替换，将原型替换成一个对象</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="comment">// 手动添加一个constructor属性，如果不手动添加，会找到 Object 的 constructor 属性</span></span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title">color</span>: &#x27;<span class="title">lime</span>&#x27;,</span><br><span class="line">  <span class="title">legs</span>: 2,</span><br><span class="line">  <span class="title">sayHi</span>: <span class="title">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;sayHi&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 原型链 + 混入式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> lw = &#123;</span><br><span class="line">  skill: <span class="string">&#x27;翻墙&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给原型添加 extend 方法  -- 混入式继承</span></span><br><span class="line">Person.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">      <span class="built_in">this</span>[k] = obj[k]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把 lw 的成员添加到了 Person 的原型上， Person 的实例就可以访问到原型上的这个成员</span></span><br><span class="line">Person.prototype.extend(lw)</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p.skill)</span><br></pre></td></tr></table></figure>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">MDN</a></p>
<blockquote>
<p>最初是由道格拉斯丶克罗克福德发布的一篇文章提出的，ECMAScript5 新增了 Object.create() 方法来规范化了这种继承</p>
</blockquote>
<p>ES5 中新增 <code>Object.create()</code> 创建新对象， 使用指定的原型对象来提供新创建的对象的 <code>__proto__</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="built_in">Object</span>.create(proto[, propertiesObject])</span><br><span class="line"><span class="comment">// 参数：proto 一个对象,新创建对象的原型对象</span></span><br><span class="line"><span class="comment">// 参数：propertiesObject 要添加到新创建对象的可枚举属性</span></span><br><span class="line"><span class="comment">// 返回值：一个新对象，带着指定的原型对象和属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(proto)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>
<p>使用 <code>Object.create()</code> 来实现继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Shape - 父类(superclass)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">0</span></span><br><span class="line">  <span class="built_in">this</span>.y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类的方法</span></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x += x</span><br><span class="line">  <span class="built_in">this</span>.y += y</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">&#x27;Shape moved.&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle - 子类(subclass)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="built_in">this</span>) <span class="comment">// call super constructor. 继承父类的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类续承父类</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype) <span class="comment">// 将父类的原型赋值给了子类</span></span><br><span class="line">Rectangle.prototype.constructor = Rectangle</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Is rect an instance of Rectangle?&#x27;</span>, rect <span class="keyword">instanceof</span> Rectangle) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Is rect an instance of Shape?&#x27;</span>, rect <span class="keyword">instanceof</span> Shape) <span class="comment">// true</span></span><br><span class="line">rect.move(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// Outputs, &#x27;Shape moved.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果你希望能继承到多个对象，则可以使用混入的方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>)</span><br><span class="line">  OtherSuperClass.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype)</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype)</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do a thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="定义函数的三种方式"><a href="#定义函数的三种方式" class="headerlink" title="定义函数的三种方式"></a>定义函数的三种方式</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn() <span class="comment">// 函数声明可以先调用，在声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;这是函数声明&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;这是函数表达式&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 函数表达式必须先声明，再调用</span></span><br></pre></td></tr></table></figure>
<h4 id="构造函数-Function"><a href="#构造函数-Function" class="headerlink" title="构造函数 Function"></a>构造函数 Function</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数也是对象，可以使用 Function 构造函数 new 出来</span></span><br><span class="line"><span class="comment">// 相当于var fn = function () &#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法：new Function(arg1,arg2,arg3..,body)</span></span><br><span class="line"><span class="comment">// 1. 所有的参数都是字符串类型</span></span><br><span class="line"><span class="comment">// 2. 前面可以定义任意多个形参，最后一个参数是代码体</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;alert(1)&#x27;</span>)</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;alert(a1 + a2)&#x27;</span>)</span><br><span class="line">fn1(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>【案例：代码实时预览效果.html】</p>
<h4 id="eval-函数–了解"><a href="#eval-函数–了解" class="headerlink" title="eval 函数–了解"></a>eval 函数–了解</h4><blockquote>
<p>eval 可以和 new Function 一样，执行字符串代码</p>
</blockquote>
<p>注意：eval 函数的功能非常的强大，但是实际使用的情况并不多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var num = 10; console.log(num)&#x27;</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>eval 形式的代码难以阅读</li>
<li>eval 形式的代码无法打断点，因为本质还是还是一个字符串</li>
<li>在浏览器端执行任意的 JavaScript 会带来潜在的安全风险，恶意的 JavaScript 代码可能会破坏应用，特别是在用它执行用户输入数据的情况下。可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）<br><a target="_blank" rel="noopener" href="http://qingbob.com/Excess-XSS/">推荐了解下 xss 攻击</a></li>
</ul>
<h3 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h3><p>分析 this 指向问题</p>
<ol>
<li>任何函数都有属于自己的 this</li>
<li>this 是动态的，this 在函数声明的时候是确定不了的，只有当函数被调用了才能够确定 this 的指向，this 的指向和函数在哪被调用没有关系</li>
</ol>
<p>分析 this 的问题的思路：</p>
<ol>
<li>this 是属于哪个函数</li>
<li><strong>这个函数是何种调用模式</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数：当一个函数不是一个对象的属性时，我们称之为函数</span><br><span class="line">方法：当一个函数被保存为对象的一个属性时，我们称之为方法</span><br></pre></td></tr></table></figure>
<h4 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h4><p><font color="red">如果一个函数不是一个对象的属性时，就是被当做一个函数来进行调用的。此时 this 指向了 window</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数名() 的调用方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// 指向window</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<h4 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h4><p><font color="red">当一个函数被保存为对象的一个属性时，我们称之为一个方法。当一个方法被调用时，this 被绑定到当前对象</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过点语法或者中括号语法来访问方法，都是属于方法调用模式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  fn: f</span><br><span class="line">&#125;</span><br><span class="line">obj.fn() <span class="comment">// obj</span></span><br><span class="line">obj[<span class="string">&#x27;fn&#x27;</span>]() <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [f, <span class="number">10</span>, <span class="number">30</span>]</span><br><span class="line"><span class="comment">// 也是方法调用模式</span></span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">// arr</span></span><br></pre></td></tr></table></figure>
<h4 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h4><p><font color="red">如果函数是通过 new 关键字进行调用的，此时 this 被绑定到创建出来的新对象上</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Person() <span class="comment">// this 指向 window</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person() <span class="comment">// this 指向 p</span></span><br></pre></td></tr></table></figure>
<p><strong>总结：分析 this 的问题，主要就是区分函数的调用模式，看函数是怎么被调用的</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分析思路：1. 看 this 是哪个函数的  2. 看这个函数是怎么调用的，处于什么调用模式</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">38</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = obj.getAge</span><br><span class="line">f() <span class="comment">// window ==&gt; 38</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">38</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age) <span class="comment">// obj ==&gt; 18</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.age) <span class="comment">// window ==&gt; 38</span></span><br><span class="line">    &#125;</span><br><span class="line">    foo()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getAge()</span><br><span class="line"><span class="comment">// obj[&#x27;getAg&#x27;]()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [fn, <span class="string">&#x27;222&#x27;</span>]</span><br><span class="line">fn() <span class="comment">// 10</span></span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">5</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn() <span class="comment">// window ==&gt; 10</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>]() <span class="comment">// argument ==&gt; 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.method(fn, <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.</span></span><br><span class="line"><span class="keyword">let</span> len = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.len)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// window ==&gt; undefined</span></span><br><span class="line"><span class="keyword">let</span> Person = &#123;</span><br><span class="line">  len: <span class="number">5</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn() <span class="comment">// window ==&gt; undefined</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>]() <span class="comment">// arguments ==&gt; undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.say(fn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="function">() =&gt;</span> <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。</span></span><br><span class="line"><span class="comment">// 将返回的函数的引用赋值给fn。</span></span><br><span class="line"><span class="keyword">var</span> fn = obj.bar()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用fn而不设置this，</span></span><br><span class="line"><span class="comment">// 通常(即不使用箭头函数的情况)默认为全局对象</span></span><br><span class="line"><span class="comment">// 若在严格模式则为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(fn() === obj) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是注意，如果你只是引用obj的方法，</span></span><br><span class="line"><span class="comment">// 而没有调用它</span></span><br><span class="line"><span class="keyword">var</span> fn2 = obj.bar</span><br><span class="line"><span class="comment">// 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。</span></span><br><span class="line"><span class="built_in">console</span>.log(fn2()() == <span class="built_in">window</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="方法借用模式"><a href="#方法借用模式" class="headerlink" title="方法借用模式"></a>方法借用模式</h4><blockquote>
<p>上下文调用模式也叫方法借用模式，分为 apply，call ，bind</p>
<p>使用方法：<code>函数.call()</code> 或者 <code>函数.apply()</code></p>
</blockquote>
<p>任何函数都可以调用 apply，call ，bind 这三个方法</p>
<h5 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a>call 方法</h5><p>call 方法可以调用一个函数，并且可以指定这个函数的 <code>this</code> 指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call 方法也可以和 () 一样，进行函数调用</span></span><br><span class="line"><span class="comment">// 第一个参数：指定函数的 this，如果不传，则 this 指向 window</span></span><br><span class="line"><span class="comment">// 其余参数：和函数的参数列表一模一样</span></span><br><span class="line"><span class="keyword">var</span> zs = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello ,我是&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// zs.sayHi()</span></span><br><span class="line"><span class="keyword">var</span> ls = &#123;</span><br><span class="line">  name: <span class="string">&#x27;ls&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ls 借用 zs 的 sayHi 方法</span></span><br><span class="line">zs.sayHi.call(ls)</span><br></pre></td></tr></table></figure>
<h5 id="伪数组与数组"><a href="#伪数组与数组" class="headerlink" title="伪数组与数组"></a>伪数组与数组</h5><blockquote>
<p>伪数组也叫类数组</p>
</blockquote>
<ol>
<li>伪数组其实就是一个对象，但是跟数组一样，伪数组也会有<code>length</code>属性，也有<code>0, 1, 2, 3</code>等属性</li>
<li>伪数组并没有数组的方法，不能使用<code>push/pop</code>等方法</li>
<li>伪数组可以跟数组一样进行遍历，通过下标操作</li>
<li>常见的伪数组：<code>arguments</code>、<code>document.getElementsByTagName的返回值</code>、<code>jQuery对象</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;ls&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;ww&#x27;</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>伪数组借用数组的方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给 obj 添加一项 3: &#x27;zl&#x27;</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(obj, <span class="string">&#x27;zl&#x27;</span>)</span><br><span class="line"><span class="comment">// 把 obj 中的每一项使用 &#x27;-&#x27; 拼接起来返回一个字符串</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(obj, <span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>将伪数组转换成真数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(obj)</span><br></pre></td></tr></table></figure>
<h5 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a>apply 方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply 的语法：</span><br><span class="line">apply(thisArg, 实参列表)</span><br><span class="line">thisArg &#x3D;&#x3D;&gt; 改变函数内的 this 指向的</span><br><span class="line">实参列表 &#x3D;&#x3D;&gt; 是一个数组或者是伪数组</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>apply()</code>方法的作用和 <code>call()</code>方法类似，只有一个区别，就是<code>apply()</code>方法接受的是<strong>一个包含多个参数的数组</strong>。而<code>call()</code>方法接受的是<strong>若干个参数的列表</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. apply 能够调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.apply() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. apply 改变 this 指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.apply([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]) <span class="comment">// [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. apply 第二个参数是数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(n1 + n2)</span><br><span class="line">&#125;</span><br><span class="line">fn.apply(&#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span> &#125;, [<span class="number">10</span>, <span class="number">20</span>]) <span class="comment">// &#123;name: &#x27;zs&#x27;&#125;, 30</span></span><br><span class="line"><span class="comment">// apply 的特性： 平铺性，把数组中的每一项取出来作为函数的实参</span></span><br><span class="line"><span class="comment">// fn.call(&#123;name: &#x27;ls&#x27;&#125;, 10, 20) // &#123;&#125;, 30</span></span><br></pre></td></tr></table></figure>
<p>call 和 apply 的使用场景：</p>
<ul>
<li>如果参数比较少，使用 call 会更加简洁</li>
<li>如果参数存放在数组中，此时需要使用 apply</li>
</ul>
<p>课后练习：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">求数组的最大值和最小值</span><br><span class="line">封装一个函数，能够打印出来所有的参数</span><br></pre></td></tr></table></figure>
<h5 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h5><p><strong>bind()</strong> 方法创建一个新的函数、可以绑定新的函数的 <code>this</code> 指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值：新的函数(不会被调用)</span></span><br><span class="line"><span class="comment">// 参数：新函数的 this 指向，当绑定了新函数的 this 指向后，无论使用何种调用模式，this 都不会改变</span></span><br><span class="line"><span class="comment">// var newFn = fn.bind(window)</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newFn = fn.bind([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// newFn 是 bind 创建并返回出来的</span></span><br><span class="line"><span class="built_in">console</span>.log(newFn)</span><br><span class="line">newFn() <span class="comment">// this ==&gt; [1,2,3]</span></span><br></pre></td></tr></table></figure>
<p>如果对一个函数进行多次 bind，那么上下文会是什么呢</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.bind().bind(a)() <span class="comment">// =&gt; ?</span></span><br></pre></td></tr></table></figure>
<p>如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply()</span><br><span class="line">  &#125;.apply(a)</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>
<p>可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。</p>
<h4 id="特殊的-this-指向"><a href="#特殊的-this-指向" class="headerlink" title="特殊的 this 指向"></a>特殊的 this 指向</h4><ul>
<li>定时器中的 this 指向了 window，因为定时器的 function 最终是由 window 来调用的</li>
<li>事件中的 this 指向的是当前的元素，在事件触发的时候，浏览器让当前元素调用了 function</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call apply bind 第一个参数表示要绑定的 this</span><br><span class="line">不传，传 null，或者 undefined ，this 均指向 window</span><br><span class="line">但在严格模式下，不传指向 undefined，传 null 指向 null，传 undefined 指向 undefined</span><br></pre></td></tr></table></figure>
<h3 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h3><blockquote>
<p>函数是由 new Function 创建出来的，因此函数也是一个对象，<code>所有的函数都是 new Function 的实例</code></p>
</blockquote>
<h4 id="函数的原型链结构"><a href="#函数的原型链结构" class="headerlink" title="函数的原型链结构"></a>函数的原型链结构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部：var Person = new Function()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Person 实例对象的原型链：</span></span><br><span class="line"><span class="comment">// Person ==&gt; Function.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="comment">// Function.prototype 原型类型是个函数</span></span><br><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">Function</span>.prototype)</span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102204558.jpeg"></p>
<h4 id="Function-prototype-成员"><a href="#Function-prototype-成员" class="headerlink" title="Function.prototype 成员"></a>Function.prototype 成员</h4><ul>
<li>arguments：获取函数的实参，已经被废弃了，现在推荐的做法是使用函数内部可用的  <code>arguments</code>对象来访问函数的实参<ul>
<li>（废弃的意思：已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性）</li>
</ul>
</li>
<li>length：获取形参的长度</li>
<li>name：获取函数的名字，此属性不允许修改</li>
<li>caller: 用于获取当前函数是在哪个函数中调用的，已经被废弃了</li>
<li>constructor：指向当前构造函数，Function</li>
<li>call：调用函数，重新指定 this</li>
<li>apply：调用函数，重新指定 this</li>
<li>bind：重新指向 this，返回一个新的函数，不调用</li>
<li>toString : 得到函数的字符串格式</li>
</ul>
<p>案例【封装 getType 函数（获取数据类型）】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, -<span class="number">1</span>) <span class="comment">// &#x27;[object 构造函数]&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完整版原型链"><a href="#完整版原型链" class="headerlink" title="完整版原型链"></a>完整版原型链</h4><blockquote>
<p>绘制完整版原型链的目的是辅助大家理解 js 中对象的继承关系</p>
</blockquote>
<p>图一<br><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102204647.png"></p>
<p>图二<br><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102204701.jpeg"></p>
<p>总结：</p>
<ol>
<li>所有函数都是 new Function 创建出来的，因此 <code>所有函数.__proto__</code> 都是 <code>Function.prototype</code></li>
<li>所有对象都是 new Object 创建出来的，因此 <code>所有对象.__proto__</code> 都是 <code>Object.prototype</code></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/creeperyang/blog/issues/9">参考链接</a></p>
<h3 id="作用域与预解析"><a href="#作用域与预解析" class="headerlink" title="作用域与预解析"></a>作用域与预解析</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><blockquote>
<p>作用域：变量起作用的区域，也就是说：变量定义后，可以在哪个范围内使用该变量</p>
</blockquote>
<p><strong>全局作用域</strong> ：在 script 标签内，<strong>函数外</strong>的区域就是全局作用域，在全局作用内声明的变量叫做<strong>全局变量</strong> 。全局变量可以在任意地方访问。（if/while/for 语句中声明的变量也是全局变量）</p>
<p><strong>函数作用域</strong> ：在函数内的区域叫做函数作用域，在函数作用域内声明的变量叫做<strong>局部变量</strong> ，局部变量只有在当前函数内才能访问到。</p>
<p>自由变量：对于一个函数来说，函数内部没有声明该变量，但在函数内部有访问该变量。对于这个函数来说， 该变量就是一个自由变量。</p>
<p>隐式全局变量：没有使用 var 定义的变量也是全局变量，叫做隐式全局变量。(不要使用)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">11</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num1 = <span class="number">22</span></span><br><span class="line">  num2 = <span class="number">33</span></span><br><span class="line">  num = <span class="number">33</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br><span class="line"><span class="comment">// console.log(num1)</span></span><br><span class="line"><span class="built_in">console</span>.log(num2)</span><br></pre></td></tr></table></figure>
<p>变量的查找规则：</p>
<ul>
<li>函数内部可以使用函数外部的变量</li>
<li>有局部变量就用局部变量，没有局部变量就用全局变量。</li>
</ul>
<p><strong>函数作用域是在函数定义的时候作用域就确定下来了，和函数在哪调用无关</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">123</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">456</span></span><br><span class="line">  f1()</span><br><span class="line">&#125;</span><br><span class="line">f2() <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">20</span></span><br><span class="line">  num = <span class="number">30</span> <span class="comment">// num 在局部声明过，只能修改局部的 num 值</span></span><br><span class="line">  num1 = <span class="number">20</span> <span class="comment">// 修改全局的 num1 值</span></span><br><span class="line">  <span class="keyword">var</span> num2 = <span class="number">40</span></span><br><span class="line">  num3 = <span class="number">50</span> <span class="comment">// 隐式全局</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 30</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1) <span class="comment">// 20</span></span><br><span class="line">  <span class="built_in">console</span>.log(num2) <span class="comment">// 40</span></span><br><span class="line">  <span class="built_in">console</span>.log(num3) <span class="comment">// 50</span></span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(num1) <span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 如果 test 函数没执行过，则 num1 值为 10</span></span><br><span class="line"><span class="built_in">console</span>.log(num3) <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>作用域链：只要是函数，就会形成一个作用域，如果这个函数被嵌套在其他函数中，那么外部函数也有自己的作用域，这个一直往上到全局环境，就形成了一个作用域链</p>
<p><code>变量的搜索原则</code>：</p>
<ol>
<li>从当前作用域开始查找是否声明了该变量，如果存在，那么就直接返回这个变量的值</li>
<li>如果不存在，就会往上一层作用域查询，如果存在，就返回</li>
<li>如果不存在，一直查询到全局作用域，如果存在，就返回。如果在全局中也没有找到该变量会<strong>报错</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line">fn1()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 -- 改造上面的面试题</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line">fn1()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 10</span></span><br><span class="line">  num = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">123</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 456 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">456</span></span><br><span class="line">  f1(num)</span><br><span class="line">  f1()</span><br><span class="line">&#125;</span><br><span class="line">f2()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1</span>) </span>&#123;</span><br><span class="line">  num1 = <span class="number">100</span></span><br><span class="line">  num2 = <span class="number">200</span></span><br><span class="line">  num3 = <span class="number">300</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1) <span class="comment">// 100</span></span><br><span class="line">  <span class="built_in">console</span>.log(num2) <span class="comment">// 200</span></span><br><span class="line">  <span class="built_in">console</span>.log(num3) <span class="comment">// 300</span></span><br><span class="line">  <span class="keyword">var</span> num3</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(num1) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// 200</span></span><br><span class="line"><span class="built_in">console</span>.log(num3) <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">  num++</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 101</span></span><br><span class="line">fn() <span class="comment">// 101</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;red&#x27;</span> <span class="comment">// blue</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> anotherColor = <span class="string">&#x27;blue&#x27;</span> <span class="comment">// red</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmpColor = color <span class="comment">// red</span></span><br><span class="line">    color = anotherColor</span><br><span class="line">    anotherColor = tmpColor <span class="comment">// red</span></span><br><span class="line">    <span class="built_in">console</span>.log(anotherColor) <span class="comment">// red</span></span><br><span class="line">  &#125;</span><br><span class="line">  inner()</span><br><span class="line">&#125;</span><br><span class="line">outer()</span><br><span class="line"><span class="built_in">console</span>.log(color) <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><blockquote>
<p>预解析：预先解析</p>
</blockquote>
<p>js 执行代码分为两个过程：</p>
<ul>
<li>预解析过程（变量与函数提升）</li>
<li>代码一行一行执行</li>
</ul>
<p>预解析过程：JavaScript 解析器在执行代码前，会把所有变量的声明和函数的声明提升到当前作用域的顶部。例如<code>var a = 11</code>其实会分为<code>var a</code> 和<code>a = 11</code>两部分，其中<code>var a;</code>会被提升</p>
<p>预解析规则 :</p>
<ol>
<li>var 声明的变量：只提升声明，不会提升赋值</li>
<li>函数声明：整体提升</li>
<li>先提升 var 声明的变量，后提升函数声明</li>
<li>遇到重名的 var 声明， var 声明会被忽略，值会保留</li>
<li>遇到重名的函数声明，后者会覆盖前者</li>
<li>如果 var 声明和函数声明同名，函数声明会把 var 声明覆盖</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数预解析</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">45</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n) <span class="comment">// undefined</span></span><br><span class="line">  n = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(n) <span class="comment">// 20</span></span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">  <span class="built_in">console</span>.log(n) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line">fn5()</span><br><span class="line"><span class="built_in">console</span>.log(n) <span class="comment">// 45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 函数体</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">23</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 23</span></span><br><span class="line"><span class="comment">// b() // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 函数体</span></span><br><span class="line">c() <span class="comment">// 嘿嘿</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  comsole.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;嘿嘿&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.</span></span><br><span class="line"><span class="built_in">console</span>.log(fn1) <span class="comment">// 函数体</span></span><br><span class="line">fn1()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>) <span class="comment">// 哈哈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn2) <span class="comment">// undefined</span></span><br><span class="line">fn2() <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;嘿嘿&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于函数表达式，函数的调用必须在表达式声明之后</span></span><br><span class="line">fn2() <span class="comment">// 嘿嘿</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.</span></span><br><span class="line"><span class="comment">// 只有用 var 声明的变量才会预解析</span></span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">// 报错</span></span><br><span class="line">d = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.</span></span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br><span class="line"><span class="built_in">console</span>.log(f) <span class="comment">// 报错 f is not defined</span></span><br><span class="line"><span class="keyword">var</span> e = (f = <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
<p><strong>不要在一个作用域内重复的声明相同的变量和函数</strong></p>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><blockquote>
<p>递归函数：函数内部直接或者间接的调用自己</p>
</blockquote>
<p>递归的要求：</p>
<ol>
<li>自己调用自己（直接或者间接）</li>
<li>要有结束条件（出口）</li>
</ol>
<p>递归函数主要是<code>化归思想</code>，将一个复杂的问题简单化，主要用于解决数学中的一些问题居多。</p>
<ul>
<li>把要解决的问题，归结为已经解决的问题上。</li>
<li>一定要考虑什么时候结束让函数结束，也就是停止递归（一定要有已知条件）</li>
</ul>
<p>练习：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 计算1-100之间所有数的和</span></span><br><span class="line"><span class="comment">// 2. 计算斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn(n - <span class="number">1</span>) + fn(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">12</span>))</span><br></pre></td></tr></table></figure>
<h4 id="实现缓存"><a href="#实现缓存" class="headerlink" title="实现缓存"></a>实现缓存</h4><blockquote>
<p>缓存（cache）：数据的缓冲区，当要读取数据时，先从缓冲中获取数据，如果找到了，直接获取，如果找不到，重新去请求数据</p>
</blockquote>
<p>计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。</p>
<p>初级优化：</p>
<p>使用缓存的基本步骤：</p>
<ul>
<li>如果要获取数据，先查询缓存，如果有就直接使用</li>
<li>如果没有，就进行计算，并且将计算后的结果放到缓存中，方便下次使用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">var</span> fbi = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[n]) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[n]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = fbi(n - <span class="number">1</span>) + fbi(n - <span class="number">2</span>)</span><br><span class="line">    arr[n] = temp <span class="comment">// 存入缓存</span></span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="闭包的基本概念"><a href="#闭包的基本概念" class="headerlink" title="闭包的基本概念"></a>闭包的基本概念</h3><p><code>闭包（closure）</code>是 JavaScript 语言的一个难点，也是 JavaScript 的一个特色，很多高级的应用都要依靠闭包来实现</p>
<blockquote>
<p>闭包是函数和声明该函数的词法环境的组合</p>
</blockquote>
<p>在 JavaScript 中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，产生闭包</p>
<p>**闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用 **</p>
<p>产生闭包的条件：有两个函数，是嵌套关系，内部函数引用了外部函数的变量，这样就会形成闭包</p>
<p>闭包的作用：</p>
<ul>
<li>私有变量，保护数据安全</li>
<li>持久化维持数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包的基本模型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line">  <span class="comment">// function inner () &#123;</span></span><br><span class="line">  <span class="comment">//   num++</span></span><br><span class="line">  <span class="comment">//   console.log(num)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// return inner  // 把inner函数给返回出去，让外部能够调用inner函数</span></span><br><span class="line">  <span class="comment">// 上面的简写</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并不一定是有返回函数才算是产生了闭包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f3</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  f3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1()</span><br><span class="line">f3() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>需求：统计一个函数的调用次数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我被调用了，调用次数是&#x27;</span> + count)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">fn()</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// 缺点：count是全局变量，不安全</span></span><br></pre></td></tr></table></figure>
<p>使用闭包解决这个问题！！！！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span> <span class="comment">// 私有变量, 将 count 保护起来了</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;当前count&#x27;</span> + count)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> add</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = outer()</span><br><span class="line">result()</span><br></pre></td></tr></table></figure>
<p>【案例：银行存钱取钱】</p>
<h4 id="缓存的私有化"><a href="#缓存的私有化" class="headerlink" title="缓存的私有化"></a>缓存的私有化</h4><blockquote>
<p>缓存（cache）：数据的缓冲区，当要读取数据时，先从缓冲中获取数据，如果找到了，直接获取，如果找不到，重新去请求数据。</p>
</blockquote>
<p>计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。</p>
<p>缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fbi = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[n]) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr[n]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> temp = fbi(n - <span class="number">1</span>) + fbi(n - <span class="number">2</span>)</span><br><span class="line">      arr[n] = temp <span class="comment">//存入缓存</span></span><br><span class="line">      <span class="keyword">return</span> temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fbi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fbi = outer()</span><br><span class="line"><span class="built_in">console</span>.log(fbi(<span class="number">40</span>))</span><br></pre></td></tr></table></figure>
<h3 id="闭包存在的问题"><a href="#闭包存在的问题" class="headerlink" title="闭包存在的问题"></a>闭包存在的问题</h3><blockquote>
<p>正常情况下：函数在调用的时候，去开辟一块内存空间用来执行内部的代码，当函数调用结束的时候，要销毁开辟的空间，节省内存</p>
<p>闭包占用的内存是不会被释放的，因此，如果滥用闭包，会造成内存泄漏的问题。闭包很强大，但是只有在必须使用闭包的时候才使用</p>
</blockquote>
<h4 id="js-的垃圾回收机制-了解"><a href="#js-的垃圾回收机制-了解" class="headerlink" title="js 的垃圾回收机制(了解)"></a>js 的垃圾回收机制(了解)</h4><ul>
<li>内存：计算机中所有程序的运行都是在<code>内存</code> 中进行的，因此内存的性能对计算机的影响非常大，运行程序需要消耗内存，当程序结束时，内存会得到释放。</li>
<li>javascript 分配内存：当我们定义变量，javascript 自动分配内存存储数据。无论是值类型或者是引用类型，都需要存储在内存中。</li>
<li>垃圾回收：当代码执行结束，分配的内存已经不需要了，这时候需要将内存进行回收，在 javascript 语言中，<code>垃圾回收机器</code>会帮我们回收<code>不再需要使用</code>的内存。</li>
</ul>
<h5 id="引用记数法清除"><a href="#引用记数法清除" class="headerlink" title="引用记数法清除"></a>引用记数法清除</h5><p>引用记数垃圾收集：如果没有引用指向某个对象（或者是函数作用域），那么这个对象或者函数作用域就会被垃圾回收机制回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象被 o 变量引用，引用记数 1</span></span><br><span class="line"><span class="keyword">var</span> obj = o <span class="comment">// 变量被 o 和 obj 引用，引用记数 2</span></span><br><span class="line">o = <span class="number">1</span> <span class="comment">// o 不在引用对象了，引用记数 1</span></span><br><span class="line">obj = <span class="literal">null</span> <span class="comment">// obj 不在引用对象了，引用记数 0，可以被垃圾回收了</span></span><br></pre></td></tr></table></figure>
<p>引用计数法无法解决循环引用导致的内存泄露</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj1 = &#123;&#125; <span class="comment">// 引用计数为 2</span></span><br><span class="line">  <span class="keyword">var</span> obj2 = &#123;&#125; <span class="comment">// 引用计数为 2</span></span><br><span class="line">  obj1.a = obj2</span><br><span class="line">  obj2.b = obj1</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 销毁fn调用开辟的空间， 但是由于引用计数考虑到两个对象都不是零引用的对象，就不能够被垃圾回收机制给回收掉</span></span><br></pre></td></tr></table></figure>
<h5 id="标记清除法清除"><a href="#标记清除法清除" class="headerlink" title="标记清除法清除"></a>标记清除法清除</h5><p>使用引用计数法进行垃圾回收的时候，会出现循环引用导致内存泄漏的问题。因此现代的浏览器都采用标记清除法来进行垃圾回收。</p>
<p>这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象 Window）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>
<p><strong>从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。</strong></p>
<h4 id="闭包占用内存释放"><a href="#闭包占用内存释放" class="headerlink" title="闭包占用内存释放"></a>闭包占用内存释放</h4><p>当闭包的功能不在需要使用了，将这个变量指向 <code>null</code>， 这样闭包占用的内存就可以被回收掉了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行次数&#x27;</span> + count)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = outer()</span><br><span class="line">result()</span><br><span class="line">result = <span class="literal">null</span> <span class="comment">// 当函数 fn 没有被变量引用了，那么函数 fn 就会被回收，函数 fn 一旦被回收，那么 outer调用形成的作用域也就得到了释放</span></span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote>
<p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串（数据验证）、将匹配的子串替换（数据删除或替换）或者从某个串中取出符合某个条件的子串等（数据提取）</p>
</blockquote>
<h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><ul>
<li>构造函数的方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RegExp(regular expression)</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/a/</span>) <span class="comment">// 匹配字母中有 a</span></span><br></pre></td></tr></table></figure>
<ul>
<li>正则字面量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/</span></span><br></pre></td></tr></table></figure>
<p>正则有 test 方法，作用是测试字符串是否符合正则表达式的规律，如果符合， 返回 true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;abc&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;def&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><blockquote>
<p>正则表达式由一些普通字符和元字符组成，普通字符包括大小写字母、数字等，而元字符则具有特殊的含义</p>
</blockquote>
<h4 id="常见元字符"><a href="#常见元字符" class="headerlink" title="常见元字符"></a>常见元字符</h4><p><code>\d</code> 匹配一个数字字符。等价于 <code>[0-9]</code></p>
<p><code>\D</code> 匹配一个非数字字符。等价于 <code>[^0-9]</code></p>
<p><code>\w</code> 匹配包括下划线的任何单词字符。等价于<code>[A-Za-z0-9_]</code></p>
<p><code>\W</code> 匹配任何非单词字符。等价于 <code>[^A-Za-z0-9_]</code></p>
<p><code>\s</code> 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[\f\n\r\t\v]</code></p>
<p><code>\S</code> 匹配任何非空白字符。等价于 <code>[^\f\n\r\t\v]</code></p>
<p><code>\</code> 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。<code>\\</code> 匹配 <code>\</code>，<code>\(</code> 则匹配 <code>(</code>。</p>
<p><code>.</code> 匹配除换行符 <code>\n</code> 之外的任何单字符。要匹配包括 ‘\n’ 在内的任何字符，可用<code>(.|\n)</code></p>
<p><code>|</code> 指明两项之间的一个选择。，优先级最低，| 的左右都是单独的整体</p>
<p><code>()</code> 优先级最高，标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。使用 $0…$9 属性。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code> 。每个()就是一个子匹配 ‘\1’和’$1’用来指定第一个子匹配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/f|boot/ <span class="comment">// 匹配 `f` 和 `boot`</span></span><br><span class="line">/(f|b)oot/ <span class="comment">// 匹配 `foot` 和 `boot`</span></span><br></pre></td></tr></table></figure>
<h4 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h4><ul>
<li><code>\f</code> 匹配一个换页符</li>
<li><code>\n</code> 匹配一个换行符</li>
<li><code>\r</code> 匹配一个回车符</li>
<li><code>\t</code> 匹配一个制表符</li>
<li><code>\v</code> 匹配一个垂直制表符</li>
</ul>
<h4 id="字符类的元字符"><a href="#字符类的元字符" class="headerlink" title="字符类的元字符"></a>字符类的元字符</h4><ul>
<li><code>[]</code> 在正则表达式中表示 <strong>单个</strong> 字符的位置，[] 里面写这个位置可以出现的字符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;<span class="regexp">/[abc]/</span> <span class="comment">// 匹配 a,b,c 任意一个字符</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>[^]</code> 在中扩号中的 <code>^</code> 表示非的意思</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ^ 在方括号表达式开头中使用，此时它表示不接受该字符集合</span></span><br><span class="line">;<span class="regexp">/[^abc]/</span> <span class="comment">// 匹配除了a, b, c以外的其他字符</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>[a-z]</code> <code>[1-9]</code>表示范围</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;<span class="regexp">/[a-z]/</span> <span class="comment">// 小写字母</span></span><br><span class="line">;<span class="regexp">/[A-Z]/</span> <span class="comment">// 大写字母</span></span><br><span class="line">;<span class="regexp">/[0-9]/</span> <span class="comment">// 数字</span></span><br><span class="line">;<span class="regexp">/[a-zA-Z0-9]/</span> <span class="comment">// 所有的小写字母和大写字母以及数字</span></span><br></pre></td></tr></table></figure>
<h4 id="边界类元字符"><a href="#边界类元字符" class="headerlink" title="边界类元字符"></a>边界类元字符</h4><blockquote>
<p>我们前面学习的正则只要有满足的条件的就会返回 true，并不能做到精确的匹配。</p>
</blockquote>
<ul>
<li><p><code>^</code> 匹配输入字符串的开始位置</p>
</li>
<li><p><code>$</code> 匹配输入字符串的结尾位置</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;<span class="regexp">/^chuan/</span> <span class="comment">// 以chuan开头</span></span><br><span class="line">;<span class="regexp">/chuan$/</span> <span class="comment">// 以chuan结尾</span></span><br><span class="line">;<span class="regexp">/^chuan$/</span> <span class="comment">// 精确匹配 chuan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 精确匹配chuan,表示必须是这个</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^chuan$/</span>.test(<span class="string">&#x27;chuanchuan&#x27;</span>)) <span class="comment">// fasle</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以后表单校验要精确匹配</p>
</blockquote>
<ul>
<li><code>\b</code> 匹配一个字边界，即字与空格间的位置。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。<br><code>/\bCha/</code> : 匹配 Chapter 的开头三个字符<br><code>/ter\b/</code> : 匹配 Chapter 的结尾三个字符</li>
<li><code>\B</code> 表示非单词边界。位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。<br><code>/\Bapt/</code> 表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt</li>
</ul>
<h4 id="量词类元字符"><a href="#量词类元字符" class="headerlink" title="量词类元字符"></a>量词类元字符</h4><blockquote>
<p>量词用来控制出现的次数，一般来说量词和边界会一起使用</p>
</blockquote>
<ul>
<li><code>*</code> 匹配前面的子表达式零次或多次，等价于 <code>&#123;0,&#125;</code></li>
<li><code>+</code> 匹配前面的子表达式一次或多次，等价于 <code>&#123;1,&#125;</code></li>
<li><code>?</code> 匹配前面的子表达式零次或一次，等价于 <code>&#123;0,1&#125;</code> 。当该字符紧跟在任何一个其他限制符 (<code>*</code>, <code>+</code>,<code>?</code>, <code>&#123;n&#125;</code>, <code>&#123;n,&#125;</code>, <code>&#123;n,m&#125;)</code> 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串</li>
<li><code>&#123;n&#125;</code> n 是一个非负整数。匹配确定的 <code>n</code> 次</li>
<li><code>&#123;n,&#125;</code> n 是一个非负整数。至少匹配 <code>n</code> 次</li>
<li><code>&#123;n,m&#125;</code> <code>m</code> 和 <code>n</code> 均为非负整数，其中<code>n</code> &lt;= <code>m</code>。最少匹配 <code>n</code> 次且最多匹配 <code>m</code> 次</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&#125; 就近修饰单个字符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/chuan&#123;2&#125;/</span>.test(<span class="string">&#x27;chuanchuan&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/(chuan)&#123;2&#125;/</span>.test(<span class="string">&#x27;chuanchuan&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/chuan&#123;2&#125;/</span>.test(<span class="string">&#x27;chuann&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h4><ul>
<li><code>g</code> 全局标记，指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配</li>
<li><code>i</code> 标记指定不区分大小写。表达式的结尾处</li>
<li><code>m</code> 表明可以进行多行匹配，但是这个只有当使用^和$模式时才会起作用，在其他的模式中，加不加入 m 都可以进行多行匹配</li>
</ul>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>从高到低的优先级顺序：</p>
<ol>
<li><strong><code>\</code></strong> 转义符</li>
<li><strong><code>()</code></strong>, <strong><code>(?:)</code></strong> , <strong><code>(?=)</code></strong>, <strong><code>[]</code></strong> 圆括号和方括号</li>
<li><strong><code>*</code></strong>, <strong><code>+</code></strong> , <strong><code>?</code></strong>, <strong><code>&#123;n&#125;</code></strong>, <strong><code>&#123;n,&#125;</code></strong>, <strong><code>&#123;n,m&#125;</code></strong> 限定符</li>
<li><strong><code>^</code></strong>, <strong><code>$</code></strong>, <strong><code>\任何元字符、任何字符</code></strong> 定位点和序列（即：位置和顺序）</li>
<li><strong><code>|</code></strong> 替换，”或”操作</li>
</ol>
<blockquote>
<p>字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</p>
</blockquote>
<h3 id="正则的使用"><a href="#正则的使用" class="headerlink" title="正则的使用"></a>正则的使用</h3><h4 id="字符串使用正则"><a href="#字符串使用正则" class="headerlink" title="字符串使用正则"></a>字符串使用正则</h4><ul>
<li><code>replace()</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;   123AD  asadf   asadfasf  adf  &#x27;</span></span><br><span class="line"><span class="comment">// 1. 替换掉字符串中的所有空白</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// g: global, 全局搜索</span></span><br><span class="line"><span class="comment">// 2. 将所有的ad替换成xx</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/ad/g</span>, <span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line"><span class="comment">// 3. 将所有的ad/AD替换成xx</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/ad/gi</span>, <span class="string">&#x27;xx&#x27;</span>) <span class="comment">// i： ignore 忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc,efg,123,abc,123,a&#x27;</span></span><br><span class="line"><span class="comment">// 4. 所有的逗号替换成句号</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/,/g</span>, <span class="string">&#x27;。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">&#x27;[&#123;&quot;name&quot;:&quot;张三&quot;,score:80&#125;,&#123;&quot;name&quot;:&quot;张三&quot;,score:90&#125;,&#123;&quot;name&quot;:&quot;张三&quot;,score:81&#125;]&#x27;</span></span><br><span class="line"><span class="comment">// 5. 把所有成绩都修改成100分</span></span><br><span class="line"><span class="keyword">var</span> str2 = jsonStr.replace(<span class="regexp">/\d&#123;1,2&#125;/g</span>, <span class="string">&#x27;100&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>match()</code> ==&gt; 匹配， 匹配符合正则表达式的字符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;zs的手机号是18938383838, ls的手机号13989907890， ww的手机号是13848962389，zl的手机号是18970890908&#x27;</span></span><br><span class="line"><span class="comment">// 需求： 匹配出来所有的手机号, 返回一个数组</span></span><br><span class="line"><span class="keyword">var</span> str3 = str2.match(<span class="regexp">/1[3-9]\d&#123;9&#125;/g</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str3)</span><br></pre></td></tr></table></figure>
<h4 id="正则的方法"><a href="#正则的方法" class="headerlink" title="正则的方法"></a>正则的方法</h4><ul>
<li><p>test() ==&gt; 测试字符串是否符合正则表达式的规律，符合，就返回 true</p>
</li>
<li><p>exec() ==&gt; 提取，提取字符串中符合正则表达式的字符，需要用括号分组， 如果没有进行分组，返回的是符合整个正则表达式的字符</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;今天是2018-10-16，我这里的需求是提取出年月日&#x27;</span></span><br><span class="line"><span class="comment">// var reg = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/;  ==&gt;  符合整个正则表达式的字符</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span> <span class="comment">// ==&gt; 有分组存在 ，默认组名为 undefined</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span> <span class="comment">// ?&lt;组名&gt; 添加组名</span></span><br><span class="line"><span class="keyword">var</span> ret = reg.exec(str) <span class="comment">// 提取出分组的内容以下标的形式存在返回的数组里面</span></span><br><span class="line"><span class="keyword">var</span> ret2 = reg2.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(ret)</span><br><span class="line"><span class="built_in">console</span>.log(ret2)</span><br><span class="line"><span class="comment">// index 代表 匹配到 ret 在 str 中的下标</span></span><br></pre></td></tr></table></figure>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul>
<li><code>[xyz]</code> 字符集合。匹配所包含的任意一个字符。例如， <code>[abc]</code> 可以匹配 “plain” 中的 ‘a’</li>
<li><code>[^xyz]</code> 负值字符集合。匹配未包含的任意字符。例如， <code>[^abc]</code> 可以匹配 “plain” 中的’p’、’l’、’i’、’n’</li>
<li><code>[a-z]</code> 匹配所有小写字母</li>
<li><code>[-a-z]</code> 或 <code>[a-z-]</code> 匹配所有小写字母和 <code>-</code></li>
<li><code>[A-Za-z0-9]</code> 匹配任何大写字母小写字母和数字</li>
<li><code>\b([a-z]+)\1\b/gi</code> 一个单词连续出现的位置</li>
<li>将通用资源指示符 (URI) 分解为其组件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;https://www.baidu.com:80/index.html&#x27;</span></span><br><span class="line"><span class="keyword">var</span> patt1 = <span class="regexp">/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/</span></span><br><span class="line">arr = str.match(patt1)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(arr[i])</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// https://www.baidu.com:80/index.html</span></span><br><span class="line"><span class="comment">// https</span></span><br><span class="line"><span class="comment">// www.baidu.com</span></span><br><span class="line"><span class="comment">// :80</span></span><br><span class="line"><span class="comment">// /index.html</span></span><br></pre></td></tr></table></figure>
<h4 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h4><p><strong><code>后向引用</code></strong> 正则表达式一个最重要的特性就是将匹配成功的模式的某部分进行存储供以后使用这一能力</p>
<p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <code>\n</code> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p>
<p>可以使用非捕获元字符 <code>?:</code>、<code>?=</code> 或 <code>?!</code> 来忽略对这部分正则表达式的保存</p>
<p><code>?:</code> 非获取匹配。匹配但不获取匹配结果，不存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， <code>industr(?:y|ies)</code> 就是一个比 <code>industry|industries</code> 更简略的表达式</p>
<p><code>?=</code> 正向预查。在任何匹配的字符串开始处匹配查找字符串。非获取匹配，不获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</p>
<p><code>?!</code> 负向预查，在任何不匹配的字符串开始处匹配查找字符串。非获取匹配，不获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</p>
<p>后向引用一个最简单，最有用的应用是提供了确定文字中连续出现两个相同单词的位置的能力。请看下面的句子： Is is the cost of of gasoline going up up? 根据所写内容，上面的句子明显存在单词多次重复的问题。如果能有一种方法无需查找每个单词的重复现象就能修改该句子就好了。下面的 JScript 正则表达式使用一个子表达式就可以实现这一功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ss = <span class="string">&#x27;Is is the cost of of gasoline going up up?&#x27;</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\b([a-z]+) \1\b/gim</span></span><br><span class="line"><span class="keyword">var</span> rv = ss.replace(re, <span class="string">&#x27;$1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在这个示例中，子表达式就是圆括号之间的每一项。所捕获的表达式包括一个或多个字母字符，即由<code>[a-z]+</code>所指定的。该正则表达式的第二部分是对前面所捕获的子匹配的引用，也就是由附加表达式所匹配的第二次出现的单词。<code>\1</code>用来指定第一个子匹配。单词边界元字符确保只检测单独的单词。如果不这样，则诸如 “is issued” 或 “this is” 这样的短语都会被该表达式不正确地识别。</p>
<h4 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h4><p>校验数字的表达式</p>
<ul>
<li>n 位的数字：<code>^\d&#123;n&#125;$</code></li>
<li>至少 n 位的数字：<code>^\d&#123;n,&#125;$</code></li>
<li>m-n 位的数字：<code>^\d&#123;m,n&#125;$</code></li>
<li>零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code></li>
<li>非零开头的最多带两位小数的数字：<code>^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</code></li>
<li>带 1-2 位小数的正数或负数：<code>^(\-)?\d+(\.\d&#123;1,2&#125;)$</code></li>
<li>正数、负数、和小数：<code>^(\-|\+)?\d+(\.\d+)?$</code></li>
<li>有两位小数的正实数：<code>^[0-9]+(\.[0-9]&#123;2&#125;)?$</code></li>
<li>非零的正整数：<code>^[1-9]\d*$</code></li>
<li>非零的负整数：<code>^-[1-9]\d*$</code></li>
<li>非负整数：<code>^\d+$</code></li>
<li>非正整数：<code>^-[1-9]\d*|0$</code></li>
</ul>
<p>校验字符的表达式</p>
<ul>
<li>汉字：<code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code></li>
<li>英文和数字：<code>^[A-Za-z0-9]+$</code></li>
<li>长度为 3-20 的所有字符：<code>^\.&#123;3,20&#125;$</code></li>
<li>由 26 个英文字母组成的字符串：<code>^[A-Za-z]+$</code></li>
<li>由 26 个大写英文字母组成的字符串：<code>^[A-Z]+$</code></li>
<li>由 26 个小写英文字母组成的字符串：<code>^[a-z]+$</code></li>
<li>由数字和 26 个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code></li>
<li>由数字、26 个英文字母或者下划线组成的字符串：<code>^\w+$</code></li>
<li>中文、英文、数字包括下划线：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></li>
<li>中文、英文、数字但不包括下划线等符号：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code></li>
</ul>
<p>特殊需求表达式(待验证)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line">域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?</span><br><span class="line">InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\s]* 或 ^http:&#x2F;&#x2F;([\w-]+\.)+[\w-]+(&#x2F;[\w-.&#x2F;?%&amp;&#x3D;]*)?$</span><br><span class="line">手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</span><br><span class="line">电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</span><br><span class="line">国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span><br><span class="line">电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\d&#123;11&#125;)|^((\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;)|(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;))$)</span><br><span class="line">身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)</span><br><span class="line">帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br><span class="line">密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$</span><br><span class="line">强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.*\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$</span><br><span class="line">日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span><br><span class="line">一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</span><br><span class="line">一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</span><br><span class="line">钱的输入格式：</span><br><span class="line">有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$</span><br><span class="line">这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$</span><br><span class="line">一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$</span><br><span class="line">这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</span><br><span class="line">必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br><span class="line">这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span><br><span class="line">xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</span><br><span class="line">中文字符的正则表达式：[\u4e00-\u9fa5]</span><br><span class="line">双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</span><br><span class="line">空白行的正则表达式：\n\s*\r (可以用来删除空白行)</span><br><span class="line">HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? &#x2F;&gt; ( 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="line">腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)</span><br><span class="line">中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)</span><br><span class="line">IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">c</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>本站为个人博客，站内所有软件资源均收集自互联网，本站仅做免费分享，不出售。本站内所有软件资源仅限个人用于学习和研究目的，不得将上述内容用于商业或者非法用途，否则，一切后果请用户自负。本站内所有软件必须在下载后的24个小时之内，从您的电脑中彻底删除。本站对任何资源不提供技术支持，遇到问题请自行研究或购买正版。本站信息来自网络，版权争议与本站无关。访问和下载本站内容，说明您已同意上述条款。


    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>

<script src="/js/local-search.js"></script>





  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <div class="pjax">



    </div>
</body>
</html>
