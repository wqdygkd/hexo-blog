<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-logo.png">
  <link rel="mask-icon" href="/images/favicon-logo.png" color="#222">
  <meta name="google-site-verification" content="4ub2lNf2WEkusifo-b7xbJIm2G5xxYUczDoWOFGp-NM">
  <meta name="msvalidate.01" content="C2030D8E2452D4B39AED09488E55F2DF">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;wqdy.top&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:true,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:true,&quot;pangu&quot;:true,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:true}}</script>
<meta name="description" content="分享各类资源、经验与技巧">
<meta property="og:type" content="website">
<meta property="og:title" content="我全都要">
<meta property="og:url" content="https://wqdy.top/page/13/index.html">
<meta property="og:site_name" content="我全都要">
<meta property="og:description" content="分享各类资源、经验与技巧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="c">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wqdy.top/page/13/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;13&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>我全都要</title><script src="/js/config.js"></script>

<!-- google 分析 -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9068539038073295"
     crossorigin="anonymous"></script>


  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112496567-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{&quot;tracking_id&quot;:&quot;UA-112496567-1&quot;,&quot;only_pageview&quot;:false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?4cf9aa5b4589576262198ad166b18a05"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我全都要</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">搞快点</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-前端"><a href="/c/frontend/" rel="section"><i class="fab fa-html5 fa-fw"></i>前端</a></li>
        <li class="menu-item menu-item-软件"><a href="/c/software/" rel="section"><i class="fas fa-th-large fa-fw"></i>软件</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="c"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">c</p>
  <div class="site-description" itemprop="description">分享各类资源、经验与技巧</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">153</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">85</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1aWxvbmdqaW4=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cuilongjin"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/2010.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2010.html" class="post-title-link" itemprop="url">Vue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-08 18:00:00" itemprop="dateCreated datePublished" datetime="2019-01-08T18:00:00+00:00">2019-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcv">vue 中文网<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZQ==">github 下载地址<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>Vue.js (读音 /vju:/ view)</p>
</li>
<li><p>渐进式 JavaScript 框架</p>
<ul>
<li><p>渐进式：小型项目使用 vue 就够了，随着页面的复杂程度提高，就要学习 vue-rouer 来管理更多的页面，再随着项目的数据越来越多，管理数据也变得麻烦起来了，就开始使用 vuex 来管理数据</p>
</li>
<li><p>框架 : 一整套的解决方案</p>
</li>
</ul>
</li>
</ul>
<h2 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h2><h3 id="库-Library-，代表-jquery"><a href="#库-Library-，代表-jquery" class="headerlink" title="库(Library) ，代表 : jquery"></a>库(Library) ，代表 : jquery</h3><ul>
<li>库就是一系列函数的集合，我们开发人员在使用库的时候，想要完成什么样的功能，就调用库中提供的某个方法</li>
</ul>
<p>比如：想要添加样式，就调用 jquery 中的 .css() / .addClass()</p>
<ul>
<li>库起到了一个辅助的作用，在使用库的是时候，是由开发人员说了算，也是由开发人员起主导作用</li>
</ul>
<h3 id="框架-Framework-，代表-vue"><a href="#框架-Framework-，代表-vue" class="headerlink" title="框架 (Framework)，代表 : vue"></a>框架 (Framework)，代表 : vue</h3><ul>
<li><p>在使用框架的时候，是由框架说了算，由框架起到了主导作用</p>
</li>
<li><p>框架是一套完整的解决方案，框架中制定了一套规则，使用框架的时候，只需要按照规则把代码放到合适的地方，然后框架会在合适的时机，主动调用开发人员的代码</p>
</li>
</ul>
<p>比如 : 想用 vue 组件里遍历就得使用 v-for，使用 for 不行</p>
<h3 id="主要区别：控制反转"><a href="#主要区别：控制反转" class="headerlink" title="主要区别：控制反转"></a>主要区别：控制反转</h3><blockquote>
<p>也就是 : 谁起到了主导作用</p>
</blockquote>
<ul>
<li><p>使用库的时候：开发人员起主导作用</p>
</li>
<li><p>使用框架的时候：框架起到了主导作用</p>
</li>
<li><p>从体量上看，框架一般比库大</p>
</li>
<li><p>会发现使用框架的时候，会受到很多限制</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjA3ODM1OT9ncm91cF9pZD04MzA4MDE4MDA0MDY5MTcxMjA=">我们所说的前端框架与库的区别？<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<h2 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC + MVVM"></a>MVC + MVVM</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ol>
<li><p>MVC 是一种软件架构模式，也有人叫做设计模式</p>
</li>
<li><p>M : Model 数据模型 (专门用来操作数据，数据的 CRUD)</p>
</li>
<li><p>V : View 视图 (对于前端来说就是页面)</p>
</li>
<li><p>C : Controller 控制器 (是视图和数据模型沟通的桥梁，用于处理业务逻辑)</p>
</li>
</ol>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><blockquote>
<p>Vue 使用的是 MVVM 模式</p>
</blockquote>
<ul>
<li><p>MVVM ===&gt; M / V / VM</p>
</li>
<li><p>M : model 数据层</p>
</li>
<li><p>V : view 视图层</p>
</li>
<li><p>VM : ViewModel 视图模型</p>
</li>
<li><p>核心 : M &lt;===&gt; VM &lt;===&gt; V</p>
</li>
</ul>
<h3 id="MVVM-优势"><a href="#MVVM-优势" class="headerlink" title="MVVM 优势"></a>MVVM 优势</h3><ul>
<li><p>MVC 模式将应用程序划为三个部分，实现职责分离</p>
<ul>
<li><p>但是，在前端中，经常要通过 js 代码来进行一些逻辑操作，最终还要把这些逻辑操作展示页面中，也需要<code>频繁的操作DOM</code></p>
</li>
<li><p>比如 : ajax 请求、添加、修改、设置样式、动画</p>
</li>
</ul>
</li>
<li><p>MVVM 的思想通过 <code>数据双向绑定</code> 让数据自动的双向同步</p>
<ul>
<li><p>V (修改视图) –&gt; M</p>
</li>
<li><p>M (修改数据) –&gt; V</p>
</li>
</ul>
</li>
<li><p>采用的是 : <strong>数据驱动视图</strong>的思想，<strong>数据是核心</strong>。不要再想着怎么操作 DOM，而是想着如何操作数据</p>
</li>
</ul>
<h3 id="Vue-中的-MVVM"><a href="#Vue-中的-MVVM" class="headerlink" title="Vue 中的 MVVM"></a>Vue 中的 MVVM</h3><ul>
<li>注意 : 不推荐直接手动操作 DOM</li>
</ul>
<blockquote>
<p>每个人操作 DOM 的方法不一样，会造成性能不一样<br>官网 : 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例</p>
</blockquote>
<h2 id="Vue-基本使用"><a href="#Vue-基本使用" class="headerlink" title="Vue 基本使用"></a>Vue 基本使用</h2><ol>
<li><p>安装 : <code>npm i vue</code></p>
</li>
<li><p>导入 : <code>&lt;script src=&#39;./vue.js&#39;&gt;&lt;/script&gt;</code></p>
</li>
<li><p>实例化 vue</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 指定 vue 管理的边界，不能是 body 或 html 节点</span></span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 提供视图中需要的数据</span></span><br><span class="line">  <span class="comment">// 视图可以直接使用 data 中的数据</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>使用 vm 表示 vue 实例</p>
<p>Vue 构造函数首字母大写</p>
<p>参数是一个对象</p>
<p>id=’#app’，其他也可以</p>
<p>边界外无法使用 msg</p>
<h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. &#123;&#123;&#125;&#125; : mustache 语法，小胡子语法，插值表达式</span><br><span class="line">2. 作用 : 使用`&#123;&#123;&#125;&#125;` 从`data`中获取数据，并展示在模板中</span><br><span class="line">3. 说明 : `&#123;&#123;&#125;&#125;` 中只能出现 js 表达式</span><br><span class="line">4. `&#123;&#123;&#125;&#125;` 语法不能作用在 HTML 元素的属性上</span><br></pre></td></tr></table></figure>

<p>表达式 (有返回值的)：</p>
<ul>
<li>基本的数据类型 <code>1 &#39;abc&#39; false [] &#123;&#125;</code></li>
<li>数据类型 和 运算符结合在一起<code>1+2 arr.join(&#39;-&#39;) true ? 123 : 321</code></li>
</ul>
<p>语句： <code>if 语句 for 语句</code></p>
<h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><h3 id="input-v-model"><a href="#input-v-model" class="headerlink" title="input + v-model"></a>input + v-model</h3><p>v-model 指令：数据双向绑定的指令</p>
<ul>
<li>作用：把 data 中的 num 值 和 input 上的值绑定到一起，一方的值发生了改变，另 一方也会跟着改变</li>
<li>注意：v-model 只能用在表单控件上（input checkbox 等）</li>
</ul>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> temp</span><br><span class="line"><span class="comment">// 参数1：要给哪个对象设置属性</span></span><br><span class="line"><span class="comment">// 参数2：给对象设置什么属性</span></span><br><span class="line"><span class="comment">// 参数3：属性的修饰符</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;赋值了&#x27;</span>, newVal)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;取值了&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="数据双向绑定的原理"><a href="#数据双向绑定的原理" class="headerlink" title="数据双向绑定的原理"></a>数据双向绑定的原理</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> temp</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置属性时会触发该函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;设置&#x27;</span>, newVal)</span><br><span class="line">    temp = newVal</span><br><span class="line">    input.value = newVal</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取属性时会触发该函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">input.oninput = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this.value)</span></span><br><span class="line">  obj.name = <span class="built_in">this</span>.value</span><br><span class="line">  <span class="built_in">console</span>.log(obj.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h3><p>检测变化注意：受现代 JavaScript 的限制 (而且 <code>Object.observe</code> 也已经被废弃)，Vue <strong>不能检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化过程，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 转换它，这样才能让它是响应的</p>
<p><strong>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性</strong>，可以使用 <code>Vue.set(object, key, value)</code> 方法将响应属性添加到嵌套的对象上，或者创建一个包含原对象属性和新属性的对象替换掉原对象</p>
<h3 id="列表渲染数组更新检测"><a href="#列表渲染数组更新检测" class="headerlink" title="列表渲染数组更新检测"></a>列表渲染数组更新检测</h3><p>数组的方法可以触发视图更新：方法如下：</p>
<p><code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>splice()</code>、<code>sort()</code>、<code>reverse()</code></p>
<p>替换数组</p>
<p>用一个含有相同元素的数组去替换原来的数组并不会导致 Vue 丢弃现有 DOM 并重新渲染整个列表</p>
<p>注意：由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p>
<ol>
<li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ol>
<p>解决第一类问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure>

<p>解决第二类问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>

<h2 id="指令学习"><a href="#指令学习" class="headerlink" title="指令学习"></a>指令学习</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li>指令：就是一个特殊的标记，起一个辅助作用，使 html 具备原来没有的功能</li>
<li>vue 中所有的指令都是以 <code>v-</code> 开头的，比如 : v-model v-bind v-if v-for 等等</li>
</ul>
<h3 id="v-model-常用"><a href="#v-model-常用" class="headerlink" title="v-model (常用)"></a>v-model (常用)</h3><blockquote>
<p>说明：用在<code>表单</code>元素中，用来实现<code>数据双向绑定</code> (input checkbox 等等)<br>作用：将 <code>数据</code> 和 <code>文本框的值</code> 绑定到一起，任何一方发生改变，都会引起对方的改变<br>注意：v-model 在不同类型的表单元素中作用不同<br><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> 的初始值而总是将 Vue 实例的数据作为数据来源</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 文本输入框 绑定的是值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;num&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 多选框  绑定的选中状态 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isChecked&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">isChecked</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-text-和-v-html"><a href="#v-text-和-v-html" class="headerlink" title="v-text 和 v-html"></a>v-text 和 v-html</h3><blockquote>
<p>说明 : 设置文本内容</p>
</blockquote>
<p>v-text : 相当于之前的 innerText</p>
<p>v-html : 相当于之前的 innerHTML，会解析 html 标签，（已经废弃三大括号的插值）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">&quot;msg1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-html</span>=<span class="string">&quot;msg2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">msg1</span>: <span class="string">&#x27;&lt;a href=&quot;#&quot;&gt;haha&lt;/a&gt;&#x27;</span>,</span><br><span class="line">    <span class="attr">msg2</span>: <span class="string">&#x27;&lt;a href=&quot;#&quot;&gt;haha&lt;/a&gt;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-bind-常用"><a href="#v-bind-常用" class="headerlink" title="v-bind (常用)"></a>v-bind (常用)</h3><blockquote>
<p>说明：动态绑定数据 (单向)<br>出现原因：在 HTML 属性中，无法使用插值表达式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;href&quot;</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-bind 可以直接省略 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;href&quot;</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-bind：</span></span><br><span class="line"><span class="comment">// 说明：动态数据绑定 (单向)，因为html的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据, 需要使用 v-bind</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">href</span>: <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="v-bind-和-v-model-的区别"><a href="#v-bind-和-v-model-的区别" class="headerlink" title="v-bind 和 v-model 的区别"></a>v-bind 和 v-model 的区别</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-model 数据双向绑定 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--场景：表单元素中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isChecked1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  v-bind 数据动态绑定 (单向) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--场景：主要用在属性中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:checked</span>=<span class="string">&quot;isChecked2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 操作样式 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1. 动态添加类，但不符合 vue 数据是核心的思想 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 2. class 值是一个对象 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性名为类名 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性值为布尔值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;red: isRed, fz: isFz&#125;&quot;</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 3. style --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;backgroundColor: &#x27;red&#x27;, fontSize: fz + &#x27;px&#x27;&#125;&quot;</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-bind :</span></span><br><span class="line"><span class="comment">// 说明 : 动态数据绑定 (单向)，因为 html 的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据 , 需要使用 v-bind</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">href</span>: <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其他操作</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;red&#x27;, &#x27;fz&#x27;]&quot;</span>&gt;</span>heheheh<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ===&gt; &lt;div class=&quot;red fz&quot;&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 多个样式对象写成数组的形式，如果有相同样式后面会覆盖前面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[&#123;red: true&#125;, &#x27;fz&#x27;]&quot;</span>&gt;</span>hehehe<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ===&gt; &lt;div class=&quot;red fz&quot;&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><blockquote>
<p>注册事件/绑定事件</p>
</blockquote>
<ol>
<li><p>v-on:click 绑定了一个 click 事件</p>
</li>
<li><p>缩写 : @click=’fn’</p>
</li>
<li><p>函数写在 <code>methods</code> 里面</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;fn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 简写 @ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fn1&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 传参 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fn2(123)&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-on 注册事件</span></span><br><span class="line"><span class="comment">// v-on:click =&gt; 绑定点击事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 事件函数写在 methods 中</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    fn () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;haha&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn1 () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;haha&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn2 (ref) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(ref)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>函数里面的 this 指的就是 vm 实例</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span> === vm <span class="comment">// true</span></span><br><span class="line"><span class="built_in">this</span>.msg <span class="comment">// 获取数据</span></span><br><span class="line"><span class="built_in">this</span>.msg = <span class="string">&#x27;XXX&#x27;</span> <span class="comment">// 修改数据</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>事件对象 $event</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定事件对象的时候, 没有添加小括号，此时，直接在方法中，通过参数 e 就可以获取到事件对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果绑定事件的地方,事件函数有()  @click=&#x27;fn()&#x27; 则需要通过 $event 获取 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fn1($event, 123)&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    fn (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn1 (e, ref) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">      <span class="built_in">console</span>.log(ref)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>遍历数据，为数据中的每一项生成一个指令所在的标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1: 最常用 遍历数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list1&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125; - &#123;&#123; index &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2: 遍历元素是对象的数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list2&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125; - id:&#123;&#123; item.id &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3: 遍历对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- item 是 属性值，key 是属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, key) in obj&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;-&#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4: 生成10个h1 （item是1-10）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">&quot;item in 10&quot;</span>&gt;</span>我是h1 &#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="headerlink" title="v-if 和 v-show"></a>v-if 和 v-show</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>我是h1 v-if<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>我是h1 v-show<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>v-if 和 v-show 都可以切换元素的显示与隐藏，不同的是 v-if 通过创建删除节点来控制元素的显示与隐藏， v-show 的元素始终会被渲染并保留在 DOM 中，只是简单地切换元素的 CSS 属性 <code>display</code>，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code></p>
<p>使用场景 :</p>
<ul>
<li>v-if 因为要不断的创建和删除来切换显示与隐藏，所以性能不高</li>
<li>v-if：切换次数不频繁的时候</li>
<li>v-show：切换次数频繁的时候</li>
</ul>
<h3 id="v-else-if-和-v-else"><a href="#v-else-if-和-v-else" class="headerlink" title="v-else-if 和 v-else"></a>v-else-if 和 v-else</h3><p>v-else：两种情况的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;num &gt; 40&quot;</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>v-else-if：三种以上情况</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;num &gt;= 40&quot;</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">&quot;num &gt;= 30 &amp;&amp; num &lt; 40&quot;</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>作用：告诉 vue 这个标签中的内容只需要解析一次，即便是数据再发送改变，这个标签中的内容也不会被更新</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>带 onece 的 &#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>作用：告诉 vue 这段节点中没有指令或表达式，不需要解析，从而，提升性能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span>带 v-pre &#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><p>使用遮盖</p>
<ul>
<li>给要遮盖的元素添加一个 v-cloak 指令：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用属性选择器，添加样式：<code>[v-cloak] &#123; display: none &#125;</code></p>
</li>
<li><p>vue 会在解析模板后将 v-cloak 指令从页面中移除，移除指令的时候，差值表达式已经变为对应的数据</p>
</li>
</ul>
<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符</p>
<p>Vue 为最常用的按键提供了别名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>全部的按键别名：</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
<p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>
<h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">&quot;clear&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>这些修饰符会限制处理函数仅响应特定的鼠标按钮</p>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  message () &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>，只有跟计算属性相关的数据发生了改变，计算属性才会重新计算</p>
<p>注意点:</p>
<p>计算属性必须返回一个值</p>
<p>计算属性只能当属性用，不能当方法用</p>
<p>不能和 data 中的属性名重名</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。它的工作方式类似于一个属性，所以你需要用 <code>v-bind</code> 来绑定动态值</p>
<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code>，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升</p>
<ul>
<li><code>就地复用</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; item.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据 --&gt;</span></span><br><span class="line">data: &#123;list: [&#123;id: 1, name: &#x27;zs&#x27;&#125;, &#123;id: 2, name: &#x27;ls&#x27;&#125;, &#123;id: 3, name: &#x27;ww&#x27;&#125;]</span><br><span class="line"><span class="comment">&lt;!-- 演示  --&gt;</span></span><br><span class="line">vm.list.unshift(&#123;id:4, name:&#x27;zl&#x27;&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 key<ul>
<li>如果数组的元素是一个对象，使用对象里固定属性，一般情况下，对象里都有 id</li>
<li>如果数组的元素是一个简单类型，不是一个对象，就可以取索引作为 key</li>
</ul>
</li>
</ul>
<h2 id="异步-DOM-更新"><a href="#异步-DOM-更新" class="headerlink" title="异步 DOM 更新"></a>异步 DOM 更新</h2><ol>
<li>Vue 中采用了 <code>异步DOM更新</code> 的机制</li>
<li>数据发生改变后，vue 没有立即将数据的改变更新到视图中，而是等到数据不再变化的时候 一次性的将数据的改变更新到视图中</li>
</ol>
<p>为什么是异步 DOM 更新?</p>
<ul>
<li>性能的考虑</li>
<li>因为对于前端来说，修改数据进行 DOM 操作是常有的事情，如果频繁操作 DOM，会严重影响页面的加载性能</li>
<li>DOM 操作这是前端的性能的瓶颈</li>
<li>比如 : for (let i = 1; i &lt; 10000; i++&gt;) 如果同步 就要重新渲染 1000 次</li>
</ul>
<p>验证异步 DOM 更新：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过dom来获取count的值</span></span><br><span class="line"><span class="comment">// this.$el ==&gt; vue 边界元素</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">this</span>.count = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>需求：在数据更新后，立即获取到更新后的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// DOM 更新后，会执行 this.$nextTick() 的回调函数，所以能拿到值</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="监听-watch"><a href="#监听-watch" class="headerlink" title="监听 watch"></a>监听 watch</h2><p>vue 中可以通过 watch 配置项来监听 vue 实例中数据的变化</p>
<p>基本使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//  监听</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="comment">// 监听 num 属性的数据变化</span></span><br><span class="line">  <span class="comment">// 作用: 只要 num 的值发生变化，这个方法就会被调用</span></span><br><span class="line">  <span class="comment">// 第一个参数: 新值</span></span><br><span class="line">  <span class="comment">// 第二个参数: 旧值</span></span><br><span class="line">  num (newVal, oldVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;新:&#x27;</span>, newVal)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;旧:&#x27;</span>, oldVal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="comment">// 监听对象</span></span><br><span class="line">  obj (newVal) &#123;</span><br><span class="line">    <span class="comment">// 虽然 obj 中的属性值发生改变了，但 obj 引用的地址没有发生改变，所以不会触发事件</span></span><br><span class="line">    <span class="built_in">console</span>.log(newVal)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听对象的属性</span></span><br><span class="line">  <span class="comment">// 从对象的角度来监听的</span></span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="comment">// 深度监听 监听对象里面的属性</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 页面刚进入立即触发监听，以表达式的当前值触发回调</span></span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 对象里的属性值发生变化，调用 handler 方法</span></span><br><span class="line">    handler (newVal) &#123;</span><br><span class="line">      <span class="built_in">this</span>.msg = <span class="string">`obj.age 值变化了，新值：<span class="subst">$&#123;newVal.age&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 从属性的角度来监听</span></span><br><span class="line">  <span class="string">&#x27;obj.age&#x27;</span> (newVal) &#123;</span><br><span class="line">    <span class="built_in">this</span>.msg = <span class="string">`obj.age 值变化了，新值：<span class="subst">$&#123;newVal&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用案例：需求 : 监听文本框字符个数，并显示格式验证码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;val&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;isTrue&quot;</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;请输入 6-12 位&#x27;</span>,</span><br><span class="line">  <span class="attr">isTrue</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  val (newVal) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^[0-9a-zA-z]&#123;6,12&#125;$/</span>.test(newVal)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.isTrue = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.isTrue = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><ul>
<li>所有的 vue 组件，都是 vue 实例，一个组件对应一个实例，并且接收相同的选项对象（一些根实例特有的选项除外）</li>
<li>实例生命周期也叫做：组件生命周期</li>
<li>声明周期图：<a href="/zh-cn/_vue/Vue%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE">01</a></li>
</ul>
<h3 id="生命周期介绍"><a href="#生命周期介绍" class="headerlink" title="生命周期介绍"></a>生命周期介绍</h3><p><span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvYXBpLyMlRTklODAlODklRTklQTElQjktJUU3JTk0JTlGJUU1JTkxJUJEJUU1JTkxJUE4JUU2JTlDJTlGJUU5JTkyJUE5JUU1JUFEJTkw">vue 生命周期钩子函数<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>简单说：一个组件（实例）从开始到最后消化所经历的各种状态，就是一个组件的生命周期</li>
<li>生命周期钩子函数的定义：从组件被创建，到组件挂在到页面上运行，再到页面关闭组件被销毁，这三个阶段总是伴随着组件的各种事件，这些事件，统称为组件的生命周期函数（简称 : 钩子函数）</li>
<li>开发人员可以通过 vue 提供的钩子函数，让我们写的代码参与到 vue 的生命周期里面来，让我们的代码在合适的阶段起到相应的作用</li>
</ul>
<p>注意：</p>
<ul>
<li>vue 在执行过程中会 <strong>自动调用</strong> <code>生命周期钩子函数</code>，我们只需要提供这些钩子函数即可</li>
<li>钩子函数的名称都是 vue 中规定好的</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODg3OTk2Ng==">vue 实例生命周期 参考 1<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODAxMDY2Ng==">vue 实例生命周期 参考 2<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="钩子函数-beforeCreate"><a href="#钩子函数-beforeCreate" class="headerlink" title="钩子函数 - beforeCreate"></a>钩子函数 - beforeCreate</h3><ul>
<li>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li>
<li>此时组件的选项还未挂载，因此无法访问 methods，data，computed 上的方法或数据</li>
<li>使用场景 : 几乎不用</li>
</ul>
<h3 id="钩子函数-created-掌握"><a href="#钩子函数-created-掌握" class="headerlink" title="钩子函数 - created (掌握)"></a>钩子函数 - created (掌握)</h3><ul>
<li>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见</li>
<li>可以调用 methods 中的方法、改变 data 中的数据，并且修改可以通过 vue 的响应式绑定体现在页面上、获取 computed 中的计算属性等</li>
<li>使用场景：发送 ajax、本地存储获取数据</li>
</ul>
<h3 id="钩子函数-beforeMounted"><a href="#钩子函数-beforeMounted" class="headerlink" title="钩子函数 - beforeMounted()"></a>钩子函数 - beforeMounted()</h3><ul>
<li>在挂载开始之前被调用（挂载：DOM 渲染）</li>
</ul>
<h3 id="钩子函数-mounted-掌握"><a href="#钩子函数-mounted-掌握" class="headerlink" title="钩子函数 - mounted() (掌握)"></a>钩子函数 - mounted() (掌握)</h3><ul>
<li><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</li>
<li>这个周期可以获取 DOM</li>
<li>指令的生效在 mounted 周期之前</li>
<li>在这个周期内，对 data 的改变可以生效。但是要进下一轮的 DOM 更新，DOM 上的数据才会更新</li>
<li>使用场景：发送 ajax、操作 DOM</li>
</ul>
<h3 id="钩子函数-beforeUpdate"><a href="#钩子函数-beforeUpdate" class="headerlink" title="钩子函数 - beforeUpdate()"></a>钩子函数 - beforeUpdate()</h3><ul>
<li><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p>
</li>
<li><p>此处获取的数据是更新后的数据，但是获取页面中的 DOM 元素是更新之前的</p>
<blockquote>
<p>小提示 : 打印 this.$el ，打开小三角是之后的，是因为打印是有监听的功能，展示的是后面更改之后的</p>
</blockquote>
</li>
</ul>
<h3 id="钩子函数-updated"><a href="#钩子函数-updated" class="headerlink" title="钩子函数 - updated()"></a>钩子函数 - updated()</h3><ul>
<li>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子</li>
<li>组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作</li>
<li>应该避免在此期间更改状态。如果要相应状态改变，通常最好使用 <strong>计算属性</strong> 或 <strong>watcher</strong> 取而代之</li>
</ul>
<h3 id="钩子函数-beforeDestroy"><a href="#钩子函数-beforeDestroy" class="headerlink" title="钩子函数 - beforeDestroy()"></a>钩子函数 - beforeDestroy()</h3><ul>
<li>实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="built_in">this</span>.timerId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1111</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果当组件销毁了,还不清除定时器会出现性能问题</span></span><br><span class="line"> <span class="comment">// 在浏览器中可以尝试销毁 vm.$destroy()</span></span><br><span class="line"> <span class="comment">// 最后销毁</span></span><br><span class="line">beforeDestroy () &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timerId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="钩子函数-destroyed"><a href="#钩子函数-destroyed" class="headerlink" title="钩子函数 - destroyed()"></a>钩子函数 - destroyed()</h3><ul>
<li>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
<h2 id="使用接口的形式发送数据"><a href="#使用接口的形式发送数据" class="headerlink" title="使用接口的形式发送数据"></a>使用接口的形式发送数据</h2><h3 id="json-server-提供假数据接口"><a href="#json-server-提供假数据接口" class="headerlink" title="json-server 提供假数据接口"></a>json-server 提供假数据接口</h3><ul>
<li>作用：根据指定的 JSON 文件，提供假数据接口</li>
<li>地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cGljb2RlL2pzb24tc2VydmVy">json-server<i class="fa fa-external-link-alt"></i></span></li>
<li>使用步骤</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 全局安装 json-server: <span class="string">`npm i -g json-server`</span></span><br><span class="line"><span class="number">2.</span> 准备一个json数据</span><br><span class="line"><span class="number">3.</span> 执行：<span class="string">`json-server data.json`</span></span><br><span class="line"></span><br><span class="line">data.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;todos&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>REST API 格式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 查询：GET</span><br><span class="line"><span class="number">2.</span> 添加：POST</span><br><span class="line"><span class="number">3.</span> 删除：DELETE</span><br><span class="line"><span class="number">4.</span> 更新：</span><br><span class="line">	PUT：需要将对象里的所有属性提交</span><br><span class="line">  PATCH(打补丁)：只需要提交需要修改的属性</span><br></pre></td></tr></table></figure>

<ul>
<li>具体接口<ul>
<li>查询全部数据 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3RvZG9z">http://localhost:3000/todos<i class="fa fa-external-link-alt"></i></span><br>查询指定数据 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3RvZG9zLzI=">http://localhost:3000/todos/2<i class="fa fa-external-link-alt"></i></span></li>
<li>添加一个对象 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3RvZG9z">http://localhost:3000/todos<i class="fa fa-external-link-alt"></i></span><br>POST<br>id 会自动帮我们添加</li>
<li>更新数据 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3RvZG9zLzM=">http://localhost:3000/todos/3<i class="fa fa-external-link-alt"></i></span><br>PUT 或者 PATCH<br>PUT 需要提供该对象的所有数据<br>PATCH 只需要提供要修改的数据即可</li>
<li>删除数据<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3RvZG9zLzM=">http://localhost:3000/todos/3<i class="fa fa-external-link-alt"></i></span><br>DELETE</li>
</ul>
</li>
<li>可以借助 <code>postman</code> 测试接口</li>
</ul>
<h3 id="axios-发送请求"><a href="#axios-发送请求" class="headerlink" title="axios 发送请求"></a>axios 发送请求</h3><ul>
<li><strong>作用</strong> : 一个专门用来发送 ajax 请求的库, 可以在浏览器或者 node.js 中使用</li>
<li><strong>使用步骤</strong><ul>
<li>本地安装 axios : <code>npm i -g axios</code></li>
<li>导入 axios</li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9z">axios 使用说明<i class="fa fa-external-link-alt"></i></span></li>
<li><strong>GTE 方式发送请求</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">axios.get(<span class="string">&#x27;http://localhost:3000/todoList/1&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;获取到数据了：&#x27;</span>, res.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">axios</span><br><span class="line">  .get(<span class="string">&#x27;http://localhost:3000/todoList&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取到数据了：&#x27;</span>, res.data)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>POST 方式发送请求</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// post 请求</span></span><br><span class="line">axios</span><br><span class="line">  <span class="comment">// 第一个参数：表示接口地址</span></span><br><span class="line">  <span class="comment">// 第二个参数：表示接口需要的参数</span></span><br><span class="line">  .post(<span class="string">&#x27;http://localhost:3000/todoList&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;haha&#x27;</span>,</span><br><span class="line">    <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><strong>概念 :</strong></p>
<ul>
<li>vue 中的过滤器(filter)：<strong>数据格式化</strong>，让数据按照我们规定的格式输出</li>
<li>比如 : 对于日期来说，将日期格式化转化为 <code>年-月-日 小时:分:秒</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">显示：2019-01-11T10:11:19.566Z 不是我们想要的 我们想要的：2019-01-11 18-11-53</span><br></pre></td></tr></table></figure>

<p><strong>全局过滤器 和 局部过滤器</strong></p>
<ul>
<li>全局方式创建的过滤器，在任何一个 Vue 实例中都可以使用 (一般情况下，为了项目方便管理，都是一个 vue 实例)</li>
<li>局部创建的过滤器只能在当前 vue 实例中使用</li>
<li>全局过滤器应在 Vue 实例创建之前创建</li>
</ul>
<p><strong>注册全局过滤器</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：过滤器的名字</span></span><br><span class="line"><span class="comment">// 第二个参数：是一个回调函数，只要使用过滤器的时候，这个回调函数就会执行，res =&gt; 原始数据</span></span><br><span class="line"><span class="comment">// 必须要有返回值：通过回调函数的返回值得到格式化后的数据</span></span><br><span class="line">Vue.filter(<span class="string">&#x27;date&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注册局部过滤器</strong></p>
<p>在 vm 的配置项里写一个 <code>filters</code>，对应的是一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  date (res) &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>moment 插件</strong></p>
<ul>
<li><p><span class="exturl" data-url="aHR0cDovL21vbWVudGpzLmNuLw==">moment<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>使用：<code>npm i moment</code></p>
</li>
<li><p>日期 =&gt; 指定格式<code>moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;)</code></p>
</li>
<li><p>时间戳 =&gt; 指定格式<code>moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;)</code></p>
</li>
<li><p>```js<br>Vue.filter(‘dataFilter’, res =&gt; {<br>  return moment(res).format(‘YYYY-MM-DD HH-mm-ss’)<br>})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**使用过滤器**</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;!-- data: 原始数据  dataFilter: 过滤器名称  |：管道--&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123; date | dataFilter &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局</span></span><br><span class="line">Vue.filter(<span class="string">&#x27;dataFilter&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> moment(res).format(<span class="string">&#x27;YYYY-MM-DD HH-mm-ss&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部</span></span><br><span class="line"><span class="attr">filters</span>: &#123;</span><br><span class="line">  date (res, format = <span class="string">&#x27;YYYY-MM-DD&#x27;</span>, arg) &#123;</span><br><span class="line">    <span class="keyword">return</span> moment(res).format(format)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数问题</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date | dateFilter(&#x27;YYYY-MM-DD HH-mm-ss&#x27;, 888) &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">&#x27;dateFilter&#x27;</span>, <span class="function">(<span class="params">res, format = <span class="string">&#x27;YYYY-MM-DD&#x27;</span>, arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// res: 原始数据</span></span><br><span class="line">  <span class="comment">// format：dateFilter 中的第一个参数，等号后面为默认值</span></span><br><span class="line">  <span class="comment">// arg: dateFilter 中的第二个参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg) <span class="comment">// 888</span></span><br><span class="line">  <span class="keyword">return</span> moment(res).format(format)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote>
<p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常 <strong>可复用</strong> 的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</p>
</blockquote>
<p><img data-src="vue/components.png" alt="组件化图释"></p>
<ul>
<li>注册组件的两种方式：全局组件、局部组件</li>
<li>Vue 实例中的配置项（如：methods、filters、watch、computed、directives、生命周期钩子函数）都可以在组件中使用</li>
</ul>
<h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><ul>
<li>说明：全局组件在所有的 vue 实例中都可以使用</li>
<li>注意：<ul>
<li>注册全局组件应放在 vm 实例之前</li>
<li>模板只允许有一个根节点</li>
<li>组件中的 <code>data</code> 必须是函数，并且要返回一个对象</li>
<li>组件复用时如果 data 为对象，所有复用的组件的 data 指向同一片内存空间，一个组件被修改了会影响其他组件，这不是我们想要的</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册全局组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;A custom component!&lt;/p&gt;&#x27;</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;注意：组件的data必须是一个函数！！！&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给组件指定返回值</span></span><br><span class="line"><span class="comment">// 组件名称为 One</span></span><br><span class="line"><span class="keyword">const</span> One = Vue.component(<span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;A custom component!&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 可以简写为 ==&gt;</span></span><br><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;A custom component!&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用：以自定义元素的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hello</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 渲染结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><ul>
<li>局部组件是在某一个具体的 vue 实例（组件）中定义的，只能在当前 vue 实例（组件）中使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 局部组件</span></span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="comment">// 子组件 com-a</span></span><br><span class="line">    <span class="string">&#x27;com-a&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">`&lt;h1&gt;局部组件：&#123;&#123; num &#125;&#125;&lt;/h1&gt;`</span>,</span><br><span class="line">      data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">num</span>: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><ul>
<li>组件是一个独立、封闭的个体</li>
<li>也就是说：组件中的数据默认情况下，只能在组件内部使用，无法直接在组件外部使用</li>
<li>可以将 vue 实例看做一个组件</li>
<li>对于组件之间需要相互使用彼此的情况，应该使用 <strong>组件通讯机制</strong> 来解决</li>
<li>组件通讯的三种情况 :<ul>
<li>父组件将数据传递给子组件(父 -&gt; 子)</li>
<li>子组件将数据传递给父组件 (子 =&gt; 父)</li>
<li>非父子组件(兄弟组件)</li>
</ul>
</li>
</ul>
<h4 id="父组件到子组件"><a href="#父组件到子组件" class="headerlink" title="父组件到子组件"></a>父组件到子组件</h4><ul>
<li>将要传递的数据，通过属性传递给子组件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">&quot;pmsg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>子组件通过 <code>props</code> 配置项来指定要接收的数据，props 是一个数组<ul>
<li>在使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名代替</li>
<li>如果使用字符串模板，那么这个限制就不存在了</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;msg&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>传递过来的 <code>props</code> 属性的用法与 <code>data</code> 属性的用法相同</li>
<li>子组件不能直接修改父组件传过来的数据，可以将父组件传过来的值保存在一个临时变量中</li>
<li>如果 props 传过来的数据为引用类型，只要不是重新赋值，修改数据不会报错，但不推荐这样做</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一步：将你要传递的数据,作为属性传递给子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hello</span> <span class="attr">:num</span>=<span class="string">&quot;pnum&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二部：子组件通过 props 配置项来指定要接收的数据</span></span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;num&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="子组件到父组件"><a href="#子组件到父组件" class="headerlink" title="子组件到父组件"></a>子组件到父组件</h4><ul>
<li>方式：父组件给子组件传递一个函数，由子组件调用这个函数</li>
<li>说明：借助 vue 中的自定义事件(v-on:cunstomFn=”fn”)</li>
<li><code>$emit()</code>：触发事件</li>
<li>第一步：父组件了里准备一个方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">pnum</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    pfn (num) &#123;</span><br><span class="line">      <span class="built_in">this</span>.pnum += num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步：把这个方法作为事件传递给子组件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello</span> @<span class="attr">fn</span>=<span class="string">&quot;pfn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或</span></span><br><span class="line"><span class="comment">&lt;hello @fn=&quot;num += $event&quot;&gt;&lt;/hello&gt;</span></span><br><span class="line"><span class="comment">$event 为传过来的参数</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第三步：子组件调用父组件传过来的方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;button @click=&#x27;click&#x27;&gt;按钮&lt;/button&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">num</span>: <span class="number">5</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    click () &#123;</span><br><span class="line">      <span class="comment">// 第一个参数：表示要触发的自定义事件名称，也就是 @fn</span></span><br><span class="line">      <span class="comment">// 第二个参数：表示要传递给父组件的数据</span></span><br><span class="line">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;fn&#x27;</span>, <span class="built_in">this</span>.num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="非父子组件通讯"><a href="#非父子组件通讯" class="headerlink" title="非父子组件通讯"></a>非父子组件通讯</h4><ul>
<li><p>是通过 <code>事件总线 (event bus 公交车) 机制</code> 来实现的</p>
</li>
<li><p>事件总线：实际上就是一个 <code>空 Vue 实例</code></p>
</li>
<li><p>可以实现任意两个组件之间的通讯而不管两个组件到底有什么样的层级关系</p>
</li>
<li><p><code>$emit()</code>：发送数据</p>
</li>
<li><p><code>$on()</code>：接收数据</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步：实例化事件总线 bus</span></span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发组件 A 中的事件</span></span><br><span class="line">bus.$emit(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件 B 创建的钩子中监听事件</span></span><br><span class="line">bus.$on(<span class="string">&#x27;id&#x27;</span>, <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>示例：组件 A —&gt; 组件 B</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com-a</span>&gt;</span><span class="tag">&lt;/<span class="name">com-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com-b</span>&gt;</span><span class="tag">&lt;/<span class="name">com-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步：实例化事件总线 bus</span></span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 A</span></span><br><span class="line">Vue.component(<span class="string">&#x27;com-a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;h1 @click=&quot;click&quot;&gt;组件A&lt;/h1&gt;`</span>,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    click () &#123;</span><br><span class="line">      <span class="comment">// 第二部：发送数据</span></span><br><span class="line">      bus.$emit(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;你好&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 B</span></span><br><span class="line">Vue.component(<span class="string">&#x27;com-b&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;h1&gt;组件B&lt;/h1&gt;`</span>,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="comment">// 第三步：接收数据</span></span><br><span class="line">    bus.$on(<span class="string">&#x27;hello&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;接收到数据&#x27;</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>[开关灯案例]</p>
<h3 id="单向数据流-组件与组件之间"><a href="#单向数据流-组件与组件之间" class="headerlink" title="单向数据流(组件与组件之间)"></a>单向数据流(组件与组件之间)</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个<code>单向下行绑定</code>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>当 todo-head 中的 todoName 设置数据后回车添加到 todoList，todoList 的长度就会发生变化，然后就会根据(组件与组件之间的)单向数据流，把数据单向下流到子组件中<br>而且必须是通过 props 往下传递的才可以</p>
<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p><code>vm.$refs</code> 一个对象，持有已注册过 ref 的所有子组件 ( HTML 元素)</p>
<ul>
<li>使用 :</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML元素 中，添加ref属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;div&quot;</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在JS中通过 $refs.属性 来获取</span></span><br><span class="line"><span class="comment">// 在 mounted 函数中使用</span></span><br><span class="line">Vue.component(<span class="string">&#x27;child&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;h1&gt;组件A&lt;/h1&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">num</span>: <span class="number">100</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    fn () &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.div) <span class="comment">// div 标签</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.child) <span class="comment">// child 组件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果获取的是一个子组件，那么通过 ref 就能获取到子组件中的 <code>data</code> 和 <code>methods</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.child.num) <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.child.fn) <span class="comment">// fn</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一般在第三方的组件中， 可能会用到这个功能</li>
</ul>
<h2 id="单页面应用程序"><a href="#单页面应用程序" class="headerlink" title="单页面应用程序"></a>单页面应用程序</h2><p>SPA : <strong>Single Page Application</strong> 单页面应用程序</p>
<p>MPA : <strong>Multiple Page Application</strong> 多页面应用程序</p>
<ul>
<li>单页 web 应用，就是只有一个 web 页面的应用，是加载单个 HTML 页面，并在用户与应用程序交互时动态更新该页面的 web 应用程序</li>
</ul>
<ul>
<li>区别<ul>
<li>对于传统的多页面应用程序来说，每次请求服务器返回的都是一个完整的页面</li>
<li>对于单页应用程序来说，只有第一次会加载页面，以后的每次请求，仅仅是获取必要的数据，然后由页面中 js 解析获取的数据展示在页面中</li>
</ul>
</li>
</ul>
<ul>
<li>优势 :<ul>
<li>减少了请求体积，加快页面响应速度，降低了对服务器的压力</li>
<li>更好的用户体验，让用户在 web app 感受 native app 的流畅</li>
</ul>
</li>
</ul>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul>
<li><strong>路由</strong> : 是浏览器 URL 中的<code>哈希值</code>( # hash) 与 <code>展示视图内容</code> 之间的<code>对应规则</code><ul>
<li>在 web App 中，通过一个页面来展示和管理整个应用的功能。SPA 往往是功能复杂的应用，为了有效管理所有视图内容，前端路由应运而生。简单来说，路由就是一套映射规则(一对一的对应规则)，由开发人员制定规则。当 URL 中的哈希值( <code>#</code> hash) 发生改变后，路由会根据制定好的规则，展示对应的视图内容。</li>
</ul>
</li>
<li><strong>vue 中的路由</strong>；是 <strong>hash</strong> 和 <strong>component</strong> 的对应关系，一个哈希值对应一个组件</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装路由 : <code>npm i vue-router</code></p>
<p>引入路由</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/vue-router/dist/vue-router.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>详细使用步骤</p>
<ul>
<li>实例路由对象并挂载到 vue 实例 上</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由实例 与 Vue 实例 关联到一起</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter()</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>入口 (#哈希值)</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">方式1 : url地址为入口 输入url地址改变哈希值</span></span><br><span class="line"><span class="comment">router.html#/one</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方式2 : router-link+to</span></span><br><span class="line"><span class="comment">to 属性：实际上就是哈希值，将来要参与路由规则中进行与组件匹配</span></span><br><span class="line"><span class="comment">router-link 标签最终会转化为 a 标签，to 属性转化为 a 标签的 href 属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/one&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/two&quot;</span>&gt;</span>Tow<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注册组件并设置返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置规则</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path : 路由路径</span></span><br><span class="line"><span class="comment">// component : 将来要展示的路由组件</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/one&#x27;</span>, <span class="attr">component</span>: One &#125;, &#123; <span class="attr">path</span>: <span class="string">&#x27;/two&#x27;</span>, <span class="attr">component</span>: Two &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>出口</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  出口：组件要展示的地方--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>示例 ：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 入口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可以直接通过url地址访问路由 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- to 属性：路由匹配路径</span></span><br><span class="line"><span class="comment">router-link 最终会转化为 a 标签</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/one&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/two&quot;</span>&gt;</span>Tow<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 5. 出口 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 注册组件并设置返回值</span></span><br><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实例化路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 4. 配置路由规则，路由和实例一一对应</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/one&#x27;</span>, <span class="attr">component</span>: One &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/two&#x27;</span>, <span class="attr">component</span>: Two &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 2. 将路由挂载到 vue 实例上，让 vue 和路由关联在一起</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>多出口情况</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 多个出口的形式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 配置路由规则，一个路由对应多个实例</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="comment">// conponents 为一个对象</span></span><br><span class="line">      <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="comment">// key 为出口的 name 属性值</span></span><br><span class="line">        <span class="comment">// value 为组件实例</span></span><br><span class="line">        <span class="attr">one</span>: One,</span><br><span class="line">        <span class="attr">two</span>: Two</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="入口菜单高亮处理"><a href="#入口菜单高亮处理" class="headerlink" title="入口菜单高亮处理"></a>入口菜单高亮处理</h3><p>点击导航会给链接添加两个类名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/one&quot;</span> <span class="attr">class</span>=<span class="string">&quot;router-link-exact-active router-link-active&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/two&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改方式 1：直接修改类的内容</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.router-link-exact-active</span>,</span><br><span class="line"><span class="selector-class">.router-link-active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰方式 2：给默认高亮类名设置别名，别名为已经定义好样式的类名 (推荐)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改默认高亮的a标签的类名</span></span><br><span class="line">  <span class="attr">linkActiveClass</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="精确匹配和模糊匹配"><a href="#精确匹配和模糊匹配" class="headerlink" title="精确匹配和模糊匹配"></a>精确匹配和模糊匹配</h3><ul>
<li>精确匹配：router-link-exact-active 类名 : 只有当浏览器地址栏中的哈希值 与 router-link 的 to 属性值完全匹配才会添加该类</li>
<li>模糊匹配：router-link-active 类名 : 只要浏览器地址栏中的哈希值包含 router-link 的 to 属性值就会添加该类名</li>
<li>解决办法：加个 exact</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span> <span class="attr">exact</span>&gt;</span></span><br><span class="line">  One</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：精确匹配和模糊匹配，只对添加类名这个机制有效，与路由的匹配规则无关</li>
</ul>
<h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><p>入口</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 入口  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/detail/1&quot;</span>&gt;</span>手机1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/detail/2&quot;</span>&gt;</span>手机2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/detail/3&quot;</span>&gt;</span>手机3<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>传参</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yb3V0ZXIudnVlanMub3JnL3poL2d1aWRlL2Vzc2VudGlhbHMvZHluYW1pYy1tYXRjaGluZy5odG1sIyVFNSU4QSVBOCVFNiU4MCU4MSVFOCVCNyVBRiVFNyU5NCVCMSVFNSU4QyVCOSVFOSU4NSU4RA==">动态路由匹配<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Detail = Vue.component(<span class="string">&#x27;detail&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">  <span class="comment">// 方式1：手动一个一个配置</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/detail/1&#x27;</span>, <span class="attr">component</span>: Detail &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/detail/2&#x27;</span>, <span class="attr">component</span>: Detail &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/detail/3&#x27;</span>, <span class="attr">component</span>: Detail &#125;，</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确的方式：把传过去的 1/2/3 当成参数</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/detail/:id?&#x27;</span>, <span class="attr">component</span>: Detail &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>?</code> 代表参数可传可不传，即可识别的路径包括：<code>detail</code>、<code>detail/1</code>、<code>detail2</code>、<code>detail3</code></p>
<p>获取参数的三种正确方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $route =&gt; 路由配置对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Detail = Vue.component(<span class="string">&#x27;detail&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 方式1：组件中直接读取</span></span><br><span class="line">  <span class="comment">// $route.path 为路由路径</span></span><br><span class="line">  <span class="comment">// $route.params.id 为路由参数</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 方式2：js直接读取</span></span><br><span class="line">    <span class="comment">// 打印只会打印一次，因为组件是复用的，每次进来钩子函数只会执行一次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// #/detail/2?name=zs</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route) <span class="comment">// 路由配置对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.path) <span class="comment">// #/detail/2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.params) <span class="comment">// &#123;id: &quot;2&quot;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.query) <span class="comment">// &#123;name: &#x27;zs&#x27;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.params.id) <span class="comment">// 2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 方式3：监听路由的参数变化(因为不是 data 中的数据，不需要深度监听)</span></span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// to：新值</span></span><br><span class="line">    <span class="comment">// from：旧值</span></span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(to.params.id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9yb3V0ZXIudnVlanMub3JnL3poL2d1aWRlL2Vzc2VudGlhbHMvbmF2aWdhdGlvbi5odG1sIyVFNyVCQyU5NiVFNyVBOCU4QiVFNSVCQyU4RiVFNyU5QSU4NCVFNSVBRiVCQyVFOCU4OCVBQQ==">编程式导航<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">&#x27;/user&#x27;</span>) <span class="comment">// -&gt; /user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象, path为路由的path属性值</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span> &#125;) <span class="comment">// -&gt; /user</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由，name 为路由的 name 属性值</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 如果提供了 path，params 会被忽略</span></span><br><span class="line"><span class="comment">// 这里的 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125;&#125;) <span class="comment">// -&gt; /register?plan=private</span></span><br><span class="line"></span><br><span class="line"><span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id?&#x27;</span>, name=<span class="string">&#x27;user&#x27;</span>, <span class="attr">component</span>: User &#125;]</span><br></pre></td></tr></table></figure>

<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p><code>redirect</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 / 重定向到 /home</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><h3 id="vue-是单文件组件"><a href="#vue-是单文件组件" class="headerlink" title="vue 是单文件组件"></a>vue 是单文件组件</h3><p>后缀为 .vue 的文件</p>
<p>单文件组件，无法直接在浏览器中使用，必须经过 webpack 这种打包工具处理后，才能在浏览器中使用</p>
<p>单文件组件的三个组成部分</p>
<ul>
<li>template (模板结构)</li>
<li>script 组件的代码逻辑</li>
<li>style 样式</li>
</ul>
<h3 id="脚手架介绍"><a href="#脚手架介绍" class="headerlink" title="脚手架介绍"></a>脚手架介绍</h3><p><strong>vue-cli</strong> 是 vue 的脚手架工具</p>
<p>因为 webpack 配置繁琐，阻止一批想用 vue 但是不会 webpack 的开发人员</p>
<p>vue-cli 提供了一条命令，我们直接通过这条命令就可以快速的生成一个 vue 项目 (<code>vue init XX</code>)，项目的基本结构、以及 webpack 配置项 <strong>全部配置</strong> 好了</p>
<p><span class="exturl" data-url="aHR0cHM6Ly92dWUtbG9hZGVyLnZ1ZWpzLm9yZy96aC8=">Vue Loader<i class="fa fa-external-link-alt"></i></span> 手动配置置 <code>webpack</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbGkudnVlanMub3JnL3poLw==">Vue CLI3<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly92dWVqcy10ZW1wbGF0ZXMuZ2l0aHViLmlvL3dlYnBhY2sv">Vue webpack 配置<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>安装：<code>npm i -g vue-cli</code></p>
<p>初始化 vue 项目：<code>vue init webpack 项目名称</code></p>
<p>进入到项目根目录运行项目：<code>npm run dev</code></p>
<p>项目安装过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">? Project name demo</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author</span><br><span class="line">? Vue build standalone  =&gt; 运行时+编译</span><br><span class="line">? Install vue-router? Yes</span><br><span class="line">? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard</span><br><span class="line">? <span class="built_in">Set</span> up unit tests No</span><br><span class="line">? Setup e2e tests <span class="keyword">with</span> Nightwatch? No</span><br></pre></td></tr></table></figure>

<h4 id="项目目录介绍"><a href="#项目目录介绍" class="headerlink" title="项目目录介绍"></a>项目目录介绍</h4><p><span class="exturl" data-url="aHR0cHM6Ly92dWVqcy10ZW1wbGF0ZXMuZ2l0aHViLmlvL3dlYnBhY2svc3RydWN0dXJlLmh0bWw=">https://vuejs-templates.github.io/webpack/structure.html<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── build/                      # webpack config files</span><br><span class="line">├── config/index.js             # main project config</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.js                 # app entry file</span><br><span class="line">│   ├── App.vue                 # main app component</span><br><span class="line">│   ├── components/             # ui components</span><br><span class="line">│   └── assets/                 # module assets (processed by webpack)</span><br><span class="line">├── static/                     # pure static assets (directly copied)</span><br><span class="line">├── test/</span><br><span class="line">│   └── unit/                   # unit tests</span><br><span class="line">│   └── e2e/                    # e2e tests</span><br><span class="line">├── .babelrc                    # babel config</span><br><span class="line">├── .editorconfig               # settings for your editor</span><br><span class="line">├── .eslintrc.js                # eslint config</span><br><span class="line">├── .eslintignore               # eslint ignore rules</span><br><span class="line">├── .gitignore                  # sensible defaults for gitignore</span><br><span class="line">├── .postcssrc.js               # postcss config</span><br><span class="line">├── index.html                  # index.html template</span><br><span class="line">├── package.json                # build scripts and dependencies</span><br><span class="line">└── README.md                   # Default README file</span><br></pre></td></tr></table></figure>

<ul>
<li>build 和 config 不要动，都是一些配置好的，还有一些他们之间的约定</li>
<li>.gitkeep：static 为预留的文件夹，空文件夹默认不会上传到 github，添加这个文件让 static 文件夹被 git 上传</li>
<li><code>.editorconfig</code> 编译器配置，需要安装 vscode 插件：Editorconfig</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">charset = utf-8   utf-8 格式编码</span><br><span class="line">indent_style = space   空格和tab都可以缩进</span><br><span class="line">indent_size = 2    缩进为2个</span><br><span class="line">end_of_line = lf  回车换行</span><br><span class="line">insert_final_newline = true   结束最后一行+一个空白</span><br><span class="line">trim_trailing_whitespace = true   开头去除空白</span><br></pre></td></tr></table></figure>

<ul>
<li><code>eslint</code> 校验<ul>
<li>忽略文件中有这个 =&gt; /*.js =&gt; 意思是根目录下的.js 文件不校验,,但是发现根目录就没有.js 文件</li>
<li><code>/* eslint-disable no-new */</code> eslint 忽略 no-new 规则</li>
<li><code>/* eslint-disable */</code> 也可以</li>
<li>如果去掉,就会提示你 不要以 new 开头</li>
<li>可以前面给个变量 var vm = new Vue()</li>
<li>但是又提示没有用,还要打印一下,其实这个赋值是没有意义的</li>
<li>不要去掉.这是 eslint 的<code>不校验下一行代码</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFuZGFyZGpzLmNvbS9yZWFkbWUtemhjbi5odG1s">standard 代码规范<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>postcssrc 处理 less css 等</li>
<li>src<ul>
<li>assets 静态资源</li>
<li>components 组件</li>
<li>router 路由</li>
<li>App.vue 根组件 =&gt; 指定路由出口</li>
<li>脚手架之后，所有的组件都将渲染到 app.vue 中</li>
<li>vm 中的 #app 还是 index.html 中的 #app， app.vue 中的会覆盖前者<br>可以通过分别添加 title 属性验证一下</li>
<li><code>&lt;router-view/&gt;</code> 路由出口要写在 app.vue 组件模板中</li>
<li>main.js<ul>
<li>入口 js 文件</li>
<li>作用：创建 vue 实例，导入其他组件并挂在到 vue 实例上</li>
<li><code>Vue.config.productionTip = false</code> 不要打印提示</li>
</ul>
</li>
<li>route/index.js：路由<ul>
<li><code>@</code>：build/ webpack.base.config.js =&gt; <code>&#39;@&#39;: resolve(&#39;src&#39;)</code></li>
<li>如果在一个模块化工程中使用它，必须要通过 <code>Vue.use()</code> 明确地安装路由功能</li>
<li><code>https://router.vuejs.org/zh/installation.html</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="两种编译模式"><a href="#两种编译模式" class="headerlink" title="两种编译模式"></a>两种编译模式</h3><p>完整版和运行时版</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUvaW5zdGFsbGF0aW9uLmh0bWwjJUU1JUFGJUI5JUU0JUI4JThEJUU1JTkwJThDJUU2JTlFJTg0JUU1JUJCJUJBJUU3JTg5JTg4JUU2JTlDJUFDJUU3JTlBJTg0JUU4JUE3JUEzJUU5JTg3JThB">参考官网<i class="fa fa-external-link-alt"></i></span></p>
<p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码</p>
<p>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切</p>
<ul>
<li>使用 完整版 (包含编译器)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">components</span>: &#123; App &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>只使用运行时</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>查看编译模式：build =&gt; webpack.base.config.js =&gt; <code>&#39;vue\$&#39;: &#39;vue/dist/vue.esm.js&#39;,</code></p>
<h3 id="手动配置路由"><a href="#手动配置路由" class="headerlink" title="手动配置路由"></a>手动配置路由</h3><p>安装路由 <code>npm i vue-router</code></p>
<p>准备工作：创建一个文件夹 router/router.js</p>
<p>具体配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* router.js */</span></span><br><span class="line"><span class="comment">// 引入路由</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;@/components/home/Home&#x27;</span>   (template + script + style)</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;@/components/login/Login&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把路由当成插件安装</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由，配置路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 路由规则</span></span><br><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span> : <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span> : Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span> : <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span> : Login</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main.js 中绑定路由</span></span><br><span class="line">router</span><br><span class="line"></span><br><span class="line">在跟组件 App.vue 下配置出口</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.js */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 绑定路由</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置出口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="编辑器配置插件"><a href="#编辑器配置插件" class="headerlink" title="编辑器配置插件"></a>编辑器配置插件</h3><ul>
<li><p><code>vetur</code>：vue 单文件组件的高亮</p>
</li>
<li><p>eslint</p>
<ul>
<li>关闭 <strong>eslint</strong>：打开 config/index.js，将 26 行 : <code>dev.useEslint</code>设置为 false，重启项目 ( npm run dev)</li>
</ul>
</li>
<li><p><code>Prettier</code>：格式化插件</p>
</li>
</ul>
<h2 id="TODOMVC-案例"><a href="#TODOMVC-案例" class="headerlink" title="TODOMVC 案例"></a>TODOMVC 案例</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li><span class="exturl" data-url="aHR0cDovL3RvZG9tdmMuY29tL2V4YW1wbGVzL3Z1ZS8=">Vue-TodoMVC<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rhc3RlanMvdG9kb212Yy1hcHAtdGVtcGxhdGU=">下载模板地址<i class="fa fa-external-link-alt"></i></span> <code>git clone https://github.com/tastejs/todomvc-app-template.git</code></li>
<li>安装依赖包 : <code>npm i</code></li>
<li>安装 vue : <code>npm i vue</code></li>
<li>开始 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1aWxvbmdqaW4vdG9kb212Yy1hcHAtdGVtcGxhdGUvdHJlZS9tYXN0ZXI=">https://github.com/cuilongjin/todomvc-app-template/tree/master<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><ul>
<li>渲染任务列表：<code>&lt;label&gt;&#123;&#123; item.name &#125;&#125;&lt;/label&gt;</code></li>
<li>任务完成 : <code>:class=&quot;&#123; completed : item.done &#125;&quot;</code></li>
<li>多选框选中状态 : <code>v-model=&#39;item.done&#39;</code></li>
</ul>
<h3 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h3><ul>
<li>获取文本输入框的内容 (关键点)<ul>
<li>把 input 通过 v-model 双向数据绑定 == todoName</li>
<li>@keyup.enter 触发事件 addTodo =&gt; 拿到 todoName 的值</li>
<li>判断文本框不能为空</li>
<li>按回车添加任务</li>
</ul>
</li>
<li>对象{done: false, id: , name : todoName}<ul>
<li>获取数组里最后一个元素的 id+1</li>
<li>如果数组之前一个元素都没有 , id = 1</li>
</ul>
</li>
<li>将对象添加进数组</li>
<li>添加完，清除文本框内容</li>
</ul>
<h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><ul>
<li>传索引<br><code>this.todoList.splice(index, 1)</code></li>
<li>传 id</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 id  找到对应的元素索引</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">this</span>.todoList.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id)</span><br><span class="line"><span class="comment">// 根据索引删除</span></span><br><span class="line"><span class="built_in">this</span>.todoList.splice(index, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>传 id 过滤</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传过来一个 id, 过滤出来不等于这个 id 的元素，重新赋值给 todoList</span></span><br><span class="line"><span class="built_in">this</span>.todoList = <span class="built_in">this</span>.todoList.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id !== id)</span><br></pre></td></tr></table></figure>

<h3 id="编辑任务"><a href="#编辑任务" class="headerlink" title="编辑任务"></a>编辑任务</h3><ul>
<li><p>显示<code>编辑框</code> ( editing : true) (难点)</p>
<ul>
<li>在 data 中添加一个 editId : -1</li>
<li>在 :class<br>editing: item.id === editId</li>
<li>双击 : 接收过来双击元素的 id<br>this.editId = id</li>
<li>关键点 :<br>vue 中 data 中的数据一旦发生改变，当前页面的指令和表达式都会重新计算</li>
</ul>
</li>
<li><p>读取内容<br><code>&lt;input class=&quot;edit&quot; v-model=&quot;item.name&quot;&gt;</code></p>
</li>
<li><p>回车隐藏编辑框</p>
</li>
</ul>
<h3 id="底部的显示与隐藏"><a href="#底部的显示与隐藏" class="headerlink" title="底部的显示与隐藏"></a>底部的显示与隐藏</h3><ul>
<li>v-if/v-show</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件部分</span></span><br><span class="line">&lt;footer <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;footer&quot;</span> v-show=<span class="string">&quot;isFooter()&quot;</span>&gt;</span><br><span class="line"><span class="comment">// js</span></span><br><span class="line">  <span class="function"><span class="title">isFooter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.todoList.length &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>因为 vue 中 data 的数据发送了改变，当前页面中的指令和表达式都会重新计算，所以只要文本框里的内容发生改变，todoName 也会发送改变，isFooter 会一直被调用，性能不好。我们需要的是数组列表的个数改变才会影响底部的变化，所以需要用到计算属性</p>
</li>
<li><p>计算属性</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isFooter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 计算属性 判断底部是否显示</span></span><br><span class="line">  <span class="comment">// 1. 计算属性只会跟着相关属性的值发生变化而变化</span></span><br><span class="line">  <span class="comment">// 2. 一定要有返回值</span></span><br><span class="line">  <span class="comment">// 3. 一定要写在 computed 里面</span></span><br><span class="line">  <span class="comment">// 4. 写起来像一个方法，用起来像一个属性</span></span><br><span class="line">  isFooter () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.todoList.length &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><ul>
<li>存储数据<ul>
<li>监听 list 数据的改变，只要 list 数据变了，就调用保存数据的方法</li>
<li>使用 vue 的 watch 监听 list 的数据改变</li>
<li>保存值，记得把对象转化为字符串(存的快省空间)</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 监听 todoList</span></span><br><span class="line">  <span class="attr">todoList</span>: &#123;</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">    handler (newVal) &#123;</span><br><span class="line">   		<span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;todoList&#x27;</span>, <span class="built_in">JSON</span>.stringify(newVal))</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 data 中可以初始值</span></span><br><span class="line"><span class="comment">// 设置一个默认值 空数组 []</span></span><br><span class="line"><span class="attr">todoList</span>: <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;todoList&#x27;</span>)) || []</span><br></pre></td></tr></table></figure>

<h3 id="使用钩子函数来完善数据存储"><a href="#使用钩子函数来完善数据存储" class="headerlink" title="使用钩子函数来完善数据存储"></a>使用钩子函数来完善数据存储</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="built_in">this</span>.todoList = <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;todoList&#x27;</span>)) || []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取接口数据"><a href="#获取接口数据" class="headerlink" title="获取接口数据"></a>获取接口数据</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cGljb2RlL2pzb24tc2VydmVy">json-server<i class="fa fa-external-link-alt"></i></span> 提供假数据接口</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9z">axios<i class="fa fa-external-link-alt"></i></span> 发送请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g json-server</span><br><span class="line">npm i axios</span><br><span class="line">json-server data.json</span><br></pre></td></tr></table></figure>

<h3 id="组件化-TODOMVC"><a href="#组件化-TODOMVC" class="headerlink" title="组件化 TODOMVC"></a>组件化 TODOMVC</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1aWxvbmdqaW4vdG9kb212Yy1hcHAtdGVtcGxhdGUvdHJlZS96dWppYW5odWE=">https://github.com/cuilongjin/todomvc-app-template/tree/zujianhua<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/429.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/429.html" class="post-title-link" itemprop="url">Webpack</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-05 22:33:14" itemprop="dateCreated datePublished" datetime="2019-01-05T22:33:14+00:00">2019-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy8=">webpack 官网<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcv">webpack 中文网<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1aWxvbmdqaW4vd2VicGFjay1jb25maWcv">webpack 配置文件<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>webpack 是一个现代 JavaScript 应用程序的模块打包器（module bundler）</p>
<p>webpack 是一个模块化方案（预编译）</p>
<p>webpack 获取具有依赖关系的模块，并生成表示这些模块的静态资源</p>
<p>webpack 的两个特点：模块化、打包</p>
<p>四个核心概念：<strong>入口(entry)<strong>、</strong>输出(output)<strong>、</strong>加载器(loader)<strong>、</strong>插件(plugins)</strong></p>
<p>模块化方案：webpack 和 requirejs（通过编写代码的方式将前端的功能，划分成独立的模块）<br>browserify 是与 webpack 相似的模块化打包工具</p>
<h3 id="webpack-起源"><a href="#webpack-起源" class="headerlink" title="webpack 起源"></a>webpack 起源</h3><ul>
<li>webpack 解决了现存模块打包器的两个痛点：<ul>
<li>Code Spliting - 代码分离</li>
<li>静态资源的模块化处理方案</li>
</ul>
</li>
</ul>
<h3 id="webpack-与模块"><a href="#webpack-与模块" class="headerlink" title="webpack 与模块"></a>webpack 与模块</h3><ul>
<li><p><span class="exturl" data-url="aHR0cDovL3poYW9kYS5uZXQvd2VicGFjay1oYW5kYm9vay9tb2R1bGUtc3lzdGVtLmh0bWw=">前端模块系统的演进<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>在 webpack 看来：所有的<strong>静态资源都是模块</strong></p>
</li>
<li><p>webpack 模块能够识别以下等形式的模块之间的依赖：</p>
<ul>
<li><p>ES2015 <code>import</code> <code>export</code></p>
</li>
<li><p>CommonJS <code>require()</code> <code>module.exports</code></p>
</li>
<li><p>AMD <code>define</code> 和 <code>require</code></p>
</li>
<li><p>css/sass/less 文件中的 <code>@import</code></p>
</li>
<li><p>图片连接，比如：样式 <code>url(...)</code> 或 HTML <code>&lt;img src=...&gt;</code></p>
</li>
<li><p>字体等</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>在 webpack 提供的模块化环境中<ul>
<li>想要加载一个 JS 文件，只需要 require(‘a.js’)</li>
<li>想要加载一个 CSS 文件，只需要 require(‘css/index.css’)</li>
<li>想要加载一个图片文件，只需要 require(‘images/a.png’)</li>
</ul>
</li>
</ul>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzQyZTExNTE1YzEwZiM=">入门 Webpack，看这篇就够了<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="webpack-打包原理："><a href="#webpack-打包原理：" class="headerlink" title="webpack 打包原理："></a>webpack 打包原理：</h3><p>​ 入口文件： main.js</p>
<p>​ webpack 从入口出发，递归分析项目中所有的依赖项（模块），使用 loader 来处理对应的模块最终，打包生成一个 bundle.js 文件。</p>
<p>​ 如果配置了 webpack 中的 代码分离（Code Spliting），webpack 会根据 分离点 将这个模块生成一个独立的 JS 文件</p>
<p>​ 还可以通过配置，将 CSS 、 图片、 字体 等文件，从 bundle.js 中抽离为独立的文件</p>
<h2 id="webpack-的基本使用"><a href="#webpack-的基本使用" class="headerlink" title="webpack 的基本使用"></a>webpack 的基本使用</h2><p>安装：<code>npm i -D webpack webpack-cli</code></p>
<p>webpack：是 webpack 工具的核心包</p>
<p>webpack-cli：提供了一些在终端中使用的命令</p>
<p>-D(–save-dev)：表示项目开发期间的依赖</p>
<p>webpack 的两种使用方式：命令行、配置文件（<code>webpack.config.js</code>）</p>
<h3 id="命令行使用说明"><a href="#命令行使用说明" class="headerlink" title="命令行使用说明"></a>命令行使用说明</h3><ul>
<li><code>package.json</code>中的<code>scripts</code>中可以存放一些 bash 命令，这些 bash 命令可以通过 <code>npm run 命令名称</code> 来执行</li>
<li>注意：npm 在执行 scripts 中的命令的时候，是在电脑系统后台默认开启一个 bash，将当前目录下的<code>./node_modules/.bin</code>这个文件夹临时加入了系统环境变量</li>
<li>使用方式：<code>npm run build</code></li>
<li>设置开发状态： <code>mode</code> 如果没有设置 mode 配置项，webpack 会默认提供开发环境(production)</li>
<li>在入口文件中可以使用 <code>import</code> 引入 js css less 等文件</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="comment">// webpack 是 webpack-cli 提供的命令</span></span><br><span class="line">  <span class="comment">// src/js/main.js 为入口文件</span></span><br><span class="line">  <span class="comment">// --output dist/bundle.js 为出口文件</span></span><br><span class="line">  <span class="comment">// --mode development 生产环境</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  <span class="string">&quot;build1&quot;</span>: <span class="string">&quot;webpack src/js/main.js --output dist/bundle.js --mode development&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件方式（推荐）"><a href="#配置文件方式（推荐）" class="headerlink" title="配置文件方式（推荐）"></a>配置文件方式（推荐）</h3><p>项目<code>根目录</code>下创建一个 <code>webpack.config.js</code>文件，运行 <code>webpack</code> 命令时的默认配置文件</p>
<p>指定其他文件：<code>--config webpack.XX.js</code></p>
<p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;build&quot;: &quot;webpack&quot;</code></p>
<p>执行命令 : <code>npm run build</code></p>
<p>示例代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 是基于 node的 , 所以配置文件符合 node 方式书写配置</span></span><br><span class="line"><span class="comment">// 注意 : 不要再这个文件中使用ES6的的模块化 import语法</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  <span class="attr">entry</span>: path.join(__dirname, <span class="string">&#x27;./src/js/main.js&#x27;</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出口</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 出口目录</span></span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>安装：<code>npm i -D webpack-dev-server</code></p>
<p>作用：配合 webpack，创建开发环境（启动服务器、监视文件变化、自动编译、刷新浏览器等），提高开发效率</p>
<p>注意：无法直接在终端中执行 <code>webpack-dev-server</code>，需要在 <code>package.json</code> 配置 <code>scripts</code> 后使用</p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul>
<li><code>webpack-dev-server</code>将打包好的文件存储在内存中，提高编译和加载速度，效率更高（不会生成 dist 目录）</li>
<li>在内存中出口目录为项目根目录（命令行中的提示：<code>webpack output is served from /</code>）<ul>
<li>在<code>index.html</code>页面中引入文件不需要加<code>dist</code></li>
</ul>
</li>
</ul>
<h3 id="CLI-配置"><a href="#CLI-配置" class="headerlink" title="CLI 配置"></a>CLI 配置</h3><ul>
<li><code>--contentBase</code> ：告诉服务器在哪个目录中提供服务（可以理解为：打开哪个目录中的 index.html）<ul>
<li><code>--contentBase ./src</code>：当前目录下的 src 文件夹</li>
</ul>
</li>
<li><code>--open true</code> ：自动打开浏览器</li>
<li><code>--port 3000</code> ：指定端口号</li>
<li><code>--hot</code> ：热更新，只加载修改的文件(按需加载修改的内容)，而非全部加载</li>
<li><code>--progress</code>：显示进度条</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --contentBase src --open --port 8888 --hot&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;dev&quot;: &quot;webpack-dev-server --hot&quot;</code></p>
<p>执行命令 : <code>npm run dev</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --hot 热更新写在命令行里，不然的话还要配其他插件麻烦</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: path.join(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">// hot: true,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">// api 表示当前项目请求的 key</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="comment">// 代理服务器路径</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;/api&#x27;</span> &#125;, <span class="comment">// 重写路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求 localhost:8080/api/.. 会被代理到 http://www.baidu.com/api/..</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// plugins: [</span></span><br><span class="line">  <span class="comment">//   new webpack.HotModuleReplacementPlugin()</span></span><br><span class="line">  <span class="comment">// ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="html-webpack-plugin-插件"><a href="#html-webpack-plugin-插件" class="headerlink" title="html-webpack-plugin 插件"></a>html-webpack-plugin 插件</h2><ul>
<li>安装：<code>npm i -D html-webpack-plugin</code></li>
<li>作用：根据模板，在内存中自动生成 html 页面，并自动引入<code>bundle.js</code>、<code>css</code>等文件</li>
</ul>
<p>配置文件配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 html-webpack-plugin 插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 配置插件</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin 配置</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 模板页面路径</span></span><br><span class="line">      <span class="attr">template</span>: path.join(__dirname, <span class="string">&#x27;src/index.html&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打包非-js-文件"><a href="#打包非-js-文件" class="headerlink" title="打包非 js 文件"></a>打包非 js 文件</h2><p>webpack 默认只能处理 js 文件，非 js(css、less、图片、字体等)处理不了，借助 loader 加载器</p>
<h3 id="处理-css-文件"><a href="#处理-css-文件" class="headerlink" title="处理 css 文件"></a>处理 css 文件</h3><p>在 <code>main.js</code>中引入 css 文件 <code>import &#39;../css/main.css&#39;</code></p>
<p>安装 : <code>npm i -D style-loader css-loader</code></p>
<p>在 <code>webpack.config.js</code> 中，添加个新的配置项 <code>module</code></p>
<p>在 <code>module</code> 中添加 <code>loader</code> 来处理 <code>css</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理 css</span></span><br><span class="line">      <span class="comment">// 注意点 use 执行loader 顺序 从右往左</span></span><br><span class="line">      <span class="comment">// css-loader: 读取css文件内容，将其转化为一个模块</span></span><br><span class="line">      <span class="comment">// style-loader: 拿到模块, 创建一个style标签，插入页面中</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理-less-文件"><a href="#处理-less-文件" class="headerlink" title="处理 less 文件"></a>处理 less 文件</h3><p>在 <code>main.js</code>中引入 less 文件 <code>import &#39;../css/main.less&#39;</code></p>
<p>安装 : <code>npm i -D less-loader less style-loader css-loader</code></p>
<p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理 <code>less</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">//处理 css</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理图片文件"><a href="#处理图片文件" class="headerlink" title="处理图片文件"></a>处理图片文件</h3><p>安装 : <code>npm i -D url-loader file-loader</code></p>
<p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理图片</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="comment">//  图片大小 &lt;= 10000 =&gt; 转化为base64</span></span><br><span class="line">              <span class="comment">//  图片大小 &gt;= 10000 =&gt; 不会转base64 内部调用 file-loader 加载图片</span></span><br><span class="line">              <span class="attr">limit</span>: <span class="number">10000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>url-loader</strong> 默认会将图片转化为 base64 编码格式，目的：提高性能</p>
<p><strong>file-loader</strong> 在处理图片时，会对文件进行重命名</p>
<p>base64 编码格式的图片说明：</p>
<ul>
<li>精灵图：将一些小图片合并为一张图片，减少请求次数，提高性能</li>
<li>字体图标：直接将一些小的图片,合并到字体文件中，并且不会失真</li>
<li>base64：是一种编码格式,能够将图片、文字等常见的文件，转化为 base64 格式，这种字符串格式浏览器能够识别并且读取显示到页面中</li>
<li>base64 是一个字符串，也可以直接被内嵌到页面中，或者 css 中</li>
<li>注意：大图片不适合用 base64 处理，只有小的图标才适合 base64 处理</li>
</ul>
<h3 id="处理字体文件"><a href="#处理字体文件" class="headerlink" title="处理字体文件"></a>处理字体文件</h3><p>在 <strong>main.js</strong> 中引入 css 文件 <code>import &#39;../css/iconfont/iconfont.css&#39;</code></p>
<p>在 webpack.config.js 中配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理字体图标</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(svg|woff|woff2|ttf|eot)$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;url-loader&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理-ES6-语法"><a href="#处理-ES6-语法" class="headerlink" title="处理 ES6 语法"></a>处理 ES6 语法</h3><ol>
<li>现在的项目都是使用 ES6 开发的，但是这些新的 ES6 语法，并不是所有的浏览器都支持，所以就需要有一个工具，帮我们转成 es5 语法，这个就是：babel</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvLw==">babel<i class="fa fa-external-link-alt"></i></span></li>
<li>Babel is a JavaScript compiler. ==&gt; babel 是一个 JavaScript 编译器</li>
<li>webpack 只能处理 import / export 这个 es6 模块化语法，而其他的 js 新语法，应该使用 babel 来处理</li>
</ol>
<p>babel 的使用 :</p>
<ul>
<li>安装： <code>npm i -D babel-core babel-loader@7</code><ul>
<li>babel-core 是 babel 的核心包</li>
<li>babel-loader 加载 js 文件，并将 js 代码内容交给 babel-core 解析为 es5 低版本的 js</li>
</ul>
</li>
</ul>
<ul>
<li>安装：<code>npm i -D babel-preset-env babel-preset-stage-2</code><ul>
<li>babel-preset-env：表示能够解析 es2015、es2016、es2017、es2018 这些标准的语法</li>
<li>babel-preset-stage-2：用来解析还没有被采纳为标准的语法</li>
<li><code>babel-polyfill与babel-plugin-transform-runtime</code> 也是做兼容处理的,以前都是用这个，兼容更早的</li>
</ul>
</li>
</ul>
<ul>
<li>配置 : 在 webpack.config.js 中添加一个 loader</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理 ES6 语法</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="comment">// 设置忽略 node-modules 文件夹</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node-modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在项目根目录中创建 babel 的配置文件，叫：<code>.babelrc</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;env&quot;,</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  -----------</span><br><span class="line">  // 暂时不用</span><br><span class="line">  // 如果未来某一天真的用到了polify</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-runtime&quot;, &#123;</span><br><span class="line">      &quot;helpers&quot;: false,</span><br><span class="line">      &quot;polyfill&quot;: true,</span><br><span class="line">      &quot;regenerator&quot;: true,</span><br><span class="line">      &quot;moduleName&quot;: &quot;babel-runtime&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="项目打包上线"><a href="#项目打包上线" class="headerlink" title="项目打包上线"></a>项目打包上线</h2><p>执行 : <code>npm run build</code> 对项目进行打包，生成 dist 文件</p>
<p>模拟本地服务器 : 安装 : <code>npm i -g http-server</code></p>
<p>把 dist 文件里的内容放到服务器里即可，直接运行<code>http-server</code></p>
<h2 id="webpack-和-gulp-区别"><a href="#webpack-和-gulp-区别" class="headerlink" title="webpack 和 gulp 区别"></a>webpack 和 gulp 区别</h2><ol>
<li>Gulp 侧重于前端开发的整个过程的控制管理（像是流水线），我们可以通过给 gulp 配置不通的 task（通过 Gulp 中的 gulp.task() 方法配置，比如启动 server、sass/less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程</li>
<li>Webpack 也称之为模块打包机 ，由此也可以看出 Webpack 更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js 文件、css 文件等）都可以看成模块，最初 Webpack 本身就是为前端 JS 代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack 是通过 loader（加载器）和 plugins（插件）对资源进行处理的</li>
<li>gulp 是构建工具，Webpack 是 js 模块化的解决方案</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/409.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/409.html" class="post-title-link" itemprop="url">nodejs 基本使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-29 22:21:15" itemprop="dateCreated datePublished" datetime="2018-12-29T22:21:15+00:00">2018-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="nodejs-基本介绍"><a href="#nodejs-基本介绍" class="headerlink" title="nodejs 基本介绍"></a>nodejs 基本介绍</h1><h2 id="为什么要学习-nodejs"><a href="#为什么要学习-nodejs" class="headerlink" title="为什么要学习 nodejs"></a>为什么要学习 nodejs</h2><ol>
<li>降低编程语言切换的成本(nodejs 实质上用的还是 javascript)</li>
<li>NodeJS 是前端项目的基础设施，前端项目中用到的大量工具 (大前端)</li>
<li>nodejs 在处理高并发上有得天独厚的优势(利用 nodejs 做中间层)</li>
<li>对于前端工程师，面试时对于 nodejs 有一定的要求</li>
</ol>
<h2 id="node-js-是什么？"><a href="#node-js-是什么？" class="headerlink" title="node.js 是什么？"></a>node.js 是什么？</h2><p>node.js，也叫作 node，或者 nodejs，指的都是一个平台</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnLw==">node.js 官方网站<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi8=">node.js 中文网<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbm9kZWpzLm9yZy8=">node.js 中文社区<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，nodejs 允许 javascript 代码运行在服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. nodejs不是一门新的编程语言，nodejs是在服务端运行javascript的运行环境</span><br><span class="line">2. 运行环境：写得程序想要运行必须要有对应的运行环境</span><br><span class="line">	php代码必须要有apache服务器</span><br><span class="line">	在web端，浏览器就是javascript的运行环境</span><br><span class="line">	在node端，nodejs就是javascript的运行环境</span><br><span class="line">2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。</span><br><span class="line">3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎</span><br></pre></td></tr></table></figure>

<p><strong>nodejs 的本质：不是一门新的编程语言，nodejs 是 javascript 运行在服务端的运行环境，编程语言还是 javascript</strong></p>
<h2 id="nodejs-与浏览器的区别"><a href="#nodejs-与浏览器的区别" class="headerlink" title="nodejs 与浏览器的区别"></a>nodejs 与浏览器的区别</h2><p>相同点：nodejs 与浏览器都是 js 的运行环境，都能够解析 js 程序。对于 ECMAScript 语法来说，在 nodejs 和浏览器中都能运行</p>
<p>不同点：nodejs 无法使用 DOM 和 BOM 的操作，浏览器无法执行 nodejs 中的文件操作等功能</p>
<h2 id="nodejs-可以干什么？"><a href="#nodejs-可以干什么？" class="headerlink" title="nodejs 可以干什么？"></a>nodejs 可以干什么？</h2><ol>
<li>开发服务端程序</li>
<li>开发命令行工具（CLI），比如 npm，webpack，gulp，less，sass 等</li>
<li>开发桌面应用程序（借助 node-webkit、electron 等框架实现）</li>
</ol>
<h1 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h1><h2 id="nodejs-版本"><a href="#nodejs-版本" class="headerlink" title="nodejs 版本"></a>nodejs 版本</h2><p>下载地址</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkLw==">当前版本<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL3JlbGVhc2VzLw==">历史版本<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>官网术语解释</p>
<ul>
<li>LTS 版本：Long-term Support 版本，长期支持版，即稳定版。</li>
<li>Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入</li>
</ul>
<p>查看 node 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<h1 id="运行-nodejs-程序"><a href="#运行-nodejs-程序" class="headerlink" title="运行 nodejs 程序"></a>运行 nodejs 程序</h1><h2 id="方式一：使用-node-执行-js-文件"><a href="#方式一：使用-node-执行-js-文件" class="headerlink" title="方式一：使用 node 执行 js 文件"></a>方式一：使用 node 执行 js 文件</h2><ul>
<li><p>创建 js 文件 <code>helloworld.js</code></p>
</li>
<li><p>写 nodejs 的内容：<code>console.log(&#39;hello nodejs&#39;)</code></p>
</li>
<li><p>打开命令窗口 <code>cmd</code></p>
<ul>
<li>shift 加右键打开命令窗口，执行 <code>node 文件名.js</code>即可</li>
</ul>
</li>
<li><p>执行命令：<code>node helloworld.js</code></p>
</li>
</ul>
<p>注意：在 nodejs 中是无法使用 DOM 和 BOM 的内容的，因此<code>document</code>， <code>window</code>等内容是无法使用的</p>
<h2 id="方式二：REPL-介绍"><a href="#方式二：REPL-介绍" class="headerlink" title="方式二：REPL 介绍"></a>方式二：REPL 介绍</h2><ol>
<li>REPL 全称: Read-Eval-Print-Loop（交互式解释器）<ul>
<li>R 读取 - 读取用户输入，解析输入了 Javascript 数据结构并存储在内存中</li>
<li>E 执行 - 执行输入的数据结构</li>
<li>P 打印 - 输出结果</li>
<li>L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出</li>
</ul>
</li>
<li>在 REPL 中编写程序 （类似于浏览器开发人员工具中的控制台功能）<ul>
<li>直接在控制台输入 <code>node</code> 命令进入 REPL 环境</li>
</ul>
</li>
<li>按两次 Control + C 退出 REPL 界面 或者 输入 <code>.exit</code> 退出 REPL 界面<ul>
<li>按住 control 键不要放开, 然后按两下 c 键</li>
</ul>
</li>
</ol>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>当要求系统运行一个<strong>程序</strong> 而没有告诉它程序所在的完整路径时</p>
<ol>
<li>首先在<strong>当前目录</strong>中查找和该字符串匹配的可执行文件</li>
<li>进入用户 path 环境变量查找</li>
<li>进入系统 path 环境变量查找</li>
</ol>
<p>配置环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到环境变量：计算机 --右键--&gt; 属性 --&gt; 高级系统设置 --&gt; 高级 --&gt; 环境变量</span><br></pre></td></tr></table></figure>

<h1 id="global-模块-全局变量"><a href="#global-模块-全局变量" class="headerlink" title="global 模块-全局变量"></a>global 模块-全局变量</h1><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>
<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 <code>global</code>，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>
<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
<p><strong>常用的 global 属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>: 用于打印日志</span><br><span class="line"><span class="built_in">setTimeout</span>/<span class="built_in">clearTimeout</span>: 设置清除延时器</span><br><span class="line"><span class="built_in">setInterval</span>/<span class="built_in">clearInterval</span>: 设置清除定时器</span><br><span class="line"></span><br><span class="line"><span class="attr">__dirname</span>: 当前文件的路径，不包括文件名</span><br><span class="line">__filename：当前文件的路径，包括文件名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与模块化相关的，模块化的时候会用到</span></span><br><span class="line"><span class="built_in">require</span></span><br><span class="line"><span class="built_in">exports</span></span><br><span class="line"><span class="built_in">module</span></span><br></pre></td></tr></table></figure>

<h1 id="fs-模块"><a href="#fs-模块" class="headerlink" title="fs 模块"></a>fs 模块</h1><blockquote>
<p>fs 模块是 nodejs 中最常用的一个模块，因此掌握 fs 模块非常的有必要，fs 模块的方法非常多，用到了哪个查哪个即可。</p>
<p>文档地址：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbA==">http://nodejs.cn/api/fs.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>在 nodejs 中，提供了 fs 模块，这是 node 的核心模块</p>
<p>注意：</p>
<ol>
<li>除了 global 模块中的内容可以直接使用，其他模块都是需要加载的。</li>
<li>fs 模块不是全局的，不能直接使用。因此需要导入才能使用。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><blockquote>
<p>语法：fs.readFile(file[, options], callback)</p>
</blockquote>
<p>方式一：不传编码参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件路径</span></span><br><span class="line"><span class="comment">// 参数2：读取文件的回调函数</span></span><br><span class="line"><span class="comment">// 回调函数参数1：错误对象，如果读取失败，err 会包含错误信息，如果读取成功，err 是 null</span></span><br><span class="line"><span class="comment">// 回调函数参数2：读取成功后的数据（是一个Buffer对象）</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;data.txt&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString()) <span class="comment">// 将Buffer对象转换成字符串</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>方式二：传编码参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件的路径</span></span><br><span class="line"><span class="comment">// 参数2：编码，如果设置了，返回一个字符串，如果没有设置，会返回一个buffer对象</span></span><br><span class="line"><span class="comment">// 参数3：回调函数</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>关于 Buffer 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Buffer对象是Nodejs用于处理二进制数据的</span><br><span class="line">2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制</span><br><span class="line">3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象</span><br><span class="line">4. Buffer对象可以调用toString()方法转换成字符串</span><br></pre></td></tr></table></figure>

<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><blockquote>
<p>语法：fs.writeFile(file, data[, options], callback)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件路径(如果文件不存在，会自动创建)</span></span><br><span class="line"><span class="comment">// 参数2：写入的文件内容（注意：写入的内容会覆盖以前的内容）</span></span><br><span class="line"><span class="comment">// 参数3：写文件后的回调函数</span></span><br><span class="line">fs.writeFile(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;写入文件失败&#x27;</span>, err)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;写入文件成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>写文件的时候，会把原来的内容给覆盖掉</li>
</ol>
<blockquote>
<p>语法：fs.appendFile(path, data[, options], callback)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：追加的文件名(如果文件不存在，会自动创建)</span></span><br><span class="line"><span class="comment">// 参数2：追加的文件内容</span></span><br><span class="line"><span class="comment">// 参数3：追加文件后的回调函数</span></span><br><span class="line">fs.appendFile(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;我是追加的内容&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;追加文件内容失败&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;追加文件内容成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>思考：如果没有 appendFile，通过 readFile 与 writeFile 应该怎么实现？</p>
<h2 id="文件同步与异步的说明"><a href="#文件同步与异步的说明" class="headerlink" title="文件同步与异步的说明"></a>文件同步与异步的说明</h2><blockquote>
<p>fs 中所有的文件操作，都提供了异步和同步两种方式</p>
</blockquote>
<p>异步方式：不会阻塞代码的执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">fs.readFile(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件失败&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;222&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>同步方式：会阻塞代码的执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步方式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line"><span class="keyword">const</span> result = fs.readFileSync(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">222</span>)</span><br></pre></td></tr></table></figure>

<p>总结：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。</p>
<h2 id="其他-api（了解）"><a href="#其他-api（了解）" class="headerlink" title="其他 api（了解）"></a>其他 api（了解）</h2><p>方法有很多，但是用起来都非常的简单，学会查文档</p>
<p>文档：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbA==">http://nodejs.cn/api/fs.html<i class="fa fa-external-link-alt"></i></span></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>fs.readFile(path, callback)</code></td>
<td>读取文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.readFileSync(path)</code></td>
<td>读取文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.writeFile(path, data, callback)</code></td>
<td>写入文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.writeFileSync(path, data)</code></td>
<td>写入文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.appendFile(path, data, callback)</code></td>
<td>追加文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.appendFileSync(path, data)</code></td>
<td>追加文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.rename(oldPath, newPath, callback)</code></td>
<td>重命名文件（异步）</td>
</tr>
<tr>
<td><code>fs.renameSync(oldPath, newPath)</code></td>
<td>重命名文件（同步）</td>
</tr>
<tr>
<td><code>fs.unlink(path, callback)</code></td>
<td>删除文件（异步）</td>
</tr>
<tr>
<td><code>fs.unlinkSync(path)</code></td>
<td>删除文件（同步）</td>
</tr>
<tr>
<td><code>fs.mkdir(path, mode, callback)</code></td>
<td>创建文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.mkdirSync(path, mode)</code></td>
<td>创建文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.rmdir(path, callback)</code></td>
<td>删除文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.rmdirSync(path)</code></td>
<td>删除文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.readdir(path, option, callback)</code></td>
<td>读取文件夹内容（异步）</td>
</tr>
<tr>
<td><code>fs.readdirSync(path, option)</code></td>
<td>读取文件夹内容（同步）</td>
</tr>
<tr>
<td><code>fs.stat(path, callback)</code></td>
<td>查看文件状态（异步）</td>
</tr>
<tr>
<td><code>fs.statSync(path)</code></td>
<td>查看文件状态（同步）</td>
</tr>
</tbody></table>
<h1 id="path-模块"><a href="#path-模块" class="headerlink" title="path 模块"></a>path 模块</h1><h2 id="路径操作的问题"><a href="#路径操作的问题" class="headerlink" title="路径操作的问题"></a>路径操作的问题</h2><p>在读写文件的时候，文件路径可以写相对路径或者绝对路径</p>
<p>data.txt 是相对路径，读取当前目录下的 data.txt，相对路径相对的是指向 node 命令的路径</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果node命令不是在当前目录下执行就会报错，在当前执行node命令的目录下查找data.txt，找不到</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件失败&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>相对路径：相对于执行 node 命令的路径</p>
<p>推荐使用绝对路径：<code>__dirname</code>: 当前文件的目录，<code>__filename</code>: 当前文件的目录，包含文件名</p>
<h2 id="path-模块的常用方法"><a href="#path-模块的常用方法" class="headerlink" title="path 模块的常用方法"></a>path 模块的常用方法</h2><blockquote>
<p>关于路径，在 linux 系统中，路径分隔符使用的是<code>/</code>，但是在 windows 系统中，路径使用的<code>\</code></p>
</blockquote>
<p>在我们拼写路径的时候会带来很多的麻烦，经常会出现 windows 下写的代码，在 linux 操作系统下执行不了，path 模块就是为了解决这个问题而存在的。</p>
<p>常用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.join() <span class="comment">// 拼接路径，返回拼接后的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// windows系统下</span></span><br><span class="line">path.join(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;gg&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abc\def\gg\a.html&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// linux系统下</span></span><br><span class="line">path.join(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;def&#x27;</span>,<span class="string">&#x27;gg&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;abc/def/gg/index.html&#x27;</span></span><br><span class="line"></span><br><span class="line">【优化读写文件的代码】</span><br><span class="line"></span><br><span class="line">其他方法:</span><br><span class="line">path.basename(path[, ext])	返回文件的最后一部分</span><br><span class="line">path.dirname(path)	返回路径的目录名</span><br><span class="line">path.extname(path)	获取路径的扩展名(后缀名)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> temp = <span class="string">&#x27;abc\\def\\gg\\a.html&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(temp)) <span class="comment">//a.html</span></span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(temp)) <span class="comment">//abc\def\gg</span></span><br><span class="line"><span class="built_in">console</span>.log(path.extname(temp)) <span class="comment">//.html</span></span><br></pre></td></tr></table></figure>

<h2 id="path-模块其他-api（了解）"><a href="#path-模块其他-api（了解）" class="headerlink" title="path 模块其他 api（了解）"></a>path 模块其他 api（了解）</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>path.basename(path[, ext])</code></td>
<td>返回文件的最后一部分</td>
</tr>
<tr>
<td><code>path.dirname(path)</code></td>
<td>返回路径的目录名</td>
</tr>
<tr>
<td><code>path.extname(path)</code></td>
<td>获取路径的扩展名</td>
</tr>
<tr>
<td><code>path.isAbsolute(path)</code></td>
<td>判断目录是否是绝对路径</td>
</tr>
<tr>
<td><code>path.join([...paths])</code></td>
<td>将所有的 path 片段拼接成一个规范的路径</td>
</tr>
<tr>
<td><code>path.normalize(path)</code></td>
<td>规范化路径</td>
</tr>
<tr>
<td><code>path.parse(path)</code></td>
<td>将一个路径解析成一个 path 对象</td>
</tr>
<tr>
<td><code>path.format(pathObj)</code></td>
<td>讲一个 path 对象解析成一个规范的路径</td>
</tr>
</tbody></table>
<h1 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h1><h2 id="创建服务器基本步骤"><a href="#创建服务器基本步骤" class="headerlink" title="创建服务器基本步骤"></a>创建服务器基本步骤</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入http模块，http模块是node的核心模块，作用是用来创建 http 服务器的</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 服务器处理请求</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我接收到请求了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 启动服务器，监听某个端口</span></span><br><span class="line">server.listen(<span class="number">9999</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;服务器启动成功了, 请访问： http://localhost:9999&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>详细说明</p>
<ol>
<li>给服务器注册 request 事件，只要服务器接收到了客户端的请求，就会触发 request 事件</li>
<li>request 事件有两个参数，req 表示请求对象，可以获取所有与请求相关的信息，res 是响应对象，可以获取所有与响应相关的信息</li>
<li>服务器监听的端口范围为：1-65535 之间，推荐使用 3000 以上的端口，因为 3000 以下的端口一般留给系统使用</li>
</ol>
<h2 id="request-对象详解"><a href="#request-对象详解" class="headerlink" title="request 对象详解"></a>request 对象详解</h2><p>文档地址：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJz">http://nodejs.cn/api/http.html#http_message_headers<i class="fa fa-external-link-alt"></i></span></p>
<p>常见属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">headers: 所有的请求头信息</span><br><span class="line">method：请求的方式</span><br><span class="line">rawHeaders：所有的请求头信息（数组的方式）</span><br><span class="line">url：请求的地址（url地址的路径部分）</span><br><span class="line">	请求 http:<span class="comment">//127.0.0.1:3000/index 获取到的是：/index</span></span><br><span class="line">	请求 http:<span class="comment">//127.0.0.1:3000 获取到的是：/</span></span><br></pre></td></tr></table></figure>

<p>注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个<code>favicon.ico</code>的请求</p>
<p>小结：request 对象中，常用的就是 method 和 url 两个参数</p>
<h2 id="response-对象详解"><a href="#response-对象详解" class="headerlink" title="response 对象详解"></a>response 对象详解</h2><p>文档地址：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvaHR0cC5odG1sI2h0dHBfY2xhc3NfaHR0cF9zZXJ2ZXJyZXNwb25zZQ==">http://nodejs.cn/api/http.html#http_class_http_serverresponse<i class="fa fa-external-link-alt"></i></span></p>
<p>常见的属性和方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.write(data): 给浏览器发送响应体，可以调用多次，从而提供连续的响应体</span><br><span class="line">res.end()：通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成</span><br><span class="line">res.end(data)：结束请求，并且响应一段内容，相当于res.write(data) + res.end()</span><br><span class="line">res.statusCode: 响应的的状态码 <span class="number">200</span> <span class="number">404</span> <span class="number">500</span></span><br><span class="line">res.statusMessage: 响应的状态信息（不能有中文）， 如果不设置会根据statusCode自动设置</span><br><span class="line">res.setHeader(name, value)：设置响应头信息，比如<span class="string">&#x27;content-type&#x27;</span>，<span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line">res.writeHead(statusCode, statusMessage, options)：设置响应头，同时可以设置状态码和状态信息</span><br><span class="line">	options 是对象，写响应头的键值对</span><br></pre></td></tr></table></figure>

<p><strong>注意：必须先设置响应头，才能设置响应主体。</strong></p>
<ul>
<li><p>注意：浏览器中输入的 URL 地址，仅仅是一个标识，可以不与服务器中的文件路径一致。也就是说：返回什么内容是由服务端的逻辑决定</p>
</li>
<li><p>路由 : url 标示和对应文件/数据的一一对应关系</p>
</li>
</ul>
<h2 id="模拟-Apache-服务器"><a href="#模拟-Apache-服务器" class="headerlink" title="模拟 Apache 服务器"></a>模拟 Apache 服务器</h2><ul>
<li>根据 <code>req.url</code> 读取不同的页面内容，返回给浏览器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求: 简单模仿apache服务器，浏览器发送127.0.0.1:8888/index.html</span></span><br><span class="line"><span class="comment">// 对应的返回www文件夹下面的index.html的内容</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer()</span><br><span class="line"><span class="comment">// 监听请求</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 根据不同请求输出不同响应数据</span></span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">&#x27;/&#x27;</span> || req.url === <span class="string">&#x27;/i&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取www下面的index.html</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(__dirname, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">    fs.readFile(filename, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">&#x27;文件读取失败&#x27;</span>)</span><br><span class="line">      <span class="comment">// 服务器响应文件</span></span><br><span class="line">      res.statusCode = <span class="number">200</span></span><br><span class="line">      res.statusMessage = <span class="string">&#x27;ok&#x27;</span></span><br><span class="line">      res.setHeader(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>)</span><br><span class="line">      res.end(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url === <span class="string">&#x27;/l&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取list.html</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(__dirname, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;list.html&#x27;</span>)</span><br><span class="line">    fs.readFile(filename, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;文件读取失败&#x27;</span>)</span><br><span class="line">      <span class="comment">// 服务器响应文件</span></span><br><span class="line">      res.writeHead(<span class="number">200</span>, <span class="string">&#x27;OOOOOOK&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      res.end(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回浏览器, 未找到资源</span></span><br><span class="line">    res.writeHead(<span class="number">404</span>, <span class="string">&#x27;NOT FOUND&#x27;</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    res.end(<span class="string">&#x27;404 ,资源未找到&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 开启服务器</span></span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="MIME-类型"><a href="#MIME-类型" class="headerlink" title="MIME 类型"></a>MIME 类型</h2><ul>
<li>MIME(Multipurpose Internet Mail Extensions)多用途 Internet 邮件扩展类型 是一种表示文档性质和格式的标准化方式</li>
<li>浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的 MIME 类型附加到响应对象的头部是非常重要的</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9NSU1FX1R5cGVz">MIME 类型<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="mime-模块"><a href="#mime-模块" class="headerlink" title="mime 模块"></a>mime 模块</h2><ul>
<li>作用：获取文件的 MIME 类型</li>
<li>安装：<code>npm i mime</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mime = <span class="built_in">require</span>(<span class="string">&#x27;mime&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路径对应的 MIME 类型</span></span><br><span class="line">mime.getType(<span class="string">&#x27;txt&#x27;</span>) <span class="comment">// &#x27;text/plain&#x27;</span></span><br><span class="line"><span class="comment">// 根据 MIME 获取到文件后缀名</span></span><br><span class="line">mime.getExtension(<span class="string">&#x27;text/plain&#x27;</span>) <span class="comment">// &#x27;txt&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="nodemon-自动重启"><a href="#nodemon-自动重启" class="headerlink" title="nodemon 自动重启"></a>nodemon 自动重启</h1><ul>
<li>作用：监听到 js 文件修改后，自动重启 node 程序</li>
<li>安装：<code>npm i -g nodemon</code></li>
<li>使用：<code>nodemon app.js</code> 运行 node 程序</li>
</ul>
<h1 id="hacknews-案例"><a href="#hacknews-案例" class="headerlink" title="hacknews 案例"></a>hacknews 案例</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS8=">Hacker News 示例<i class="fa fa-external-link-alt"></i></span></li>
<li>路由（route）：就是一套映射规则，根据 url 地址分配到对应的处理程序</li>
</ul>
<h2 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h2><ul>
<li>1 新闻列表页 - /index get</li>
<li>2 新闻详情页 - /details get</li>
<li>3 新闻添加页 - /submit get</li>
<li>4 新闻添加请求 - /add post</li>
</ul>
<h2 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art-template 模板引擎"></a>art-template 模板引擎</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hdWkuZ2l0aHViLmlvL2FydC10ZW1wbGF0ZS96aC1jbi9kb2NzLw==">文档<i class="fa fa-external-link-alt"></i></span></li>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install art-template</span><br></pre></td></tr></table></figure>

<ul>
<li>核心方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于模板路径渲染模板</span></span><br><span class="line"><span class="comment">// 参数1：文件的路径</span></span><br><span class="line"><span class="comment">// 参数2：数据</span></span><br><span class="line"><span class="comment">// 返回值：返回渲染后的内容</span></span><br><span class="line"><span class="comment">// template(filename, data)</span></span><br><span class="line"><span class="keyword">let</span> html = template(path.join(__dirname, <span class="string">&#x27;pages&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>), &#123; <span class="attr">name</span>: <span class="string">&#x27;大吉大利，今晚吃鸡&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意点：文件的路径必须是绝对路径</strong>；会将整个 html 当做模板返回</p>
<h2 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a>url 模块</h2><ul>
<li>说明：用于 URL 处理与解析</li>
<li>注意：通过 url 拿到的查询参数都是字符串格式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入url模块</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 URL 字符串并返回一个 URL 对象</span></span><br><span class="line"><span class="comment">// 第一个参数：表示要解析的URL字符串</span></span><br><span class="line"><span class="comment">// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象</span></span><br><span class="line"><span class="keyword">var</span> ret = url.parse(<span class="string">&#x27;http://localhost:3000/details?id=1&amp;name=jack&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ret.query) <span class="comment">// &#123;id: &#x27;1&#x27;, name: &#x27;jack&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="querystring-模块"><a href="#querystring-模块" class="headerlink" title="querystring 模块"></a>querystring 模块</h2><ul>
<li>用于解析与格式化 URL 查询字符串</li>
<li>注意：只在专门处理查询字符串时使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo=bar&amp;abc=xyz&amp;abc=123</span></span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将查询参数转化为对象</span></span><br><span class="line"><span class="comment">// 第一个参数: 要解析的 URL 查询字符串</span></span><br><span class="line">querystring.parse(<span class="string">&#x27;foo=bar&amp;abc=xyz&#x27;</span>) <span class="comment">// &#123;foo: &#x27;bar&#x27;, abc: &#x27;xyz&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="服务端重定向"><a href="#服务端重定向" class="headerlink" title="服务端重定向"></a>服务端重定向</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9TdGF0dXM=">HTTP 状态码说明<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3NodWFpLmJlL2FyY2hpdmVzLzMwMS0zMDItcmVkaXJlY3Rpb24v">301 和 302<i class="fa fa-external-link-alt"></i></span></li>
<li>说明：服务端可以通过 HTTP 状态码让浏览器中的页面重定向</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.writeHead(<span class="number">302</span>, &#123;</span><br><span class="line">  <span class="attr">Location</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">res.end()</span><br></pre></td></tr></table></figure>

<h2 id="POST-请求参数的处理"><a href="#POST-请求参数的处理" class="headerlink" title="POST 请求参数的处理"></a>POST 请求参数的处理</h2><ul>
<li>说明：POST 请求可以发送大量数据，没有大小限制</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受POST参数</span></span><br><span class="line"><span class="keyword">var</span> postData = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// data事件：用来接受客户端发送过来的POST请求数据</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">  result += chunk</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// end事件：当POST数据接收完毕时，触发</span></span><br><span class="line">req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cosnole.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="模块化改造-hackerNews"><a href="#模块化改造-hackerNews" class="headerlink" title="模块化改造 hackerNews"></a>模块化改造 hackerNews</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/405.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/405.html" class="post-title-link" itemprop="url">ES6（ECMAScript）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-29 22:17:58" itemprop="dateCreated datePublished" datetime="2018-12-29T22:17:58+00:00">2018-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ES6（ECMAScript）"><a href="#ES6（ECMAScript）" class="headerlink" title="ES6（ECMAScript）"></a>ES6（ECMAScript）</h1><p>ECMAScript 6.0（以下简称 ES6）是在 2015 年 6 月正式发布的标准。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言</p>
<p><span class="exturl" data-url="aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=">ECMAScript 6 入门 阮一峰<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h2><blockquote>
<p>ES6 中提供了两个声明变量的关键字：const 和 let</p>
</blockquote>
<p>参考链接</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yODE0MDQ1MA==">[知乎]我用了两个月的时间才理解 let<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9Ib2lzdGluZw==">[MDN]变量提升<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="let-的使用"><a href="#let-的使用" class="headerlink" title="let 的使用"></a>let 的使用</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code></p>
<ul>
<li>let 声明的变量只有在当前作用域(块作用域)有效</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不允许重复声明</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> <span class="comment">// SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>

<ul>
<li><span class="red">使用 let 声明的全局变量，不会成为 window 的属性</span></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><span class="error">存在变量提升</span></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">  <span class="keyword">let</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 let 不会提升，那么 a = 2 就会将外面的 a 由 1 变成 2</span></span><br><span class="line"><span class="comment">// 但运行发现 a = 2 报错：Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br></pre></td></tr></table></figure>

<p>总结 1：</p>
<ul>
<li>let 声明会提升到块顶部</li>
<li>从块顶部到该变量的初始化语句，这块区域叫做 TDZ（临时死区）</li>
<li>如果你在 TDZ 内使用该变量，JS 就会报错</li>
</ul>
<p>总结 2：</p>
<ul>
<li>let 的「创建」过程被提升了，但是初始化没有提升</li>
<li>var 的「创建」和「初始化」都被提升了</li>
<li>function 的「创建」「初始化」和「赋值」都被提升了</li>
</ul>
<p>所谓暂时死区，就是不能在初始化之前，使用变量</p>
<p>总结 3：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(a = <span class="number">1</span>; <span class="keyword">let</span> a) <span class="comment">// （括号去掉） // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line">a <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br></pre></td></tr></table></figure>

<p>如果 let x 的初始化过程失败了，那么</p>
<ul>
<li>x 变量就将永远处于 created 状态</li>
<li>你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）</li>
<li>由于 x 无法被初始化，所以 x 永远处在暂时死区</li>
</ul>
<h3 id="const-的使用"><a href="#const-的使用" class="headerlink" title="const 的使用"></a>const 的使用</h3><p><code>const</code>声明一个常量。常量：代码执行的过程中，不可以修改常量里面的值</p>
<ul>
<li>const 声明的量不可以改变</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span></span><br><span class="line">PI = <span class="number">3</span> <span class="comment">// TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure>

<ul>
<li>const 声明的变量必须赋值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果 const 声明了一个对象，仅仅保证地址不变，可以修改对象的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span> &#125;</span><br><span class="line">obj.age = <span class="number">18</span> <span class="comment">// 正确</span></span><br><span class="line">obj = &#123;&#125; <span class="comment">// TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他用法和 let 一样</li>
</ul>
<p>只能在当前代码块中使用<br>不能重复声明<br>不绑定全局作用域</p>
<h2 id="模板字符串-模板字面量"><a href="#模板字符串-模板字面量" class="headerlink" title="模板字符串(模板字面量)"></a>模板字符串(模板字面量)</h2><p>模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 通过``可以定义一个字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`hello world`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 模板字符串内部允许换行</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">  hello</span></span><br><span class="line"><span class="string">  world</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 模板字符串内部可以使用表达式</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">	你好，我是<span class="subst">$&#123;name&#125;</span></span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 标准新增了一种新的函数：Arrow Function（箭头函数）</p>
<p>为什么叫 Arrow Function？因为它的定义用的就是一个箭头</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line"><span class="comment">// 语法： (参数列表) =&gt; &#123;函数体&#125;</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><ul>
<li>如果没有参数列表，使用()表示参数列表</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果只有一个参数，可以省略()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">n1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果有多个参数，需要使用 () 把参数列表括起来</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>给参数指定默认值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">n = <span class="number">1</span></span>) =&gt;</span> <span class="built_in">console</span>.log(n)</span><br><span class="line">a() <span class="comment">// 1</span></span><br><span class="line">a(<span class="number">3</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不存在 prototype 这个属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有 arguments</p>
<p>箭头函数没有自己的 arguments 对象，箭头函数可以访问外围函数的 arguments 对象</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">arguments</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a(<span class="number">1</span>, <span class="number">2</span>)()) <span class="comment">// [Arguments] &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问箭头函数的参数</span></span><br><span class="line"><span class="comment">// Rest 参数接受函数的多余参数组成一个数组</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">a, b, ...Args</span>) =&gt;</span> <span class="built_in">console</span>.log(Args)</span><br><span class="line">a(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// [3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.length) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Rest 参数和 arguments 对象的区别：</li>
</ul>
<p>rest 参数只包括那些没有给出名称的参数，arguments 包含所有参数</p>
<p>rest 参数之后不能再有其他参数，否则会报错</p>
<p>函数的 length 属性，不包括 rest 参数</p>
<p>arguments 对象不是真正的数组，而 rest 参数是数组实例，可以直接使用数组的方法</p>
<p>arguments 对象拥有一些自己额外的功能</p>
<h3 id="返回值详解"><a href="#返回值详解" class="headerlink" title="返回值详解"></a>返回值详解</h3><ul>
<li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> n1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">n1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> n1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果函数体只有一行一句，并且需要返回这个值，那么可以省略 {} 和 return</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1 + n2</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数的注意点"><a href="#箭头函数的注意点" class="headerlink" title="箭头函数的注意点"></a>箭头函数的注意点</h3><ol>
<li>箭头函数内部没有 this，因此箭头函数内部的 this 指向了外部的 this</li>
<li>因为箭头函数没有 this，因此箭头函数不能作为构造函数</li>
<li>不能用 call()、apply()、bind() 这些方法改变 this 的指向</li>
</ol>
<p>【定义一个对象，定时器打招呼】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;大家好，我是&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.sayHi()</span><br></pre></td></tr></table></figure>

<h2 id="对象简化语法"><a href="#对象简化语法" class="headerlink" title="对象简化语法"></a>对象简化语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当属性的 key 和变量的名相同时可以简写</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: name&#125; ==&gt; <span class="keyword">let</span> person = &#123;name&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="keyword">let</span> cal = &#123;</span><br><span class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 可以省略 `:function`</span></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><ul>
<li>ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">let</span> methodKey = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// foo: true</span></span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span>,</span><br><span class="line">  <span class="comment">// abc: 123</span></span><br><span class="line">  [methodKey]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="class-关键字"><a href="#class-关键字" class="headerlink" title="class 关键字"></a>class 关键字</h2><p>ES5 中通过 构造函数 + 原型 的方式来实现面向对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在原型中添加实例方法</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure>

<p>ES6 中出现了 class 关键字，用来实现面向对象</p>
<p>class 声明不允许再次声明已经存在的类，否则将会抛出一个类型错误<br>class 声明不可以提升</p>
<p>class 仅仅是一个语法结构（语法糖），本质还是函数，实现继承本质上还是通过构造函数+原型的方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line">Person <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>类声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="comment">// 创建 Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类的构造函数</span></span><br><span class="line">  <span class="comment">// constructor 固定名称</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加实例方法</span></span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;tom&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure>

<p>类表达式</p>
<p>赋予一个命名类表达式的名称是类的主体的本地名称</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="comment">// Person &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名类</span></span><br><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="comment">// A &#123;&#125;</span></span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">//A &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person) <span class="comment">// class A &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(A) <span class="comment">// A is not defined</span></span><br></pre></td></tr></table></figure>

<p>类表达式也不存在提升</p>
<p>static 关键字用来定义一个类的静态方法。调用静态方法不需要实例化该类，但不能通过一个类实例调用静态方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">distance</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dx = a.x - b.x</span><br><span class="line">    <span class="keyword">const</span> dy = a.y - b.y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.hypot(dx, dy)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Point(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Point.distance(p1, p2))</span><br></pre></td></tr></table></figure>

<p>继承：要实现至少需要两个 class（子类 和 父类），子类继承自父类，继承后，子类就可以使用父类中的属性或方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;父类中的 say 方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 子类中使用 constructor 必须手动调用 super</span></span><br><span class="line">    <span class="comment">// super 表示父类的构造函数</span></span><br><span class="line">    <span class="comment">// 先调用 super() 在使用 this</span></span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;ls&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Chinese()</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br><span class="line">c.say() <span class="comment">// 父类中的方法</span></span><br></pre></td></tr></table></figure>

<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 对象解构</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同</span></span><br><span class="line">;(&#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;) <span class="comment">// 使用没有声明的赋值，数组解构类似</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取变量并赋值</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: p, <span class="attr">b</span>: q &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(p, q) <span class="comment">// 10 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将剩余属性赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b, ...rest &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;</span><br><span class="line"><span class="comment">// ;(&#123; a, b, ...rest &#125; = &#123; a: 10, b: 20, c: 30, d: 40 &#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, rest) <span class="comment">// 10 20 &#123;c: 30, d: 40&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123; a = <span class="number">1</span>, b = <span class="number">1</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值并提供默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">1</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa, bb) <span class="comment">// 10 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 数组解构</span></span><br><span class="line"><span class="keyword">var</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将剩余数组赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> [a, b, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, rest) <span class="comment">// 1 2 [3, 4]</span></span><br><span class="line"><span class="comment">// ==&gt; var a = arr[0]; var b = arr[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供默认值</span></span><br><span class="line"><span class="keyword">var</span> [c = <span class="number">2</span>, d = <span class="number">2</span>] = [<span class="number">10</span>]</span><br><span class="line"><span class="built_in">console</span>.log(c, d) <span class="comment">// 10 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略某些值</span></span><br><span class="line"><span class="keyword">var</span> [a = <span class="number">2</span>, , b = <span class="number">2</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 函数参数的解构赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">foo(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x = <span class="number">10</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 解构的特殊应用</span></span><br><span class="line"><span class="comment">// 交换变量</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line">;[a, b] = [b, a]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串解构</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;love&#x27;</span></span><br><span class="line"><span class="keyword">var</span> [a, b, c, d] = str</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d) <span class="comment">// l o v e</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符（spread）是三个点（…）。作用：将一个数组转为用逗号分隔的参数序列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr)</span><br><span class="line"><span class="comment">// 上面这句代码相当于：</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>应用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组深拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = [...arr]</span><br><span class="line"><span class="built_in">console</span>.log(arr === arr1) <span class="comment">// false, 说明arr1和arr指向不同数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个数组插入另一个数组字面量</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转数组</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;love&#x27;</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [...str]</span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">// [ &#x27;l&#x27;, &#x27;o&#x27;, &#x27;v&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>对象展开</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123; <span class="attr">food</span>: <span class="string">&#x27;spicy&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$$&#x27;</span>, <span class="attr">ambiance</span>: <span class="string">&#x27;noisy&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> search = &#123; ...defaults, <span class="attr">food</span>: <span class="string">&#x27;rich&#x27;</span> &#125; <span class="comment">// &#123; food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125; 后面的属性会覆盖前面的属性</span></span><br></pre></td></tr></table></figure>

<p>对象展开仅包含对象自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  p = <span class="number">12</span></span><br><span class="line">  <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C()</span><br><span class="line"><span class="keyword">let</span> clone = &#123; ...c &#125;</span><br><span class="line">clone.p <span class="comment">// ok</span></span><br><span class="line">clone.m() <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/422.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/422.html" class="post-title-link" itemprop="url">gulp 前端自动化环境</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-12 22:28:56" itemprop="dateCreated datePublished" datetime="2018-12-12T22:28:56+00:00">2018-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前端自动化环境"><a href="#前端自动化环境" class="headerlink" title="前端自动化环境"></a>前端自动化环境</h1><p>实现一些简单的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 版本控制</span><br><span class="line">2. 编译SASS</span><br><span class="line">3. 检查JS</span><br><span class="line">4. 图片合并</span><br><span class="line">5. 压缩CSS</span><br><span class="line">6. 压缩JS</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这些都是每个 Web 项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。</p>
<p>构建工具： Gulp、Grunt、Webpack、…</p>
<h2 id="gulp-环境"><a href="#gulp-环境" class="headerlink" title="gulp 环境"></a>gulp 环境</h2><p>Gulp 是基于 Node.js 的，需要要安装 Node.js</p>
<h3 id="安装-4-0-版本"><a href="#安装-4-0-版本" class="headerlink" title="安装 # 4.0 版本"></a>安装 # 4.0 版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查 node 环境</span></span><br><span class="line">$ node -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装 gulp</span></span><br><span class="line">$ npm install -g gulp</span><br><span class="line">$ gulp -v  <span class="comment">#4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到你的在项目根文件夹下，运行</span></span><br><span class="line">$ npm install gulp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 gulp 功能插件依赖包</span></span><br><span class="line">$ npm install gulp-less gulp-sass gulp-concat gulp-connect gulp-rename</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>新建 <code>gulpfile.js</code> 配置文件放在项目根目录下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gulp3.x 配置不能直接在 4.0 上使用</span></span><br><span class="line"><span class="comment">// gulp4.0 配置内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"><span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">&#x27;gulp-less&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fileinclude = <span class="built_in">require</span>(<span class="string">&#x27;gulp-file-include&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> connect = <span class="built_in">require</span>(<span class="string">&#x27;gulp-connect&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 serve</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  connect.server(&#123;</span><br><span class="line">    <span class="attr">root</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="string">&#x27;8888&#x27;</span>,</span><br><span class="line">    <span class="comment">// 启用https</span></span><br><span class="line">    <span class="comment">// https: true,</span></span><br><span class="line">    <span class="attr">livereload</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译 less</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileLess</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    gulp</span><br><span class="line">      <span class="comment">// &#x27;!./**&#x27; 忽略文件</span></span><br><span class="line">      .src([<span class="string">&#x27;./less/*.less&#x27;</span>, <span class="string">&#x27;!./less/_*.less&#x27;</span>])</span><br><span class="line">      .pipe(less())</span><br><span class="line">      .pipe(gulp.dest(<span class="string">&#x27;./public/css&#x27;</span>))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html 刷新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshHtml</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./*.html&#x27;</span>).pipe(connect.reload())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入外部 html 文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileHtml</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src([<span class="string">&#x27;./*.html&#x27;</span>, <span class="string">&#x27;!./_*.html&#x27;</span>])</span><br><span class="line">    .pipe(</span><br><span class="line">      fileinclude(&#123;</span><br><span class="line">        <span class="attr">prefix</span>: <span class="string">&#x27;@@&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 html 中使用 `@@include(&#x27;_header-aside.html&#x27;)` 引入公共 html 结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听文件变化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  gulp.watch([<span class="string">&#x27;./less&#x27;</span>], compileLess)</span><br><span class="line">  gulp.watch([<span class="string">&#x27;./image&#x27;</span>], compileImg)</span><br><span class="line">  gulp.watch([<span class="string">&#x27;./js&#x27;</span>], compileJs)</span><br><span class="line">  gulp.watch([<span class="string">&#x27;./*.html&#x27;</span>], compileHtml)</span><br><span class="line">  gulp.watch([<span class="string">&#x27;./public&#x27;</span>], refreshHtml)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认任务，执行 gulp 会自动执行的任务</span></span><br><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>, gulp.parallel(serve, watch))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制 lib 文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyLib</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./lib/**/*&#x27;</span>).pipe(gulp.dest(<span class="string">&#x27;./dest/lib&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空 dest 文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> del([<span class="string">&#x27;./dest&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行-gulp-任务"><a href="#运行-gulp-任务" class="headerlink" title="运行 gulp 任务"></a>运行 gulp 任务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行定义的 default 任务</span></span><br><span class="line"><span class="comment"># $ gulp default</span></span><br><span class="line">$ gulp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独运行 sass 任务</span></span><br><span class="line">$ gulp less</span><br></pre></td></tr></table></figure>

<p><code>!./**</code> 忽略文件</p>
<p><code>gulp.parallel()</code> –并行运行任务</p>
<p><code>gulp.series()</code> –运行任务序列</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他 gulp 插件参考</span><br><span class="line">gulp-imagemin: 		压缩图片</span><br><span class="line">gulp-minify-css: 	压缩css</span><br><span class="line">gulp-uglify:      压缩js</span><br><span class="line">gulp-concat:    	合并文件</span><br><span class="line">gulp-rename:  		重命名文件</span><br><span class="line">gulp-htmlmin: 		压缩html</span><br><span class="line">gulp-clean:      	清空文件夹</span><br><span class="line">del:              删除文件</span><br></pre></td></tr></table></figure>

<p>gulp-connect 启动服务本机可以打开，局域网下手机打不开解决办法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">connect.server(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">  或</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;::&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 gulp 3.x 版本中报错会暂停监听需重新开启任务，4.0 修复了此问题</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudHVpY29vbC5jb20vYXJ0aWNsZXMvbkF6cWlhTg==">https://www.tuicool.com/articles/nAzqiaN<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/398.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/398.html" class="post-title-link" itemprop="url">防抖和节流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-12 22:13:29" itemprop="dateCreated datePublished" datetime="2018-12-12T22:13:29+00:00">2018-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>防抖和节流都是为了解决<strong>短时间内大量触发某函数</strong>而导致的<strong>性能问题，</strong>比如触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象</p>
</blockquote>
<h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>在事件被触发 n 秒后再执行回调函数，如果在这 n 秒内又被触发，则重新计时（只会触发最后一次）</p>
<p>应用场景</p>
<ul>
<li><p>用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询 ajax 请求，这样可以有效减少请求次数，节约请求资源</p>
</li>
<li><p>window 的 resize、scroll 事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次</p>
</li>
</ul>
<h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p>规定一个单位时间 n，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内事件被触发多次，只有一次能生效（每 n 秒触发一次）</p>
<p>应用场景</p>
<ul>
<li><p>鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次</p>
</li>
<li><p>在页面的无限加载场景下，需要用户在滚动页面时，每隔一段时间发一次 ajax 请求，而不是在用户停下滚动页面操作时才去请求数据</p>
</li>
<li><p>监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断</p>
</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>防抖的作用是将多个连续的<code>debounced</code>调用合并为一次<code>callback</code>调用。防抖是基于最近次 <code>debounced</code> 调用来重置 <code>waitTime</code>，如果<code>debounced</code>事件触发间隔小于 <code>waitTime</code>，<code>callback</code>就不会执行；</p>
<p>节流的作用是限制<code>callback</code>调用的频率（每<code>waitTime</code>调用一次）。是基于上次 <code>callback</code> 调用来计算 <code>waitTime</code> 的，不管<code>callback</code> 事件触发有多频繁，只要距离上次 <code>callback</code> 调用超过了 <code>waitTime</code>，就一定会进行下次 <code>callback</code> 调用。</p>
<p>– 原理：</p>
<p>防抖是 <code>debounced</code> 维护了一个计时器，规定在 <code>waitTime</code> 时间后触发 <code>callback</code>，但是在 <code>waitTime</code> 时间内再次触发 <code>debounced</code> 的话，会清除当前的 timer 然后重新计时，这样一来，只有最后一次<code>debounced</code> 操作才能触发 <code>callback</code>；</p>
<p>节流是通过判断是否到达一定时间 (<code>waitTime</code>) 来再次触发 <code>callback</code> ， <code>func</code> 在 <code>waitTime</code> 时间内不能被再次触发。</p>
<p>实现</p>
<p>throttle-debounce 插件 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdGhyb3R0bGUtZGVib3VuY2U=">https://www.npmjs.com/package/throttle-debounce<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">input.oninput = throttle(<span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = debounce(<span class="number">1000</span>, b)</span><br><span class="line">a.call(&#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">delay, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> lastExec = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> elapsed = <span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>()) - lastExec</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback.apply(self, args)</span><br><span class="line">      lastExec = <span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt; delay) &#123;</span><br><span class="line">      exec()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        exec()</span><br><span class="line">      &#125;, delay - elapsed)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">delay, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback.apply(self, args)</span><br><span class="line">      lastExec = <span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      exec()</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/425.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/425.html" class="post-title-link" itemprop="url">LESS 基本使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-11 22:30:46" itemprop="dateCreated datePublished" datetime="2018-12-11T22:30:46+00:00">2018-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Less-简介"><a href="#Less-简介" class="headerlink" title="Less 简介"></a>Less 简介</h2><blockquote>
<p><strong><em>Less</em>  是一门 CSS 预处理语言（预先处理）,它扩展了 CSS 语言，增加了变量、Mixin、函数等特性</strong></p>
<p>浏览器不直接识别 less 文件，浏览器只识别 css 文件，所以我们写了 less 文件之后，我们需要预先把 less 文件转换成 css 文件。</p>
</blockquote>
<p>本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。</p>
<p><strong>less 仅仅是写 css 的另一种方式，写出来的 less 文件浏览器也不识别，所以啊，我们写完了 less 文件，还需要通过 less 解析器解析成 css，最终浏览器引入的还是 css 文件。</strong></p>
<p>学习网站：</p>
<p><span class="exturl" data-url="aHR0cDovL2xlc3Njc3Mub3JnLw==">官网 http://lesscss.org/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2xlc3Njc3MuY24v">中文网 http://lesscss.cn/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="less-的编译"><a href="#less-的编译" class="headerlink" title="less 的编译"></a>less 的编译</h2><blockquote>
<p>如何把 less 文件变成 css 文件</p>
</blockquote>
<h3 id="使用打包工具"><a href="#使用打包工具" class="headerlink" title="使用打包工具"></a>使用打包工具</h3><p><code>gulp</code></p>
<p><code>webpack</code></p>
<h3 id="使用考拉"><a href="#使用考拉" class="headerlink" title="使用考拉"></a>使用考拉</h3><blockquote>
<p>koala 是一个前端预处理器语言（less/sass）图形编译工具，支持 Less、Sass、Compass、CoffeeScript，帮助 web 开发者更高效地使用它们进行开发。跨平台运行，完美兼容 windows、linux、mac。</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cDovL2tvYWxhLWFwcC5jb20vaW5kZXgtemguaHRtbA==">考拉官网<i class="fa fa-external-link-alt"></i></span></p>
<p>使用步骤：</p>
<ol>
<li>把<code>less</code>文件夹拖进去</li>
<li>会在当前目录生成一个<code>css</code>目录</li>
</ol>
<p>优点：不用 node 环境，不用 less 环境，koala 内置了</p>
<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>easy less</p>
<h2 id="Less-语法"><a href="#Less-语法" class="headerlink" title="Less 语法"></a>Less 语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>注释</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是CSS中的注释，因此会编译到css中 */</span></span><br><span class="line"><span class="comment">// 这是less的注释，css不能识别这个注释， 最后不会编译到css文件</span></span><br></pre></td></tr></table></figure>

<p><strong>变量</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @变量名: 变量值;</span></span><br><span class="line"><span class="variable">@color:</span> <span class="number">#ccc</span>;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mixin-函数"><a href="#mixin-函数" class="headerlink" title="mixin 函数"></a>mixin 函数</h3><p><strong>混入函数</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数：不带参数</span></span><br><span class="line"><span class="selector-class">.btn</span>() &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="selector-class">.btn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数：带参数</span></span><br><span class="line"><span class="selector-class">.btn_border</span>(<span class="variable">@width</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@width</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="comment">// 如果函数定义了参数，调用的时候必须传入参数，否则会报错</span></span><br><span class="line">  <span class="selector-class">.btn_border</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数：带参数默认值</span></span><br><span class="line"><span class="selector-class">.btn_border</span>(<span class="variable">@width</span>: <span class="number">1px</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@width</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="comment">// 因为有默认值，所以不会报错</span></span><br><span class="line">  <span class="selector-class">.btn_border</span>();</span><br><span class="line">  <span class="selector-class">.btn_border</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：定义兼容多浏览器的圆角</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.border_radius</span>(<span class="variable">@value</span>: <span class="number">5px</span>) &#123;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="variable">@value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.border_radius</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><blockquote>
<p>我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。</p>
</blockquote>
<ul>
<li>使用伪类的时候 可以使用<code>&amp;</code> 表示自己</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="comment">// 子代</span></span><br><span class="line">  <span class="selector-class">.son1</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后代</span></span><br><span class="line">  &gt; <span class="selector-class">.son2</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交集： &amp; 表示本身</span></span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-class">.now</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后缀名</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;variable&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;maxin&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>模块化的思想，分模块进行管理这些 less 文件，最终只需要使用 import 将 less 引入到一起即可</p>
<h3 id="函数（运算）"><a href="#函数（运算）" class="headerlink" title="函数（运算）"></a>函数（运算）</h3><blockquote>
<p>在我们的 CSS 中充斥着大量的数值型的 value，less 可以直接支持运算，也提供了一系列的函数提供给我们使用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: round(100%/6, 2);</span><br><span class="line">  height: 100px + 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cDovL3d3dy4xMDI0aS5jb20vZGVtby9sZXNzL3JlZmVyZW5jZS5odG1s">http://www.1024i.com/demo/less/reference.html<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/390.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/390.html" class="post-title-link" itemprop="url">bootstrap 框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-11 22:06:47" itemprop="dateCreated datePublished" datetime="2018-12-11T22:06:47+00:00">2018-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ib290Y3NzLmNvbS8=">bootstrap 中文网<i class="fa fa-external-link-alt"></i></span></p>
<p>特点：</p>
<ul>
<li>组件简洁大方、代码规范精简、界面自定义性强</li>
<li>Bootstrap 是基于 HTML5 和 CSS3 开发的，它在 jQuery 的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分 jQuery 插件</li>
<li>Bootstrap 中包含了丰富的 Web 组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站</li>
</ul>
<p>优点：</p>
<ul>
<li>有自己的生态圈，不断的更新迭代</li>
<li>提供了一套简洁、直观、强悍的组件</li>
<li>标准化的 HTML+CSS 编码规范</li>
<li>让开发更简单，提高了开发效率</li>
<li>扩展性强，虽然界面组件样式已经定义好了，我们还可以自定义，修改默认样式</li>
</ul>
<p>版本：</p>
<ul>
<li>2.x.x 停止维护<ul>
<li>优点：兼容性好 IE678</li>
<li>缺点：代码不够简洁、功能不够完善</li>
</ul>
</li>
<li>3.x.x <strong>目前使用最多（H5C3 很多东西）</strong><ul>
<li>优点：稳定，偏向于开发响应式布局，移动设备优先的 WEB 项目</li>
<li>缺点：放弃了 IE67，对 IE8 支持但是界面效果不友好</li>
</ul>
</li>
<li>4.x.x 测试阶段</li>
</ul>
<h2 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h2><p>!&gt; 但凡看到 <code>role属性</code> <code>aria-*的属性</code> <code>class=&#39;sr-only&#39;的标签</code> 都可以直接删除，因为是给屏幕阅读器用的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>bootstrap基本模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 bootstrap 的核心样式文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;lib/bootstrap/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- html5shiv 是用来解决 IE8 以下浏览器不支持 HTML5 语义化标签的问题 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- respond 是用来解决 IE8 以下浏览器不支持媒体查询的问题，注意：respond 不支持 file 协议打开 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 条件注释：IE浏览器专属 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;respond.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">  &lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- bootstrap 依赖于 jquery，因此需要在 bootstrap 之前引入jquery文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/jquery/jquery-1.12.4.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 bootstrap 的核心js文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/bootstrap/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h2><h3 id="normalize-css"><a href="#normalize-css" class="headerlink" title="normalize.css"></a>normalize.css</h3><p>Normalize.css 是一种 CSS reset 的替代方案。经过@necolas 和@jon_neal 花了几百个小时来努力研究不同浏览器的默认样式的差异，这个项目终于变成了现在这样</p>
<p><span class="exturl" data-url="aHR0cDovL25lY29sYXMuZ2l0aHViLmlvL25vcm1hbGl6ZS5jc3Mv">官网<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcw==">github 网址<i class="fa fa-external-link-alt"></i></span></p>
<p>normalize 的特点：</p>
<ul>
<li><strong>保护有用的浏览器默认样式</strong>而不是完全去掉它们</li>
<li><strong>一般化的样式</strong>：为大部分 HTML 元素提供</li>
<li><strong>修复浏览器自身的 bug</strong>并保证各浏览器的一致性</li>
<li><strong>优化 CSS 可用性</strong>：用一些小技巧</li>
</ul>
<p><code>Normalize.css</code> 支持包括手机浏览器在内的超多浏览器，同时对 HTML5 元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS93ZWJwdXNoL3AvNDk3NDA2My5odG1s">Normalize.css 与 CSS reset 区别<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h3><p>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。默认带了 15px 的 padding 值</p>
<p><code>.container</code> 类用于固定宽度并支持响应式布局的容器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>.container-fluid</code> 类用于 100% 宽度，占据全部视口（viewport）的容器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两种容器类不能互相嵌套</p>
<h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>栅格系统，也叫网格系统，bootstrap 栅格系统把一个盒子分成 12 格</p>
<ul>
<li><p>栅格参数：<code>col-xx-yy</code></p>
<p>xx：<code>lg</code> 大屏(≥1200px)、<code>md</code> 中屏(≥992px)、<code>sm</code> 小屏(≥768px)、<code>xs</code> 超小屏(&lt;768px)</p>
<p>yy：取值范围为 1 - 12 表示占几格</p>
<p><code>col-xx-12</code>：可以省略不写</p>
</li>
<li><p>列偏移：<code>col-xx-offset-yy</code></p>
<p>xx ：lg、md、sm、xs</p>
<p>yy：取值范围为 1 - 12 表示往右偏移几格</p>
<p>列偏移：实际上是给当前元素增加了左侧的边距（margin）</p>
</li>
<li><p>多余列（column）的元素将作为一个整体单元被另起一行排列</p>
</li>
<li><p><code>.row</code>用于抵消 <code>.container</code>容器的 15px 的 padding 值，实际上是给元素添加了 margin: -15px</p>
</li>
<li><p>可以在<code>.row</code>中嵌套<code>column</code></p>
</li>
<li><p>列排序：<code>.col-md-push-*</code> 和 <code>.col-md-pull-*</code></p>
</li>
</ul>
<p>栅格系统常用类（总共 12 列）</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>例子</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>.col-xs-xx</td>
<td>.col-xs-6</td>
<td>在超小屏幕（及以上）生效</td>
</tr>
<tr>
<td>.col-sm-xx</td>
<td>.col-sm-6</td>
<td>在小屏幕（及以上）生效</td>
</tr>
<tr>
<td>.col-md-xx</td>
<td>.col-md-6</td>
<td>在中屏幕（及以上）生效</td>
</tr>
<tr>
<td>.col-lg-xx</td>
<td>.col-lg-3</td>
<td>在大屏幕及生效，占 1/4</td>
</tr>
<tr>
<td>.col-lg-xx</td>
<td>.col-lg-4</td>
<td>在大屏幕及生效，占 1/3</td>
</tr>
<tr>
<td>.col-lg-xx</td>
<td>.col-lg-5</td>
<td>在大屏幕及生效，占 1/2</td>
</tr>
</tbody></table>
<p>【案例：列嵌套.html】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-4&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 栅格系统无处不在，只要父盒子有宽度，就可以使用栅格系统 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>【案例：列偏移.html】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 .col-md-offset-* 类可以将列向右侧偏移--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- col-lg-offset-3:在大屏下，这个div将向右侧偏移3个单位 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-6 col-lg-offset-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><p>标题：h1 到 h6 标签、<code>.h1</code> 到 <code>.h6</code> 类、 <code>&lt;small&gt;</code> 标签或 <code>.small</code> 类用来标记副标题</p>
<p>文本：<code>&lt;mark&gt;</code>标记、<code>&lt;del&gt;</code>删除、<code>&lt;s&gt;</code>无用文本、<code>&lt;ins&gt;</code>插入文本、<code>&lt;u&gt;</code>下划线文本、 <code>.small</code> 类或<code>&lt;small&gt;</code> 小号文本、<code>&lt;strong&gt;</code>着重</p>
<p>对齐：<code>text-left</code>、<code>text-center</code>、<code>text-right</code>、<code>text-justify</code>、<code>text-nowrap</code></p>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p><code>&lt;a&gt;</code>、<code>&lt;button&gt;</code> 或 <code>&lt;input&gt;</code></p>
<p>预定义样式：btn、btn-default、btn-primary(蓝)、btn-success(绿)、btn-info(浅蓝)、btn-warning(橙)、btn-danger(红)、btn-link(链接)</p>
<p>尺寸：btn-lg(大)、(默认)、btn-sm(小)、btn-xs(超小)<br>btn-block (块元素 100%宽度)</p>
<p>激活状态：active</p>
<p>禁用状态：button 元素 添加 <code>disabled</code> 属性、链接<code>&lt;a&gt;</code>元素添加 <code>.disabled</code> 类（建议通过 JavaScript 代码来禁止链接的原始功能）</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>响应式图片：<code>img-responsive</code></p>
<p>实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性</p>
<p>图片形状：<code>img-rounded</code>、<code>img-circle</code>、<code>img-thumbnail</code></p>
<h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><p>文本颜色：<code>text-muted</code>、<code>text-muted</code>、<code>text-primary</code>、<code>text-success</code>、<code>text-info</code>、<code>text-warning</code>、<code>text-danger</code></p>
<p>背景颜色：<code>bg-primary</code>、<code>bg-success</code>、<code>bg-info</code>、<code>bg-warning</code>、<code>bg-danger</code></p>
<p>关闭按钮：<code>&lt;button type=&quot;button&quot; class=&quot;close&quot;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;</code></p>
<p>三角符号：<code>&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</code></p>
<p>快速浮动：<code>pull-left</code>、<code>pull-right</code></p>
<p>让内容块居中：<code>&lt;div class=&quot;center-block&quot;&gt;...&lt;/div&gt;</code></p>
<p>清除浮动：<code>clearfix</code></p>
<p>显示隐藏内容：<code>show</code>、<code>hidden</code>、<code>invisible</code></p>
<h3 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	            超小屏 小屏幕 中等屏幕 大屏幕桌面</span><br><span class="line">.visible-xs-*	可见   隐藏   隐藏	  隐藏</span><br><span class="line">.visible-sm-*	隐藏   可见   隐藏	  隐藏</span><br><span class="line">.visible-md-*	隐藏   隐藏   可见	  隐藏</span><br><span class="line">.visible-lg-*	隐藏   隐藏   隐藏	  可见</span><br><span class="line"></span><br><span class="line">.hidden-xs	  隐藏	 可见	  可见	  可见</span><br><span class="line">.hidden-sm	  可见	 隐藏	  可见	  可见</span><br><span class="line">.hidden-md	  可见	 可见	  隐藏	  可见</span><br><span class="line">.hidden-lg    可见	 可见	  可见	  隐藏</span><br></pre></td></tr></table></figure>

<p><code>*</code> -&gt; block inline inline-block</p>
<p>推荐使用 hidden 相关的属性</p>
<h2 id="bootstrap-validator-插件"><a href="#bootstrap-validator-插件" class="headerlink" title="bootstrap-validator 插件"></a>bootstrap-validator 插件</h2><p>基于 bootstrap 的前端校验插件</p>
<p><span class="exturl" data-url="aHR0cDovL2Jvb3RzdHJhcHZhbGlkYXRvci52b3RpbnRzZXYucnUvYXBp">http://bootstrapvalidator.votintsev.ru/api<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="引包"><a href="#引包" class="headerlink" title="引包"></a>引包</h3><p>引入 css 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;lib/bootstrap/css/bootstrap.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;lib/bootstrap-validator/css/bootstrapValidator.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入 js 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/jquery/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/bootstrap/js/bootstrap.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/bootstrap-validator/js/bootstrapValidator.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化表单校验插件"><a href="#初始化表单校验插件" class="headerlink" title="初始化表单校验插件"></a>初始化表单校验插件</h3><p>bootstrap-validator 插件会在表单提交的时候进行校验，如果校验成功了，表单会继续提交，但是如果校验失败了，就会阻止表单的提交</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用表单校验插件</span></span><br><span class="line">$(formSelector).bootstrapValidator(&#123;</span><br><span class="line">  <span class="comment">// 1. 指定不校验的类型，默认为[&#x27;:disabled&#x27;, &#x27;:hidden&#x27;, &#x27;:not(:visible)&#x27;],可以不设置</span></span><br><span class="line">  <span class="attr">excluded</span>: [], <span class="comment">// 全部校验</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 指定校验时的图标显示，默认是bootstrap风格</span></span><br><span class="line">  <span class="attr">feedbackIcons</span>: &#123;</span><br><span class="line">    <span class="attr">valid</span>: <span class="string">&#x27;glyphicon glyphicon-ok&#x27;</span>,</span><br><span class="line">    <span class="attr">invalid</span>: <span class="string">&#x27;glyphicon glyphicon-remove&#x27;</span>,</span><br><span class="line">    <span class="attr">validating</span>: <span class="string">&#x27;glyphicon glyphicon-refresh&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 指定校验字段</span></span><br><span class="line">  <span class="attr">fields</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: &#123;</span><br><span class="line">      <span class="comment">// 设置校验规则</span></span><br><span class="line">      <span class="attr">validators</span>: &#123;</span><br><span class="line">        <span class="comment">// 不能为空</span></span><br><span class="line">        <span class="attr">notEmpty</span>: &#123;</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">stringLength</span>: &#123;</span><br><span class="line">          <span class="attr">min</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">max</span>: <span class="number">12</span>,</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 正则校验</span></span><br><span class="line">        <span class="attr">regexp</span>: &#123;</span><br><span class="line">          <span class="attr">regexp</span>: <span class="regexp">/^[a-zA-Z0-9_\.]+$/</span>,</span><br><span class="line">          message: <span class="string">&#x27;用户名由数字字母下划线和.组成&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="attr">callback</span>: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">password</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="注册表单校验成功的事件"><a href="#注册表单校验成功的事件" class="headerlink" title="注册表单校验成功的事件"></a>注册表单校验成功的事件</h3><p>当表单校验成功时，会触发<code>success.form.bv</code>事件，此时会提交表单，通常我们需要禁止表单的自动提交，使用 ajax 进行表单的提交</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#form&#x27;</span>).on(<span class="string">&#x27;success.form.bv&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="comment">// 使用ajax提交逻辑</span></span><br><span class="line">  $.ajax(&#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="获取-validator-实例-对象"><a href="#获取-validator-实例-对象" class="headerlink" title="获取 validator 实例(对象)"></a>获取 validator 实例(对象)</h3><p>当我们初始化好表单校验插件时，我们可以通过以下方法来获取表单校验的 validator 实例，通过 validator 实例调用一些方法来完成某些功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取表单校验实例</span></span><br><span class="line"><span class="keyword">var</span> validator = $(<span class="string">&#x27;#form&#x27;</span>).data(<span class="string">&#x27;bootstrapValidator&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用表单校验实例可以调用一些常用的方法</span></span><br><span class="line">validator.methodName(params)</span><br></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h4><p>重置表单中设置过校验的内容，将隐藏所有错误提示和图标</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重置表单，隐藏所有的错误提示和图标 传入参数 true 会将内容也清空</span></span><br><span class="line">validator.resetForm()</span><br></pre></td></tr></table></figure>

<h4 id="更新字段的状态"><a href="#更新字段的状态" class="headerlink" title="更新字段的状态"></a>更新字段的状态</h4><p>BootstrapValidator 在用户输入内容的时候，会做校验，当调用 bootstrap 的插件的方法可以手动会改变字段值的状态</p>
<p><code>validator.updateStatus(field*, status*, validator)</code></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>field</code></td>
<td>String|jQuery</td>
<td>The field name or field element</td>
</tr>
<tr>
<td><code>status</code></td>
<td>String</td>
<td>Can be <code>NOT_VALIDATED</code>, <code>VALIDATING</code>, <code>INVALID</code> or <code>VALID</code></td>
</tr>
<tr>
<td><code>validator</code></td>
<td>String</td>
<td>The validator name. If <code>null</code>, the method updates validity result for all validators</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/389.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/389.html" class="post-title-link" itemprop="url">移动 web</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-11 22:05:45" itemprop="dateCreated datePublished" datetime="2018-12-11T22:05:45+00:00">2018-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="移动-web-基础"><a href="#移动-web-基础" class="headerlink" title="移动 web 基础"></a>移动 web 基础</h1><h2 id="移动端开发现状"><a href="#移动端开发现状" class="headerlink" title="移动端开发现状"></a>移动端开发现状</h2><ul>
<li>移动 web 开发指的是需要适配移动设备的网页开发</li>
<li>移动 web 开发与 pc 端 web 开发没有本质的区别，使用的还是 HTML/CSS/JavaScript 的技术</li>
<li>移动 web 开发与 pc 端 web 开发的区别是什么？</li>
</ul>
<p>移动端的浏览器与 pc 端不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">谷歌浏览器 苹果浏览器、 UC浏览器 QQ浏览器 欧朋浏览器 百度手机浏览器  360安全浏览器  搜狗浏览器  猎豹浏览器等</span><br><span class="line">国内的手机浏览器都是根据webkit内核修改过来的，国内没有自主研发的内核，国内的操作系统也是基于Android系统修改的。</span><br><span class="line"></span><br><span class="line">因此在移动端，css3 属性只需要加 webkit 前缀即可</span><br></pre></td></tr></table></figure>

<p>移动端设备尺寸不一样(尺寸非常多，碎片化很严重)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Android： <span class="number">320</span>*<span class="number">480</span> <span class="number">480</span>*<span class="number">800</span>  <span class="number">540</span>*<span class="number">960</span> <span class="number">720</span>*<span class="number">1280</span> <span class="number">1080</span>*<span class="number">1920</span> 2k屏 4k屏</span><br><span class="line">iphpne：  <span class="number">640</span>*<span class="number">960</span> <span class="number">640</span>*<span class="number">1136</span> <span class="number">750</span>*<span class="number">1334</span> <span class="number">1242</span>*<span class="number">2208</span></span><br></pre></td></tr></table></figure>

<h2 id="移动端开发分类"><a href="#移动端开发分类" class="headerlink" title="移动端开发分类"></a>移动端开发分类</h2><ul>
<li>原生 app（native app）</li>
<li>混合 app（Hybrid app）</li>
<li>web 应用（webApp）</li>
</ul>
<p><strong>原生 app（native app）</strong></p>
<blockquote>
<p>原生 app 是基于操作系统的开发，比如安卓，ios，windows phone,他们只能在各自的操作系统上运行。</p>
</blockquote>
<p>优点：</p>
<ol>
<li>可以访问操作系统，获取更多的资源（gps，摄像头，传感器，麦克风等）</li>
<li>速度快，性能高，用户体验好</li>
<li>可以离线使用</li>
</ol>
<p>缺点：</p>
<ol>
<li>开发成本高</li>
<li>需要安装和更新，更新与发布需要审核。</li>
</ol>
<p><strong>Web App</strong></p>
<blockquote>
<p>Web 应用使用 H5C3 开发页面，为浏览器设计的基于 web 的应用，可以在各种智能设备的手机浏览器上运行。不需要安装即可运行。</p>
</blockquote>
<p>优点：</p>
<ol>
<li>支持设备广泛</li>
<li>开发成本低（使用）</li>
<li>可以随时上线与更新，无需审核</li>
</ol>
<p>缺点：</p>
<ol>
<li>用户体验极度依赖网速</li>
<li>要求联网</li>
<li>无法获取手机的资源（gps，摄像头）</li>
</ol>
<p><strong>混合 app（Hybrid App）</strong></p>
<blockquote>
<p>Hybrid App 是指介于 web-app、native-app 这两者之间的 app,它虽然看上去是一个 Native App，但只有一个 UI WebView，里面访问的是一个 Web App。（淘宝、京东、手机百度）</p>
</blockquote>
<p>Hybird App 说白了就是使用了 Native app 的壳，里面其实还是 HTML5 页面</p>
<p>优点：</p>
<ol>
<li>开发成本和难度更低，兼容多个平台</li>
<li>也可以访问手机的操作系统资源。</li>
<li>更新维护更方便</li>
</ol>
<p>缺点：</p>
<ol>
<li>用户体验相比原生 app 稍差</li>
<li>性能依赖于网速</li>
</ol>
<p>总结：</p>
<p>三种开发各有优缺点，具体用什么需要根据实际情况而定，比如预算，app 注重功能还是内容等</p>
<h2 id="屏幕与分辨率"><a href="#屏幕与分辨率" class="headerlink" title="屏幕与分辨率"></a>屏幕与分辨率</h2><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMTc1Mzg1NQ==">理解设备像素、设备独立像素和 css 像素<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>移动设备与 PC 设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面</p>
</blockquote>
<p>屏幕尺寸</p>
<p>通常我们所指的屏幕<code>尺寸</code>，实际上指的是屏幕对角线的长度（一般用英寸来度量）</p>
<p><code>1英寸 = 2.54厘米</code></p>
<p>屏幕分辨率</p>
<p>分辨率则一般用像素来度量，表示屏幕水平和垂直方向的像素数，例如 1920*1080 指的是屏幕垂直方向和水平方向分别有 1920 和 1080 个像素点而构成</p>
<p><code>像素</code>：指计算机显示设备中的最小单位，即一个像素点的大小。每一个像素点可以理解为就是屏幕上的一个发光点</p>
<p>像素密度 ppi</p>
<p><code>PPI (Pixels Per Inch)</code>表示屏幕每英寸的像素数</p>
<p>PPI 值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙</p>
<h2 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a>设备像素</h2><blockquote>
<p>设备像素 (device pixels）也叫物理像素</p>
</blockquote>
<p>设备像素指的是显示器上的真实像素，每个像素的大小是屏幕固有的属性，屏幕出厂以后就不会改变了</p>
<p>设备分辨率描述的就是这个显示器的宽和高分别是多少个设备像素</p>
<p>设备像素和设备分辨率交给操作系统来管理，浏览器不知道、也不需要知道设备分辨率的大小，浏览器只需要知道<strong>逻辑分辨率</strong>就可以了</p>
<h2 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h2><blockquote>
<p>设备独立像素（Device Independent Pixels）也叫逻辑像素、设备无关像素。在 IOS 设备上叫<code>PT</code>，Android 设备上叫<code>DP</code>，在 css 中，叫<code>PX</code></p>
</blockquote>
<p>为了能够保证 <code>图像内容在不同的 PPI 设备看上去大小应该差不多</code> ，操作系统定义了一个单位：设备独立像素，用设备独立像素定义的尺寸，不管屏幕的参数如何，都能以合适的大小显示（这也是设备独立像素名字的由来）</p>
<p>对于那些像素密度高的屏幕，操作系统将多个设备像素划分为一个逻辑像素。屏幕的像素密度越高，就需要更多的设备像素来显示一个设备独立像素。至于将多少设备像素划分为一个逻辑像素，这由操作系统决定</p>
<p>获取设备的像素比</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.devicePixelRatio <span class="comment">// 物理像素 与 css 像素的比值 DPR</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>screen.width/height</code>得到的屏幕宽度和高度就是逻辑分辨率（单位：设备独立像素）</p>
<h2 id="css-像素与缩放"><a href="#css-像素与缩放" class="headerlink" title="css 像素与缩放"></a>css 像素与缩放</h2><p>在缩放比例为 100% 的情况下，一个 css 像素大小等于一个设备独立像素</p>
<p>缩放页面的时候，元素的 css 像素数量不会改变，改变的只是每个 css 像素的大小</p>
<p>缩放比例 = css 像素边长 / 设备独立像素边长</p>
<p>如果原本元素宽度为 128 个设备独立像素，那么缩放 200% 以后元素宽度为 256 个设备独立像素（css 像素宽度始终是 128）</p>
<p>桌面浏览器上缩放机制是 page zoom，缩放会导致 CSS 像素边长的改变，从而导致 window.devicePixelRatio 的改变</p>
<p>在移动端缩放机制是 pinch zoom，计算 window.devicePixelRatio 时，不考虑 pinch zoom 对 CSS 像素尺寸的影响，因此 window.devicePixelRatio 不会随缩放而改变</p>
<h2 id="2-倍图与-3-倍图"><a href="#2-倍图与-3-倍图" class="headerlink" title="2 倍图与 3 倍图"></a>2 倍图与 3 倍图</h2><blockquote>
<p>以后同学在工作的过程中，从 UI 那拿到的设计图通常都是 640 的设计图或者是 750 的设计图</p>
</blockquote>
<p>把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度</p>
<p>设备像素比 devicePixelRatio：即像素的压缩比例</p>
<p><strong>结论 ：在移动端为了在高清屏手机上显示得更加细腻，通常会使用更大的图片，比如 2 倍图或者 3 倍图</strong></p>
<h2 id="视口-viewport"><a href="#视口-viewport" class="headerlink" title="视口 viewport"></a>视口 viewport</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题：一个电脑上的网站，在手机端访问，效果是什么样的？</span><br><span class="line"></span><br><span class="line">iPhone5 的设备宽度只有 320px，一张宽度为 640px 的图片在手机端访问，显示的效果是什么？</span><br><span class="line"></span><br><span class="line">1. 在手机端，html的 大小都是 980px，为什么？</span><br><span class="line">这主要是历史原因导致的，因为在移动设备刚流行的时候，网站大多都是pc端的，pc端的页面宽度一般都比较大，移动设备的宽度比较小，如果pc端页面直接在移动端显示的话，页面就会错乱。为了解决这个问题，移动端html的大小直接就定死成了980px（因为早起的pc端网站版心就是980px居多）</span><br><span class="line"></span><br><span class="line">2. 视口</span><br><span class="line">在 pc 端，html 的大小默认是继承了浏览器的宽度，即浏览器多宽，html 的大小就是多宽，但是在移动端，多出来了一个视口的概念（乔布斯）,视口说白了就是介于浏览器与 html 之间的一个东西，视口的宽度默认定死了 980px，因此 html 的宽度默认就是 980px，视口的特点是能够根据设备的宽度进行缩放</span><br><span class="line"></span><br><span class="line">3. 视口设置</span><br><span class="line">对于现在的移动端页面来说，视口默认为 980px 肯定不合适，因为设备宽度不够的话，视口会进行缩放，导致页面展示效果不好看</span><br></pre></td></tr></table></figure>

<p><strong>视口参数设置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// width 设置视口的宽度</span></span><br><span class="line"><span class="comment">// width=device-width   设置视口宽度为设备的宽度（常用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initial-scale 设置初始缩放比例</span></span><br><span class="line"><span class="comment">// initial-scale=1.0  表示不缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user-scalable 设置是否允许用户缩放</span></span><br><span class="line"><span class="comment">// user-scalable=no  不允许用户缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum-scale  设置允许的最大缩放比例</span></span><br><span class="line"><span class="comment">// maximum-scale=1.0  可以不设置，因为都禁止用户缩放了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// minimum-scale 设置允许最小缩放比</span></span><br><span class="line"><span class="comment">// minimum-scale=1.0  不设置，因为都禁用用户缩放了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准写法：</span></span><br><span class="line"><span class="comment">// 快捷键：  meta:vp + tab键</span></span><br><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="移动端调试问题"><a href="#移动端调试问题" class="headerlink" title="移动端调试问题"></a>移动端调试问题</h2><ol>
<li>模拟器调试</li>
<li>真机调试：使用手机进行访问。</li>
</ol>
<p>手机设备五花八门，屏幕尺寸都大不一样，尤其是安卓端，给我们的页面预览带来了一些麻烦。在实际工作中，作为开发者不可能有足够的设备让我们去测试（<strong>除了测试部门</strong> ），即便有，效率也特别的低，因此开发者一般都是通过浏览器的手机模拟器来模拟不同的设备。</p>
<h1 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h1><p><strong>移动端的特点</strong></p>
<ul>
<li>手机端的兼容性问题比 PC 端小很多，因为手机端的浏览器版本比较新</li>
<li>手机端屏幕比较小，能够放的内容比较少。</li>
</ul>
<p>问题：布局的时候怎么解决屏幕大小不一致的问题？</p>
<ul>
<li>PC 端，固定版心，让所有分辨率的电脑的版心都是一样的，比如京东</li>
<li>移动端：移动端无法设置版心，因为移动端的设备屏幕本身就小，设置版心不合适。因此移动端大多会采用流式布局（百分比布局）</li>
</ul>
<p><strong>流式布局</strong>，也叫百分比布局，是移动端开发中经常使用的布局方式之一。</p>
<p>流式布局的特征：</p>
<ul>
<li>宽度自适应，高度写死，并不是百分百还原设计图</li>
<li>图标都是固定死大小的，包括字体等也是固定死的。并不是所有的东西都是自适应的。</li>
<li>一些大的图片，设置宽度为百分比自适应即可，随着屏幕大小进行变化</li>
</ul>
<p><strong>流式布局无法做到所有设备都非常逼真的还原设计图，有些设备显示效果不是特别的好看。但是流式布局是移动端非常常用的一种布局方式，比较简单，需要掌握（携程、京东)</strong></p>
<p><strong>最后一天会学习 rem 布局，配合 less 非常的方便，并且能够实现完全的自适应，包括字体以及图标等</strong></p>
<p>经典的流式布局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 左侧固定，右侧自适应</span><br><span class="line">2. 右侧固定，左侧自适应</span><br><span class="line">3. 两侧固定，中间自适应（圣杯布局，双飞翼布局）</span><br><span class="line">4. 等分布局</span><br></pre></td></tr></table></figure>

<h1 id="touch-事件"><a href="#touch-事件" class="headerlink" title="touch 事件"></a>touch 事件</h1><p>移动端新增了 4 个与手指触摸相关的事件</p>
<ul>
<li><code>touchstart</code>: 手指放到屏幕上时触发</li>
<li><code>touchmove</code>: 手指在屏幕上滑动式触发（会触发多次）</li>
<li><code>touchend</code>: 手指离开屏幕时触发</li>
<li><code>touchcancel</code>: 系统取消 touch 事件的时候触发，比如电话</li>
</ul>
<p>每个触摸事件被触发后，会生成一个 event 对象，event 对象中<code>changedTouches</code>会记录手指滑动的信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">e.touches <span class="comment">// 当前屏幕上的手指</span></span><br><span class="line">e.targetTouches <span class="comment">// 当前dom元素上的手指。</span></span><br><span class="line">e.changedTouches <span class="comment">// 触摸时发生改变的手指(重点)(如手指离开屏幕)</span></span><br></pre></td></tr></table></figure>

<p>这些列表里的每次触摸由 touch 对象组成，touch 对象里包含着触摸信息，主要属性如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e.changedTouches[0].clientX</span></span><br><span class="line">clientX / clientY <span class="comment">// 触摸点相对浏览器窗口的位置</span></span><br><span class="line">pageX / pageY <span class="comment">// 触摸点相对于页面的位置</span></span><br></pre></td></tr></table></figure>

<p>!&gt; 使用 jquery 注册 touch 类事件时，获取手指使用 <code>e.originalEvent.touchs[0]</code> ，因为 jq 对事件对象进行了封装</p>
<p>【案例：jdm-滑动轮播图】</p>
<p>【案例：jdm-区域滚动】</p>
<h2 id="iscroll-插件使用"><a href="#iscroll-插件使用" class="headerlink" title="iscroll 插件使用"></a>iscroll 插件使用</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1YmlxL2lzY3JvbGw=">https://github.com/cubiq/iscroll<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5tYW1pY29kZS5jb20vaW5mby1kZXRhaWwtMzMxODI3Lmh0bWw=">iscroll 参考文档<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>注意</strong>：使用 iscroll 需要满足的条件</p>
<ol>
<li>父盒子嵌套了子盒子（一个）</li>
<li>如果有多个子盒子，所以我们需要使用一个盒子把所有的子盒子包裹起来</li>
<li>如果有图片，我们需要保证图片加载完成，如果有浮动，需要清除浮动，为了保证子盒子的高度获取的是正确的</li>
<li>子盒子大小一定要超过父盒子的大小</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用：box为父盒子</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> IScroll(box, &#123;</span><br><span class="line">  <span class="attr">scrollX</span>: <span class="literal">false</span>, <span class="comment">// 横向滚动</span></span><br><span class="line">  <span class="attr">scrollY</span>: <span class="literal">true</span> <span class="comment">// 纵向滚动</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="zepto-框架"><a href="#zepto-框架" class="headerlink" title="zepto 框架"></a>zepto 框架</h1><blockquote>
<p><strong>Zepto</strong>是一个轻量级的<strong>针对现代高级浏览器的 JavaScript 库， <strong>它与 jquery</strong>有着类似的 api</strong>。 如果你会用 jquery，那么你也会用 zepto</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hZHJvYmJ5L3plcHRv">github 地址<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3plcHRvanNfYXBpLw==">中文文档<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="zepto-与-jquery-的区别"><a href="#zepto-与-jquery-的区别" class="headerlink" title="zepto 与 jquery 的区别"></a>zepto 与 jquery 的区别</h2><ul>
<li>jquery 针对 pc 端，主要用于解决浏览器兼容性问题，zepto 主要针对移动端</li>
<li>zepto 比 jquery 轻量，文件体积更小</li>
<li>zepto 封装了一些移动端的手势事件</li>
</ul>
<h2 id="zepto-的基本使用"><a href="#zepto-的基本使用" class="headerlink" title="zepto 的基本使用"></a>zepto 的基本使用</h2><p>zepto 的使用与 jquery 基本一致，zepto 是分模块的，需要某个功能，就需要引入某个 zepto 的文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;zepto/zepto.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;zepto/event.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;zepto/fx.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">&#x27;.box&#x27;</span>).addClass(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  $(<span class="string">&#x27;button&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.box&#x27;</span>).animate(&#123; <span class="attr">width</span>: <span class="number">500</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="zepto-的定制"><a href="#zepto-的定制" class="headerlink" title="zepto 的定制"></a>zepto 的定制</h2><p>安装 Nodejs 环境</p>
<p>1、下载 zepto.js</p>
<p>2、解压缩</p>
<p>3、cmd 命令行进入解压缩后的目录</p>
<p>4、执行<code>npm install</code>命令</p>
<p>5、编辑 make 文件的<code>41行</code>，添加自定义模块并保存</p>
<p>7、然后执行命令 <code>npm run-script dist</code></p>
<p>8、查看目录 dist 即构建好的 zepto.js</p>
<h2 id="zepto-手势事件"><a href="#zepto-手势事件" class="headerlink" title="zepto 手势事件"></a>zepto 手势事件</h2><p>zepto 中根据<code>touchstart touchmove touchend</code>封装了一些常用的手势事件，这些事件都是基于 touchstart touchmove touchend 封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tap <span class="comment">// 轻触事件,用于替代移动端的click事件，因为click事件在老版本中会有300ms的延迟</span></span><br><span class="line">swipe <span class="comment">//手指滑动时触发</span></span><br><span class="line">swipeLeft <span class="comment">//左滑</span></span><br><span class="line">swipeRight <span class="comment">//右滑</span></span><br><span class="line">swipeUp <span class="comment">//上滑</span></span><br><span class="line">swipeDown <span class="comment">//下滑</span></span><br></pre></td></tr></table></figure>

<h1 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h1><h2 id="什么是响应式布局"><a href="#什么是响应式布局" class="headerlink" title="什么是响应式布局"></a>什么是响应式布局</h2><blockquote>
<p>响应式布局（respond layout）是 Ethan Marcotte 在 2010 年 5 月份提出的一个概念，简而言之，就是<strong>一个网站能够兼容多个终端（手机、平板、pc 电脑、手表）</strong> ——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的</p>
</blockquote>
<p><strong>为什么要有响应式布局？</strong></p>
<ul>
<li>在移动互联日益成熟的时候，在 PC 端开发的网页已经无法满足移动设备的要求</li>
<li>通常的做法是针对移动端单独做一套特定的版本</li>
<li>如果终端越来越多，那么需要开发的版本就会越来越多（大屏设备的普及）</li>
<li><strong>响应式布局</strong> ：一个网站能够兼容多个终端（节约开发成本）</li>
</ul>
<p><strong>优点：</strong></p>
<p>面对不同分辨率设备灵活性强</p>
<p>能够快捷解决多设备显示适应问题</p>
<p>**缺点： **</p>
<p>兼容各种设备工作量大，效率低下</p>
<p>代码累赘，会出现隐藏无用的元素，加载时间加长</p>
<p>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</p>
<p>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</p>
<p>响应式开发现状：</p>
<ul>
<li>如果已经存在 PC 的网站了，那么一般不会使用响应式开发，而是针对移动端再开发一套系统（比如京东、淘宝）</li>
<li>在<strong>新建站点</strong> 上采用响应式开发的越来越多</li>
<li>在国内，响应式开发还不是特别的流行。但响应式开发是大势所趋，会越来越流行</li>
</ul>
<h2 id="响应式开发与移动-web-开发的比较"><a href="#响应式开发与移动-web-开发的比较" class="headerlink" title="响应式开发与移动 web 开发的比较"></a>响应式开发与移动 web 开发的比较</h2><table>
<thead>
<tr>
<th>开发方式</th>
<th>移动 web 开发+pc 开发</th>
<th>响应式开发</th>
</tr>
</thead>
<tbody><tr>
<td>引用场景</td>
<td>一般已经有了 PC 端网站，只需要端独开发移动端网站即可</td>
<td>针对一些新建网站，并且要求适配移动端</td>
</tr>
<tr>
<td>开发</td>
<td>针对性强，开发效率高</td>
<td>兼容各种终端，效率低</td>
</tr>
<tr>
<td>适配</td>
<td>只能适配移动端或者 PC 端，pad 上体验比较差</td>
<td>可以适配各种终端</td>
</tr>
<tr>
<td>效率</td>
<td>代码简介，加载快</td>
<td>代码相对复杂，加载慢</td>
</tr>
</tbody></table>
<h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><blockquote>
<p>媒体查询（Media Query）是 CSS3 提出来的一个新的属性，通过媒体查询可以查询到 screen 的宽度，从而指定某个宽度区间的网页布局</p>
</blockquote>
<h2 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>宽度范围</th>
</tr>
</thead>
<tbody><tr>
<td>大屏设备</td>
<td>&gt;1200px</td>
</tr>
<tr>
<td>中屏设备</td>
<td>992px~1200px</td>
</tr>
<tr>
<td>小屏设备</td>
<td>768px~992px</td>
</tr>
<tr>
<td>超小屏设备</td>
<td>&lt; 768px</td>
</tr>
</tbody></table>
<h2 id="媒体查询的使用"><a href="#媒体查询的使用" class="headerlink" title="媒体查询的使用"></a>媒体查询的使用</h2><p>需求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  大屏设备(&gt;1200px)   版心：1170px   背景色：红色</span></span><br><span class="line"><span class="comment">  中屏设备(992-1200)  版心：970px    背景色：蓝色</span></span><br><span class="line"><span class="comment">  小屏设备(768-992)   版心：750px    背景色：黄色</span></span><br><span class="line"><span class="comment">  超小屏设备(&lt;768px)  版心：100%     背景色：绿色</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>响应式开发的原理：使用媒体查询实现不同终端的布局和样式的切换</p>
<p>媒体查询语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查询屏幕 */</span></span><br><span class="line"><span class="comment">/* screen 和第一个 and 可以省略 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> 条件 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 条件的写法 */</span></span><br><span class="line"><span class="comment">/* min-width: 只要屏幕宽度超过这个值的设备样式就能生效 */</span></span><br><span class="line"><span class="comment">/* max-width: 只要屏幕宽度小于这个值的设备样式就能生效 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1170px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">992px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">992px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="bootstrap-框架"><a href="#bootstrap-框架" class="headerlink" title="bootstrap 框架"></a>bootstrap 框架</h1><p><strong>【项目：微金所】</strong></p>
<h1 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h1><h2 id="rem-是什么？"><a href="#rem-是什么？" class="headerlink" title="rem 是什么？"></a>rem 是什么？</h2><p><code>rem</code>（font size of the root element）是指相对于<code>根元素</code>的字体大小的单位。它就是一个相对单位。</p>
<p><code>em</code>（font size of the element）是指相对于 <code>当前元素的字体大小</code> 的单位。它也是一个相对单位。</p>
<p>它们之间其实很相似，只不过计算的规则一个是依赖根元素，一个是当前元素计算。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.em</span> &#123;</span><br><span class="line">  <span class="comment">/* em 的计算方式参照的当前元素的 font-size，如果不设置，默认继承自父盒子 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* rem 的计算方式参照的是 html 的 font-size */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.rem</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么要用-rem？"><a href="#为什么要用-rem？" class="headerlink" title="为什么要用 rem？"></a>为什么要用 rem？</h2><blockquote>
<p>rem 的主要目的就是解决用于不同屏幕的适配问题。rem 能够等比例的适配所有的屏幕。</p>
</blockquote>
<p>由于市面上手机种类繁多，导致移动端的屏幕种类非常的混乱，比如有常见的<code>320px 360px 375px 384px 480px 640px</code>等。在开发中，美工一般只会提供 750px 或者是 640px 的设计稿，这就要求我们通过一张设计稿能够适配所有的屏幕。通常解决方案如下：</p>
<ul>
<li>流式布局：虽然可以让各种屏幕都适配，但是显示效果不是非常的友好，因为只有几个尺寸的手机能够完美的显示出来视觉设计师和交互最想要的效果。但是目前使用流式布局的公司非常多，比如 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYW1hem9uLmNuLw==">亚马逊<i class="fa fa-external-link-alt"></i></span> 、<span class="exturl" data-url="aHR0cHM6Ly9tLmpkLmNvbS8=">京东<i class="fa fa-external-link-alt"></i></span> 、<span class="exturl" data-url="aHR0cHM6Ly9tLmN0cmlwLmNvbS8=">携程<i class="fa fa-external-link-alt"></i></span></li>
<li>响应式布局：响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是<strong>工作大，维护性难</strong> 。所以一般都是中小型的门户或者博客类站点会采用响应式的方法从 PC 端页面到移动端页面以及 web app 直接一步到位，因为这样反而可以节约成本。</li>
<li>rem 布局：rem 能够适配所有的屏幕，与 less 配合使用效果会更好。目前使用 rem 布局的有：<span class="exturl" data-url="aHR0cHM6Ly9tLnRhb2Jhby5jb20v">淘宝<i class="fa fa-external-link-alt"></i></span> 、 <span class="exturl" data-url="aHR0cHM6Ly9tLnN1bmluZy5jb20v">苏宁<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h2><p>因为 rem 的基准点是根元素 html 的字体大小，因此我们只需要设置不同屏幕的 html 的 font-size 大小不一样就可以达到不同屏幕的适配了。</p>
<h3 id="rem-配合媒体查询"><a href="#rem-配合媒体查询" class="headerlink" title="rem 配合媒体查询"></a>rem 配合媒体查询</h3><p>使用 rem 配合媒体查询可以适配多个终端</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span>(min-width: <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="comment">/* 基准值 / 设计图的大小  = 某个屏幕的font-size / 屏幕的宽度 */</span></span><br><span class="line">    <span class="comment">/* 100/750 = x/370 */</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>优点：使用媒体查询适配，速度快。</p>
<p>缺点：适配多个终端时，需要添加响应的代码。</p>
<h3 id="rem-配合-javascript"><a href="#rem-配合-javascript" class="headerlink" title="rem 配合 javascript"></a>rem 配合 javascript</h3><p>通过 javascript 获取可视区的宽度，计算 font-size 的值，也可以适配多个终端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据屏幕的大小动态设置 html的 font-size</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">responsive</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> uiWidth = <span class="number">750</span> <span class="comment">// 设计图宽度</span></span><br><span class="line">  <span class="keyword">var</span> base = <span class="number">100</span> <span class="comment">// 设计图中1rem的大小</span></span><br><span class="line">  <span class="comment">// 当前屏幕的大小</span></span><br><span class="line">  <span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth</span><br><span class="line">  <span class="keyword">if</span>(pageWidth &gt;= <span class="number">750</span>) &#123;</span><br><span class="line">    pageWidth = <span class="number">750</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pageWidth &lt;= <span class="number">320</span>) &#123;</span><br><span class="line">    pageWidth = <span class="number">320</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 说白了就是把一个屏幕分成了 7.5 rem</span></span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.fontSize = (base / uiWidth * pageWidth).toFixed(<span class="number">2</span>) + ’px‘</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：直接适配所有的终端</p>
<p>缺点：必须在页面加载之前设置 html 的 font-size 值，不然会出现文字大小调动的情况。</p>
<h3 id="rem-配合-flexible-插件"><a href="#rem-配合-flexible-插件" class="headerlink" title="rem 配合 flexible 插件"></a>rem 配合 flexible 插件</h3><ul>
<li><p>flexible 插件基准值（base）是设计图的 1/10</p>
</li>
<li><p>使用 flexible</p>
</li>
</ul>
<ol>
<li><p>在 header 中引入 flexible.js 这个文件</p>
</li>
<li><p>根据设计图能够确定基准值， 配合 px2rem 插件 ，需要设置一个 rootFontSize</p>
</li>
</ol>
<p>【案例：苏宁易购】</p>
<h1 id="swiper-插件"><a href="#swiper-插件" class="headerlink" title="swiper 插件"></a>swiper 插件</h1><blockquote>
<p>Swiper 是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5zd2lwZXIuY29tLmNuLw==">swiper 中文网<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="comment">/* 取消链接高亮, 移动端特有的样式  */</span></span><br><span class="line">  -webkit-tap-highlight-<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/400.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/400.html" class="post-title-link" itemprop="url">浏览器的工作原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-30 22:14:52" itemprop="dateCreated datePublished" datetime="2018-11-30T22:14:52+00:00">2018-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h2><p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102203825.png"></p>
<ul>
<li>用户界面－ 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</li>
<li>浏览器引擎－ 用来查询及操作渲染引擎的接口</li>
<li>渲染引擎（浏览器内核）－ 用来显示请求的内容，例如，如果请求内容为 html，它负责解析 html 及 css，并将解析后的结果显示出来</li>
<li>网络－ 用来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作</li>
<li>UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</li>
<li>JS 解释器－ 用来解释执行 JS 代码</li>
<li>数据存储－ 属于持久层，浏览器需要在硬盘中保存类似 cookie 的各种数据，HTML5 定义了 Storage 技术，这是一种轻量级完整的客户端存储技术</li>
</ul>
<h2 id="主流的渲染引擎"><a href="#主流的渲染引擎" class="headerlink" title="主流的渲染引擎"></a>主流的渲染引擎</h2><blockquote>
<p>浏览器的渲染引擎也叫排版引擎，或者是<strong>浏览器内核</strong></p>
</blockquote>
<p>主流的 渲染引擎 有</p>
<ul>
<li><strong>Chrome 浏览器</strong>: Blink 引擎（WebKit 的一个分支）。</li>
<li><strong>Safari 浏览器</strong>: WebKit 引擎，windows 版本 2008 年 3 月 18 日推出正式版，但苹果已于 2012 年 7 月 25 日停止开发 Windows 版的 Safari。</li>
<li><strong>FireFox 浏览器</strong>: Gecko 引擎。</li>
<li><strong>Opera 浏览器</strong>: Blink 引擎(早期版使用 Presto 引擎）。</li>
<li><strong>Internet Explorer 浏览器</strong>: Trident 引擎。</li>
<li><strong>Microsoft Edge 浏览器</strong>: EdgeHTML 引擎（Trident 的一个分支）。</li>
</ul>
<h2 id="渲染引擎工作原理"><a href="#渲染引擎工作原理" class="headerlink" title="渲染引擎工作原理"></a>渲染引擎工作原理</h2><p>渲染引擎解析的基本流程：</p>
<ol>
<li><p>解析 HTML 构建 <code>Dom树</code>，同时解析所有的 css 样式，构建 css 规则。DOM 是 W3C 组织推荐的处理可扩展置标语言的标准编程接口。</p>
</li>
<li><p>根据 DOM 树和 css 规则合并构建 <code>渲染树</code></p>
<ul>
<li>DOM 树上的节点没有样式的，渲染树的节点有样式的</li>
<li>渲染树上的节点都是需要渲染的，所以渲染树上没有像<code>head</code>标签 或 <code>display: none</code>这样的元素，但是它们在 Dom 树中</li>
</ul>
</li>
<li><p>对渲染树进行布局，定位坐标和大小、确定是否换行、确定 position、overflow、z-index 等等，这个过程叫<code>layout</code> 或 <code>reflow</code>。</p>
</li>
<li><p>绘制渲染树，调用操作系统底层 API(UI Backend)进行绘图操作。</p>
</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102203846.png"></p>
<p><strong>webkit 内核工作流程</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102203907.png"></p>
<p><strong>gecko 内核工作流程</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@main/img/20210102203924.jpeg"></p>
<p>结论：浏览器能够解析 HTML 文件，并且显示到页面中。所以我们写的文件能够使用浏览器打开并且能够看到效果。</p>
<h1 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h1><h2 id="重绘与回流-1"><a href="#重绘与回流-1" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><p><code>回流(reflow)</code>: 又叫重排，当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。</p>
<p><code>重绘(repaint)</code>：当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。</p>
<ol>
<li>每个页面至少需要一次回流+重绘</li>
<li>回流必将引起重绘</li>
</ol>
<p>回流什么时候发生？</p>
<p>1、添加或者删除可见的 DOM 元素</p>
<p>2、元素位置改变</p>
<p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p>
<p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变</p>
<p>5、页面渲染初始化</p>
<p>6、浏览器窗口尺寸改变——resize 事件发生时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style</span><br><span class="line">s.padding = <span class="string">&#x27;2px&#x27;</span> <span class="comment">// 回流+重绘</span></span><br><span class="line">s.border = <span class="string">&#x27;1px solid red&#x27;</span> <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">&#x27;blue&#x27;</span> <span class="comment">// 再一次重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">&#x27;#ccc&#x27;</span> <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">&#x27;14px&#x27;</span> <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="comment">// 添加node，再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;abc!&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="聪明的浏览器"><a href="#聪明的浏览器" class="headerlink" title="聪明的浏览器"></a>聪明的浏览器</h2><blockquote>
<p>从上个实例代码中可以看到几行简单的 JS 代码就引起了 6 次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句 JS 操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
</blockquote>
<p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前 flush 队列，这样浏览器的优化可能就起不到作用了。当你向浏览器请求一些 style 信息的时候，就会让浏览器 flush 队列，比如：</p>
<ol>
<li><p>offsetTop, offsetLeft, offsetWidth, offsetHeight</p>
</li>
<li><p>scrollTop/Left/Width/Height</p>
</li>
<li><p>clientTop/Left/Width/Height</p>
</li>
<li><p>width,height</p>
</li>
<li><p>请求了 getComputedStyle(), 或者 IE 的 currentStyle</p>
</li>
</ol>
<h2 id="如何性能优化"><a href="#如何性能优化" class="headerlink" title="如何性能优化"></a>如何性能优化</h2><blockquote>
<p>减少回流与重绘的次数，就需要简单对渲染树的操作</p>
</blockquote>
<ol>
<li>直接使用 <code>className</code> 修改样式，少用 style 设置样式</li>
<li>让要操作的元素进行”离线处理”，处理完后一起更新<ul>
<li>使用 <code>DocumentFragment</code> 进行缓存操作，引发一次回流和重绘</li>
<li>使用 <code>display:none</code> 技术，只引发两次回流和重绘</li>
</ul>
</li>
<li>将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow</li>
<li><strong>完成功能是前提，在完成功能的情况下想着优化代码</strong></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">c</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>本站为个人博客，站内所有软件资源均收集自互联网，本站仅做免费分享，不出售。本站内所有软件资源仅限个人用于学习和研究目的，不得将上述内容用于商业或者非法用途，否则，一切后果请用户自负。本站内所有软件必须在下载后的24个小时之内，从您的电脑中彻底删除。本站对任何资源不提供技术支持，遇到问题请自行研究或购买正版。本站信息来自网络，版权争议与本站无关。访问和下载本站内容，说明您已同意上述条款。


    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>





  <script class="next-config" data-name="nprogress" type="application/json">{&quot;enable&quot;:true,&quot;spinner&quot;:true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{&quot;enable&quot;:true,&quot;repo&quot;:&quot;cuilongjin&#x2F;hexo-blog&quot;,&quot;issue_term&quot;:&quot;pathname&quot;,&quot;theme&quot;:&quot;github-light&quot;,&quot;label&quot;:&quot;comment&quot;}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
