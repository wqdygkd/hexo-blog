<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-logo.png">
  <link rel="mask-icon" href="/images/favicon-logo.png" color="#222">
  <meta name="google-site-verification" content="4ub2lNf2WEkusifo-b7xbJIm2G5xxYUczDoWOFGp-NM">
  <meta name="msvalidate.01" content="C2030D8E2452D4B39AED09488E55F2DF">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;wqdy.top&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:true,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:true,&quot;pangu&quot;:true,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:true}}</script>
<meta name="description" content="分享各类资源、经验与技巧">
<meta property="og:type" content="website">
<meta property="og:title" content="我全都要">
<meta property="og:url" content="https://wqdy.top/page/15/index.html">
<meta property="og:site_name" content="我全都要">
<meta property="og:description" content="分享各类资源、经验与技巧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="c">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wqdy.top/page/15/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;15&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>我全都要</title><script src="/js/config.js"></script>

<!-- google 分析 -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9068539038073295"
     crossorigin="anonymous"></script>


  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112496567-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{&quot;tracking_id&quot;:&quot;UA-112496567-1&quot;,&quot;only_pageview&quot;:false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?0a902dd83e2d4f1aebaeaa0bafe307a0"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我全都要</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">搞快点</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-前端"><a href="/c/frontend/" rel="section"><i class="fab fa-html5 fa-fw"></i>前端</a></li>
        <li class="menu-item menu-item-软件"><a href="/c/software/" rel="section"><i class="fas fa-th-large fa-fw"></i>软件</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-面试"><span class="exturl" data-url="aHR0cHM6Ly9tcy53cWR5LnRvcA=="><i class="fas fa-archive fa-fw"></i>面试</span></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="c"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">c</p>
  <div class="site-description" itemprop="description">分享各类资源、经验与技巧</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">157</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1aWxvbmdqaW4=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cuilongjin"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/1663.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1663.html" class="post-title-link" itemprop="url">PHP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-10-25" itemprop="dateCreated datePublished" datetime="2018-10-25T14:42:21+00:00">2018-10-25</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="什么是服务器？"><a href="#什么是服务器？" class="headerlink" title="什么是服务器？"></a>什么是服务器？</h3><blockquote>
<p>通过安装服务器软件，<strong>提供服务</strong> 的计算机</p>
</blockquote>
<p>服务器可以从硬件、软件(系统软件、应用软件)几个角度描述。</p>
<p>按硬件描述： 服务器就是一台超级计算机(配置很高)。<br>按操作系统划分： 在硬件上安装了什么操作系统，就可以称为该系统的服务器<br>​ 例如: linux 服务器、windows 服务器、unix 服务器等。<br>按软件划分： 在操作系统中安装了什么软件，就可以称作该软件的服务器 iis tomcat<br>​ 例如: <strong>web 服务器</strong>、数据库服务器、邮件服务器等。</p>
<h3 id="什么是-Web-服务器"><a href="#什么是-Web-服务器" class="headerlink" title="什么是 Web 服务器"></a>什么是 Web 服务器</h3><p>Web 服务器就是安装了 Web 服务软件，web 服务器的作用是能够提供网站服务的服务器。淘宝、京东、新浪等等</p>
<p>常见的 Web 软件：<br><strong>Apache</strong>、Nginx、IIS、Tomcat、Node 等。<br>Apache 服务器、Nginx 服务器、IIS 服务器、Tomcat 服务器、Node 服务器</p>
<p>Apache 是世界使用排名第一的 Web 服务器软件。我们将编写好的 html、css、js 等文件存入 apache，就能够通过网络来访问这些文件了</p>
<p>PS: web 服务器又叫做 http/httpd 服务器</p>
<h2 id="phpStudy-介绍"><a href="#phpStudy-介绍" class="headerlink" title="phpStudy 介绍"></a>phpStudy 介绍</h2><blockquote>
<p>phpStudy 是一个 PHP 调试环境的程序集成包</p>
<p>该程序包集成最新的 Apache+PHP+MySQL</p>
<p>安装 phpStudy，一定不能有中文，否则肯定启动不起来</p>
</blockquote>
<p>**注意: **将要访问的文件(html,php,img 等)，放到安装路径下的 <code>www</code> 目录下，通过浏览器就可以访问到了</p>
<h3 id="phpStudy-的错误解决"><a href="#phpStudy-的错误解决" class="headerlink" title="phpStudy 的错误解决"></a>phpStudy 的错误解决</h3><p>如果 phpStudy 启动发生错误，参数下列几点。</p>
<ul>
<li><p>一是防火墙拦截</p>
</li>
<li><p>二是 80 端口已经被别的程序占用，如 IIS 等</p>
</li>
<li><p>三是没有安装 VC9 运行库,php 和 apache 都是 VC9 编译</p>
</li>
</ul>
<h2 id="PHP-基础-重点"><a href="#PHP-基础-重点" class="headerlink" title="PHP 基础(重点)"></a>PHP 基础(重点)</h2><h3 id="PHP-简介"><a href="#PHP-简介" class="headerlink" title="PHP 简介"></a>PHP 简介</h3><p>PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。主要适用于 <strong>Web 领域的开发</strong> ，能够完成 <strong>动态网页</strong> 的制作</p>
<h3 id="PHP-特点"><a href="#PHP-特点" class="headerlink" title="PHP 特点"></a>PHP 特点</h3><ul>
<li>PHP 是目前最流行的网站开发语言（B/S 结构）之一</li>
<li>PHP 是一种在服务器端执行的嵌入 HTML 文档的脚本语言</li>
<li>支持几乎所有流行的 <strong>数据库</strong> 以及操作系统</li>
<li>源码开放、免费（free)</li>
<li>php 是世界上最好的语言</li>
</ul>
<h3 id="动态网站与静态网站-了解"><a href="#动态网站与静态网站-了解" class="headerlink" title="动态网站与静态网站(了解)"></a>动态网站与静态网站(了解)</h3><ul>
<li><p>静态网站：使用浏览器端语言进行编程，网站由静态代码（HTML,CSS,JS）组成。</p>
</li>
<li><p>动态网站  ：网页通过服务器的程序(php 等)动态生成。用户可以和服务器进行交互（可以根据用户输入的不同信息，返回不同的运行结果）</p>
</li>
</ul>
<p><strong>总结</strong></p>
<p>动态网站的 <strong>动</strong> 指的是网站 <strong>数据的动</strong> 而不是 <strong>视觉上的动</strong></p>
<h3 id="软件架构-了解"><a href="#软件架构-了解" class="headerlink" title="软件架构(了解)"></a>软件架构(了解)</h3><blockquote>
<p>软件架构可以分为 BS 架构与 CS 架构</p>
</blockquote>
<h4 id="C-S-架构"><a href="#C-S-架构" class="headerlink" title="C/S 架构"></a>C/S 架构</h4><p>Client/Server 架构，即客户端/服务器架构。需要安装对应的客户端软件，才能获取服务器的服务</p>
<p>常见的 CS 架构：QQ、LOL、微信等</p>
<p>特点：</p>
<ul>
<li><p>需要安装才能使用</p>
</li>
<li><p>性能高效，使用更加稳定和流畅</p>
</li>
</ul>
<h4 id="B-S-架构"><a href="#B-S-架构" class="headerlink" title="B/S 架构"></a>B/S 架构</h4><p>Broswer/Server 架构，即浏览器/服务器架构。随着 Internet 的兴起，无需安装专门客户端软件，通过浏览器去请求服务器</p>
<ul>
<li>不需要安装，只需要浏览器即可。</li>
<li>相比 CS 架构，性能相对较差，没有那么流畅和稳定</li>
</ul>
<h2 id="php-基本语法结构"><a href="#php-基本语法结构" class="headerlink" title="php 基本语法结构"></a>php 基本语法结构</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 避免使用中文目录和中文文件名</span></span><br><span class="line"><span class="comment">// 文件以.php后缀结尾，所有程序包含在<span class="meta">&lt;?php</span> 这里是代码 <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">// php页面无法直接打开需要运行在服务器环境当中</span></span><br><span class="line"><span class="comment">// 末尾必须加分号，不然就报错了（最后一行可以不加分号）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出中文乱码问题：如果使用 echo 输出中文，可能会乱码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment">// 解决中文乱码的问题</span></span><br><span class="line">  header(<span class="string">&quot;content-Type:text/html;charset=utf-8&quot;</span>); <span class="comment">// 返回HTML文档文本并设置编码集</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;大家好，我是一名摄影工作者&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="PHP-运行原理"><a href="#PHP-运行原理" class="headerlink" title="PHP 运行原理"></a>PHP 运行原理</h2><h3 id="HTML-运行原理"><a href="#HTML-运行原理" class="headerlink" title="HTML 运行原理"></a>HTML 运行原理</h3><p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102205640.png"></p>
<ol>
<li>在浏览器的 URL 地址栏中输入 <span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20vaW5kZXguaHRtbA==">www.baidu.com/index.html</span> 地址，点回车。请求就发送给百度服务器。</li>
<li>百度服务器找到 index.html 文件，并将文件的内容返回给浏览器</li>
<li>浏览器接收到 index.html 中的内容，渲染到页面上。</li>
</ol>
<p>同理: localhost/a.html , 则会返回 本机 web 服务器根目录下 a.html 文件的内容。浏览器拿到内容后进行渲染。</p>
<h3 id="PHP-运行原理-1"><a href="#PHP-运行原理-1" class="headerlink" title="PHP 运行原理"></a>PHP 运行原理</h3><p>apache 不认识 php<br>浏览器也不认识 php</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102205658.png"></p>
<ol>
<li> 在浏览器地址栏中输入 localhost/index.php ,点回车之后。将请求发送给 apache 服务器</li>
<li> 服务器找到 index.php 文件之后，转发给 php 解释器</li>
<li> php 解释器将 index.php 文件中的 php 代码全部转为字符串，再返回给 apache</li>
<li> apache 将处理好的字符串返回给浏览器，浏览器渲染后就可以看到页面</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote>
<p>php 是一门弱类型语法，变量的类型可以随意改变。<br>变量其实就是存储数据的容器</p>
</blockquote>
<p><strong>变量的命名规则</strong></p>
<ul>
<li>不需要关键字进行声明，变量在第一次赋值的时候被创建</li>
<li>必须以 <code>$</code> 符号开始</li>
<li><code>$</code> 后面的命名规则与 js 的变量命名规则一致</li>
</ul>
<h3 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h3><p><strong>声明变量</strong></p>
<p>声明变量的时候也一定要同时赋值,否则变量无法声明成功</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量在声明的时候一定要同时赋值,否则变量无法声明成功</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&quot;呵呵&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除变量 unset()</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unset</span>(<span class="variable">$name</span>); <span class="comment">// 销毁指定的变量</span></span><br></pre></td></tr></table></figure>

<p><strong>判断变量是否设置值 isset()</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">isset</span>(<span class="variable">$name</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">isset</span>(<span class="variable">$name</span>); <span class="comment">// 用 echo 打印，如果为 true 会打印出 1 ， 如果为 false 打印空</span></span><br><span class="line">var_dump(<span class="keyword">isset</span>(<span class="variable">$name</span>)); <span class="comment">// 会打印出 bool(true)/bool(false)</span></span><br></pre></td></tr></table></figure>

<p>变量未设置或者设置为 null，返回 false（认为变量没有设置），其余情况全部为 true。一般用来判断变量是否设置，因为变量未设置，无法直接使用。(变量先赋值，在使用！）</p>
<p><strong>判断变量是否为空 empty()</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">var_dump(<span class="keyword">empty</span>(<span class="variable">$name</span>)); <span class="comment">// 为空打印出 bool(true)，不为空则打印 bool(false)</span></span><br></pre></td></tr></table></figure>

<p>PHP 中认为变量的值为：<code>&quot;&quot;</code>、<code>0</code>、<code>&quot;0&quot;</code>、<code>null</code>、<code>false</code>、<code>[]</code> 时，变量虽然赋值了，但是无实际的意义，为空。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote>
<p>php 数据类型: 8 种数据类型</p>
<p>基本数据类型: 布尔, 字符串, 整数, 浮点数</p>
<p>复合数据类型:数组, 对象</p>
<p>特殊的类型:resource(资源) null</p>
</blockquote>
<h3 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h3><h4 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. echo 输出简单数据类型</span></span><br><span class="line"><span class="comment">//2. print_r 输出数据结构，一般用于输出复杂类型。</span></span><br><span class="line">print_r(<span class="variable">$arr</span>); <span class="comment">// print_r 是一个函数，不要忘记小括号</span></span><br><span class="line"><span class="comment">//3. var_dump 输出完整的数据结构，包括类型，一般用于精准调试</span></span><br><span class="line">var_dump(<span class="variable">$arr</span>);</span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$str</span> = <span class="string">&quot;php是世界上是最好的语言&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>;</span><br></pre></td></tr></table></figure>

<p><strong>字符串连接符</strong></p>
<p>php 中，<code>+</code> 号只有算数的功能，并不能拼串，拼串使用 <code>.</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="string">&quot;大象&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;大家好，我是&quot;</span> . <span class="variable">$name</span> . <span class="string">&quot;，今年18岁&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>php 中的单引号与双引号</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 字符串的定义可以使用单引号，也可以使用双引号</span></span><br><span class="line"><span class="comment">//2. 双引号可以解析变量</span></span><br><span class="line"><span class="comment">//3. 单引号的性能会高于双引号（了解）</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&quot;大象&quot;</span>;</span><br><span class="line"><span class="variable">$desc</span> = <span class="string">&#x27;很帅&#x27;</span>;</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;$name 很帅&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>; <span class="comment">// $name 很帅</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;<span class="subst">$name</span> 很帅&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>; <span class="comment">// 大象 很帅</span></span><br></pre></td></tr></table></figure>

<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$num</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$num</span>;</span><br></pre></td></tr></table></figure>

<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$float</span> = <span class="number">11.11</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$float</span>;</span><br></pre></td></tr></table></figure>

<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$flag</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 当布尔类型值为true时，输出1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line"><span class="variable">$flag</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 当布尔类型为false时，输出空字符串</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>在 php 中，数组分为两种，<strong>索引数组</strong> 和 <strong>关联数组</strong></p>
<p>计算数组长度的方法：count(数组名)；</p>
</blockquote>
<p><strong>索引数组（类似与 JS 中的数组）</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;张飞&quot;</span>,<span class="string">&quot;赵云&quot;</span>,<span class="string">&quot;马超&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$arr</span>; <span class="comment">// Array // echo 只能打印基本数据类型</span></span><br><span class="line"><span class="comment">// 使用 print_r() 打印</span></span><br><span class="line">print_r(<span class="variable">$arr</span>); <span class="comment">// Array ([0] =&gt; 张飞 [1] =&gt; 赵云 [2] =&gt; 马超)</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$arr</span>[<span class="number">0</span>]; <span class="comment">// 张飞</span></span><br></pre></td></tr></table></figure>

<p><strong>关联数组（类似与 JS 中的对象）</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 属性名必须用引号引起来</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;name&quot;</span>=&gt;<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span>=&gt;<span class="number">18</span>);</span><br><span class="line">print_r(<span class="variable">$arr</span>); <span class="comment">// Array ( [name] =&gt; zhangsan [age] =&gt; 18 )</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$arr</span>[<span class="string">&quot;name&quot;</span>];</span><br></pre></td></tr></table></figure>

<p><strong>二维数组与多维数组</strong></p>
<p>数组中的每个元素又是一个数组<br>二维数组的存取元素，需要两次访问，依次确定行和列 <code>$arr[x][y]</code>;</p>
<blockquote>
<p>多维数组数组里面嵌套了两层以上的数组</p>
</blockquote>
<h3 id="对象-了解"><a href="#对象-了解" class="headerlink" title="对象(了解)"></a>对象(了解)</h3><blockquote>
<p>在 php 以及其他高级语言中，都有类的概念，表示一类对象，跟 js 中构造函数类似。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个类（类似js的构造函数）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="variable">$sex</span> = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$zs</span> = <span class="keyword">new</span> Person;</span><br><span class="line">print_r(<span class="variable">$zs</span>);</span><br><span class="line"><span class="comment">//打印对象的结构信息 Person Object ([name] =&gt; 小明[sex:Person:private] =&gt; 男 )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$zs</span>-&gt;name; <span class="comment">// 对象中取值用 -&gt;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$zs</span>-&gt;sex; <span class="comment">// 私有属性，无法获取</span></span><br></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="分支结构-if-switch"><a href="#分支结构-if-switch" class="headerlink" title="分支结构(if/switch)"></a>分支结构(if/switch)</h3><p>基本上来说，所有语言的 if..else 语法都是一样</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$age</span> = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$age</span> &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;终于可以抽烟喝酒烫头了&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;哎......&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===================</span></span><br><span class="line"><span class="keyword">switch</span>(变量)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">		程序块<span class="number">1</span>；</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">		程序块<span class="number">2</span>；</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		程序块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环结构-while-for-do…while"><a href="#循环结构-while-for-do…while" class="headerlink" title="循环结构(while / for / do…while)"></a>循环结构(while / for / do…while)</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(判断表达式)&#123;</span><br><span class="line">	程序块;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(赋值表达式; 判断表达式; 步进表达式)&#123;</span><br><span class="line">	程序块;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	程序块</span><br><span class="line">&#125; <span class="keyword">while</span>(判断表达式)</span><br></pre></td></tr></table></figure>

<p><strong>遍历索引数组</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;赵六&quot;</span>, <span class="string">&quot;田七&quot;</span>, <span class="string">&quot;王八&quot;</span>);</span><br><span class="line"><span class="comment">// 获取数组的长度： count($arr)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; count(<span class="variable">$arr</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="foreach-语句结构"><a href="#foreach-语句结构" class="headerlink" title="foreach 语句结构"></a>foreach 语句结构</h3><blockquote>
<p>用来遍历数组(关联数组和索引数组均可)。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>)&#123;</span><br><span class="line">	程序体</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$value</span>)&#123;</span><br><span class="line">	程序体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$arr</code> : 要遍历的数组</p>
<p><code>$key</code>: 键，可以是任意变量名</p>
<p><code>$value</code>: 值，可以是任意变量名</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历关联数组</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">&quot;name&quot;</span>=&gt;<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>=&gt;<span class="number">18</span>,</span><br><span class="line">  <span class="string">&quot;sex&quot;</span>=&gt;<span class="number">20</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$k</span> . <span class="string">&quot;=&quot;</span> . <span class="variable">$v</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>注意，在 php 中函数不能重复声明</p>
</blockquote>
<p>php 中函数的语法与 js 中函数的语法基本一样，不同点在于</p>
<ol>
<li>函数名大小写不敏感</li>
<li>函数的形参可以设置默认值</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    header(<span class="string">&quot;content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"><span class="variable">$name</span>=<span class="string">&quot;周杰伦&quot;</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;大家好，我是<span class="subst">$name</span>&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        [<span class="keyword">return</span> 返回值;]</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello(); <span class="comment">// 不传参数，会使用默认值</span></span><br><span class="line">    sayHello(<span class="string">&quot;大象&quot;</span>); <span class="comment">// 传参数，默认值不生效</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>在 php 中函数不能重复声明</li>
<li>函数体内的变量只在函数体内有效</li>
<li>函数体外的变量只在函数体外有效</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$age</span> = <span class="number">18</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="variable">$name</span> = <span class="string">&#x27;大象&#x27;</span>;</span><br><span class="line">    	<span class="keyword">echo</span> <span class="variable">$name</span>;  <span class="comment">// 有效</span></span><br><span class="line">    	<span class="keyword">echo</span> <span class="variable">$age</span>;  <span class="comment">// 无效</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span>(<span class="params"></span>)</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$name</span>;  <span class="comment">// 无效</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$age</span>; <span class="comment">// 有效</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>保存不会发生改变的数据(如：3.1415， 路径等)时，最好使用常量。</p>
<p>常量的使用方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">define(常量名, 常量值, [是否区分大小写]);</span><br><span class="line"><span class="comment">// 默认 false 区分大小写， true 不区分大小写</span></span><br><span class="line">define(<span class="string">&quot;PI&quot;</span>, <span class="number">3.1415</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">echo</span> PI;</span><br><span class="line"><span class="keyword">echo</span> pi;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 一般在实际工作中，常量都用大写，<strong>常量不能被重新赋值</strong></p>
<h2 id="PHP-内置函数"><a href="#PHP-内置函数" class="headerlink" title="PHP 内置函数"></a>PHP 内置函数</h2><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul>
<li>max(),min() 分别返回一组数的最大值及最小值；</li>
<li>abs() 返回绝对值。</li>
<li>floor() 向下取整。</li>
<li>ceil() 向上取整。</li>
<li>round() 四舍五入。</li>
<li>rand()  返回随机整数，可以取到两端的值。</li>
</ul>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><ul>
<li><p><code>time()</code> 返回当前的时间戳 (1970 到现在的时间的秒数)</p>
</li>
<li><p><code>date(format,time)</code> 格式化一个本地时间或日期</p>
<p>格式：Y(年) m(月) d(日) H(时) i(分) s 秒</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$time</span> = time(); <span class="comment">// 获取时间戳</span></span><br><span class="line"><span class="keyword">echo</span> date(<span class="string">&#x27;Y-m-d H:i:s&#x27;</span>,<span class="variable">$time</span>); <span class="comment">// 格式化时间戳</span></span><br><span class="line"><span class="comment">// Y, m, d, H, i, s 分别代表 年 月 日 时 分 秒</span></span><br></pre></td></tr></table></figure>

<p>默认时区会不太正确, 我们在东八区, 比 0 时区会多八小时</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">路径: D:\phpStudy\php\php-<span class="number">5.4</span>.<span class="number">45</span></span><br><span class="line">在php.ini里加上找到date.timezone项，设置date.timezone = <span class="string">&quot;PRC&quot;</span>，重启环境就ok了。</span><br><span class="line">PRC: 中华人民共和国</span><br></pre></td></tr></table></figure>

<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul>
<li><code>str_replace(查找的值，替换的值，执行替换操作的字符)</code> 字符串替换（会把符合的值全部替换）</li>
<li><code>trim(字符串);</code> 去除首尾空白字符</li>
<li><code>explode(分割符，执行分割的字符串);</code> 使用一个字符分割一个字符串，返回一个数组(类似 split)</li>
<li><code>implode(连接符，执行连接的数组);</code> 将数组根据连接符拼接成字符串(类似 join)</li>
<li><code>substr(字符串，起始索引，截取长度);</code> 截取字符串，注意中文占 3 个字节长度</li>
<li><code>strchr(字符串，标识字符);</code> 从左向右找标识字符，返回该字符后全部字符(包括该字符)</li>
<li><code>strrchr(字符串，标识字符);</code> 从右向左找标识字符，返回该字符后全部字符(包括该字符) <strong>主要用于获取后缀名</strong></li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>查找数组中是否含有指定内容</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in_array(查找的内容, 数组)   如果查找到返回 true ，查找不到返回 false</span></span><br><span class="line">result = in_array(<span class="variable">$uname</span>, <span class="variable">$arr</span>);</span><br><span class="line"><span class="comment">// 可用来判断用户名是否已存在数据库中</span></span><br></pre></td></tr></table></figure>

<p><strong>从数组中随机获取数据</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array_rand(被操作的数据, 数据长度) 返回一个随机的下标</span></span><br><span class="line"><span class="variable">$arr</span> = array_rand(<span class="variable">$results</span>, <span class="number">2</span>); <span class="comment">// 返回一个数组，随机两个下标</span></span><br><span class="line"><span class="variable">$index</span> = array_rand(<span class="variable">$results</span>, <span class="number">1</span>); <span class="comment">// 返回一个随机的下标</span></span><br><span class="line"><span class="variable">$results</span>[<span class="variable">$index</span>]; <span class="comment">// 用来随机获取数组中的一项</span></span><br></pre></td></tr></table></figure>

<h2 id="页面动态渲染"><a href="#页面动态渲染" class="headerlink" title="页面动态渲染"></a>页面动态渲染</h2><ul>
<li><p>PHP 本身支持与 HTML 混编</p>
</li>
<li><p>混编的文件后缀必须为 .php， Apache 才会调用 PHP 解析</p>
</li>
<li><p>PHP 与 HTML 混编时，服务器中的 PHP 引擎 只会执行 php 标签内部的 PHP 代码，非 PHP 的代码(PHP 标签外部的内容)直接忽略，最后会将 PHP 的执行结果和非 PHP 代码 一起返回给浏览器,由浏览器进行解析</p>
</li>
<li><p>一个 php 页面当中,可以写多个 php 语法结构,但是 php 语法结构 <strong>不能嵌套</strong></p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  header(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">  <span class="keyword">echo</span> <span class="number">2</span>+<span class="number">3</span>;</span><br><span class="line">  <span class="comment">// php的引擎 只会执行php代码块中代码，代码块外面的代码会被忽略最后 服务器会将php执行的结果和代码块外面的内容一起返回给浏览器，由浏览器进行解析</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">// 在php语法结构外面， 可以写 html ，会直接在浏览器中渲染</span></span><br><span class="line">&lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;百度一下&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h2 id="include-文件引入"><a href="#include-文件引入" class="headerlink" title="include 文件引入"></a>include 文件引入</h2><p><strong>介绍</strong>：不同的页面中有相同的代码部分，可以将其分离为单个文件。需要调用时，<strong>include 引入对应的文件即可调用</strong>。提高代码的复用率。类似于 js 中 script 标签导入, 可以用于函数复用</p>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以是html、php或其他类型的页面</span></span><br><span class="line">include | include_once   <span class="string">&quot;文件的路径&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>include 与 include_once 区别</strong></p>
<ul>
<li>include 可以重复引入文件</li>
<li>include_once 只引入一次，防止多次引入文件</li>
<li>如果文件中有函数，include 重复引入会报错，include_once 不会报错</li>
</ul>
<h2 id="PHP-数据读写到文件-数据持久化"><a href="#PHP-数据读写到文件-数据持久化" class="headerlink" title="PHP 数据读写到文件(数据持久化)"></a>PHP 数据读写到文件(数据持久化)</h2><p>程序运行过程中，数据存储在内存中的，程序结束, 数据会销毁</p>
<p>如果希望可以永久存储某些数据，可以将数据存储在硬盘上（存储在文件中）</p>
<p>将数据由内存存储到硬盘的过程，称为数据持久化；</p>
<ul>
<li><p><code>file_get_contents(path)</code>   根据路径读取文件内容, 返回一个字符串</p>
</li>
<li><p><code>file_put_contents(path,$str)</code>   将一个字符串写入到一个文件中。(只能存储字符串)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file_put_contents(<span class="keyword">string</span> <span class="variable">$file</span>, <span class="keyword">string</span> <span class="variable">$data</span>[, constants flag]);</span><br><span class="line">参数<span class="number">1</span>: 文件路径</span><br><span class="line">参数<span class="number">2</span>: 要写入文件的字符串</span><br><span class="line">参数<span class="number">3</span>: 可选参数，默认不写，新内容覆盖原文件中的内容；FILE_APPEND 是向文件中追加内容</span><br><span class="line">返回值: 写入文件的字符串长度(不用记)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用 <code>file_put_contents</code> 存储数组的时候，会丢失数据</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>];</span><br><span class="line"><span class="variable">$arr1</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">18</span>];</span><br><span class="line">file_put_contents(<span class="string">&quot;02-test.txt&quot;</span>, <span class="variable">$arr</span>); <span class="comment">// zslsww</span></span><br><span class="line">file_put_contents(<span class="string">&quot;02-test.txt&quot;</span>, <span class="variable">$arr1</span>); <span class="comment">// zs18</span></span><br></pre></td></tr></table></figure>

<p>把一个数组，转成一个 json 格式的字符串</p>
<ul>
<li><code>json_encode($data)</code> 将 PHP 数组转成 JSON 格式字符串。</li>
<li><code>json_decode($str,true)</code> 将 JSON 字符串, 转换为 PHP 数组。（不传 true, 有可能转完之后是个对象, 传了 true,一定是数组）</li>
</ul>
<h2 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h2><blockquote>
<p>表单（form）：表单用于收集用户输入信息，并将数据提交给服务器。是一种常见的与服务端数据交互的一种方式</p>
</blockquote>
<ol>
<li><code>action</code>: 指定表单的提交地址（如果提交到当前页面，action 可以为空）</li>
<li><code>method</code>: 指定表单的提交方式，get/post，默认 get</li>
<li><code>input</code> 的数据想要提交到后台，必须指定 name 属性，后台通过 name 属性获取值</li>
<li>想要提交表单，不能使用 <code>input:button</code> 必须使用 <code>input:submit</code></li>
</ol>
<h3 id="php-获取表单数据"><a href="#php-获取表单数据" class="headerlink" title="php 获取表单数据"></a>php 获取表单数据</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $_GET 是 PHP 系统提供的一个超全局变量，是一个数组，里面存放了表单通过 get 方式提交的数据</span></span><br><span class="line"><span class="comment">// $_POST 是 PHP 系统提供的一个超全局变量，是一个数组，里面存放了表单通过 post 方式提交的数据</span></span><br></pre></td></tr></table></figure>

<p><strong>get 与 post 的区别</strong></p>
<ul>
<li><code>get</code> 方式<br>数据会拼接在 url 地址的后面 (?username=pp&amp;password=123456)<br>地址栏有长度限制，因此 get 方式提交数据大小不会超过 4k</li>
<li><code>post</code> 方式<br>数据不会在 url 中显示，相比 get 方式，post 更安全<br>提交的数据没有大小限制，可用于文件上传</li>
</ul>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><strong>html 要求</strong></p>
<ul>
<li><p>文件上传的提交方式必须是 <code>post</code> 方式</p>
</li>
<li><p>需要给 <code>form</code> 指定 <code>enctype=&quot;multipart/form-data&quot;</code></p>
</li>
<li><p>指定 <code>name</code> 属性，后台才能获取到</p>
</li>
</ul>
<p><strong>php 相关</strong></p>
<ul>
<li>文件上传时，通过 <code>$_FILES</code> 才能获取到，这是一个二维数组。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">  [photo] =&gt; <span class="keyword">Array</span></span><br><span class="line">    (</span><br><span class="line">      [name] =&gt; <span class="number">001</span>.jpg   <span class="comment">// 文件名字</span></span><br><span class="line">      [type] =&gt; image/jpeg  <span class="comment">// 文件类型</span></span><br><span class="line">      <span class="comment">// 上传图片保存的位置</span></span><br><span class="line">      [tmp_name] =&gt; C:\Users\Jepson\AppData\Local\Temp\phpF2A0.tmp</span><br><span class="line">      [<span class="built_in">error</span>] =&gt; <span class="number">0</span>     <span class="comment">// 上传错误码, 错误码为 0 表示没有错误</span></span><br><span class="line">      [size] =&gt; <span class="number">6000</span>   <span class="comment">// 文件大小, 单位字节, 大小 6kb 左右</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上传文件时，文件会临时保存在服务器上，如果文件最终没有保存，那么临时文件会被删除，保证服务器安全。</p>
</li>
<li><p><code>sleep(10)</code> 可以让代码延迟 10 秒钟才执行。</p>
</li>
<li><p><code>move_uploaded_file($path, $newPath);</code> 可以转存临时文件，真正把文件存储起来</p>
</li>
<li><p><code>unlink(filename,context)</code> 删除文件，若成功，则返回 true，失败则返回 false</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存图片的完整代码</span></span><br><span class="line"><span class="comment">// 思路:</span></span><br><span class="line"><span class="comment">// 1. 在文件上传成功的情况下, 进行图片的保存   error == 0</span></span><br><span class="line"><span class="comment">// 2. 获取临时文件路径</span></span><br><span class="line"><span class="comment">// 3. 随机生成新的文件名, 注意文件中后缀名是不能改变的</span></span><br><span class="line"><span class="comment">// 4. 根据新的文件名, 转移临时文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;photo&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断上传是否成功</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="variable">$file</span>[<span class="string">&#x27;error&#x27;</span>] == <span class="number">0</span> ) &#123; <span class="comment">// 上传成功</span></span><br><span class="line">  <span class="comment">// 1. 获取临时文件路径</span></span><br><span class="line">  <span class="variable">$ftemp</span> = <span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 随机生成新的文件名, 后缀不能随便起, 要获取一下</span></span><br><span class="line">  <span class="variable">$name</span> = <span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">  <span class="variable">$text</span> = strrchr(<span class="variable">$name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="comment">// 为了防止重复, 生成随机的文件名以当前时间秒数+随机数组成</span></span><br><span class="line">  <span class="variable">$newName</span> = time().rand(<span class="number">10000</span>,<span class="number">99990</span>).<span class="variable">$text</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 进行转存</span></span><br><span class="line">  move_uploaded_file(<span class="variable">$ftemp</span>, <span class="string">&quot;./upload/<span class="subst">$newName</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="学生信息管理系统-1-0"><a href="#学生信息管理系统-1-0" class="headerlink" title="学生信息管理系统 1.0"></a>学生信息管理系统 1.0</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul>
<li>学生添加功能</li>
<li>展示学生信息功能</li>
<li>删除学生信息</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array_splice(数组, 开始的下标, 截取长度) 将匹配到的数据截取掉，会改变原来的数组</span></span><br><span class="line">array_splice(<span class="variable">$arr</span>, <span class="variable">$_GET</span>[<span class="string">&quot;index&quot;</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加内容到数组：将 $stuArr 添加到数组 $arr 中</span></span><br><span class="line"><span class="variable">$arr</span>[] = <span class="variable">$stuArr</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Mysql-数据库"><a href="#Mysql-数据库" class="headerlink" title="Mysql 数据库"></a>Mysql 数据库</h2><h3 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h3><p>专门用来存储、管理数据的仓库 英文：Database, DB。</p>
<h3 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h3><ul>
<li><p>关系型数据库: 基于表，表与表之间可以存在关系，可以进行多表查询的存储方式，适合较为复杂的存储</p>
<p>如: MySQL, SQL Server, oracle</p>
<p>表结构:</p>
<p>每一行代表一条数据 — <strong>记录</strong></p>
<p>每一列都是一类数据 — <strong>字段</strong></p>
<table>
<thead>
<tr>
<th><strong>订单编号</strong></th>
<th><strong>商品名称</strong></th>
<th><strong>价格</strong></th>
<th><strong>数量</strong></th>
</tr>
</thead>
<tbody><tr>
<td>100123</td>
<td>华为 mate10</td>
<td>4999</td>
<td>2</td>
</tr>
<tr>
<td>100124</td>
<td>花裙子</td>
<td>499</td>
<td>1</td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th>订单编号</th>
<th>用户</th>
<th>配送地址</th>
</tr>
</thead>
<tbody><tr>
<td>100123</td>
<td>隔壁老王</td>
<td>北京市京顺路 99 号</td>
</tr>
<tr>
<td>100124</td>
<td>隔壁老宋</td>
<td>北京市清华大学 1 号楼</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>非关系型数据库: 基于键值对的存储方式，数据之间没有耦合性，特点执行效率高</p>
<p>如：mongodb</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似对象的键值对形式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;gblw&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="number">123456</span>,</span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: <span class="number">007</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="MySQL-数据库软件"><a href="#MySQL-数据库软件" class="headerlink" title="MySQL 数据库软件"></a>MySQL 数据库软件</h3><blockquote>
<p>MySQL 数据库软件中可以有多个数据库,每一个数据库中可以有多个表</p>
</blockquote>
<h4 id="可视化工具-navicat"><a href="#可视化工具-navicat" class="headerlink" title="可视化工具 navicat"></a>可视化工具 navicat</h4><blockquote>
<p>MySQL 只是一个数据库软件，如果我们要创建数据库，或对数据库进行增删改查，刚开始可以用可视化工具来操作，让我们更加直观的了解数据库</p>
</blockquote>
<h5 id="安装-navicat"><a href="#安装-navicat" class="headerlink" title="安装 navicat"></a>安装 navicat</h5><h5 id="让-navicat-和-MySQL-建立连接"><a href="#让-navicat-和-MySQL-建立连接" class="headerlink" title="让 navicat 和 MySQL 建立连接"></a>让 navicat 和 MySQL 建立连接</h5><p>点击左上角 连接 =&gt; MySQL =&gt; 常规 =&gt; 端口 3306 =&gt;</p>
<h4 id="数据库表的操作"><a href="#数据库表的操作" class="headerlink" title="数据库表的操作"></a>数据库表的操作</h4><h5 id="数据库的数据类型"><a href="#数据库的数据类型" class="headerlink" title="数据库的数据类型"></a>数据库的数据类型</h5><blockquote>
<p>也就是数据库中可以存储的数据类型(又叫做字段类型)</p>
</blockquote>
<p><strong>字段类型</strong></p>
<ul>
<li><p>整型 <code>int</code></p>
<p>​ 存储如年龄，产品数量，编号等。</p>
</li>
<li><p>小数类型 <code>float</code> , <code>decimal</code></p>
<blockquote>
<p>重量，工资，奖金，价格等使用 decimal 类型，实现小数的精确存储,一般用来存储与钱有关的数字。3.333333331</p>
</blockquote>
</li>
<li><p>字符串型 <code>varchar(M)</code>，<code>char(M)</code></p>
<ul>
<li><p>M 为该字段可以存储的最多字符数(字节) ，如 varchar(10)最大可以存储 10 个字节</p>
</li>
<li><p>varchar 一般用来存储长度变化比较大的字符串，如文章标题，商品名称</p>
</li>
<li><p>char 存储长度比较固定的字符串，如手机号，身份证号，序列号，邮编</p>
</li>
<li><p>此外可以使用 text 类型，存储较长的字符串，无需指定字符串的具体长度</p>
</li>
</ul>
</li>
<li><p>日期时间型 <code>datetime</code>, <code>date(年月日)</code>，<code>time(时分秒)</code></p>
</li>
</ul>
<p><strong>字段约束</strong></p>
<p>字段约束: 字段数据的属性规则（特征）</p>
<ol>
<li><p><code>not null</code> 不为空，可以限制字段值不能为空</p>
</li>
<li><p><code>default</code> 默认值，可以设置字段的默认值，在没有录入时自动使用默认值填充。</p>
</li>
<li><p><code>primary key</code> 主键 ：唯一标识，不能重复，不能为空</p>
<p>设置字段为主键，主键字段的值不能重复，不能为空。而且一个数据表中只能设置一个字段为主键，作为每行记录的唯一身份信息（索引）。</p>
</li>
<li><p><code>auto_increment</code> 自动增长</p>
<p>设置字段为自动增长，默认从 1 开始自动分配编号。自增长字段必须为一个 key（索引，数据结构，便于快速查找数据，相当于书的目录），一般与 primary key 结合使用。类型必须为整型。</p>
</li>
<li><p><code>unique key</code> 不能重复</p>
<p>唯一键，设置字段的值为唯一的，可以设置多个字段为唯一键。唯一键字段的值可以为空。</p>
</li>
</ol>
<h5 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h5><blockquote>
<p>注意 创建表时，每个表必须有一个主键</p>
</blockquote>
<h2 id="SQL-操作数据库的语言"><a href="#SQL-操作数据库的语言" class="headerlink" title="SQL-操作数据库的语言"></a>SQL-操作数据库的语言</h2><blockquote>
<p>SQL：structured Query Language 结构化查询语言。</p>
</blockquote>
<ul>
<li>通过这个语言可以对数据库进行增删改查</li>
</ul>
<p>SQL 编写注意点: 注释用 <code>--</code> , 语句结束加分号 <code>;</code></p>
<h3 id="基本用法：增删改查"><a href="#基本用法：增删改查" class="headerlink" title="基本用法：增删改查"></a>基本用法：增删改查</h3><ol>
<li>插入数据 <code>insert</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- insert into 表名 (字段列表) values (值列表)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> book (name, age, sex) <span class="keyword">values</span> (<span class="string">&#x27;zs&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;m&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>修改数据 <code>update</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- update 表名 set 字段名称1=值1,字段名称2=值2,... where 条件</span></span><br><span class="line"><span class="comment">-- 如果不加条件会修改表中所有对应的字段</span></span><br><span class="line">update book <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;ls&#x27;</span>, age<span class="operator">=</span><span class="string">&#x27;30&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>删除数据 <code>delete</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- delete from 表名 where 条件</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> book <span class="comment">-- 会删除所有数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> book <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>查询数据 select</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select 字段列表 from 表名</span></span><br><span class="line"><span class="keyword">select</span> name, age <span class="keyword">from</span> book <span class="comment">-- 只查询表中 name 和 author 的信息</span></span><br><span class="line"><span class="comment">-- select * from 表名 where 条件  * 表示所有字段</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> book <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> book <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;zs&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><ul>
<li><p><code>where</code> 条件</p>
<p>查询时，不添加 where 条件, 返回数据表所有行。需要添加限定条件，只返回需要的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select  字段列表 from  表名 where 条件；</span></span><br><span class="line"><span class="comment">-- 条件 : =, &gt;, &lt;, &gt;=, &lt;=, and, or</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>like</code> 模糊匹配  % 通配符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找姓张的人</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span>;​</span><br></pre></td></tr></table></figure></li>
<li><p><code>in</code> 语法：一次查询多个符合条件的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select * from 表名 where 字段 in (value1,value2,value3);</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;zs&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>); <span class="comment">-- 查找name值为zs, ls, ww 的数据</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>count()</code> 获取返回数据的总条数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询满足条件数据的总条数</span></span><br><span class="line"><span class="comment">-- select count(*) from 表名 where 条件</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>order</code> 排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select * from 表名 order by  字段名称;   	  	默认升序</span></span><br><span class="line"><span class="comment">-- select * from 表名 order by  age;  -- 按照年龄来排序</span></span><br><span class="line"><span class="comment">-- select * from 表名 order by 字段名称 desc;      desc 表示降序</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>limit</code> 对结果集进行截取 一般用于取数据的前几条</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select *  from  表名  limit 截取的起始索引，截取的长度</span></span><br></pre></td></tr></table></figure></li>
<li><p>联合查询（多个表联合查询）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A <span class="keyword">join</span> 表B <span class="keyword">on</span> 表A.字段<span class="operator">=</span>表B.字段 <span class="keyword">where</span> 条件</span><br><span class="line"><span class="keyword">join</span> 将表A和表B联合起来</span><br><span class="line"><span class="keyword">on</span> 根据什么字段把表A和表B联合起来</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span>  teacher  <span class="keyword">join</span> class  <span class="keyword">on</span> class.id<span class="operator">=</span>teacher.classid;  <span class="comment">-- 老师表和班级表联合查询</span></span><br><span class="line"><span class="keyword">select</span> teacher.<span class="operator">*</span>, class.classname  <span class="keyword">from</span>  teacher  <span class="keyword">join</span> class  <span class="keyword">on</span> class.id<span class="operator">=</span>teacher.classid;   <span class="comment">-- 老师表和班级表联合查询,但只显示老师表的全部内容和班级表的名称</span></span><br><span class="line"><span class="comment">-- 注意: 多表联合查询时,字段要写明是那个表的字段 如  表.字段名</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="PHP-操作数据库"><a href="#PHP-操作数据库" class="headerlink" title="PHP 操作数据库"></a>PHP 操作数据库</h2><h3 id="连接数据库基本步骤"><a href="#连接数据库基本步骤" class="headerlink" title="连接数据库基本步骤"></a>连接数据库基本步骤</h3><ol>
<li>连接数据库</li>
<li>准备 sql 语句</li>
<li>执行 sql 语句</li>
<li>获取执行的结果并分析</li>
<li>关闭数据库</li>
</ol>
<h3 id="操作数据库常用-API"><a href="#操作数据库常用-API" class="headerlink" title="操作数据库常用 API"></a>操作数据库常用 API</h3><ul>
<li><p><code>mysqli_connect(IP, 用户名，密码，数据库名)，端口号</code> 连接数据库</p>
</li>
<li><p><code>mysqli_query($link, $sql)</code> 执行 SQL 语句</p>
</li>
<li><p><code>mysqli_error($link);</code> 返回错误描述</p>
</li>
<li><p><code>mysqli_close($link);</code> 关闭连接</p>
</li>
<li><p><code>mysqli_fetch_assoc($res);</code> 从结果集中取得一行作为关联数组返回</p>
</li>
<li><p><code>mysqli_num_rows($res);</code> 返回结果集的行数</p>
</li>
</ul>
<h3 id="sql-操作"><a href="#sql-操作" class="headerlink" title="sql 操作"></a>sql 操作</h3><ul>
<li>使用 PHP 发送 SQL 语句前，可以先打印 SQL 语句，检查语句的正确性。</li>
<li>修改数据库的数据时, 使用变量拼接 SQL 语句=，字段的值为字符串类型时，需要在变量的两侧使用单、双引号包裹。可以将所有的字段外面都使用双引号包含。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 连接数据库</span></span><br><span class="line"><span class="comment">// mysqli_connect(ip地址, 用户名, 密码, 数据库的名称, 端口号);</span></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//    1. 连接成功, 返回一个数据库连接对象</span></span><br><span class="line"><span class="comment">//    2. 连接失败, 返回 false</span></span><br><span class="line"><span class="comment">// @ 表示错误抑制符, 可以抑制错误的输出</span></span><br><span class="line"><span class="variable">$link</span> = @ mysqli_connect(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;study&#x27;</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="comment">// var_dump($link);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果数据库连接失败</span></span><br><span class="line"><span class="keyword">if</span> ( !<span class="variable">$link</span> ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;数据库连接失败&quot;</span>；</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 程序结束, die 方法, 终止当前程序执行, 输出一段语句</span></span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&quot;数据库连接失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;数据库连接成功&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 准备 sql 语句: 删除一条数据</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;delete from stu where id = 14&quot;</span>;</span><br><span class="line"><span class="variable">$name</span> = <span class="string">&quot;gblw&quot;</span>;</span><br><span class="line"><span class="variable">$age</span> = <span class="number">31</span>;</span><br><span class="line"><span class="variable">$sq2</span> = <span class="string">&quot;insert into stu (name, age) values (&#x27;<span class="subst">$name</span>&#x27;, <span class="subst">$age</span>)&quot;</span>;</span><br><span class="line"><span class="comment">// sql 语句一般用双引号包裹</span></span><br><span class="line"><span class="comment">// 如果语句中含有拼接的变量，需要用单引号包裹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 让数据库执行 sql 语句, 并分析结果</span></span><br><span class="line"><span class="comment">// mysqli_query(数据库连接对象, 要执行的sql语句)</span></span><br><span class="line"><span class="comment">// 非查询语句：执行成功返回 true, 执行失败返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 根据结果不同做逻辑判断</span></span><br><span class="line"><span class="keyword">if</span> ( mysqli_query( <span class="variable">$link</span>, <span class="variable">$sql</span> ) ) &#123;</span><br><span class="line">    <span class="comment">// 如果删除的数据不存在，也会返回 true，</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;删除成功&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// sql 语句错误，才会返回 false</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;删除失败&quot;</span>;</span><br><span class="line">    <span class="comment">// mysqli_error 可以查看错误消息</span></span><br><span class="line">    <span class="keyword">echo</span> mysqli_error(<span class="variable">$link</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询语句： 成功返回结果集, 失败返回 false</span></span><br><span class="line"><span class="comment">// 数据查询不到也会返回结果集，只是数据条数为 0，sql 语句有错误才会返回 false</span></span><br><span class="line"><span class="variable">$res2</span> = mysqli_query( <span class="variable">$link</span>, <span class="variable">$sq2</span> );</span><br><span class="line"><span class="comment">// $res2 是返回的结果集,是一个对象，表面上看没有我们要的数据,如果我们想要数据,需要调用mysqli_fetch_assoc($res2)去获取</span></span><br><span class="line"><span class="comment">// 结果集中 field_count 表示字段数，num_rows 表示查询到的数据条数</span></span><br><span class="line"><span class="comment">// 注意: mysqli_fetch_assoc($res2)执行一次,只会从结果集中拿一条数据出来(执行几次就拿出几条数据)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 根据结果不同做逻辑判断</span></span><br><span class="line"><span class="keyword">if</span> ( !<span class="variable">$res</span> ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> mysqli_error( <span class="variable">$link</span> );</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;数据库查询失败&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mysqli_fetch_assoc 查询成功, 从结果集中取数据, 以关联数组的形式返回</span></span><br><span class="line"><span class="comment">// 一次只取一条数据, 如果没取到, 返回 null</span></span><br><span class="line"><span class="variable">$arr</span> = [];</span><br><span class="line"><span class="keyword">while</span>( <span class="variable">$row</span> = mysqli_fetch_assoc( <span class="variable">$res</span> ) ) &#123;</span><br><span class="line">    <span class="comment">// 将值推到数组中</span></span><br><span class="line">    <span class="variable">$arr</span>[] = <span class="variable">$row</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以采用 for 循环遍历</span></span><br><span class="line"><span class="comment">// mysqli_num_rows($res) 方法返回获取到的数据条数 ，</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; mysqli_num_rows(<span class="variable">$res</span>); <span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="comment">// echo $i;</span></span><br><span class="line">    <span class="variable">$arr</span>[] =  mysqli_fetch_assoc(<span class="variable">$res</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// echo &#x27;&lt;pre&gt;&#x27;;</span></span><br><span class="line"><span class="comment">// print_r($arr);</span></span><br><span class="line"><span class="comment">// echo &#x27;&lt;/pre&gt;&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 关闭数据库连接 (挂电话)</span></span><br><span class="line">mysqli_close( <span class="variable">$link</span> );</span><br></pre></td></tr></table></figure>

<h3 id="数据库工具函数的封装"><a href="#数据库工具函数的封装" class="headerlink" title="数据库工具函数的封装"></a>数据库工具函数的封装</h3><blockquote>
<p>为了提高代码的复用性，把数据增删改的操作封装成一个方法</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line">define( <span class="string">&#x27;HOST&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span> );</span><br><span class="line">define( <span class="string">&#x27;UNAME&#x27;</span>, <span class="string">&#x27;root&#x27;</span> );</span><br><span class="line">define( <span class="string">&#x27;PWD&#x27;</span>, <span class="string">&#x27;root&#x27;</span> );</span><br><span class="line">define( <span class="string">&#x27;DB&#x27;</span>, <span class="string">&#x27;test02&#x27;</span> );</span><br><span class="line">define( <span class="string">&#x27;PORT&#x27;</span>, <span class="number">3306</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非查询语句封装</span></span><br><span class="line"><span class="comment">// 封装一个执行非查询语句的方法, 提高代码的复用性</span></span><br><span class="line"><span class="comment">// 参数: $sql 要执行的 sql 语句</span></span><br><span class="line"><span class="comment">// 返回值: true / false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_exec</span>(<span class="params"> <span class="variable">$sql</span> </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 连接数据库</span></span><br><span class="line">  <span class="variable">$link</span> = @ mysqli_connect( HOST, UNAME, PWD, DB, PORT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( !<span class="variable">$link</span> ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;数据库连接失败&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 准备 sql 语句, 就是传递过来的 $sql</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 执行 sql 语句, 分析结果</span></span><br><span class="line">  <span class="keyword">if</span> ( mysqli_query( <span class="variable">$link</span>, <span class="variable">$sql</span> ) ) &#123;</span><br><span class="line">    <span class="comment">// 执行成功</span></span><br><span class="line">    mysqli_close( <span class="variable">$link</span> ); <span class="comment">// 关闭数据库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行失败</span></span><br><span class="line">    mysqli_close( <span class="variable">$link</span> ); <span class="comment">// 关闭数据库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询语句的封装</span></span><br><span class="line"><span class="comment">// 参数: $sql 要执行的 sql 语句</span></span><br><span class="line"><span class="comment">// 返回值:</span></span><br><span class="line"><span class="comment">//    (1) 成功, 返回数据(二维数组)</span></span><br><span class="line"><span class="comment">//    (2) 失败, 返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_query</span>(<span class="params"> <span class="variable">$sql</span> </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 建立连接</span></span><br><span class="line">  <span class="variable">$link</span> = @ mysqli_connect( HOST, UNAME, PWD, DB, PORT );</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="variable">$link</span> ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;数据库连接失败&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 准备 sql 语句 $sql</span></span><br><span class="line">  <span class="comment">// 3. 执行 sql 语句, 分析结果</span></span><br><span class="line">  <span class="variable">$res</span> = mysqli_query( <span class="variable">$link</span>, <span class="variable">$sql</span> );  <span class="comment">// 结果集 或者 false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="variable">$res</span> ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;获取数据失败&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> mysqli_error(<span class="variable">$link</span>);</span><br><span class="line">    mysqli_close( <span class="variable">$link</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到结果集, 将结果集的所有内容取出到数组中</span></span><br><span class="line">  <span class="variable">$arr</span> = [];</span><br><span class="line">  <span class="keyword">while</span> ( <span class="variable">$row</span> = mysqli_fetch_assoc(<span class="variable">$res</span>) ) &#123;</span><br><span class="line">    <span class="variable">$arr</span>[] = <span class="variable">$row</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mysqli_close( <span class="variable">$link</span> );</span><br><span class="line">  <span class="keyword">return</span> <span class="variable">$arr</span>; <span class="comment">// 返回结果数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="学生管理系统-2-0"><a href="#学生管理系统-2-0" class="headerlink" title="学生管理系统 2.0"></a>学生管理系统 2.0</h2><h3 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h3><ul>
<li>添加学生功能</li>
<li>展示学生列表功能</li>
<li>删除学生功能</li>
<li>查看学生详情</li>
<li>更新学生数据</li>
</ul>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p><strong>注册功能思路：</strong></p>
<ol>
<li>表单设计，点击提交按钮向服务器提交表单数据</li>
<li>在后台获取表单提交的数据，保存到数据库中<ul>
<li>先获取表单的标签的数据</li>
<li>保存上传的图片（并保存图片存储的路径）</li>
<li>将表单的数据和图片的路径一起保存到数据库中</li>
</ul>
</li>
<li>保存完成，跳转到列表页，查看新添加的数据</li>
</ol>
<p><strong>展示功能思路：</strong></p>
<ol>
<li>先从数据库中获取数据（二维数组 arr）</li>
<li>遍历二维数组，将数组中数据渲染到页面中</li>
</ol>
<p><strong>删除功能思路：</strong></p>
<ol>
<li>获取要删除数据的 id</li>
<li>根据 id 删除数据库中指定的数据</li>
<li>删除完毕，返回列表页</li>
</ol>
<p><strong>详情展示功能</strong></p>
<ol>
<li>获取要查看详情数据的 id</li>
<li>根据 id 通过联合查询，获取到需要用数据</li>
<li>把数据显示在页面中</li>
<li>点击返回按钮，可以返回到列表页</li>
</ol>
<p><strong>更新数据思路：</strong><br>更新数据的思路=先渲染再提交</p>
<ol>
<li>获取要查看详情数据的 id</li>
<li>把对应 id 的数据填充到修改页面中</li>
<li>点击修改按钮，获取表单的数据，提交给服务器</li>
<li>在服务器更新数据</li>
<li>更新完成后跳转到列表页</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">隐藏域表单：和其他表单标签一样，只是看不到而已</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;?php echo $data[&#x27;id&#x27;] ?&gt;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/1652.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1652.html" class="post-title-link" itemprop="url">javascript 高级</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-10-18" itemprop="dateCreated datePublished" datetime="2018-10-18T14:34:36+00:00">2018-10-18</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102204500.png"></p>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>Everything is object （万物皆对象）</p>
</blockquote>
<p>对象到底是什么，我们可以从两次层次来理解</p>
<p><strong>(1) 对象是具体事物的抽象</strong></p>
<p>一本书、一辆汽车、一个人都可以是对象，当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程</p>
<p>问： 书是对象吗</p>
<p><strong>(2)对象是无序键值对的集合，其属性可以包含基本值、对象或者函数</strong></p>
<p>每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型</p>
<h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p>面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想</p>
<p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务<br>因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目</p>
<p><strong>面向对象与面向过程：</strong></p>
<ul>
<li>面向过程就是亲历亲为，事无巨细，有条不紊，面向过程是解决问题的一种思维方式，（执行者的角度）<ul>
<li>关注点在于解决问题的过程（先 xx，然后 xx，在 xx）</li>
</ul>
</li>
<li>面向对象就是找一个对象，让她去做这件事情（指挥者的角度）<ul>
<li>关注点在找到能解决问题的对象上</li>
</ul>
</li>
<li>面向对象不是面向过程的替代，而是面向过程的封装</li>
</ul>
<p><strong>面向对象的特性：</strong></p>
<ul>
<li>封装性<ul>
<li>将功能的具体实现，全部封装到对象的内部，外界使用对象时，只需要关注对象提供的方法如何使用，而不需要关心对象的内部具体实现，这就是封装</li>
</ul>
</li>
<li>继承性<ul>
<li>在 js 中，继承的概念很简单，一个对象没有的一些属性和方法，另外一个对象有，拿过来用，就实现了继承</li>
<li><strong>注意：在其他语言里面，继承是类与类之间的关系，在 js 中，是对象与对象之间的关系</strong></li>
</ul>
</li>
<li>[多态性]<ul>
<li>多态是在强类型的语言中才有的；js 是弱类型语言，所以 js 不支持多态</li>
</ul>
</li>
</ul>
<h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><h3 id="内置构造函数创建"><a href="#内置构造函数创建" class="headerlink" title="内置构造函数创建"></a>内置构造函数创建</h3><p>我们可以直接通过 <code>new Object()</code> 创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 js 中，对象有动态特性，可以随时的给一个对象增加属性或者删除属性</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">person.age = <span class="number">18</span></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：麻烦，每个属性都需要添加</p>
<h3 id="对象字面量创建"><a href="#对象字面量创建" class="headerlink" title="对象字面量创建"></a>对象字面量创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：无法批量生成多个对象，代码冗余</p>
<h3 id="简单改进：工厂函数"><a href="#简单改进：工厂函数" class="headerlink" title="简单改进：工厂函数"></a>简单改进：工厂函数</h3><p>我们可以写一个函数，解决代码重复问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">age</span>: age,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后生成实例对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">&#x27;ls&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>缺点：没有解决对象识别的问题，创建出来的对象都是 Object 类型的</p>
<h3 id="继续改进：自定义构造函数"><a href="#继续改进：自定义构造函数" class="headerlink" title="继续改进：自定义构造函数"></a>继续改进：自定义构造函数</h3><p>构造函数是一个函数，用于实例化对象，需要配合 new 操作符使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">p1.sayName() <span class="comment">// zs</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;ls&#x27;</span>, <span class="number">23</span>)</span><br><span class="line">p2.sayName() <span class="comment">// ls</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3><p>使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;ls&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello &#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.sayHello = sayHello</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;ls&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>缺点：会暴漏很多的函数，容易造成全局变量污染</p>
<blockquote>
<p>术语：</p>
<ol>
<li>实例（实例对象）：通过构造函数创建出来的对象，叫做实例，实例可以有多个</li>
<li>实例化：构造函数创建对象的过程</li>
<li>成员：对象的属性和方法</li>
</ol>
</blockquote>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型基本概念"><a href="#原型基本概念" class="headerlink" title="原型基本概念"></a>原型基本概念</h3><p>Javascript 规定，每一个函数都有一个 <code>prototype</code> 属性，属性值是一个对象，这个对象就叫做原型（原型对象），这个对象的所有属性和方法，都会被构造函数的实例继承</p>
<p>这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 <code>prototype</code> 对象上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(...)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(...)</span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这时所有实例的 <code>sayName()</code> 方法，其实都指向同一个内存地址</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p>任意对象都有 <code>__proto__</code> 属性，这个属性指向了构造函数的 prototype 属性，也就是原型对象</p>
<p>获取原型对象：</p>
<ul>
<li>通过 <code>构造函数.prototype</code> 可以获取</li>
<li>通过 <code>实例.__proto__</code> 可以获取（隐式原型）</li>
<li>它们指向了同一个对象 <code>构造函数.prototype === 实例.__proto__</code></li>
</ul>
<p><strong>注意：<code>__proto__</code>是浏览器的一个隐藏（私有）属性，IE 浏览器不支持，不要通过它来修改原型里的内容，如果要修改原型中的内容，使用 <code>构造函数.prototype</code> 去修改</strong></p>
<h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>默认情况下，原型对象中只包含了一个属性：constructor，constructor 属性指向了当前原型对象的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor) <span class="comment">// 构造函数本身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="comment">// p 实例对象没有constructor 属性， 该属性来源于原型上</span></span><br><span class="line"><span class="built_in">console</span>.log(p.constructor == Person.prototype.constructor) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数、实例、原型三者之间的关系"><a href="#构造函数、实例、原型三者之间的关系" class="headerlink" title="构造函数、实例、原型三者之间的关系"></a>构造函数、实例、原型三者之间的关系</h3><p>构造函数：构造函数就是一个函数，配合 new 可以新建对象</p>
<p>实例：通过构造函数实例化出来的对象我们把它叫做构造函数的实例。一个构造函数可以有很多实例</p>
<p>原型：每一个构造函数都有一个属性<code>prototype</code>，函数的 prototype 属性值就是原型。通过构造函数创建出来的实例能够直接使用原型上的属性和方法</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102204519.png"></p>
<p>原型三角关系：</p>
<ul>
<li><p>构造函数和原型：配偶关系</p>
<ul>
<li>构造函数（妈妈），通过 prototype 属性访问原型（爸爸）</li>
<li>原型通过 constructor 属性访问到构造函数</li>
</ul>
</li>
<li><p>构造函数 和 实例对象：母子关系</p>
<ul>
<li>构造函数可以创建实例对象</li>
<li>实例对象不能直接访问到构造函数</li>
</ul>
</li>
<li><p>原型 和 实例对象关系：父子关系</p>
<ul>
<li>实例对象可以直接访问到原型上的所有成员</li>
<li>实例对象可以间接的访问到构造函数（通过原型上的 constructor 属性）</li>
</ul>
</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="原型链概念"><a href="#原型链概念" class="headerlink" title="原型链概念"></a>原型链概念</h3><p>任何一个对象，都有原型对象，原型对象本身又是一个对象，所以原型对象也有自己的原型对象，这样形成的链式结构，就是原型链</p>
<p>绘制对象的原型链结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// p ==&gt; Person.prototype  ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="comment">// o ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="comment">// arr ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Math 是个内置对象，不是个构造函数</span></span><br><span class="line"><span class="comment">// Math ==&gt; Object.prototype ==&gt; null</span></span><br></pre></td></tr></table></figure>

<p>总结：Object.prototype 是原型链的尽头，Object.prototype 的原型是 null</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102204539.png"></p>
<h3 id="属性查找原则"><a href="#属性查找原则" class="headerlink" title="属性查找原则"></a>属性查找原则</h3><p><strong>属性搜索（查找）原则： 沿着原型链进行查找</strong></p>
<ol>
<li>首先在当前对象上查找是否有该属性，如果有，直接返回属性值</li>
<li>如果没有，去对象的原型上查找，如果有，直接返回属性值</li>
<li>如果也没有， 沿着原型链进行查找，直到 Object.prototype ，如果找到了，就返回属性值，如果还没有，返回 undefined</li>
</ol>
<p><strong>属性修改（设置）原则：</strong></p>
<ol>
<li>只会修改对象自身的属性</li>
<li>如果自身没有这个属性，那么就会添加这个属性，并不会修改原型中的属性</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;ls&#x27;</span>, <span class="number">19</span>)</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// p 的原型链：</span></span><br><span class="line"><span class="comment">// p ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// ls</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age) <span class="comment">// 19</span></span><br><span class="line"><span class="built_in">console</span>.log(p.gender) <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(p.sex) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.age) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// p1 对象依旧有 name 和age 属性， 只不过属性值都是 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.gender) <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sex) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">p.gender = <span class="string">&#x27;不详&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.gender) <span class="comment">// 不详</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">&#x27;ww&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// ww</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-prototype-成员介绍"><a href="#Object-prototype-成员介绍" class="headerlink" title="Object.prototype 成员介绍"></a>Object.prototype 成员介绍</h3><blockquote>
<p>任何对象的原型链上都有 Object.prototype，根据属性搜索原则(沿着原型链进行查找)，任何对象都可以访问到 Object.prototype 上的成员</p>
</blockquote>
<p>constructor：指向了构造函数 Object</p>
<h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a><code>hasOwnProperty</code></h4><p><code>hasOwnProperty()</code> 方法会返回一个布尔值，判断对象自身是否具有该属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断name属性是不是obj自己提供的</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong><code>hasOwnProperty</code> 与 <code>in</code> 的区别</strong></p>
<ol>
<li><p><code>in</code> 操作符：判断对象能否访问到该属性（不管这个属性是自己提供的，还是从原型上继承来的），如果可以访问到， 都会返回 true</p>
</li>
<li><p><code>hasOwnProperty</code>：该属性必须是自己提供，才返回 true，否则返回 false</p>
</li>
</ol>
<p><strong>hasOwnProperty 的使用场景</strong>：用在 for…in 循环中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> p) &#123;</span><br><span class="line">  <span class="comment">// 可以遍历到对象自身的属性以及对象原型链上的属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只遍历得到对象自身的属性，if 条件过滤下</span></span><br><span class="line">  <span class="comment">// if (p.hasOwnProperty(k)) &#123;</span></span><br><span class="line">  <span class="comment">// 		console.log(k)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf"></a><code>isPrototypeOf</code></h4><p><code>isPrototypeOf()</code> 方法用于测试一个对象是否存在于另一个对象的原型链上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 A 对象是否在 B 对象的原型链上</span></span><br><span class="line"><span class="comment">// 返回值：true，在原型链上  false：不在原型链上</span></span><br><span class="line">A.isPrototetypeOf(B)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="comment">// p 的原型链：</span></span><br><span class="line"><span class="comment">// p ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.isPrototypeOf(p)) <span class="comment">// false Person 是构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(p)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(p)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong><code>isPropertyOf</code> 与 <code>instanceof</code> 运算符的区别</strong></p>
<p><code>instanceof</code> 运算符用来测试一个对象的原型链中是否存在一个构造函数的 <code>prototype</code> 属性。作用和 isPrototypeOf 类似</p>
<p>语法： 实例对象 instanceof 构造函数</p>
<p>作用：构造函数的 prototype 属性是否在实例对象的原型链上</p>
<ul>
<li>A.isPrototypeOf(B) 判断 A 是否在 B 的原型链上 A： 是一个原型对象</li>
<li>B instanceof A 判断 A 的 prototype 是否在 B 的原型链上 A：是一个构造函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isPrototypeOf([])) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.isPrototypeOf([])) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>.prototype) <span class="comment">// 语法错误，instanceof 的右边是个构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title="propertyIsEnumerable"></a><code>propertyIsEnumerable</code></h4><p><code>propertyIsEnumerable()</code> 方法返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">19</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;lw&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.propertyIsEnumerable(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.propertyIsEnumerable(<span class="string">&#x27;age&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>拓展：给对象添加不可遍历的属性 : <code>Object.defineProperty()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法： Object.defineProperty(obj, prop, desc)</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// obj： 给哪个对象添加属性</span></span><br><span class="line"><span class="comment">// prop：属性， 类型是字符串</span></span><br><span class="line"><span class="comment">// desc： 属性描述符， 类型是个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作用： 定义对象的属性特征</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给obj 添加一个不可遍历的 gender 属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;gender&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;female&#x27;</span>, <span class="comment">// 配置该属性的默认值</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">// 配置该属性是否可以被修改， 默认值是false， 不可修改</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">// 配置该属性是否可遍历， 默认值是false， 不可遍历</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj.propertyIsEnumerable(<span class="string">&#x27;gender&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="toString-toLocaleString"><a href="#toString-toLocaleString" class="headerlink" title="toString/toLocaleString"></a>toString/toLocaleString</h4><p>返回对象的字符串格式</p>
<blockquote>
<p>每个内置对象的原型上都有属于自己的 toString 方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.toString()) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.toLocaleString()) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// arr ==&gt;  Array.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="comment">//           toString()         toString()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype) <span class="comment">// 含有自己的 toString 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// &#x27;1,2,3&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toLocaleString()) <span class="comment">// &#x27;1,2,3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">//  date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="comment">//           toString()          toString()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype) <span class="comment">// 含有自己的 toString 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toString()) <span class="comment">// Wed Oct 10 2018 16:00:51 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toLocaleString()) <span class="comment">// 2018/10/10 下午4:00:51 得到的是本地时间格式</span></span><br></pre></td></tr></table></figure>

<h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h4><p>语法：对象.valueOf()</p>
<p>作用： 返回对象的原始值（简单数据类型），默认的 valueOf 方法（Object.prototype 上的 valueOf 方法）只会返回对象自身；日期对象的 valueOf 方法返回的是时间戳，因为 Date 的原型链上有自己的 valueOf 方法，该 valueOf 的作用就是返回日期的时间戳</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.valueOf()) <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// arr ==&gt;  Array.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.valueOf()) <span class="comment">// arr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">// date 原型链</span></span><br><span class="line"><span class="comment">// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype) <span class="comment">// 含有 valueOf 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(date.valueOf()) <span class="comment">// 时间戳</span></span><br></pre></td></tr></table></figure>

<h4 id="valueOf-和-toString-的应用"><a href="#valueOf-和-toString-的应用" class="headerlink" title="valueOf 和 toString 的应用"></a>valueOf 和 toString 的应用</h4><p>当对象在参与运算和比较的时候，js 内部会自动的调用 valueOf 和 toString 方法</p>
<p>调用规则：</p>
<ol>
<li><p>默认先调用 vauleOf， 尝试将对象转成简单数据类型， 如果没有转成简单数据类型， 会继续在调用 toString 方法</p>
</li>
<li><p>如果 valueOf 和 toString 方法都没有转成简单数据类型，会报错</p>
</li>
</ol>
<h2 id="沙箱模式"><a href="#沙箱模式" class="headerlink" title="沙箱模式"></a>沙箱模式</h2><p>沙箱其实就是一个独立的环境，这个环境中任何的改变，都不会对外部环境产生影响</p>
<p>函数自调用一样，在自调用函数内部的变量是不会影响到外部的，因此<strong>函数自调用模式也叫沙箱模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;这是fn函数&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>代码写在自调用函数里面，减少全局污染</li>
<li>想要在外面使用 fn 函数，可将 fn 暴露到全局 <code>window.fn = fn;</code> 将 fn 函数的地址赋值给了 window 上的 fn 属性</li>
<li>一般，我们一个 js 文件只会暴露一个核心的功能（函数、方法）： 目的还是为了减少全局污染</li>
</ol>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><ul>
<li>语法：<code>&#39;use strict&#39;</code></li>
<li>作用：让 js 引擎以更加严格的模式执行 js 代码</li>
<li>最佳实践：在某个函数内部开启严格模式，而不是在全局环境中开启</li>
<li>注意：<ul>
<li>严格模式只对当前作用域起作用</li>
<li>应该<strong>在当前作用域最顶端使用<code>use strict</code>，否则严格模式无效</strong></li>
</ul>
</li>
<li>使用严格模式好处：<ul>
<li>规范</li>
<li>提高代码执行效率</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格模式应该配合沙箱模式一起使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 沙箱模式 + 严格模式：</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="严格模式规定"><a href="#严格模式规定" class="headerlink" title="严格模式规定"></a>严格模式规定</h3><ul>
<li>变量必须显示声明</li>
<li>函数参数不能重名</li>
<li>禁止使用八进制</li>
<li>不能使用保留字作为变量名称：<code>implements, interface, let, package, private, protected, public, static, yield</code></li>
<li>如果不符合上述规范，会直接报错</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>继承：子承父业</p>
</blockquote>
<p>在 js 中的继承概念非常简单，拿来主义：一个对象自己没有的属性和方法，另一个对象有，拿过来使用，就实现了继承。</p>
<p>继承的目的：让一个对象可以使用另一个对象的属性和方法。</p>
<h3 id="混入式继承（mixin）"><a href="#混入式继承（mixin）" class="headerlink" title="混入式继承（mixin）"></a>混入式继承（mixin）</h3><blockquote>
<p>把一个对象中的属性和方法拷贝到另一个对象中。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ls = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">extend</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 只拷贝对象obj自身的成员，原型链上的成员不用拷贝给this</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">      <span class="built_in">this</span>[k] = obj[k]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>一个对象可以访问构造函数的原型中的属性和方法，那么如果想要让一个对象增加某些属性和方法，</p>
<p>只需要把这些属性和方法放到原型对象中即可。这样就实现了继承, 称之为原型链继承</p>
<ul>
<li>直接给原型增加属性和方法</li>
<li>原型替换（注意：constructor）</li>
<li>mixin+原型替换</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 直接给原型增加属性和方法（麻烦）</span></span><br><span class="line">Person.prototype.color = <span class="string">&#x27;lime&#x27;</span></span><br><span class="line">Person.prototype.legs = <span class="number">2</span></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;sayHi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 原型替换，将原型替换成一个对象</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="comment">// 手动添加一个constructor属性，如果不手动添加，会找到 Object 的 constructor 属性</span></span><br><span class="line">  <span class="attr">constructor</span>: Person,</span><br><span class="line"></span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;lime&#x27;</span>,</span><br><span class="line">  <span class="attr">legs</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;sayHi&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 原型链 + 混入式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> lw = &#123;</span><br><span class="line">  <span class="attr">skill</span>: <span class="string">&#x27;翻墙&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给原型添加 extend 方法  -- 混入式继承</span></span><br><span class="line">Person.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">      <span class="built_in">this</span>[k] = obj[k]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把 lw 的成员添加到了 Person 的原型上， Person 的实例就可以访问到原型上的这个成员</span></span><br><span class="line">Person.prototype.extend(lw)</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p.skill)</span><br></pre></td></tr></table></figure>

<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZQ==">MDN</span></p>
<blockquote>
<p>最初是由道格拉斯丶克罗克福德发布的一篇文章提出的，ECMAScript5 新增了 Object.create() 方法来规范化了这种继承</p>
</blockquote>
<p>ES5 中新增 <code>Object.create()</code> 创建新对象， 使用指定的原型对象来提供新创建的对象的 <code>__proto__</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="built_in">Object</span>.create(proto[, propertiesObject])</span><br><span class="line"><span class="comment">// 参数：proto 一个对象,新创建对象的原型对象</span></span><br><span class="line"><span class="comment">// 参数：propertiesObject 要添加到新创建对象的可枚举属性</span></span><br><span class="line"><span class="comment">// 返回值：一个新对象，带着指定的原型对象和属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(proto)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<p>使用 <code>Object.create()</code> 来实现继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Shape - 父类(superclass)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">0</span></span><br><span class="line">  <span class="built_in">this</span>.y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类的方法</span></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x += x</span><br><span class="line">  <span class="built_in">this</span>.y += y</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">&#x27;Shape moved.&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle - 子类(subclass)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="built_in">this</span>) <span class="comment">// call super constructor. 继承父类的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类续承父类</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype) <span class="comment">// 将父类的原型赋值给了子类</span></span><br><span class="line">Rectangle.prototype.constructor = Rectangle</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Is rect an instance of Rectangle?&#x27;</span>, rect <span class="keyword">instanceof</span> Rectangle) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Is rect an instance of Shape?&#x27;</span>, rect <span class="keyword">instanceof</span> Shape) <span class="comment">// true</span></span><br><span class="line">rect.move(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// Outputs, &#x27;Shape moved.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果你希望能继承到多个对象，则可以使用混入的方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>)</span><br><span class="line">  OtherSuperClass.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype)</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype)</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do a thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="定义函数的三种方式"><a href="#定义函数的三种方式" class="headerlink" title="定义函数的三种方式"></a>定义函数的三种方式</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn() <span class="comment">// 函数声明可以先调用，在声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;这是函数声明&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;这是函数表达式&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 函数表达式必须先声明，再调用</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数-Function"><a href="#构造函数-Function" class="headerlink" title="构造函数 Function"></a>构造函数 Function</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数也是对象，可以使用 Function 构造函数 new 出来</span></span><br><span class="line"><span class="comment">// 相当于var fn = function () &#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法：new Function(arg1,arg2,arg3..,body)</span></span><br><span class="line"><span class="comment">// 1. 所有的参数都是字符串类型</span></span><br><span class="line"><span class="comment">// 2. 前面可以定义任意多个形参，最后一个参数是代码体</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;alert(1)&#x27;</span>)</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;alert(a1 + a2)&#x27;</span>)</span><br><span class="line">fn1(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>【案例：代码实时预览效果.html】</p>
<h4 id="eval-函数–了解"><a href="#eval-函数–了解" class="headerlink" title="eval 函数–了解"></a>eval 函数–了解</h4><blockquote>
<p>eval 可以和 new Function 一样，执行字符串代码</p>
</blockquote>
<p>注意：eval 函数的功能非常的强大，但是实际使用的情况并不多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var num = 10; console.log(num)&#x27;</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>eval 形式的代码难以阅读</li>
<li>eval 形式的代码无法打断点，因为本质还是还是一个字符串</li>
<li>在浏览器端执行任意的 JavaScript 会带来潜在的安全风险，恶意的 JavaScript 代码可能会破坏应用，特别是在用它执行用户输入数据的情况下。可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）<br><span class="exturl" data-url="aHR0cDovL3Fpbmdib2IuY29tL0V4Y2Vzcy1YU1Mv">推荐了解下 xss 攻击</span></li>
</ul>
<h3 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h3><p>分析 this 指向问题</p>
<ol>
<li>任何函数都有属于自己的 this</li>
<li>this 是动态的，this 在函数声明的时候是确定不了的，只有当函数被调用了才能够确定 this 的指向，this 的指向和函数在哪被调用没有关系</li>
</ol>
<p>分析 this 的问题的思路：</p>
<ol>
<li>this 是属于哪个函数</li>
<li><strong>这个函数是何种调用模式</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数：当一个函数不是一个对象的属性时，我们称之为函数</span><br><span class="line">方法：当一个函数被保存为对象的一个属性时，我们称之为方法</span><br></pre></td></tr></table></figure>

<h4 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h4><p><font color="red">如果一个函数不是一个对象的属性时，就是被当做一个函数来进行调用的。此时 this 指向了 window</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数名() 的调用方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// 指向window</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<h4 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h4><p><font color="red">当一个函数被保存为对象的一个属性时，我们称之为一个方法。当一个方法被调用时，this 被绑定到当前对象</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过点语法或者中括号语法来访问方法，都是属于方法调用模式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">fn</span>: f</span><br><span class="line">&#125;</span><br><span class="line">obj.fn() <span class="comment">// obj</span></span><br><span class="line">obj[<span class="string">&#x27;fn&#x27;</span>]() <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [f, <span class="number">10</span>, <span class="number">30</span>]</span><br><span class="line"><span class="comment">// 也是方法调用模式</span></span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">// arr</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h4><p><font color="red">如果函数是通过 new 关键字进行调用的，此时 this 被绑定到创建出来的新对象上</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Person() <span class="comment">// this 指向 window</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person() <span class="comment">// this 指向 p</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：分析 this 的问题，主要就是区分函数的调用模式，看函数是怎么被调用的</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分析思路：1. 看 this 是哪个函数的  2. 看这个函数是怎么调用的，处于什么调用模式</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">38</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = obj.getAge</span><br><span class="line">f() <span class="comment">// window ==&gt; 38</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">38</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age) <span class="comment">// obj ==&gt; 18</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.age) <span class="comment">// window ==&gt; 38</span></span><br><span class="line">    &#125;</span><br><span class="line">    foo()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getAge()</span><br><span class="line"><span class="comment">// obj[&#x27;getAg&#x27;]()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [fn, <span class="string">&#x27;222&#x27;</span>]</span><br><span class="line">fn() <span class="comment">// 10</span></span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn() <span class="comment">// window ==&gt; 10</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>]() <span class="comment">// argument ==&gt; 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.method(fn, <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.</span></span><br><span class="line"><span class="keyword">let</span> len = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.len)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// window ==&gt; undefined</span></span><br><span class="line"><span class="keyword">let</span> Person = &#123;</span><br><span class="line">  <span class="attr">len</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">say</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn() <span class="comment">// window ==&gt; undefined</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>]() <span class="comment">// arguments ==&gt; undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.say(fn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="function">() =&gt;</span> <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。</span></span><br><span class="line"><span class="comment">// 将返回的函数的引用赋值给fn。</span></span><br><span class="line"><span class="keyword">var</span> fn = obj.bar()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用fn而不设置this，</span></span><br><span class="line"><span class="comment">// 通常(即不使用箭头函数的情况)默认为全局对象</span></span><br><span class="line"><span class="comment">// 若在严格模式则为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(fn() === obj) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是注意，如果你只是引用obj的方法，</span></span><br><span class="line"><span class="comment">// 而没有调用它</span></span><br><span class="line"><span class="keyword">var</span> fn2 = obj.bar</span><br><span class="line"><span class="comment">// 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。</span></span><br><span class="line"><span class="built_in">console</span>.log(fn2()() == <span class="built_in">window</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="方法借用模式"><a href="#方法借用模式" class="headerlink" title="方法借用模式"></a>方法借用模式</h4><blockquote>
<p>上下文调用模式也叫方法借用模式，分为 apply，call ，bind</p>
<p>使用方法：<code>函数.call()</code> 或者 <code>函数.apply()</code></p>
</blockquote>
<p>任何函数都可以调用 apply，call ，bind 这三个方法</p>
<h5 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a>call 方法</h5><p>call 方法可以调用一个函数，并且可以指定这个函数的 <code>this</code> 指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call 方法也可以和 () 一样，进行函数调用</span></span><br><span class="line"><span class="comment">// 第一个参数：指定函数的 this，如果不传，则 this 指向 window</span></span><br><span class="line"><span class="comment">// 其余参数：和函数的参数列表一模一样</span></span><br><span class="line"><span class="keyword">var</span> zs = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello ,我是&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// zs.sayHi()</span></span><br><span class="line"><span class="keyword">var</span> ls = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;ls&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ls 借用 zs 的 sayHi 方法</span></span><br><span class="line">zs.sayHi.call(ls)</span><br></pre></td></tr></table></figure>

<h5 id="伪数组与数组"><a href="#伪数组与数组" class="headerlink" title="伪数组与数组"></a>伪数组与数组</h5><blockquote>
<p>伪数组也叫类数组</p>
</blockquote>
<ol>
<li>伪数组其实就是一个对象，但是跟数组一样，伪数组也会有<code>length</code>属性，也有<code>0, 1, 2, 3</code>等属性</li>
<li>伪数组并没有数组的方法，不能使用<code>push/pop</code>等方法</li>
<li>伪数组可以跟数组一样进行遍历，通过下标操作</li>
<li>常见的伪数组：<code>arguments</code>、<code>document.getElementsByTagName的返回值</code>、<code>jQuery对象</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;ls&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;ww&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>伪数组借用数组的方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给 obj 添加一项 3: &#x27;zl&#x27;</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(obj, <span class="string">&#x27;zl&#x27;</span>)</span><br><span class="line"><span class="comment">// 把 obj 中的每一项使用 &#x27;-&#x27; 拼接起来返回一个字符串</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(obj, <span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>将伪数组转换成真数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(obj)</span><br></pre></td></tr></table></figure>

<h5 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a>apply 方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply 的语法：</span><br><span class="line">apply(thisArg, 实参列表)</span><br><span class="line">thisArg ==&gt; 改变函数内的 this 指向的</span><br><span class="line">实参列表 ==&gt; 是一个数组或者是伪数组</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>apply()</code>方法的作用和 <code>call()</code>方法类似，只有一个区别，就是<code>apply()</code>方法接受的是<strong>一个包含多个参数的数组</strong>。而<code>call()</code>方法接受的是<strong>若干个参数的列表</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. apply 能够调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.apply() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. apply 改变 this 指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.apply([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]) <span class="comment">// [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. apply 第二个参数是数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(n1 + n2)</span><br><span class="line">&#125;</span><br><span class="line">fn.apply(&#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span> &#125;, [<span class="number">10</span>, <span class="number">20</span>]) <span class="comment">// &#123;name: &#x27;zs&#x27;&#125;, 30</span></span><br><span class="line"><span class="comment">// apply 的特性： 平铺性，把数组中的每一项取出来作为函数的实参</span></span><br><span class="line"><span class="comment">// fn.call(&#123;name: &#x27;ls&#x27;&#125;, 10, 20) // &#123;&#125;, 30</span></span><br></pre></td></tr></table></figure>

<p>call 和 apply 的使用场景：</p>
<ul>
<li>如果参数比较少，使用 call 会更加简洁</li>
<li>如果参数存放在数组中，此时需要使用 apply</li>
</ul>
<p>课后练习：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">求数组的最大值和最小值</span><br><span class="line">封装一个函数，能够打印出来所有的参数</span><br></pre></td></tr></table></figure>

<h5 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h5><p><strong>bind()</strong> 方法创建一个新的函数、可以绑定新的函数的 <code>this</code> 指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值：新的函数(不会被调用)</span></span><br><span class="line"><span class="comment">// 参数：新函数的 this 指向，当绑定了新函数的 this 指向后，无论使用何种调用模式，this 都不会改变</span></span><br><span class="line"><span class="comment">// var newFn = fn.bind(window)</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newFn = fn.bind([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// newFn 是 bind 创建并返回出来的</span></span><br><span class="line"><span class="built_in">console</span>.log(newFn)</span><br><span class="line">newFn() <span class="comment">// this ==&gt; [1,2,3]</span></span><br></pre></td></tr></table></figure>

<p>如果对一个函数进行多次 bind，那么上下文会是什么呢</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.bind().bind(a)() <span class="comment">// =&gt; ?</span></span><br></pre></td></tr></table></figure>

<p>如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply()</span><br><span class="line">  &#125;.apply(a)</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>

<p>可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。</p>
<h4 id="特殊的-this-指向"><a href="#特殊的-this-指向" class="headerlink" title="特殊的 this 指向"></a>特殊的 this 指向</h4><ul>
<li>定时器中的 this 指向了 window，因为定时器的 function 最终是由 window 来调用的</li>
<li>事件中的 this 指向的是当前的元素，在事件触发的时候，浏览器让当前元素调用了 function</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call apply bind 第一个参数表示要绑定的 this</span><br><span class="line">不传，传 null，或者 undefined ，this 均指向 window</span><br><span class="line">但在严格模式下，不传指向 undefined，传 null 指向 null，传 undefined 指向 undefined</span><br></pre></td></tr></table></figure>

<h3 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h3><blockquote>
<p>函数是由 new Function 创建出来的，因此函数也是一个对象，<code>所有的函数都是 new Function 的实例</code></p>
</blockquote>
<h4 id="函数的原型链结构"><a href="#函数的原型链结构" class="headerlink" title="函数的原型链结构"></a>函数的原型链结构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部：var Person = new Function()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Person 实例对象的原型链：</span></span><br><span class="line"><span class="comment">// Person ==&gt; Function.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="comment">// Function.prototype 原型类型是个函数</span></span><br><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">Function</span>.prototype)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102204558.jpeg"></p>
<h4 id="Function-prototype-成员"><a href="#Function-prototype-成员" class="headerlink" title="Function.prototype 成员"></a>Function.prototype 成员</h4><ul>
<li>arguments：获取函数的实参，已经被废弃了，现在推荐的做法是使用函数内部可用的  <code>arguments</code>对象来访问函数的实参<ul>
<li>（废弃的意思：已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性）</li>
</ul>
</li>
<li>length：获取形参的长度</li>
<li>name：获取函数的名字，此属性不允许修改</li>
<li>caller: 用于获取当前函数是在哪个函数中调用的，已经被废弃了</li>
<li>constructor：指向当前构造函数，Function</li>
<li>call：调用函数，重新指定 this</li>
<li>apply：调用函数，重新指定 this</li>
<li>bind：重新指向 this，返回一个新的函数，不调用</li>
<li>toString : 得到函数的字符串格式</li>
</ul>
<p>案例【封装 getType 函数（获取数据类型）】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, -<span class="number">1</span>) <span class="comment">// &#x27;[object 构造函数]&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整版原型链"><a href="#完整版原型链" class="headerlink" title="完整版原型链"></a>完整版原型链</h4><blockquote>
<p>绘制完整版原型链的目的是辅助大家理解 js 中对象的继承关系</p>
</blockquote>
<p>图一<br><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102204647.png"></p>
<p>图二<br><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102204701.jpeg"></p>
<p>总结：</p>
<ol>
<li>所有函数都是 new Function 创建出来的，因此 <code>所有函数.__proto__</code> 都是 <code>Function.prototype</code></li>
<li>所有对象都是 new Object 创建出来的，因此 <code>所有对象.__proto__</code> 都是 <code>Object.prototype</code></li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NyZWVwZXJ5YW5nL2Jsb2cvaXNzdWVzLzk=">参考链接</span></p>
<h3 id="作用域与预解析"><a href="#作用域与预解析" class="headerlink" title="作用域与预解析"></a>作用域与预解析</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><blockquote>
<p>作用域：变量起作用的区域，也就是说：变量定义后，可以在哪个范围内使用该变量</p>
</blockquote>
<p><strong>全局作用域</strong> ：在 script 标签内，<strong>函数外</strong>的区域就是全局作用域，在全局作用内声明的变量叫做<strong>全局变量</strong> 。全局变量可以在任意地方访问。（if/while/for 语句中声明的变量也是全局变量）</p>
<p><strong>函数作用域</strong> ：在函数内的区域叫做函数作用域，在函数作用域内声明的变量叫做<strong>局部变量</strong> ，局部变量只有在当前函数内才能访问到。</p>
<p>自由变量：对于一个函数来说，函数内部没有声明该变量，但在函数内部有访问该变量。对于这个函数来说， 该变量就是一个自由变量。</p>
<p>隐式全局变量：没有使用 var 定义的变量也是全局变量，叫做隐式全局变量。(不要使用)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">11</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num1 = <span class="number">22</span></span><br><span class="line">  num2 = <span class="number">33</span></span><br><span class="line">  num = <span class="number">33</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br><span class="line"><span class="comment">// console.log(num1)</span></span><br><span class="line"><span class="built_in">console</span>.log(num2)</span><br></pre></td></tr></table></figure>

<p>变量的查找规则：</p>
<ul>
<li>函数内部可以使用函数外部的变量</li>
<li>有局部变量就用局部变量，没有局部变量就用全局变量。</li>
</ul>
<p><strong>函数作用域是在函数定义的时候作用域就确定下来了，和函数在哪调用无关</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">123</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">456</span></span><br><span class="line">  f1()</span><br><span class="line">&#125;</span><br><span class="line">f2() <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">20</span></span><br><span class="line">  num = <span class="number">30</span> <span class="comment">// num 在局部声明过，只能修改局部的 num 值</span></span><br><span class="line">  num1 = <span class="number">20</span> <span class="comment">// 修改全局的 num1 值</span></span><br><span class="line">  <span class="keyword">var</span> num2 = <span class="number">40</span></span><br><span class="line">  num3 = <span class="number">50</span> <span class="comment">// 隐式全局</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 30</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1) <span class="comment">// 20</span></span><br><span class="line">  <span class="built_in">console</span>.log(num2) <span class="comment">// 40</span></span><br><span class="line">  <span class="built_in">console</span>.log(num3) <span class="comment">// 50</span></span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(num1) <span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 如果 test 函数没执行过，则 num1 值为 10</span></span><br><span class="line"><span class="built_in">console</span>.log(num3) <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>作用域链：只要是函数，就会形成一个作用域，如果这个函数被嵌套在其他函数中，那么外部函数也有自己的作用域，这个一直往上到全局环境，就形成了一个作用域链</p>
<p><code>变量的搜索原则</code>：</p>
<ol>
<li>从当前作用域开始查找是否声明了该变量，如果存在，那么就直接返回这个变量的值</li>
<li>如果不存在，就会往上一层作用域查询，如果存在，就返回</li>
<li>如果不存在，一直查询到全局作用域，如果存在，就返回。如果在全局中也没有找到该变量会<strong>报错</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line">fn1()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 -- 改造上面的面试题</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line">fn1()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 10</span></span><br><span class="line">  num = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">123</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 456 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">456</span></span><br><span class="line">  f1(num)</span><br><span class="line">  f1()</span><br><span class="line">&#125;</span><br><span class="line">f2()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1</span>) </span>&#123;</span><br><span class="line">  num1 = <span class="number">100</span></span><br><span class="line">  num2 = <span class="number">200</span></span><br><span class="line">  num3 = <span class="number">300</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1) <span class="comment">// 100</span></span><br><span class="line">  <span class="built_in">console</span>.log(num2) <span class="comment">// 200</span></span><br><span class="line">  <span class="built_in">console</span>.log(num3) <span class="comment">// 300</span></span><br><span class="line">  <span class="keyword">var</span> num3</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(num1) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// 200</span></span><br><span class="line"><span class="built_in">console</span>.log(num3) <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">  num++</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 101</span></span><br><span class="line">fn() <span class="comment">// 101</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;red&#x27;</span> <span class="comment">// blue</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> anotherColor = <span class="string">&#x27;blue&#x27;</span> <span class="comment">// red</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmpColor = color <span class="comment">// red</span></span><br><span class="line">    color = anotherColor</span><br><span class="line">    anotherColor = tmpColor <span class="comment">// red</span></span><br><span class="line">    <span class="built_in">console</span>.log(anotherColor) <span class="comment">// red</span></span><br><span class="line">  &#125;</span><br><span class="line">  inner()</span><br><span class="line">&#125;</span><br><span class="line">outer()</span><br><span class="line"><span class="built_in">console</span>.log(color) <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>

<h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><blockquote>
<p>预解析：预先解析</p>
</blockquote>
<p>js 执行代码分为两个过程：</p>
<ul>
<li>预解析过程（变量与函数提升）</li>
<li>代码一行一行执行</li>
</ul>
<p>预解析过程：JavaScript 解析器在执行代码前，会把所有变量的声明和函数的声明提升到当前作用域的顶部。例如<code>var a = 11</code>其实会分为<code>var a</code> 和<code>a = 11</code>两部分，其中<code>var a;</code>会被提升</p>
<p>预解析规则 :</p>
<ol>
<li>var 声明的变量：只提升声明，不会提升赋值</li>
<li>函数声明：整体提升</li>
<li>先提升 var 声明的变量，后提升函数声明</li>
<li>遇到重名的 var 声明， var 声明会被忽略，值会保留</li>
<li>遇到重名的函数声明，后者会覆盖前者</li>
<li>如果 var 声明和函数声明同名，函数声明会把 var 声明覆盖</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数预解析</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">45</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n) <span class="comment">// undefined</span></span><br><span class="line">  n = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(n) <span class="comment">// 20</span></span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">  <span class="built_in">console</span>.log(n) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line">fn5()</span><br><span class="line"><span class="built_in">console</span>.log(n) <span class="comment">// 45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 函数体</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">23</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 23</span></span><br><span class="line"><span class="comment">// b() // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 函数体</span></span><br><span class="line">c() <span class="comment">// 嘿嘿</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  comsole.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;嘿嘿&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.</span></span><br><span class="line"><span class="built_in">console</span>.log(fn1) <span class="comment">// 函数体</span></span><br><span class="line">fn1()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>) <span class="comment">// 哈哈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn2) <span class="comment">// undefined</span></span><br><span class="line">fn2() <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;嘿嘿&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于函数表达式，函数的调用必须在表达式声明之后</span></span><br><span class="line">fn2() <span class="comment">// 嘿嘿</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.</span></span><br><span class="line"><span class="comment">// 只有用 var 声明的变量才会预解析</span></span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">// 报错</span></span><br><span class="line">d = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.</span></span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br><span class="line"><span class="built_in">console</span>.log(f) <span class="comment">// 报错 f is not defined</span></span><br><span class="line"><span class="keyword">var</span> e = (f = <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// abc</span></span><br></pre></td></tr></table></figure>

<p><strong>不要在一个作用域内重复的声明相同的变量和函数</strong></p>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><blockquote>
<p>递归函数：函数内部直接或者间接的调用自己</p>
</blockquote>
<p>递归的要求：</p>
<ol>
<li>自己调用自己（直接或者间接）</li>
<li>要有结束条件（出口）</li>
</ol>
<p>递归函数主要是<code>化归思想</code>，将一个复杂的问题简单化，主要用于解决数学中的一些问题居多。</p>
<ul>
<li>把要解决的问题，归结为已经解决的问题上。</li>
<li>一定要考虑什么时候结束让函数结束，也就是停止递归（一定要有已知条件）</li>
</ul>
<p>练习：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 计算1-100之间所有数的和</span></span><br><span class="line"><span class="comment">// 2. 计算斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn(n - <span class="number">1</span>) + fn(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">12</span>))</span><br></pre></td></tr></table></figure>

<h4 id="实现缓存"><a href="#实现缓存" class="headerlink" title="实现缓存"></a>实现缓存</h4><blockquote>
<p>缓存（cache）：数据的缓冲区，当要读取数据时，先从缓冲中获取数据，如果找到了，直接获取，如果找不到，重新去请求数据</p>
</blockquote>
<p>计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。</p>
<p>初级优化：</p>
<p>使用缓存的基本步骤：</p>
<ul>
<li>如果要获取数据，先查询缓存，如果有就直接使用</li>
<li>如果没有，就进行计算，并且将计算后的结果放到缓存中，方便下次使用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">var</span> fbi = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[n]) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[n]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = fbi(n - <span class="number">1</span>) + fbi(n - <span class="number">2</span>)</span><br><span class="line">    arr[n] = temp <span class="comment">// 存入缓存</span></span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="闭包的基本概念"><a href="#闭包的基本概念" class="headerlink" title="闭包的基本概念"></a>闭包的基本概念</h3><p><code>闭包（closure）</code>是 JavaScript 语言的一个难点，也是 JavaScript 的一个特色，很多高级的应用都要依靠闭包来实现</p>
<blockquote>
<p>闭包是函数和声明该函数的词法环境的组合</p>
</blockquote>
<p>在 JavaScript 中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，产生闭包</p>
<p>**闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用 **</p>
<p>产生闭包的条件：有两个函数，是嵌套关系，内部函数引用了外部函数的变量，这样就会形成闭包</p>
<p>闭包的作用：</p>
<ul>
<li>私有变量，保护数据安全</li>
<li>持久化维持数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包的基本模型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line">  <span class="comment">// function inner () &#123;</span></span><br><span class="line">  <span class="comment">//   num++</span></span><br><span class="line">  <span class="comment">//   console.log(num)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// return inner  // 把inner函数给返回出去，让外部能够调用inner函数</span></span><br><span class="line">  <span class="comment">// 上面的简写</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并不一定是有返回函数才算是产生了闭包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f3</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  f3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1()</span><br><span class="line">f3() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>需求：统计一个函数的调用次数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我被调用了，调用次数是&#x27;</span> + count)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">fn()</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// 缺点：count是全局变量，不安全</span></span><br></pre></td></tr></table></figure>

<p>使用闭包解决这个问题！！！！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span> <span class="comment">// 私有变量, 将 count 保护起来了</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;当前count&#x27;</span> + count)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> add</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = outer()</span><br><span class="line">result()</span><br></pre></td></tr></table></figure>

<p>【案例：银行存钱取钱】</p>
<h4 id="缓存的私有化"><a href="#缓存的私有化" class="headerlink" title="缓存的私有化"></a>缓存的私有化</h4><blockquote>
<p>缓存（cache）：数据的缓冲区，当要读取数据时，先从缓冲中获取数据，如果找到了，直接获取，如果找不到，重新去请求数据。</p>
</blockquote>
<p>计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。</p>
<p>缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fbi = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[n]) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr[n]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> temp = fbi(n - <span class="number">1</span>) + fbi(n - <span class="number">2</span>)</span><br><span class="line">      arr[n] = temp <span class="comment">//存入缓存</span></span><br><span class="line">      <span class="keyword">return</span> temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fbi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fbi = outer()</span><br><span class="line"><span class="built_in">console</span>.log(fbi(<span class="number">40</span>))</span><br></pre></td></tr></table></figure>

<h3 id="闭包存在的问题"><a href="#闭包存在的问题" class="headerlink" title="闭包存在的问题"></a>闭包存在的问题</h3><blockquote>
<p>正常情况下：函数在调用的时候，去开辟一块内存空间用来执行内部的代码，当函数调用结束的时候，要销毁开辟的空间，节省内存</p>
<p>闭包占用的内存是不会被释放的，因此，如果滥用闭包，会造成内存泄漏的问题。闭包很强大，但是只有在必须使用闭包的时候才使用</p>
</blockquote>
<h4 id="js-的垃圾回收机制-了解"><a href="#js-的垃圾回收机制-了解" class="headerlink" title="js 的垃圾回收机制(了解)"></a>js 的垃圾回收机制(了解)</h4><ul>
<li>内存：计算机中所有程序的运行都是在<code>内存</code> 中进行的，因此内存的性能对计算机的影响非常大，运行程序需要消耗内存，当程序结束时，内存会得到释放。</li>
<li>javascript 分配内存：当我们定义变量，javascript 自动分配内存存储数据。无论是值类型或者是引用类型，都需要存储在内存中。</li>
<li>垃圾回收：当代码执行结束，分配的内存已经不需要了，这时候需要将内存进行回收，在 javascript 语言中，<code>垃圾回收机器</code>会帮我们回收<code>不再需要使用</code>的内存。</li>
</ul>
<h5 id="引用记数法清除"><a href="#引用记数法清除" class="headerlink" title="引用记数法清除"></a>引用记数法清除</h5><p>引用记数垃圾收集：如果没有引用指向某个对象（或者是函数作用域），那么这个对象或者函数作用域就会被垃圾回收机制回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象被 o 变量引用，引用记数 1</span></span><br><span class="line"><span class="keyword">var</span> obj = o <span class="comment">// 变量被 o 和 obj 引用，引用记数 2</span></span><br><span class="line">o = <span class="number">1</span> <span class="comment">// o 不在引用对象了，引用记数 1</span></span><br><span class="line">obj = <span class="literal">null</span> <span class="comment">// obj 不在引用对象了，引用记数 0，可以被垃圾回收了</span></span><br></pre></td></tr></table></figure>

<p>引用计数法无法解决循环引用导致的内存泄露</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj1 = &#123;&#125; <span class="comment">// 引用计数为 2</span></span><br><span class="line">  <span class="keyword">var</span> obj2 = &#123;&#125; <span class="comment">// 引用计数为 2</span></span><br><span class="line">  obj1.a = obj2</span><br><span class="line">  obj2.b = obj1</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 销毁fn调用开辟的空间， 但是由于引用计数考虑到两个对象都不是零引用的对象，就不能够被垃圾回收机制给回收掉</span></span><br></pre></td></tr></table></figure>

<h5 id="标记清除法清除"><a href="#标记清除法清除" class="headerlink" title="标记清除法清除"></a>标记清除法清除</h5><p>使用引用计数法进行垃圾回收的时候，会出现循环引用导致内存泄漏的问题。因此现代的浏览器都采用标记清除法来进行垃圾回收。</p>
<p>这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象 Window）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>
<p><strong>从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。</strong></p>
<h4 id="闭包占用内存释放"><a href="#闭包占用内存释放" class="headerlink" title="闭包占用内存释放"></a>闭包占用内存释放</h4><p>当闭包的功能不在需要使用了，将这个变量指向 <code>null</code>， 这样闭包占用的内存就可以被回收掉了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行次数&#x27;</span> + count)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = outer()</span><br><span class="line">result()</span><br><span class="line">result = <span class="literal">null</span> <span class="comment">// 当函数 fn 没有被变量引用了，那么函数 fn 就会被回收，函数 fn 一旦被回收，那么 outer调用形成的作用域也就得到了释放</span></span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote>
<p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串（数据验证）、将匹配的子串替换（数据删除或替换）或者从某个串中取出符合某个条件的子串等（数据提取）</p>
</blockquote>
<h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><ul>
<li>构造函数的方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RegExp(regular expression)</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/a/</span>) <span class="comment">// 匹配字母中有 a</span></span><br></pre></td></tr></table></figure>

<ul>
<li>正则字面量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/</span></span><br></pre></td></tr></table></figure>

<p>正则有 test 方法，作用是测试字符串是否符合正则表达式的规律，如果符合， 返回 true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;abc&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;def&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><blockquote>
<p>正则表达式由一些普通字符和元字符组成，普通字符包括大小写字母、数字等，而元字符则具有特殊的含义</p>
</blockquote>
<h4 id="常见元字符"><a href="#常见元字符" class="headerlink" title="常见元字符"></a>常见元字符</h4><p><code>\d</code> 匹配一个数字字符。等价于 <code>[0-9]</code></p>
<p><code>\D</code> 匹配一个非数字字符。等价于 <code>[^0-9]</code></p>
<p><code>\w</code> 匹配包括下划线的任何单词字符。等价于<code>[A-Za-z0-9_]</code></p>
<p><code>\W</code> 匹配任何非单词字符。等价于 <code>[^A-Za-z0-9_]</code></p>
<p><code>\s</code> 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[\f\n\r\t\v]</code></p>
<p><code>\S</code> 匹配任何非空白字符。等价于 <code>[^\f\n\r\t\v]</code></p>
<p><code>\</code> 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。<code>\\</code> 匹配 <code>\</code>，<code>\(</code> 则匹配 <code>(</code>。</p>
<p><code>.</code> 匹配除换行符 <code>\n</code> 之外的任何单字符。要匹配包括 ‘\n’ 在内的任何字符，可用<code>(.|\n)</code></p>
<p><code>|</code> 指明两项之间的一个选择。，优先级最低，| 的左右都是单独的整体</p>
<p><code>()</code> 优先级最高，标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。使用 $0…$9 属性。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code> 。每个()就是一个子匹配 ‘\1’和’$1’用来指定第一个子匹配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/f|boot/ <span class="comment">// 匹配 `f` 和 `boot`</span></span><br><span class="line"><span class="regexp">/(f|b)oot/</span> <span class="comment">// 匹配 `foot` 和 `boot`</span></span><br></pre></td></tr></table></figure>

<h4 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h4><ul>
<li><code>\f</code> 匹配一个换页符</li>
<li><code>\n</code> 匹配一个换行符</li>
<li><code>\r</code> 匹配一个回车符</li>
<li><code>\t</code> 匹配一个制表符</li>
<li><code>\v</code> 匹配一个垂直制表符</li>
</ul>
<h4 id="字符类的元字符"><a href="#字符类的元字符" class="headerlink" title="字符类的元字符"></a>字符类的元字符</h4><ul>
<li><code>[]</code> 在正则表达式中表示 <strong>单个</strong> 字符的位置，[] 里面写这个位置可以出现的字符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;<span class="regexp">/[abc]/</span> <span class="comment">// 匹配 a,b,c 任意一个字符</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>[^]</code> 在中扩号中的 <code>^</code> 表示非的意思</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ^ 在方括号表达式开头中使用，此时它表示不接受该字符集合</span></span><br><span class="line">;<span class="regexp">/[^abc]/</span> <span class="comment">// 匹配除了a, b, c以外的其他字符</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>[a-z]</code> <code>[1-9]</code>表示范围</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;<span class="regexp">/[a-z]/</span> <span class="comment">// 小写字母</span></span><br><span class="line">;<span class="regexp">/[A-Z]/</span> <span class="comment">// 大写字母</span></span><br><span class="line">;<span class="regexp">/[0-9]/</span> <span class="comment">// 数字</span></span><br><span class="line">;<span class="regexp">/[a-zA-Z0-9]/</span> <span class="comment">// 所有的小写字母和大写字母以及数字</span></span><br></pre></td></tr></table></figure>

<h4 id="边界类元字符"><a href="#边界类元字符" class="headerlink" title="边界类元字符"></a>边界类元字符</h4><blockquote>
<p>我们前面学习的正则只要有满足的条件的就会返回 true，并不能做到精确的匹配。</p>
</blockquote>
<ul>
<li><p><code>^</code> 匹配输入字符串的开始位置</p>
</li>
<li><p><code>$</code> 匹配输入字符串的结尾位置</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;<span class="regexp">/^chuan/</span> <span class="comment">// 以chuan开头</span></span><br><span class="line">;<span class="regexp">/chuan$/</span> <span class="comment">// 以chuan结尾</span></span><br><span class="line">;<span class="regexp">/^chuan$/</span> <span class="comment">// 精确匹配 chuan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 精确匹配chuan,表示必须是这个</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^chuan$/</span>.test(<span class="string">&#x27;chuanchuan&#x27;</span>)) <span class="comment">// fasle</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以后表单校验要精确匹配</p>
</blockquote>
<ul>
<li><code>\b</code> 匹配一个字边界，即字与空格间的位置。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。<br><code>/\bCha/</code> : 匹配 Chapter 的开头三个字符<br><code>/ter\b/</code> : 匹配 Chapter 的结尾三个字符</li>
<li><code>\B</code> 表示非单词边界。位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。<br><code>/\Bapt/</code> 表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt</li>
</ul>
<h4 id="量词类元字符"><a href="#量词类元字符" class="headerlink" title="量词类元字符"></a>量词类元字符</h4><blockquote>
<p>量词用来控制出现的次数，一般来说量词和边界会一起使用</p>
</blockquote>
<ul>
<li><code>*</code> 匹配前面的子表达式零次或多次，等价于 <code>&#123;0,&#125;</code></li>
<li><code>+</code> 匹配前面的子表达式一次或多次，等价于 <code>&#123;1,&#125;</code></li>
<li><code>?</code> 匹配前面的子表达式零次或一次，等价于 <code>&#123;0,1&#125;</code> 。当该字符紧跟在任何一个其他限制符 (<code>*</code>, <code>+</code>,<code>?</code>, <code>&#123;n&#125;</code>, <code>&#123;n,&#125;</code>, <code>&#123;n,m&#125;)</code> 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串</li>
<li><code>&#123;n&#125;</code> n 是一个非负整数。匹配确定的 <code>n</code> 次</li>
<li><code>&#123;n,&#125;</code> n 是一个非负整数。至少匹配 <code>n</code> 次</li>
<li><code>&#123;n,m&#125;</code> <code>m</code> 和 <code>n</code> 均为非负整数，其中<code>n</code> &lt;= <code>m</code>。最少匹配 <code>n</code> 次且最多匹配 <code>m</code> 次</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&#125; 就近修饰单个字符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/chuan&#123;2&#125;/</span>.test(<span class="string">&#x27;chuanchuan&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/(chuan)&#123;2&#125;/</span>.test(<span class="string">&#x27;chuanchuan&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/chuan&#123;2&#125;/</span>.test(<span class="string">&#x27;chuann&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h4><ul>
<li><code>g</code> 全局标记，指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配</li>
<li><code>i</code> 标记指定不区分大小写。表达式的结尾处</li>
<li><code>m</code> 表明可以进行多行匹配，但是这个只有当使用^和$模式时才会起作用，在其他的模式中，加不加入 m 都可以进行多行匹配</li>
</ul>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>从高到低的优先级顺序：</p>
<ol>
<li><strong><code>\</code></strong> 转义符</li>
<li><strong><code>()</code></strong>, <strong><code>(?:)</code></strong> , <strong><code>(?=)</code></strong>, <strong><code>[]</code></strong> 圆括号和方括号</li>
<li><strong><code>*</code></strong>, <strong><code>+</code></strong> , <strong><code>?</code></strong>, <strong><code>&#123;n&#125;</code></strong>, <strong><code>&#123;n,&#125;</code></strong>, <strong><code>&#123;n,m&#125;</code></strong> 限定符</li>
<li><strong><code>^</code></strong>, <strong><code>$</code></strong>, <strong><code>\任何元字符、任何字符</code></strong> 定位点和序列（即：位置和顺序）</li>
<li><strong><code>|</code></strong> 替换，”或”操作</li>
</ol>
<blockquote>
<p>字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</p>
</blockquote>
<h3 id="正则的使用"><a href="#正则的使用" class="headerlink" title="正则的使用"></a>正则的使用</h3><h4 id="字符串使用正则"><a href="#字符串使用正则" class="headerlink" title="字符串使用正则"></a>字符串使用正则</h4><ul>
<li><code>replace()</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;   123AD  asadf   asadfasf  adf  &#x27;</span></span><br><span class="line"><span class="comment">// 1. 替换掉字符串中的所有空白</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// g: global, 全局搜索</span></span><br><span class="line"><span class="comment">// 2. 将所有的ad替换成xx</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/ad/g</span>, <span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line"><span class="comment">// 3. 将所有的ad/AD替换成xx</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/ad/gi</span>, <span class="string">&#x27;xx&#x27;</span>) <span class="comment">// i： ignore 忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc,efg,123,abc,123,a&#x27;</span></span><br><span class="line"><span class="comment">// 4. 所有的逗号替换成句号</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/,/g</span>, <span class="string">&#x27;。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">&#x27;[&#123;&quot;name&quot;:&quot;张三&quot;,score:80&#125;,&#123;&quot;name&quot;:&quot;张三&quot;,score:90&#125;,&#123;&quot;name&quot;:&quot;张三&quot;,score:81&#125;]&#x27;</span></span><br><span class="line"><span class="comment">// 5. 把所有成绩都修改成100分</span></span><br><span class="line"><span class="keyword">var</span> str2 = jsonStr.replace(<span class="regexp">/\d&#123;1,2&#125;/g</span>, <span class="string">&#x27;100&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>match()</code> ==&gt; 匹配， 匹配符合正则表达式的字符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;zs的手机号是18938383838, ls的手机号13989907890， ww的手机号是13848962389，zl的手机号是18970890908&#x27;</span></span><br><span class="line"><span class="comment">// 需求： 匹配出来所有的手机号, 返回一个数组</span></span><br><span class="line"><span class="keyword">var</span> str3 = str2.match(<span class="regexp">/1[3-9]\d&#123;9&#125;/g</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str3)</span><br></pre></td></tr></table></figure>

<h4 id="正则的方法"><a href="#正则的方法" class="headerlink" title="正则的方法"></a>正则的方法</h4><ul>
<li><p>test() ==&gt; 测试字符串是否符合正则表达式的规律，符合，就返回 true</p>
</li>
<li><p>exec() ==&gt; 提取，提取字符串中符合正则表达式的字符，需要用括号分组， 如果没有进行分组，返回的是符合整个正则表达式的字符</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;今天是2018-10-16，我这里的需求是提取出年月日&#x27;</span></span><br><span class="line"><span class="comment">// var reg = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/;  ==&gt;  符合整个正则表达式的字符</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span> <span class="comment">// ==&gt; 有分组存在 ，默认组名为 undefined</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span> <span class="comment">// ?&lt;组名&gt; 添加组名</span></span><br><span class="line"><span class="keyword">var</span> ret = reg.exec(str) <span class="comment">// 提取出分组的内容以下标的形式存在返回的数组里面</span></span><br><span class="line"><span class="keyword">var</span> ret2 = reg2.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(ret)</span><br><span class="line"><span class="built_in">console</span>.log(ret2)</span><br><span class="line"><span class="comment">// index 代表 匹配到 ret 在 str 中的下标</span></span><br></pre></td></tr></table></figure>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul>
<li><code>[xyz]</code> 字符集合。匹配所包含的任意一个字符。例如， <code>[abc]</code> 可以匹配 “plain” 中的 ‘a’</li>
<li><code>[^xyz]</code> 负值字符集合。匹配未包含的任意字符。例如， <code>[^abc]</code> 可以匹配 “plain” 中的’p’、’l’、’i’、’n’</li>
<li><code>[a-z]</code> 匹配所有小写字母</li>
<li><code>[-a-z]</code> 或 <code>[a-z-]</code> 匹配所有小写字母和 <code>-</code></li>
<li><code>[A-Za-z0-9]</code> 匹配任何大写字母小写字母和数字</li>
<li><code>\b([a-z]+)\1\b/gi</code> 一个单词连续出现的位置</li>
<li>将通用资源指示符 (URI) 分解为其组件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;https://www.baidu.com:80/index.html&#x27;</span></span><br><span class="line"><span class="keyword">var</span> patt1 = <span class="regexp">/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/</span></span><br><span class="line">arr = str.match(patt1)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(arr[i])</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// https://www.baidu.com:80/index.html</span></span><br><span class="line"><span class="comment">// https</span></span><br><span class="line"><span class="comment">// www.baidu.com</span></span><br><span class="line"><span class="comment">// :80</span></span><br><span class="line"><span class="comment">// /index.html</span></span><br></pre></td></tr></table></figure>

<h4 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h4><p><strong><code>后向引用</code></strong> 正则表达式一个最重要的特性就是将匹配成功的模式的某部分进行存储供以后使用这一能力</p>
<p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <code>\n</code> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p>
<p>可以使用非捕获元字符 <code>?:</code>、<code>?=</code> 或 <code>?!</code> 来忽略对这部分正则表达式的保存</p>
<p><code>?:</code> 非获取匹配。匹配但不获取匹配结果，不存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， <code>industr(?:y|ies)</code> 就是一个比 <code>industry|industries</code> 更简略的表达式</p>
<p><code>?=</code> 正向预查。在任何匹配的字符串开始处匹配查找字符串。非获取匹配，不获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</p>
<p><code>?!</code> 负向预查，在任何不匹配的字符串开始处匹配查找字符串。非获取匹配，不获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</p>
<p>后向引用一个最简单，最有用的应用是提供了确定文字中连续出现两个相同单词的位置的能力。请看下面的句子： Is is the cost of of gasoline going up up? 根据所写内容，上面的句子明显存在单词多次重复的问题。如果能有一种方法无需查找每个单词的重复现象就能修改该句子就好了。下面的 JScript 正则表达式使用一个子表达式就可以实现这一功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ss = <span class="string">&#x27;Is is the cost of of gasoline going up up?&#x27;</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\b([a-z]+) \1\b/gim</span></span><br><span class="line"><span class="keyword">var</span> rv = ss.replace(re, <span class="string">&#x27;$1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，子表达式就是圆括号之间的每一项。所捕获的表达式包括一个或多个字母字符，即由<code>[a-z]+</code>所指定的。该正则表达式的第二部分是对前面所捕获的子匹配的引用，也就是由附加表达式所匹配的第二次出现的单词。<code>\1</code>用来指定第一个子匹配。单词边界元字符确保只检测单独的单词。如果不这样，则诸如 “is issued” 或 “this is” 这样的短语都会被该表达式不正确地识别。</p>
<h4 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h4><p>校验数字的表达式</p>
<ul>
<li>n 位的数字：<code>^\d&#123;n&#125;$</code></li>
<li>至少 n 位的数字：<code>^\d&#123;n,&#125;$</code></li>
<li>m-n 位的数字：<code>^\d&#123;m,n&#125;$</code></li>
<li>零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code></li>
<li>非零开头的最多带两位小数的数字：<code>^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</code></li>
<li>带 1-2 位小数的正数或负数：<code>^(\-)?\d+(\.\d&#123;1,2&#125;)$</code></li>
<li>正数、负数、和小数：<code>^(\-|\+)?\d+(\.\d+)?$</code></li>
<li>有两位小数的正实数：<code>^[0-9]+(\.[0-9]&#123;2&#125;)?$</code></li>
<li>非零的正整数：<code>^[1-9]\d*$</code></li>
<li>非零的负整数：<code>^-[1-9]\d*$</code></li>
<li>非负整数：<code>^\d+$</code></li>
<li>非正整数：<code>^-[1-9]\d*|0$</code></li>
</ul>
<p>校验字符的表达式</p>
<ul>
<li>汉字：<code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code></li>
<li>英文和数字：<code>^[A-Za-z0-9]+$</code></li>
<li>长度为 3-20 的所有字符：<code>^\.&#123;3,20&#125;$</code></li>
<li>由 26 个英文字母组成的字符串：<code>^[A-Za-z]+$</code></li>
<li>由 26 个大写英文字母组成的字符串：<code>^[A-Z]+$</code></li>
<li>由 26 个小写英文字母组成的字符串：<code>^[a-z]+$</code></li>
<li>由数字和 26 个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code></li>
<li>由数字、26 个英文字母或者下划线组成的字符串：<code>^\w+$</code></li>
<li>中文、英文、数字包括下划线：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></li>
<li>中文、英文、数字但不包括下划线等符号：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code></li>
</ul>
<p>特殊需求表达式(待验证)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line">域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span><br><span class="line">InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span><br><span class="line">手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</span><br><span class="line">电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</span><br><span class="line">国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span><br><span class="line">电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\d&#123;11&#125;)|^((\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;)|(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;))$)</span><br><span class="line">身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)</span><br><span class="line">帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br><span class="line">密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$</span><br><span class="line">强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</span><br><span class="line">日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span><br><span class="line">一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</span><br><span class="line">一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</span><br><span class="line">钱的输入格式：</span><br><span class="line">有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$</span><br><span class="line">这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$</span><br><span class="line">一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$</span><br><span class="line">这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</span><br><span class="line">必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br><span class="line">这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span><br><span class="line">xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</span><br><span class="line">中文字符的正则表达式：[\u4e00-\u9fa5]</span><br><span class="line">双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</span><br><span class="line">空白行的正则表达式：\n\s*\r (可以用来删除空白行)</span><br><span class="line">HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="line">腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)</span><br><span class="line">中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)</span><br><span class="line">IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/414.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/414.html" class="post-title-link" itemprop="url">jquery 中 AJAX 的全局事件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-10-16" itemprop="dateCreated datePublished" datetime="2018-10-16T22:24:10+00:00">2018-10-16</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="jquery-中-AJAX-的全局事件"><a href="#jquery-中-AJAX-的全局事件" class="headerlink" title="jquery 中 AJAX 的全局事件"></a>jquery 中 AJAX 的全局事件</h2><blockquote>
<p>ajax 提供了 6 个全局函数，会被页面中所有的 ajax 请求触发，在不同时间点会触发不同的全局事件。</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9jYXRlZ29yeS9hamF4L2dsb2JhbC1hamF4LWV2ZW50LWhhbmRsZXJzLw==">https://api.jquery.com/category/ajax/global-ajax-event-handlers/</span></p>
<p>在页面中会有很多的 ajax 请求，但是这些 ajax 请求都有相同的消息机制，比如我们需要在 ajax 请求发送之前弹出了一个提示框，提示”正在读取数据….” 在 ajax 请求成功时显示”获取数据成功…”,在 ajax 结束后隐藏提示框。如果不使用全局事件，那么需要在每一个 ajax 的 beforeSend、success、complete 回调函数中都加上相同的代码。</p>
<ul>
<li>jquery 的全局事件需要给 <code>document</code> 注册（固定写法）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ajaxStart(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>全局事件的执行时机</li>
</ul>
<ol>
<li><code>ajaxStart</code>： 在第一个 ajax 请求开始时触发 first start</li>
<li><code>ajaxSend</code>： 在一个 ajax 请求开始之前触发（在 beforeSend 回调函数之后）one start</li>
<li><code>ajaxSuccess</code>： 在一个 ajax 请求成功之后触发（在 success 回调函数之后触发）one success</li>
<li><code>ajaxComplete</code>： 在一个 ajax 请求完成时触发（在 complete 回调函数之后触发） one complete</li>
<li><code>ajaxError</code>： 在一个 ajax 请求失败时触发（在 error 回调函数之后触发）</li>
<li><code>ajaxStop</code>： 在所有的 ajax 请求完成之后触发 all complete</li>
</ol>
<p>若<code>$.ajax()</code> global 参数设置为 false，则 ajax 全局事件不会被触发，global 参数默认为 true</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/413.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/413.html" class="post-title-link" itemprop="url">jquery-fileupload 插件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-10-16" itemprop="dateCreated datePublished" datetime="2018-10-16T22:23:33+00:00">2018-10-16</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>github 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvalF1ZXJ5LUZpbGUtVXBsb2Fk">https://github.com/blueimp/jQuery-File-Upload</span></p>
<p>中文文档：<span class="exturl" data-url="aHR0cDovL3d3dy5qcTIyLmNvbS9qcXVlcnktaW5mbzIzMA==">http://www.jq22.com/jquery-info230</span></p>
<h2 id="引包"><a href="#引包" class="headerlink" title="引包"></a>引包</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jquery-fileupload依赖与jquery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jquery ui小部件，上传插件依赖了jquery ui的小部件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vendor/jquery.ui.widget.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果上传图片需要跨域，那么需要引入这个js文件，如果不跨域，则不需要引入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.iframe-transport.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jquery上传插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.fileupload.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="html-结构"><a href="#html-结构" class="headerlink" title="html 结构"></a>html 结构</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- name指定图片上传时的name属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- data-url指定图片上传时的接口地址 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- multiple指定多文件上传 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;fileupload&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span> <span class="attr">data-url</span>=<span class="string">&quot;server/php/&quot;</span> <span class="attr">multiple</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>multiple 上传多文件（实质上是发送多次单文件异步上传请求）</p>
<h2 id="js-代码"><a href="#js-代码" class="headerlink" title="js 代码"></a>js 代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#fileupload&#x27;</span>).fileupload(&#123;</span><br><span class="line">  <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">  <span class="comment">// e：事件对象</span></span><br><span class="line">  <span class="comment">// data：图片上传后的对象，通过data.result.picAddr 可以获取上传后的图片地址</span></span><br><span class="line">  <span class="attr">done</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/1661.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1661.html" class="post-title-link" itemprop="url">jquery</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-10-16" itemprop="dateCreated datePublished" datetime="2018-10-16T14:40:19+00:00">2018-10-16</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="jQuery-基本介绍"><a href="#jQuery-基本介绍" class="headerlink" title="jQuery 基本介绍"></a>jQuery 基本介绍</h2><h3 id="为什么要学-jQuery"><a href="#为什么要学-jQuery" class="headerlink" title="为什么要学 jQuery"></a>为什么要学 jQuery</h3><p>使用 JS 操作 DOM 的时候，会遇到以下的一些缺点：</p>
<ul>
<li>获取元素的方法太少且长，麻烦</li>
<li>遍历伪数组很麻烦，通常要嵌套一大堆的 for 循环。注册的事件会覆盖</li>
<li>有兼容性问题</li>
<li>实现动画很麻烦</li>
</ul>
<h3 id="jQuery-初体验"><a href="#jQuery-初体验" class="headerlink" title="jQuery 初体验"></a>jQuery 初体验</h3><p>【让 div 显示与设置内容】</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">&#x27;#btn1&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。</span></span><br><span class="line">    <span class="comment">// show() 显示元素</span></span><br><span class="line">    $(<span class="string">&#x27;div&#x27;</span>).show(<span class="number">200</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  $(<span class="string">&#x27;#btn2&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// text() 设置文本内容</span></span><br><span class="line">    $(<span class="string">&#x27;div&#x27;</span>).text(<span class="string">&#x27;我是内容&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  $(<span class="string">&#x27;#btn3&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// css(name, value);  设置样式</span></span><br><span class="line">    <span class="comment">// name: 设置什么样式</span></span><br><span class="line">    <span class="comment">// value ： 设置的值是多少</span></span><br><span class="line">    $(<span class="string">&#x27;div&#x27;</span>).css(<span class="string">&#x27;fontSize&#x27;</span>, <span class="number">30</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>使用 jQuery 的优点</strong></p>
<ul>
<li>获取元素的方式非常的简单，而且非常的丰富</li>
<li>jQuery 的隐式迭代特性，不再需要书写 for 循环语句</li>
<li>使用 jQuery 完全不用考虑兼容性问题</li>
<li>jQuery 提供了一系列动画相关的函数，使用非常方便</li>
<li>代码简单、粗暴</li>
</ul>
<p><strong>什么是 jQuery</strong></p>
<blockquote>
<p>jQuery 是一个快速的、轻量的、功能丰富的 js 库</p>
</blockquote>
<p>jQuery 的官网 <span class="exturl" data-url="aHR0cDovL2pxdWVyeS5jb20v">http://jquery.com/</span></p>
<p>js 库：把一些常用到的方法写到一个单独的 js 文件，使用的时候直接去引用这 js 文件就可以了。（animate.js、common.js）</p>
<h3 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h3><p>官网下载地址：<span class="exturl" data-url="aHR0cDovL2pxdWVyeS5jb20vZG93bmxvYWQv">http://jquery.com/download/</span></p>
<p>jQuery 版本有很多，分为 1.x 2.x 3.x</p>
<p>大版本分类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.x 版本：能够兼容IE678浏览器（最终版本1.12.4）</span><br><span class="line">2.x 版本：不兼容IE678浏览器（最终版本2.2.4）</span><br><span class="line">3.x 版本：不兼容IE678，更加的精简（在国内不流行，因为国内使用 jQuery 的主要目的就是兼容IE678）,3.x 版本只是在原来的基础上增加了一些新的特性</span><br></pre></td></tr></table></figure>

<p>关于压缩版和未压缩版</p>
<ul>
<li><code>jquery.min.js</code>：压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，采用了代码混淆，基本没有可阅读性</li>
<li><code>jquery.js</code>：未压缩版本，适用于学习与开发环境，源码清晰，易阅读</li>
</ul>
<h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><p>入口函数的好处：</p>
<ul>
<li>等待文档加载完成，不论代码是写在 body、head 中都可以正常去获取到元素</li>
<li>形成了一个沙箱，防止全局变量污染</li>
</ul>
<p>两种写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>原生 JavaScript 的入口函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>jQuery 入口函数与 js 入口函数的对比</p>
<ul>
<li>JavaScript 的入口函数要等到页面中所有资源（包括图片、文件等外部资源）加载完成才开始执行。jQuery 的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。所以 jQuery 的入口函数要比 js 入口函数先执行</li>
<li>window.onload 存在覆盖问题；jq 的入口函数不存在覆盖问题</li>
</ul>
<h3 id="jQuery-使用步骤"><a href="#jQuery-使用步骤" class="headerlink" title="jQuery 使用步骤"></a>jQuery 使用步骤</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引包（引入js文件） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 写上入口函数</span></span></span><br><span class="line"><span class="javascript">  $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 或者</span></span></span><br><span class="line"><span class="javascript">  $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在入口函数内部实现功能</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="jquery-中的-符号"><a href="#jquery-中的-符号" class="headerlink" title="jquery 中的 $ 符号"></a>jquery 中的 <code>$</code> 符号</h3><p><code>$</code> 来源于 jQuery ， 是个函数（查看 jQuery 源码中最后几行代码）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jquery 和 $ 是等价的</span></span><br><span class="line">jQuery === $ <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：根据参数的不同， 作用是不同的</p>
<ul>
<li><p>参数是个函数 <code>$(function()&#123;&#125;)</code> 作用是入口函数</p>
</li>
<li><p>参数是个 dom 对象 <code>$(document)</code> 作用是 dom 转 jq</p>
</li>
<li><p>参数是选择器 <code>$(&#39;body&#39;)</code> 作用是获取元素</p>
</li>
<li><p>参数是个 html 字符串 <code>$(&#39;&lt;a&gt;123&lt;/a&gt;&#39;)</code> 作用是创建节点</p>
</li>
</ul>
<h3 id="jQuery-对象与-DOM-对象"><a href="#jQuery-对象与-DOM-对象" class="headerlink" title="jQuery 对象与 DOM 对象"></a>jQuery 对象与 DOM 对象</h3><p><strong>基本概念：</strong></p>
<ol>
<li><code>DOM 对象</code>：使用 JavaScript 中的方法获取页面中的元素返回的对象就是 Dom 对象</li>
<li><code>jQuery 对象</code>：jquery 对象就是使用 jquery 的方法获取页面中的元素返回的对象</li>
<li>jQuery 对象其实就是 DOM 对象的包装集（包装了 DOM 对象的集合），是一个 <strong>伪数组</strong></li>
</ol>
<p><strong>jQuery 对象与 DOM 对象的区别：</strong></p>
<ol>
<li>DOM 对象与 jQuery 对象的方法不能混用。dom 对象不能使用 jq 对象的方法，jq 对象也不能使用 dom 对象的属性和方法</li>
<li>DOM 对象可以和 jQuery 对象可以相互转化</li>
</ol>
<ul>
<li>DOM 对象转换成 jQuery 对象：【联想记忆：花钱】</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 dom 对象作为参数传递到 $() 里面去， 那么这个整体就是个jq对象</span></span><br><span class="line"><span class="keyword">var</span> $obj = $(domObj)</span><br></pre></td></tr></table></figure>

<ul>
<li>jQuery 对象转换成 DOM 对象：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 $()  来获取到的元素返回的对象就是jq对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $li = $(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"><span class="comment">// 第一种方法,通过下标取出（推荐使用）</span></span><br><span class="line">$li[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line">$li.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>【练习：隔行变色案例】</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h3><p>jQuery 选择器是 jQuery 为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery 选择器返回的是 jQuery 对象</p>
<p>jQuery 选择器有很多，基本兼容了 CSS1 到 CSS3 所有的选择器，并且 jQuery 还添加了很多更加复杂的选择器</p>
<h3 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h3><p>jQuery 完全兼容 css 选择器</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>ID 选择器</td>
<td><code>$(&#39;#id&#39;)</code></td>
<td align="left">获取指定 id 的元素</td>
</tr>
<tr>
<td>类选择器</td>
<td><code>$(&#39;.class&#39;)</code></td>
<td align="left">获取同一类 class 的元素</td>
</tr>
<tr>
<td>标签选择器</td>
<td><code>$(&#39;div&#39;)</code></td>
<td align="left">获取同一类标签的所有元素</td>
</tr>
<tr>
<td>并集选择器</td>
<td><code>$(&#39;div, p, li&#39;)</code></td>
<td align="left">使用逗号分隔，只要符合条件之一就可</td>
</tr>
<tr>
<td>交集选择器</td>
<td><code>$(&#39;div.redClass&#39;)</code></td>
<td align="left">获取 class 为 redClass 的 div 元素</td>
</tr>
<tr>
<td>子代选择器</td>
<td><code>$(&#39;ul&gt;li&#39;)</code></td>
<td align="left">使用 &gt; 号，获取儿子层级的元素，注意，并不会获取孙子层级的元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td><code>$(&#39;ul li&#39;)</code></td>
<td align="left">使用空格，代表后代选择器，获取 ul 下的所有 li 元素，包括孙子等</td>
</tr>
</tbody></table>
<h3 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h3><p>这类选择器都带冒号 <code>:</code></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>:eq(index)</code></td>
<td><code>$(&#39;li:eq(2)&#39;)</code></td>
<td align="left">获取 li 元素中，选择索引号为 2 的元素，索引号 index 从 0 开始</td>
</tr>
<tr>
<td><code>:odd</code></td>
<td><code>$(&#39;li:odd&#39;)</code></td>
<td align="left">获取 li 元素中，选择索引号为奇数的元素</td>
</tr>
<tr>
<td><code>:even</code></td>
<td><code>$(&#39;li:even&#39;)</code></td>
<td align="left">获取 li 元素中，选择索引号为偶数的元素</td>
</tr>
<tr>
<td><code>:first</code></td>
<td><code>$(&#39;li:first&#39;)</code></td>
<td align="left">获取 li 元素中的第一个</td>
</tr>
<tr>
<td><code>:last</code></td>
<td><code>$(&#39;li:last&#39;)</code></td>
<td align="left">获取 li 元素中的最后一个</td>
</tr>
</tbody></table>
<p>【案例：隔行变色】</p>
<h3 id="筛选选择器-方法"><a href="#筛选选择器-方法" class="headerlink" title="筛选选择器(方法)"></a>筛选选择器(方法)</h3><p>筛选选择器的功能与过滤选择器有点类似，但是用法不一样，<code>筛选选择器</code> 主要是方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>children(selector)</code></td>
<td><code>$(&#39;ul&#39;).children(&#39;li&#39;)</code></td>
<td align="left">获取当前元素的所有子元素中的 li 元素</td>
</tr>
<tr>
<td><code>find(selector)</code></td>
<td><code>$(&#39;ul&#39;).find(&#39;li&#39;)</code></td>
<td align="left">获取当前元素中的后代元素中的 li 元素</td>
</tr>
<tr>
<td><code>siblings(selector)</code></td>
<td><code>$(&#39;#first&#39;).siblings(&#39;li&#39;)</code></td>
<td align="left">查找兄弟节点，不包括自己本身</td>
</tr>
<tr>
<td><code>parent()</code></td>
<td><code>$(&#39;#first&#39;).parent()</code></td>
<td align="left">查找父亲</td>
</tr>
<tr>
<td><code>parents()</code></td>
<td><code>$(&#39;#first&#39;).parents(&#39;&#39;)</code></td>
<td align="left">查找所有祖宗（参数 指定具体祖宗）</td>
</tr>
<tr>
<td><code>eq(index)</code></td>
<td><code>$(&#39;li&#39;).eq(2)</code></td>
<td align="left">相当于<code>$(&#39;li:eq(2)&#39;)</code>，index 从 0 开始</td>
</tr>
<tr>
<td><code>next()</code></td>
<td><code>$(&#39;li&#39;).next()</code></td>
<td align="left">找下一个兄弟</td>
</tr>
<tr>
<td><code>nextAll()</code></td>
<td><code>$(&#39;li&#39;).nextAll()</code></td>
<td align="left">找后面所有的兄弟</td>
</tr>
<tr>
<td><code>prev()</code></td>
<td><code>$(&#39;li&#39;).prev()</code></td>
<td align="left">找上一个兄弟</td>
</tr>
<tr>
<td><code>prevAll()</code></td>
<td><code>$(&#39;li&#39;).prevAll()</code></td>
<td align="left">找前面所有的兄弟</td>
</tr>
</tbody></table>
<p>【案例：下拉菜单】<br>【案例：突出展示】<br>【案例：手风琴】<br>【案例：淘宝精品】</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="mouseover-与-mouseenter"><a href="#mouseover-与-mouseenter" class="headerlink" title="mouseover 与 mouseenter"></a><code>mouseover</code> 与 <code>mouseenter</code></h4><ul>
<li>mouseover 和 mouseoverenter 都有鼠标经过的意思，但是在注册鼠标经过事件的时候，推荐使用<code>mouseenter</code></li>
</ul>
<p><span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vdGl5L3QuYXNwP2Y9anF1ZXJ5X2V2ZW50X21vdXNlZW50ZXJfbW91c2VvdmVy">mouseenter 与 mouseover 的不同</span></p>
<ul>
<li><p>mouseover 与 mouseout 是一对事件，当鼠标经过当前元素或者当前元素的子元素的时候，会触发【事件冒泡】。</p>
</li>
<li><p>mouseenter 与 mouseleave 是一对事件，只有当鼠标经过当前元素时，事件会触发，鼠标经过子元素，mousenter 事件是不会触发的</p>
</li>
</ul>
<h4 id="index-方法"><a href="#index-方法" class="headerlink" title="index 方法"></a>index 方法</h4><p><code>index()</code> 方法返回的是当前元素在所有兄弟元素里面的索引</p>
<h4 id="区分-jQuery-与-Javascript"><a href="#区分-jQuery-与-Javascript" class="headerlink" title="区分 jQuery 与 Javascript"></a>区分 jQuery 与 Javascript</h4><p>JavaScript 是一门编程语言，jQuery 仅仅是用 JavaScript 实现的一个 JavaScript 库，目的是简化我们的开发</p>
<h2 id="jQuery-样式操作"><a href="#jQuery-样式操作" class="headerlink" title="jQuery 样式操作"></a>jQuery 样式操作</h2><h3 id="css-操作"><a href="#css-操作" class="headerlink" title="css 操作"></a>css 操作</h3><p>功能：设置或者修改样式，操作的是 style 属性</p>
<p>设置单个样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name：需要设置的样式名称</span></span><br><span class="line"><span class="comment">// value：对应的样式值</span></span><br><span class="line">css(name, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用案例</span></span><br><span class="line">$(<span class="string">&#x27;#one&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;gray&#x27;</span>) <span class="comment">// 将背景色修改为灰色</span></span><br></pre></td></tr></table></figure>

<p>设置多个样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一个对象，对象中包含了需要设置的样式名和样式值</span></span><br><span class="line">css(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用案例</span></span><br><span class="line">$(<span class="string">&#x27;#one&#x27;</span>).css(&#123;</span><br><span class="line">  <span class="attr">background</span>: <span class="string">&#x27;gray&#x27;</span>,</span><br><span class="line">  <span class="attr">width</span>: <span class="string">&#x27;400px&#x27;</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>获取样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name: 需要获取的样式名称</span></span><br><span class="line">css(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).css(<span class="string">&#x27;background-color&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值</li>
<li>获取操作的时候，如果是多个元素，那么只会返回第一个元素的值</li>
</ul>
<h3 id="class-操作"><a href="#class-操作" class="headerlink" title="class 操作"></a>class 操作</h3><ul>
<li>添加样式类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给所有的 div 添加 one 的样式</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).addClass(<span class="string">&#x27;one&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>移除样式类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除 div 中 one 类名</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).removeClass(<span class="string">&#x27;one&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否有某个样式类</li>
</ul>
<p>判断标准是： 只要有一个元素有指定的类名，就返回 true，所有的元素都没有该类名，就返回 false</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否有 one 的样式类</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).hasClass(<span class="string">&#x27;one&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>切换样式类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果有，移除该类，如果没有，添加该类</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).toggleClass(<span class="string">&#x27;one&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>【案例：tab 栏切换案例.html】</p>
<h2 id="jQuery-属性操作"><a href="#jQuery-属性操作" class="headerlink" title="jQuery 属性操作"></a>jQuery 属性操作</h2><h3 id="attr-操作"><a href="#attr-操作" class="headerlink" title="attr 操作"></a>attr 操作</h3><p>设置单个属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：需要设置的属性名</span></span><br><span class="line"><span class="comment">// 第二个参数：对应的属性值</span></span><br><span class="line">attr(name, value)</span><br><span class="line"><span class="comment">// 用法举例</span></span><br><span class="line">$(<span class="string">&#x27;img&#x27;</span>).attr(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;哈哈&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>设置多个属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一个对象，包含了需要设置的属性名和属性值</span></span><br><span class="line">$(<span class="string">&#x27;img&#x27;</span>).attr(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">alt</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">style</span>: <span class="string">&#x27;opacity: .5&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>获取属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传需要获取的属性名称，返回对应的属性值</span></span><br><span class="line"><span class="keyword">var</span> oTitle = $(<span class="string">&#x27;img&#x27;</span>).attr(<span class="string">&#x27;title&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>移除属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：需要移除的属性名</span></span><br><span class="line">$(<span class="string">&#x27;img&#x27;</span>).removeAttr(<span class="string">&#x27;title&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>【案例：美女相册.html】</p>
<h3 id="prop-操作"><a href="#prop-操作" class="headerlink" title="prop 操作"></a>prop 操作</h3><p>在 jQuery1.6 之后，对于 checked、selected、disabled 这类 boolean 类型的属性来说，不能用 attr 方法，只能用 prop 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line">$(<span class="string">&#x27;input:checked&#x27;</span>).prop(<span class="string">&#x27;checked&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">$(<span class="string">&#x27;input:checked&#x27;</span>).prop(<span class="string">&#x27;checked&#x27;</span>) <span class="comment">// 返回 true 或者 false</span></span><br></pre></td></tr></table></figure>

<p>【案例：表格全选案例.html】</p>
<h2 id="jQuery-动画"><a href="#jQuery-动画" class="headerlink" title="jQuery 动画"></a>jQuery 动画</h2><p>jquery 提供了三组基本动画，这些动画都是标准的、有规律的效果，jquery 还提供了自定义动画的功能</p>
<h3 id="三组基本动画"><a href="#三组基本动画" class="headerlink" title="三组基本动画"></a>三组基本动画</h3><ul>
<li>显示 (show) 与隐藏 (hide) 与切换 (slideToggle)</li>
<li>上滑 (slideUp) 与下滑 (slideDown) 与切换 (slideToggle)，效果与卷帘门类似</li>
<li>淡入 (fadeIn) 与淡出 (fadeOut) 与切换 (fadeToggle)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// show() 系列</span></span><br><span class="line">show([speed], [easing], [callback])</span><br><span class="line"><span class="comment">// speed(可选)：动画的执行时间</span></span><br><span class="line"><span class="comment">// 1.如果不传，就没有动画效果。如果是 slide 和 fade 系列，会默认为 normal</span></span><br><span class="line"><span class="comment">// 2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐)</span></span><br><span class="line"><span class="comment">// 3.固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal</span></span><br><span class="line"><span class="comment">// easing(可选)：动画效果，默认是 swing，秋千，提供了一个 linear 匀速的效果</span></span><br><span class="line"><span class="comment">// callback(可选)：执行完动画后执行的回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slide 系列，参数使用和show 是一样的，不传参数，默认有动画效果</span></span><br><span class="line">slideDown([speed], [easing], [callback])</span><br><span class="line"></span><br><span class="line"><span class="comment">// fade 系列，参数使用和 show 是一样的，不传参数，默认有动画效果</span></span><br><span class="line">fadeIn([speed], [easing], [callback])</span><br></pre></td></tr></table></figure>

<p>【案例：下拉菜单动画版.html】<br>【案例：京东轮播图(呼吸灯).html】</p>
<h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><p>animate：自定义动画（只支持数值型的动画）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(selector).animate(&#123; params &#125;, [speed], [easing], [callback])</span><br><span class="line"><span class="comment">// &#123;params&#125;：要执行动画的 CSS 属性，带数字（必选），多个属性会同时执行</span></span><br><span class="line"><span class="comment">// speed：执行动画时长（可选）</span></span><br><span class="line"><span class="comment">// easing: 执行效果，默认为swing（缓动）  linear（匀速）</span></span><br><span class="line"><span class="comment">// callback：动画执行完后立即执行的回调函数（可选）</span></span><br></pre></td></tr></table></figure>

<h3 id="动画队列与停止动画"><a href="#动画队列与停止动画" class="headerlink" title="动画队列与停止动画"></a>动画队列与停止动画</h3><p>在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有顺序的执行效果</span></span><br><span class="line"><span class="comment">// 动画队列：</span></span><br><span class="line"><span class="comment">// 像链式编程一样，通过 . 继续写动画，给元素添加了多个动画, 这多个动画会添加到元素的动画队列里面，按照顺序依次执行</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    .animate(&#123; <span class="attr">left</span>: <span class="number">800</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">    .animate(&#123; <span class="attr">top</span>: <span class="number">300</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">    .animate(&#123; <span class="attr">borderRadius</span>: <span class="number">50</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">    .slideUp(<span class="number">2000</span>)</span><br><span class="line">    .slideDown(<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 好处：可以有顺序的执行动画效果</span></span><br><span class="line"><span class="comment">// 坏处：bug 给元素不停的添加动画，元素就不停的运动</span></span><br></pre></td></tr></table></figure>

<ul>
<li>stop 方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 停止当前正在执行的动画，如果元素的动画队列里面有后续动画，后续动画会执行</span></span><br><span class="line">stop(clearQueue, jumpToEnd)</span><br><span class="line"><span class="comment">// 第一个参数：可选，是否清除队列，true，表示清除掉，默认 false</span></span><br><span class="line"><span class="comment">// 第二个参数：可选，是否跳转到当前正在执行的动画的最终效果，true，表示跳转， 默认false</span></span><br></pre></td></tr></table></figure>

<p>【案例：手风琴特效】<br>【案例：音乐导航】</p>
<h2 id="jQuery-节点操作"><a href="#jQuery-节点操作" class="headerlink" title="jQuery 节点操作"></a>jQuery 节点操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $()</span></span><br><span class="line"><span class="comment">// 括号内写 html 格式的字符串</span></span><br><span class="line">$(<span class="string">&#x27;&lt;span&gt;这是一个span元素&lt;/span&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// append</span></span><br><span class="line">A.append(B) <span class="comment">// 把 B 添加到 A 里面去，B 作为 A 的最后一个子元素</span></span><br><span class="line"><span class="comment">// appendTo</span></span><br><span class="line">B.appendTo(A) <span class="comment">// 作用同上，写法不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// prepend</span></span><br><span class="line">A.prepend(B) <span class="comment">// 把 B 添加到 A 里面去，B 作为 A 的第一个子元素</span></span><br><span class="line"><span class="comment">// prependTo</span></span><br><span class="line">B.prependTo(A) <span class="comment">// 作用同上，写法不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">A.after(B) <span class="comment">// 把 B 作为 A 的兄弟，添加在 A 的后面</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line">A.before(B) <span class="comment">// 把 B 作为 A 的兄弟，添加在 A 的前面</span></span><br></pre></td></tr></table></figure>

<p>【案例：城市选择案例】</p>
<h3 id="清空节点与删除节点"><a href="#清空节点与删除节点" class="headerlink" title="清空节点与删除节点"></a>清空节点与删除节点</h3><p>empty：清空指定节点的所有元素，自身保留(清理门户)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).empty() <span class="comment">// 清空 div 的所有内容（推荐使用，会清除子元素上绑定的内容，源码）</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).html(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 使用 html 方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除</span></span><br></pre></td></tr></table></figure>

<p>remove：删除节点，会把元素自身给删除掉</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).remove() <span class="comment">// 删除 div 节点</span></span><br></pre></td></tr></table></figure>

<h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><p>clone：克隆元素节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).clone() <span class="comment">// 返回复制的 div 新元素，（默认不显示，需要配合 append 方法）</span></span><br><span class="line"><span class="comment">// 新元素和原来的元素没有任何关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clone(布尔类型参数)， 参数为true， 克隆元素的事件，默认值是false</span></span><br></pre></td></tr></table></figure>

<h2 id="jQuery-特殊属性操作"><a href="#jQuery-特殊属性操作" class="headerlink" title="jQuery 特殊属性操作"></a>jQuery 特殊属性操作</h2><h3 id="val"><a href="#val" class="headerlink" title="val()"></a>val()</h3><p>val 方法用于设置和获取表单元素的值，例如 input、textarea 的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">$(<span class="string">&#x27;#name&#x27;</span>).val(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line">$(<span class="string">&#x27;#name&#x27;</span>).val()</span><br></pre></td></tr></table></figure>

<p>【案例：搜索框】</p>
<h3 id="html-与-text"><a href="#html-与-text" class="headerlink" title="html() 与 text()"></a>html() 与 text()</h3><p>html 方法相当于 innerHTML，text 方法相当于 innerText</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置内容</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).html(<span class="string">&#x27;&lt;span&gt;这是一段内容&lt;/span&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).html()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置内容</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).text(<span class="string">&#x27;&lt;span&gt;这是一段内容&lt;/span&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).text()</span><br></pre></td></tr></table></figure>

<p><strong>区别</strong>：html 方法会识别 html 标签，text 方法会将内容直接当成字符串，并不会识别 html 标签</p>
<h3 id="width-与-height"><a href="#width-与-height" class="headerlink" title="width() 与 height()"></a>width() 与 height()</h3><p>设置或者获取 <strong>内容区域</strong> 的宽度和高度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带参数表示设置</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).width(<span class="number">200</span>)</span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).height(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带参数表示获取</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).width()</span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).height()</span><br></pre></td></tr></table></figure>

<p>获取 <strong>内容区域 + padding</strong> 的宽度和高度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).innerWidth()</span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).innerHeight()</span><br></pre></td></tr></table></figure>

<p>获取 <strong>内容区域 + padding + border</strong> 的宽度和高度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).outerWidth()</span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).outerHeight()</span><br></pre></td></tr></table></figure>

<p>获取 <strong>内容区域 + padding + border + margin</strong> 的宽度和高度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入参数true</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).outerWidth(<span class="literal">true</span>)</span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).outerHeight(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>获取网页的可视区宽高</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).width()</span><br><span class="line">$(<span class="built_in">window</span>).height()</span><br></pre></td></tr></table></figure>

<h3 id="scrollTop-与-scrollLeft"><a href="#scrollTop-与-scrollLeft" class="headerlink" title="scrollTop 与 scrollLeft"></a>scrollTop 与 scrollLeft</h3><p>设置或者获取垂直滚动条的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传参表示设置，不传参表示获取</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollTop(<span class="number">2000</span>)</span><br><span class="line">$(<span class="built_in">window</span>).scrollLeft()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时的去获取到页面垂直卷曲的距离</span></span><br><span class="line">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log($(<span class="built_in">window</span>).scrollTop())</span><br><span class="line">  <span class="built_in">console</span>.log($(<span class="built_in">window</span>).scrollLeft())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>返回顶部固定写法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$goTop.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">&#x27;html, body&#x27;</span>).animate(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">scrollTop</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>【案例：固定菜单栏案例】<br>【案例：小火箭返航案例】</p>
<h3 id="offset-方法与-position-方法"><a href="#offset-方法与-position-方法" class="headerlink" title="offset 方法与 position 方法"></a>offset 方法与 position 方法</h3><p>offset 方法获取元素距离 document 的位置，position 方法获取的是元素距离有定位的父元素的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取元素距离 document 的位置，和父元素没有关系，返回值为对象：&#123;left:100, top:100&#125;</span></span><br><span class="line">$(selector).offset()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取相对于其最近的有定位的父元素的位置，返回值为对象</span></span><br><span class="line">$(selector).position()</span><br></pre></td></tr></table></figure>

<h2 id="jQuery-事件机制"><a href="#jQuery-事件机制" class="headerlink" title="jQuery 事件机制"></a>jQuery 事件机制</h2><p>JavaScript 中已经学习过了事件，但是 jQuery 对 JavaScript 事件进行了封装，增加并扩展了事件处理机制。jQuery 不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。</p>
<h3 id="jQuery-事件发展历程-了解"><a href="#jQuery-事件发展历程-了解" class="headerlink" title="jQuery 事件发展历程(了解)"></a>jQuery 事件发展历程(了解)</h3><p>简单事件绑定&gt;&gt; bind 事件绑定&gt;&gt; delegate 事件绑定 &gt;&gt;on 事件绑定(推荐)</p>
<ul>
<li>简单方式事件注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jq 中简单方式注册相同的事件是不会被覆盖的</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).click(<span class="literal">null</span>) <span class="comment">// alert(&#x27;2&#x27;) 依然会执行</span></span><br></pre></td></tr></table></figure>

<p>缺点：不能同时注册多个事件，无法解绑事件</p>
<ul>
<li>bind 方式注册事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：事件类型，如果需要给元素注册多个事件，可以用空格隔开写上多个事件名</span></span><br><span class="line"><span class="comment">// 第二个参数：事件处理函数</span></span><br><span class="line">$(<span class="string">&#x27;p&#x27;</span>).bind(<span class="string">&#x27;click mouseenter&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 事件响应方法</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>unbind 解绑事件（不用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).unbind() <span class="comment">// 不传参数解绑所有的事件</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).unbind(<span class="string">&#x27;click&#x27;</span>) <span class="comment">// 解绑指定的事件</span></span><br></pre></td></tr></table></figure>

<p>缺点：不支持动态事件绑定</p>
<ul>
<li><p>delegate 注册委托事件</p>
<p>事件是注册给父元素的，由子元素去触发该事件</p>
<p>原理： 事件冒泡</p>
<p>优点：节省内存，支持动态绑定</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：要绑定事件的元素</span></span><br><span class="line"><span class="comment">// 第二个参数：事件类型</span></span><br><span class="line"><span class="comment">// 第三个参数：事件处理函数</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).delegate(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 事件注册给了父元素 div，为所有的子元素 p 绑定事件， 由 p 去触发事件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>undelegate 解绑事件（不用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).undelegate() <span class="comment">// 解绑所有的 delegate 事件</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).undelegate(<span class="string">&#x27;click&#x27;</span>) <span class="comment">// 解绑所有的 click 事件</span></span><br></pre></td></tr></table></figure>

<p>缺点：只能注册委托事件，因此注册时间需要记得方法太多了</p>
<h3 id="on-注册事件-重点"><a href="#on-注册事件-重点" class="headerlink" title="on 注册事件(重点)"></a>on 注册事件(重点)</h3><p>jQuery 1.7 之后，jQuery 用 on 统一了所有事件的处理方法，强烈建议使用</p>
<ul>
<li>on 注册简单事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示给 $(&#x27;div&#x27;) 绑定事件，并且由自己触发，不支持动态绑定</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>on 注册委托事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示给 $(&#x27;div&#x27;) 绑定代理事件，必须是它的内部元素 span 才能触发这个事件，支持动态绑定</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;span&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>on 注册事件的语法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）</span></span><br><span class="line"><span class="comment">// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行</span></span><br><span class="line"><span class="comment">// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）</span></span><br><span class="line"><span class="comment">// 第四个参数：handler，事件处理函数</span></span><br><span class="line">$(selector).on(events[,selector][,data],handler)</span><br></pre></td></tr></table></figure>

<h3 id="off-解绑事件"><a href="#off-解绑事件" class="headerlink" title="off 解绑事件"></a>off 解绑事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解绑匹配元素的所有事件，父元素子元素的所有事件都解绑了</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).off()</span><br><span class="line"><span class="comment">// 解绑匹配元素的所有 click 事件</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).off(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"><span class="comment">// 解绑子元素 p 的所有 click 事件, 父元素的click事件不会被解绑</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).off(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;p&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击 div 触发事件</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可由其他元素触发 div 的事件</span></span><br><span class="line"><span class="comment">// 点击 btn 触发 div 的 click 事件</span></span><br><span class="line">$(<span class="string">&#x27;#btn&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $(&#x27;div&#x27;).click() // 触发 div 的 click 事件</span></span><br><span class="line">  $(<span class="string">&#x27;div&#x27;</span>).trigger(<span class="string">&#x27;click&#x27;</span>) <span class="comment">// trigger(type) 触发 div 的 click 事件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="jQuery-事件对象"><a href="#jQuery-事件对象" class="headerlink" title="jQuery 事件对象"></a>jQuery 事件对象</h3><p>jQuery 事件对象其实就是 js 事件对象的一个封装，处理了兼容性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// screenX 和 screenY 对应屏幕最左上角的值</span></span><br><span class="line"><span class="comment">// clientX 和 clientY 距离页面左上角的位置（忽视滚动条）</span></span><br><span class="line"><span class="comment">// pageX 和 pageY 距离页面最顶部的左上角的位置（会计算滚动条的距离）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// event.keyCode 按下的键盘代码</span></span><br><span class="line"><span class="comment">// event.data 存储绑定事件时传递的附加数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// event.stopPropagation() 阻止事件冒泡行为</span></span><br><span class="line"><span class="comment">// event.preventDefault() 阻止浏览器默认行为</span></span><br><span class="line"><span class="comment">// return false 既能阻止事件冒泡，又能阻止浏览器默认行为</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>js</code> 中的 <code>return false</code> 只能起到阻止浏览器的默认行为，<code>jquery</code> 中的 <code>return false</code> 既能阻止事件冒泡也能阻止浏览器的默认行为</p>
<p>【案例：钢琴版导航（加强)】</p>
<p>【案例：弹幕效果】</p>
<h2 id="jQuery-特点"><a href="#jQuery-特点" class="headerlink" title="jQuery 特点"></a>jQuery 特点</h2><h3 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>隐式迭代：jQuery 在设置属性时会自动的遍历，因此我们不需要再遍历</p>
<ol>
<li>jQuery 在执行设置性操作时，会给所有的元素都设置上相同的值</li>
<li>jQuery 在执行获取性操作时，只会返回第一个元素对应的值</li>
<li>如果想要给每一个元素都设置不同的值，需要手动进行遍历 jQuery 对象</li>
</ol>
<h4 id="each-方法"><a href="#each-方法" class="headerlink" title="each 方法"></a>each 方法</h4><p>遍历 jQuery 对象集合，为每个匹配的元素执行一个函数</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(selector).each(<span class="function"><span class="keyword">function</span>(<span class="params">index, element</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// index 表示当前元素在所有匹配元素中的索引号</span></span><br><span class="line">  <span class="comment">// element 表示当前元素</span></span><br><span class="line">  <span class="comment">// this 在函数内部，this指向了element</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;li&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index, ele</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $(ele).css(&#x27;backgroundColor&#x27;, arr[index])</span></span><br><span class="line">  $(<span class="built_in">this</span>).css(<span class="string">&#x27;backgroundColor&#x27;</span>, arr[index])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><p>链式编程的原理：设置性操作会返回一个 jQuery 对象，因此可以继续调用 jQuery 的方法</p>
<ol>
<li>设置操作的时候，可以使用链式编程</li>
<li>获取操作的时候，无法使用链式编程，（因为没有返回 jq 对象）</li>
<li>链式编程不要太长，因为代码可读性差</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">prevObject: 返回上一次找到的jq对象</span><br><span class="line">end() <span class="comment">// 上一次返回的 jq 对象（封装了 prevObject 属性）</span></span><br></pre></td></tr></table></figure>

<p>【案例：五角星评分案例.html】</p>
<h3 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h3><p>jQuery 使用 <code>$</code>作为标示符，但是如果与其他框架中的 <code>$</code> 冲突时，jQuery 可以释放 <code>$</code> 符的控制权</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// noConflict() // 返回 $ 的功能</span></span><br><span class="line"><span class="keyword">var</span> c = $.noConflict() <span class="comment">// 释放 $ 的控制权,并且把 $ 的能力给了 c</span></span><br></pre></td></tr></table></figure>

<h2 id="jQuery-插件"><a href="#jQuery-插件" class="headerlink" title="jQuery 插件"></a>jQuery 插件</h2><p>插件：其实就是个 js 库，依赖于 jquery，而且在 jquery 的基础上新增一些功能</p>
<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 先引入jQuery文件</span><br><span class="line">2. 在引入插件（如果有用到css的话，需要引入css）</span><br><span class="line">3. 使用插件</span><br></pre></td></tr></table></figure>

<p>常用插件的使用</p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktY29sb3I=">jquery.color.js</span></p>
<p>animate 只支持数值型的动画，色值型的不支持，这个插件就可以让 animate 做色值型的动画</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R1dXBvbGEvanF1ZXJ5X2xhenlsb2Fk">jquery.lazyload.js</span></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="comment">// html图片调用方法</span></span><br><span class="line"><span class="comment">// 为图片加入样式 lazy 图片路径引用方法用 data-original</span></span><br><span class="line"><span class="comment">// &lt;img class=&#x27;lazy&#x27; data-original=&#x27;img/1.jpg&#x27;&gt;</span></span><br><span class="line"><span class="comment">// js出始化lazyload并设置图片显示方式</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">&#x27;img.lazy&#x27;</span>).lazyload(&#123;</span><br><span class="line">    <span class="attr">effect</span>: <span class="string">&#x27;fadeIn&#x27;</span>,</span><br><span class="line">    <span class="attr">placeholder</span>: <span class="string">&#x27;img/2.jpg&#x27;</span>, <span class="comment">// 用图片提前占位,待图片加载时,占位图则会隐藏</span></span><br><span class="line">    <span class="attr">effect</span>: <span class="string">&#x27;fadeIn&#x27;</span>, <span class="comment">// 载入使用何种效果</span></span><br><span class="line">    <span class="attr">threshold</span>: <span class="number">200</span>, <span class="comment">// 表示滚动条在离目标位置200的高度时开始加载图片,可以做到不让用户察觉</span></span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;click&#x27;</span> <span class="comment">// 事件触发时才加载</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="制作-jQuery-插件"><a href="#制作-jQuery-插件" class="headerlink" title="制作 jQuery 插件"></a>制作 jQuery 插件</h3><p>制作 jQuery 插件的核心思想：给 jQuery 的原型增加方法即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.fn.pluginName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>制作基本的 jQuery 插件（jquery.bgc.js）</li>
<li>制作手风琴插件</li>
</ul>
<h2 id="jQuery-架构"><a href="#jQuery-架构" class="headerlink" title="jQuery 架构"></a>jQuery 架构</h2><p>看源码学习推荐看 1.7.0 版本，源码比较清晰</p>
<h3 id="jq-的基本架构"><a href="#jq-的基本架构" class="headerlink" title="jq 的基本架构"></a>jq 的基本架构</h3><p>沙箱 ，减少全局污染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span>, <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(undefined)</span></span><br><span class="line">  <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 往外暴露</span></span><br><span class="line">  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"><span class="keyword">var</span> jq = <span class="keyword">new</span> jQuery() <span class="comment">// ==&gt; 得到一个jq的实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log(jq)</span><br></pre></td></tr></table></figure>

<p>参数 <code>window</code> 的作用：</p>
<ul>
<li>减少对 window 的搜索过程</li>
<li>有利于代码压缩</li>
</ul>
<p>参数 <code>undefined</code> 的作用：</p>
<ul>
<li>参数 <code>undefined</code> 的值是 <code>undefined</code></li>
<li><code>undefined</code> 这个数据类型的值在 ie678 中是可以被修改的，现在有 <code>undefined</code> 形参在这，在沙箱里面去使用 <code>undefined</code> 的时候，就不会去引用外面被修改的 <code>undefined</code> 的值</li>
</ul>
<h3 id="省去-new-操作"><a href="#省去-new-操作" class="headerlink" title="省去 new 操作"></a>省去 new 操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省去 new 操作，得到一个jq的实例对象</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span>, <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// jQuery 是 工厂函数， 里面干啥？</span></span><br><span class="line">  <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return new 构造函数</span></span><br><span class="line">    <span class="comment">// 在 jq 里面，真正的构造函数是 init，而且 init 方法放在 jq 的原型上</span></span><br><span class="line">    <span class="comment">// jQuery.fn.init ==&gt; 是从 jq 的原型上拿 init 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector) <span class="comment">// init 何种调用模式， 构造函数模式</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    <span class="comment">// 原型替换</span></span><br><span class="line">    <span class="attr">constructor</span>: jQuery,</span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// init 是真正的构造函数</span></span><br><span class="line">      <span class="comment">// 获取元素</span></span><br><span class="line">      <span class="keyword">var</span> ele = <span class="built_in">document</span>.querySelectorAll(selector)</span><br><span class="line">      <span class="comment">// this ==&gt; init的实例对象</span></span><br><span class="line">      ;[].push.apply(<span class="built_in">this</span>, ele)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">css</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;css is ok&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 init 的构造函数的 prototype 改成 jquery 的原型</span></span><br><span class="line"><span class="comment">// 目的： 让 init 的实例对象可以访问 jq 原型上的方法</span></span><br><span class="line">jQuery.fn.init.prototype = jQuery.fn</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $div = $(<span class="string">&#x27;div&#x27;</span>) <span class="comment">// init实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log($div)</span><br><span class="line">$div.css()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/1658.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1658.html" class="post-title-link" itemprop="url">Web Api</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-09-20" itemprop="dateCreated datePublished" datetime="2018-09-20T14:38:17+00:00">2018-09-20</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Web-Api-基本概念"><a href="#Web-Api-基本概念" class="headerlink" title="Web Api 基本概念"></a>Web Api 基本概念</h1><p><strong>API</strong>（Application Programming Interface,应用程序编程接口）</p>
<p><strong>API 是一些预先定义的方法，这些方法能够实现某些特定的功能</strong></p>
<ul>
<li>任何开发语言都会提供自己的 API</li>
<li>API 的特征输入和输出(参数/返回值)</li>
</ul>
<p>通俗的讲，API 就是编程语言给我提供的一些 <code>工具</code>，通过这些<code>工具</code>，我们可以非常轻易的完成一些功能。</p>
<p><strong>Web API</strong> : 是浏览器提供的 <strong>一套操作网页(web)的方法(API)</strong>, 通过这套 API 我们可以非常轻松的操作<code>页面的元素</code>和<code>浏览器的一些功能</code></p>
<p>**ECMAScript - JavaScript 的核心 **</p>
<ul>
<li>ECMAScript 是一套标准, 规范了语言的基本语法和数据类型</li>
<li>与具体实现无关</li>
</ul>
<p><strong>DOM</strong> - 文档对象模型</p>
<ul>
<li>一套操作页面元素的 API</li>
<li>通过 DOM 提供的 API 可以获取/操作网页上的元素</li>
</ul>
<p><strong>BOM - 浏览器对象模型</strong></p>
<ul>
<li>一套操作浏览器功能的 API</li>
<li>通过 BOM 可以操作浏览器窗口, 比如刷新、控制浏览器跳转等</li>
</ul>
<h1 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM 文档对象模型"></a>DOM 文档对象模型</h1><h2 id="DOM-基本概念"><a href="#DOM-基本概念" class="headerlink" title="DOM 基本概念"></a>DOM 基本概念</h2><blockquote>
<p>DOM ( Document Object Model ) 文档对象模型，是<code>W3C组织</code>推荐的一套操作网页元素的 API</p>
</blockquote>
<p>DOM 又称为文档树模型，因为整个 HTML 文档是一个树形的结构</p>
<p><strong>DOM 中常见的概念</strong> :</p>
<ul>
<li><p><strong>文档 <code>document</code></strong> : 一个网页可以称为文档；（换句话说：操作页面，其实就是操作 document）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>)</span><br><span class="line"><span class="comment">// DOM 会把整个网页当成一个对象，我们操作这个网页，只要操作这个document对象</span></span><br><span class="line"><span class="comment">// DOM 会把网页中的所有的东西都当作对象</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>节点<code>node</code></strong> : 网页中的所有内容都是节点 (标签、属性、文本)</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  ul: 标签节点 class=&quot;box&quot;: 属性节点</span><br><span class="line">  <span class="comment">&lt;!-- 这是一些测试 --&gt;</span></span><br><span class="line">  注释节点</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  测试:文本节点</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>元素 <code>element</code></strong> : 网页中的<strong>标签节点</strong></li>
</ul>
<h2 id="获取元素的方法"><a href="#获取元素的方法" class="headerlink" title="获取元素的方法"></a>获取元素的方法</h2><ul>
<li><strong>document.getElementById()</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过id 获取元素</span></span><br><span class="line"><span class="comment">// 参数 : 字符串类型的id</span></span><br><span class="line"><span class="comment">// 返回值 : 一个元素（dom对象）</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.dir(div) <span class="comment">// 以对象的形式显示</span></span><br><span class="line"><span class="built_in">console</span>.log(div) <span class="comment">// 以内容的形式显示</span></span><br></pre></td></tr></table></figure>

<p>​ <strong>关于<code>console.log()</code>和<code>console.dir()</code>的区别</strong></p>
<p>​ <code>console.log()</code> ：打印一个元素的时候，是以标签的形式进行展示的</p>
<p>​ <code>console.dir()</code> ：打印一个元素的时候，是以对象的形式进行展示的</p>
<ul>
<li><strong>getElementsByClassName()</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过类名获取元素</span></span><br><span class="line"><span class="comment">// 参数：字符串类型的类名</span></span><br><span class="line"><span class="comment">// 返回值：伪数组</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;class&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>getElementsByTagName()</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过标签名获取元素</span></span><br><span class="line"><span class="comment">// 参数：标签名字符串</span></span><br><span class="line"><span class="comment">// 返回值：伪数组</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>getElementsByName()</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过name属性值获取元素</span></span><br><span class="line"><span class="comment">// 参数 : name值</span></span><br><span class="line"><span class="comment">// 返回值 : 伪数组</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;aa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>querySelector()</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据css选择器获取元素 (重点)</span></span><br><span class="line"><span class="comment">// 参数：是一个css选择器</span></span><br><span class="line"><span class="comment">// 返回值：只会返回一个对象，如果有很多个，会返回第一个</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#box&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>querySelectorAll()</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据css选择器获取元素 (重点)</span></span><br><span class="line"><span class="comment">// 参数：是一个css选择器</span></span><br><span class="line"><span class="comment">// 返回值：伪数组</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.box&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li><p><code>getElementById()</code> 只能由 <code>document</code> 调用，如果通过其他元素调用会报错，其他方法可由已经获取到的 dom 对象调用</p>
</li>
<li><p><code>querySelector</code>和 <code>getElementById</code>如果获取不到元素会返回 null；<code>getElementsByClassName</code> 、<code>getElementsByTagName</code> 、<code>getElementsByName</code> 、<code>querySelectorAll</code> 如果没有获取到元素也会返回一个伪数组，只不过伪数组长度为 0</p>
</li>
<li><p>伪数组不是数组，不能使用属性的方法，但是可以跟数组一样进行遍历和使用下标进行操作；伪数组不能直接注册事件，需要遍历后拿到标签再注册事件</p>
</li>
<li><p>在 DOM 中, 获取元素操作需要写在 html 内容的后面，保证页面加载完成之后才能获取到内容</p>
</li>
</ul>
<h2 id="事件学习"><a href="#事件学习" class="headerlink" title="事件学习"></a>事件学习</h2><h3 id="认识事件"><a href="#认识事件" class="headerlink" title="认识事件"></a>认识事件</h3><blockquote>
<p>事件：理解为浏览器的感知系统 , 触发 –&gt; 响应机制，javascript 是基于事件驱动的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击事件</span></span><br><span class="line"><span class="comment">// 结构 : 事件源.onclick = function () &#123;..&#125;</span></span><br></pre></td></tr></table></figure>

<p>事件三要素 : 事件源 + 事件名称 + 事件处理函数</p>
<ul>
<li>事件源 : 给谁注册事件 ( 按钮 btn )</li>
<li>事件名称 : 注册了什么事件 ( click 事件 )</li>
<li>事件处理函数 : 事件触发后要执行的代码(函数形式)</li>
</ul>
<p>注意：事件处理函数并不会立马执行，而是当事件触发的时候才会执行（浏览器会自动调用）</p>
<p>注册事件的基本语法 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>)</span><br><span class="line"><span class="comment">//on:当  click:点击   当按钮被点击的时候触发</span></span><br><span class="line">box.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;代码会在box被点击后执行&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两种按钮</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>点亮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;哈&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">都是可点击的普通按钮，一个是文字显示在标签内容里, 而且还可以放其他标签，一个是文字显示在vaue中</span><br></pre></td></tr></table></figure>

<h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><ul>
<li><code>focus</code> : 获得焦点</li>
<li><code>blur</code> : 失去焦点</li>
</ul>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ul>
<li><code>click</code> : 单击</li>
<li><code>dblclick</code> ：双击</li>
<li><code>mouseover/mouseout</code> : 进入/离开元素</li>
<li><code>mouseenter/mouseleave</code> : 进入/离开元素</li>
<li><code>mousedown</code> ：按下</li>
<li><code>mouseup</code> ：抬起/释放</li>
<li><code>mousemove</code> ：移动</li>
</ul>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ul>
<li><code>keydown/keypress</code> ：按下</li>
<li><code>keyup</code>： 释放</li>
</ul>
<h3 id="事件中的-this"><a href="#事件中的-this" class="headerlink" title="事件中的 this"></a>事件中的 this</h3><blockquote>
<p>this 指向注册事件的事件源</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 给 btn 注册的事件，因此 this 表示 btn</span></span><br><span class="line">  <span class="built_in">this</span>.value = <span class="string">&#x27;哈哈&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 给多个按钮注册点击事件，点击的那个变成红色 --&gt;</span></span><br><span class="line">.red &#123; background: red &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 给多个按钮注册点击事件，点击的那个变成红色，其他的恢复默认</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">    btns[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(i) // 点击按钮时打印 2</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// btns[i].className = &#x27;red&#x27; // 此时 i = 2，报错</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        btns[i].className = <span class="string">&#x27;&#x27;</span> <span class="comment">// 恢复默认样式 ，排他思想</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.className = <span class="string">&#x27;red&#x27;</span> <span class="comment">// 给自己添加样式</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 2. 点击按钮，显示对应的图片 1-6</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;第一张&quot;</span> <span class="attr">title</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;images/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="阻止浏览器默认行为"><a href="#阻止浏览器默认行为" class="headerlink" title="阻止浏览器默认行为"></a>阻止浏览器默认行为</h2><blockquote>
<p>对于 a 标签来说，默认的行为就是进行页面跳转，如果不想让 a 标签进行跳转，可以在注册事件中使用<code>return false</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>这是a<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;呵呵&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 阻止页面跳转</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>e.preventDefault() 只会阻止浏览器的默认行为，并不会停止函数执行</li>
<li>return false 后的代码不在执行</li>
<li>在 jQuery 中，<code>return false</code>在调用时会执行 3 个单独的操作：</li>
<li><code>event.preventDefault()</code></li>
<li><code>event.stopPropagation()</code></li>
<li>停止回调执行并在调用时立即返回</li>
</ol>
<h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><ul>
<li>在 DOM 中，页面标签的属性和 DOM 对象的属性是一一对应的，因此我们可以通过修改 DOM 对象的属性来修改标签的属性</li>
</ul>
<h3 id="普通标签属性"><a href="#普通标签属性" class="headerlink" title="普通标签属性"></a>普通标签属性</h3><ul>
<li><p>常见的属性有：src、title、src、href、class、id 等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 js 中 class 是关键字，因此对应的是 className 属性</span></span><br><span class="line">div.className = <span class="string">&#x27;hg&#x27;</span> <span class="comment">// 修改类名会把原类名直接覆盖掉</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="表单属性操作"><a href="#表单属性操作" class="headerlink" title="表单属性操作"></a>表单属性操作</h3><ul>
<li>常见的表单属性有：disabled、type、value、checked、selected</li>
<li>对于 disabled、checked、selected 三个属性来说，比较特殊。在 DOM 对象中，这些属性是一个布尔类型的属性，值只有 true 或者 false</li>
</ul>
<p>!&gt; reset() 方法可把表单中的元素重置为它们的默认值</p>
<p>【案例：禁用文本框】</p>
<p>【案例：随机下拉框选中】</p>
<p>【案例：表格全选案例】</p>
<h3 id="标签的自定义属性"><a href="#标签的自定义属性" class="headerlink" title="标签的自定义属性"></a>标签的自定义属性</h3><blockquote>
<p>我们之前讨论的属性，都是 HTML 规范中，标签本来就有的属性，对于标签自定义的一些属性，比较特殊</p>
</blockquote>
<p>在 html 页面中，定义一个自定义属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">aa</span>=<span class="string">&quot;bb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在对应的 DOM 对象中是不存在的，在 DOM 对象中只会存在固定的那些属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(box.aa) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>attribute 方法</strong></p>
<blockquote>
<p>attribute 系列方法用于设置标签的属性，不管是自定义的还是固有的属性</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取标签的属性</span></span><br><span class="line">box.getAttribute(属性名)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置标签的属性</span></span><br><span class="line">box.setAttribute(属性名, 属性值)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标签的属性</span></span><br><span class="line">box.removeAttribute(属性名)</span><br></pre></td></tr></table></figure>

<p>区别 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;div a=&quot;1&quot; id=&quot;box&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 直接给标签里只能添加固有的属性 title 等 标签+对象里都有显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 给标签添加自定义属性--标签上显示</span></span><br><span class="line"><span class="built_in">console</span>.log(box.a) <span class="comment">// undefined =&gt; 对象中不显示</span></span><br><span class="line"><span class="built_in">console</span>.log(box.getAttribute(<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// 1 =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 给对象添加自定义属性 -- 标签中不显示</span></span><br><span class="line">box.b = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(box.b) <span class="comment">// 2 =&gt; 对象中显示</span></span><br><span class="line"><span class="built_in">console</span>.log(box.getAttribute(<span class="string">&#x27;b&#x27;</span>)) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Attribute方法</span></span><br><span class="line">box.setAttribute(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>) <span class="comment">// 标签中显示</span></span><br><span class="line"><span class="built_in">console</span>.dir(box)</span><br><span class="line"><span class="built_in">console</span>.log(box.c) <span class="comment">// undefined =&gt;对象中不显示</span></span><br><span class="line"><span class="built_in">console</span>.log(box.getAttribute(<span class="string">&#x27;c&#x27;</span>)) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(box.attributes) <span class="comment">// &#123;0: a, 1: id, 2: c, a: a, id: id, c: c, length: 3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(box.attributes.c) <span class="comment">// c=&#x27;3&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="tab-栏案例-重点"><a href="#tab-栏案例-重点" class="headerlink" title="tab 栏案例 (重点)"></a>tab 栏案例 (重点)</h3><p><strong>[案例：获取当前元素的索引]</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1：</span></span><br><span class="line"><span class="comment">// 存</span></span><br><span class="line">btns[i].setAttribute(<span class="string">&#x27;index&#x27;</span>, i)</span><br><span class="line"><span class="comment">// 取</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.getAttribute(<span class="string">&#x27;index&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：</span></span><br><span class="line"><span class="comment">// 存</span></span><br><span class="line">btns[i].index = i</span><br><span class="line"><span class="comment">// 取</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.index)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区别在于: 第一个显示在标签内  第二个不显示在标签内 推荐第二种</span></span><br></pre></td></tr></table></figure>

<p><strong>【案例：tab 栏切换】</strong></p>
<h2 id="标签的内容属性"><a href="#标签的内容属性" class="headerlink" title="标签的内容属性"></a>标签的内容属性</h2><h3 id="innerText-和-innerHTML"><a href="#innerText-和-innerHTML" class="headerlink" title="innerText 和 innerHTML"></a>innerText 和 innerHTML</h3><ul>
<li>共同点 : 都是用来获取和设置标签的内容的</li>
<li>区别：<ul>
<li>innerHTML 能够识别标签，标签能够生效</li>
<li>innerText 只识别文本，标签会被转义</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="comment">// 获取标签内容的时候，只会获取文本，标签扔掉了</span></span><br><span class="line"><span class="built_in">console</span>.log(div.innerText) <span class="comment">// 哈哈</span></span><br><span class="line"><span class="comment">// 获取标签内容的时候，不管标签还是文本，都能获取到</span></span><br><span class="line"><span class="built_in">console</span>.log(div.innerHTML) <span class="comment">// &lt;h1&gt;哈哈&lt;/h1&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置内容</span></span><br><span class="line"><span class="comment">// 设置标签内容的时候，覆盖原来内容，对标签进行转义</span></span><br><span class="line">div.innerText = <span class="string">&#x27;&lt;h1&gt;嘿嘿&lt;/h1&gt;&#x27;</span></span><br><span class="line"><span class="comment">// 设置内容的时候，覆盖原来内容，标签也能生效，浏览器能解析这个标签</span></span><br><span class="line">div.innerHTML = <span class="string">&#x27;&lt;h1&gt;嘿嘿&lt;/h1&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>浏览器兼容性：指网页在各种浏览器上的显示效果不一致。或者是一些属性和方法在低版本的浏览器中不支持</p>
</blockquote>
<ul>
<li>innerText 是 IE 提出来的属性，因此低版本的火狐浏览器不支持这个属性。</li>
<li>火狐有一个 textContent 属性，效果跟 innerText 一样，但是 IE678 不支持这个属性</li>
</ul>
<p>书写 innerText 的兼容性代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInnerText</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> element.innerText === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> element.innerText</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element.textContent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="行内样式操作（style-属性）"><a href="#行内样式操作（style-属性）" class="headerlink" title="行内样式操作（style 属性）"></a>行内样式操作（style 属性）</h2><blockquote>
<p>标签不仅可以通过 class 属性操作样式 (嵌套样式)，还可以通过 style 属性操作样式 (行内样式)。</p>
<p>同样的 DOM 对象可以通过 className 操作样式 (嵌套样式)，也可以通过 style 属性操作样 (行内样式)。</p>
<p>css : 嵌套样式 =&gt; js : 类名 div.className = ‘red’</p>
<p>css : 行内样式 =&gt; js : style 对象 div.style.color = ‘red’</p>
</blockquote>
<h3 id="样式属性"><a href="#样式属性" class="headerlink" title="样式属性"></a>样式属性</h3><ul>
<li>style 属性是一个对象，里面存储了所有行内样式的键值对</li>
<li>style 属性只能获取和设置<strong>行内样式</strong>，嵌套样式通过 style 获取不到</li>
<li>如果样式的名字带 <code>-</code> ，比如 background-color ，在 style 对象中使用 backgroundColor =&gt; （因为 <code>-</code> 在 js 中不是一个合法的标识符）</li>
<li>style 设置的样式是行内样式，优先级要高于通过 className 设置的样式</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:red;background-color:blue;&quot;</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取样式</span></span><br><span class="line"><span class="built_in">console</span>.log(div.style)</span><br><span class="line"><span class="built_in">console</span>.log(div.style.color) <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置样式</span></span><br><span class="line">div.style.width = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">div.style.height = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">div.style.fontSize = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">div.className = <span class="string">&#x27;box&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>getComputedStyle 获取元素计算后的样式</strong></p>
<p>语法： <code>window.getComputedStyle( 获取的元素， 伪类)</code></p>
<p>​ 伪类 ==&gt; ::after ::before，如果写上了伪类，表示要获取元素的伪类的样式，如果不需要获取的话，该参数写 null</p>
<p>​ 返回值： 返回一个样式对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取元素自身的</span></span><br><span class="line"><span class="keyword">var</span> ret = <span class="built_in">window</span>.getComputedStyle(div, <span class="literal">null</span>).fontSize</span><br><span class="line"><span class="keyword">var</span> ret1 = <span class="built_in">window</span>.getComputedStyle(div, <span class="literal">null</span>).backgroundColor</span><br><span class="line"><span class="comment">// 推荐：对于复合样式，需要获取什么样式，写具体的样式名，这样能更好的兼容更多浏览器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取伪类的</span></span><br><span class="line"><span class="keyword">var</span> ret2 = <span class="built_in">window</span>.getComputedStyle(div, <span class="string">&#x27;::after&#x27;</span>).width</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="关于-body-的样式操作"><a href="#关于-body-的样式操作" class="headerlink" title="关于 body 的样式操作"></a>关于 body 的样式操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bd = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bd) <span class="comment">// 通过 querySelector 获取 body 元素</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body) <span class="comment">// 直接获取 body 元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.documentElement <span class="comment">// 可以获取 html 元素</span></span><br><span class="line"><span class="built_in">document</span>.head <span class="comment">// 直接获取 head 元素</span></span><br><span class="line"><span class="built_in">document</span>.title <span class="comment">// 获取的是 title 中的文本</span></span><br></pre></td></tr></table></figure>

<p><strong>【案例：开关灯案例】</strong></p>
<p><strong>【案例：随机背景颜色案例】</strong></p>
<p><strong>【案例：百度换肤】</strong></p>
<h3 id="关于-cssText-了解"><a href="#关于-cssText-了解" class="headerlink" title="关于 cssText (了解)"></a>关于 cssText (了解)</h3><blockquote>
<p>使用 cssText 可以设置 style 的属性值</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px&quot;</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 优点：可以一次性设置多个值</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 缺点：会覆盖整个style属性且不利于阅读</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  div.style.cssText = <span class="string">&#x27;background:red;color:yellow&#x27;</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="节点操作-超级重要"><a href="#节点操作-超级重要" class="headerlink" title="节点操作 (超级重要)"></a>节点操作 (超级重要)</h2><h3 id="节点属性-了解"><a href="#节点属性-了解" class="headerlink" title="节点属性 (了解)"></a>节点属性 (了解)</h3><p><strong>节点分类：</strong></p>
<p>​ 元素节点、文本节点、属性节点、注释节点</p>
<p><strong>节点常用的属性</strong></p>
<ul>
<li><p>childNodes : 获取所有的子节点</p>
</li>
<li><p><strong>nodeType</strong>:  节点类型：元素节点 = 1 属性-2(过时) 注释-8 文本-3</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL05vZGUvbm9kZVR5cGU=">nodeType 链接-MDN</span></p>
</li>
<li><p><strong>nodeName</strong>: 节点名称</p>
</li>
<li><p><strong>nodeValue</strong>: 节点值</p>
</li>
</ul>
<h3 id="节点查找-重点"><a href="#节点查找-重点" class="headerlink" title="节点查找 (重点)"></a>节点查找 (重点)</h3><h4 id="孩子节点"><a href="#孩子节点" class="headerlink" title="孩子节点"></a>孩子节点</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 下面是li --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>导航1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>导航2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>导航3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>导航4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取ul所有的子节点（包括了元素节点和其他很多类型的节点，基本不常用）</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(ul.childNodes)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取第一个子节点  (不常用)</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(ul.firstChild)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取最后一个子节点  (不常用)</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(ul.lastChild)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取所有的子元素，兼容性：IE678会把注释节点算上</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(ul.children)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取第一个子元素 有兼容性问题（IE678）</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(ul.firstElementChild)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取最后一个子元素 有兼容性问题（IE678）</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(ul.lastElementChild)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取第n个子元素 有兼容性问题（IE678）</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(ul.children[n])</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><ul>
<li><code>nextSibling</code> : 下一个兄弟节点 (基本不常用)</li>
<li><code>nextElementSibling</code> : 下一个兄弟元素（IE678 不兼容）</li>
<li><code>previousSibling</code> : 上一个兄弟节点 (基本不常用)</li>
<li><code>previousElementSibling</code> : 上一个兄弟元素 有兼容性问题 可以封装一个兼容性方法</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>导航1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p&quot;</span>&gt;</span>导航2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>导航3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> p2 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.p&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p2)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p2.nextSibling)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p2.nextElementSibling)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p2.previousSibling)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p2.previousElementSibling)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>【案例 1：表单校验】</strong></p>
<h4 id="父亲节点"><a href="#父亲节点" class="headerlink" title="父亲节点"></a>父亲节点</h4><ul>
<li><code>parentNode</code> : 父节点（没有兼容性问题）</li>
<li><code>parentElement</code> : 父元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div.parentNode // 获取父节点</span><br></pre></td></tr></table></figure>

<h3 id="添加节点-重点"><a href="#添加节点-重点" class="headerlink" title="添加节点 (重点)"></a>添加节点 (重点)</h3><h4 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild()"></a>appendChild()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用：在子元素的最后添加一个元素</span></span><br><span class="line"><span class="comment">// 语法：parent.appendChild(newChild)</span></span><br><span class="line"><span class="comment">// 父元素.appendChild(新子元素)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> : 如果 newChild 已经存在于 DOM 树中，则它会被从原始位置删除</p>
</blockquote>
<h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore()"></a>insertBefore()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用：在某个子元素之前添加一个元素</span></span><br><span class="line"><span class="comment">// 语法：parent.insertBefore(newChild, refChild)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>必须要父节点来调用，newChild 为需要添加的那个节点，refChild 为添加到哪一个节点的前面</li>
<li>没有 <code>insertAfter()</code></li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将元素添加到最后</span></span><br><span class="line">div.appendChild(p) <span class="comment">// (常用)</span></span><br><span class="line">div.insertBefore(p, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素添加到 s1 之前(常用)</span></span><br><span class="line">div.insertBefore(p, s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素添加到 s1 之后</span></span><br><span class="line"><span class="comment">// 没有 insertAfter</span></span><br><span class="line">div.insertBefore(p, s1.nextElementSibling)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素添加到最前</span></span><br><span class="line">div.insertBefore(p, div.children[<span class="number">0</span>]) <span class="comment">// (常用)</span></span><br><span class="line">div.insertBefore(p, div.firstElementChild)</span><br></pre></td></tr></table></figure>

<h3 id="克隆节点-重点"><a href="#克隆节点-重点" class="headerlink" title="克隆节点 (重点)"></a>克隆节点 (重点)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：var newNode = 节点.cloneNode([isDeep])</span></span><br><span class="line"><span class="comment">// isDeep参数：false / true</span></span><br><span class="line"><span class="comment">// false：默认值：是浅复制，只会复制标签节点本身，不会复制节点的孩子</span></span><br><span class="line"><span class="comment">// true:   深度复制，会复制标签，还会复制标签的所有内容</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>克隆出来的节点跟原来的节点没有关系了，修改了也不会相互影响</li>
<li>如果克隆的节点带了 id，我们需要给 id 重新设置一个值，不让 id 冲突</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newNode = div.cloneNode(<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newNode)</span><br></pre></td></tr></table></figure>

<h3 id="创建节点-3-种方式-重点"><a href="#创建节点-3-种方式-重点" class="headerlink" title="创建节点(3 种方式) (重点)"></a>创建节点(3 种方式) (重点)</h3><h4 id="document-write（基本不用）"><a href="#document-write（基本不用）" class="headerlink" title="document.write（基本不用）"></a>document.write（基本不用）</h4><p>可以生成新的节点，但是不推荐使用。如果页面已经加载完成了，再用 document.write 写内容的话，会把之前的页面给覆盖掉</p>
<blockquote>
<p>原理：页面从上往下加载的时候，会开启一个文档流，当页面加载完，文档流就会关闭。document.write 的本意就是在文档流上写入内容。如果页面没加载完成，文档流还是开着的，document.write 直接在这个文档流上写东西，如果页面加载完成了，还是用 document.write 写东西，会重新开启一个新的文档流，往新的文档流上写东西，旧的文档流就被新的文档流覆盖了。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">&#x27;呵呵&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="innerHTML-偶尔用"><a href="#innerHTML-偶尔用" class="headerlink" title="innerHTML (偶尔用)"></a>innerHTML (偶尔用)</h4><p>innerHTML 也可以创建节点</p>
<blockquote>
<p>使用 innerHTML 创建节点时，如果原来有内容的话，会把原先的内容覆盖</p>
<p>慎用：很容易出现效率问题</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.innerHTML = <span class="string">&#x27;&lt;h1&gt;哈哈&lt;/h1&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="createElement-常用"><a href="#createElement-常用" class="headerlink" title="createElement (常用)"></a>createElement (常用)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：var element = document.createElement(&#x27;tagName&#x27;)</span></span><br><span class="line"><span class="comment">// 返回：一个元素</span></span><br><span class="line"><span class="comment">// 需要配合 appendChild 和 innerText 来使用</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> h1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;h1&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(h1)</span><br><span class="line">h1.style.background = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">h1.innerText = <span class="string">&#x27;哈&#x27;</span></span><br><span class="line">div.appendChild(h1)</span><br></pre></td></tr></table></figure>

<h3 id="删除节点-重点"><a href="#删除节点-重点" class="headerlink" title="删除节点 (重点)"></a>删除节点 (重点)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：parent.removeChild(child)</span></span><br><span class="line"><span class="comment">// 解析：父元素.removeChild(子元素)</span></span><br><span class="line"><span class="comment">// 功能：由父元素调用，删除里面的一个子元素</span></span><br><span class="line"></span><br><span class="line">div.removeChild(p)</span><br><span class="line">p.parentNode.removeChild(p)</span><br></pre></td></tr></table></figure>

<p><strong>【案例 : 节点操作-删除节点】</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 使用 children 和 TagName  =&gt;  需要配合 i--</span><br><span class="line"><span class="comment">// 原因 :动态计算 , 每删除一个,都会重新分配一次下标</span></span><br><span class="line"><span class="number">2.</span> 使用 querySelectorAll(<span class="string">&#x27;li&#x27;</span>) =&gt;  ok的</span><br><span class="line"><span class="comment">// 原因 : 静态计算</span></span><br></pre></td></tr></table></figure>

<p><strong>[案例 : 许愿墙案例]</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">功能<span class="number">1</span>: 克隆<span class="number">10</span>个tip, 并且随机分布</span><br><span class="line">功能<span class="number">2</span>: 点击提高层级</span><br><span class="line">功能<span class="number">3</span>: 点击x, 删除当前tip</span><br><span class="line">功能<span class="number">4</span>: 双击tip头部, 删除当前tip</span><br></pre></td></tr></table></figure>

<h3 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="comment">// newChild 为用来替换 oldChild 的新节点</span></span><br><span class="line">parentNode.replaceChild(newChild, oldChild)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> : 如果 newChild 已经存在于 DOM 树中，则它会被从原始位置删除</p>
</blockquote>
<h3 id="节点操作综合案例"><a href="#节点操作综合案例" class="headerlink" title="节点操作综合案例"></a>节点操作综合案例</h3><p>【动态生成表格】</p>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><blockquote>
<p>BOM（Browser Object Model）：浏览器对象模型，提供了一套操作浏览器功能的工具</p>
</blockquote>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102205413.png"></p>
<p><strong>重点</strong> ：定时器、 offset 系列</p>
<h2 id="window"><a href="#window" class="headerlink" title="window"></a><code>window</code></h2><ul>
<li>window 对象是一个全局对象，也可以说是 JavaScript 中的顶级对象</li>
<li>所有定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法</li>
<li>像 document、alert()、console.log() 这些都是 window 的属性，其实 BOM 中基本所有的属性和方法都是 window 的</li>
<li>window 对象下的属性和方法调用的时候可以省略 window</li>
</ul>
<h3 id="onload（掌握）"><a href="#onload（掌握）" class="headerlink" title=".onload（掌握）"></a>.onload（掌握）</h3><blockquote>
<p>window.onload 事件会在 <strong>窗体加载完成</strong> 后执行，通常我们称之为入口函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//代码会在窗体加载完成后执行。</span></span><br><span class="line">  <span class="comment">//窗体加载完成 包括文档树(DOM html)的加载、还有图片、文件的加载完成。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果有图片加载，那么代码一定要写到 window.onload 里面，否则会出现图片没有加载完成，获取到的宽度和高度不对的情况。</p>
<p>浏览器会对页面的加载做优化，在加载图片的时候，图片的引入会延迟。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;./01.png&quot;</span> alt=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(img.width)</span><br><span class="line">  <span class="built_in">console</span>.log(img.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="open-与-close-了解"><a href="#open-与-close-了解" class="headerlink" title=".open() 与 .close() (了解)"></a>.open() 与 .close() (了解)</h3><ul>
<li>window.open() 打开一个窗口</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：window.open(url, [name], [features])</span></span><br><span class="line"><span class="comment">// 参数1：需要载入的 url 地址</span></span><br><span class="line"><span class="comment">// 参数2：新窗口的名称或者 targt 属性</span></span><br><span class="line"><span class="comment">// _blank:如果指定为 _blank，表示在新的窗口打开</span></span><br><span class="line"><span class="comment">// 参数3：窗口的属性，指定窗口的大小</span></span><br><span class="line"><span class="comment">// 返回值：会返回刚刚创建的那个窗口，在 window.close() 时使用</span></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="string">&#x27;_blank&#x27;</span>, <span class="string">&#x27;width=300,height=300&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数配置：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open</span></span><br></pre></td></tr></table></figure>

<ul>
<li>window.close() 关闭窗口</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">newWin.close() <span class="comment">// newWin 是刚刚创建的那个窗口</span></span><br><span class="line"><span class="built_in">window</span>.close() <span class="comment">// 把当前窗口给关闭</span></span><br></pre></td></tr></table></figure>

<h2 id="延时器与定时器-重点"><a href="#延时器与定时器-重点" class="headerlink" title="延时器与定时器 (重点)"></a>延时器与定时器 (重点)</h2><h3 id="setTimeout-延时器"><a href="#setTimeout-延时器" class="headerlink" title="setTimeout 延时器"></a>setTimeout 延时器</h3><blockquote>
<p>可以在延迟一定时间后执行指定的代码</p>
</blockquote>
<p><strong>设置延时器</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法: setTimeOut(callback,time)</span></span><br><span class="line"><span class="comment">// 参数1: 回调函数, 时间到了就会执行</span></span><br><span class="line"><span class="comment">// 参数2: 延时的时间  毫秒为单位 1s = 1000毫秒</span></span><br><span class="line"><span class="comment">// 返回 : 延时器的id,用于清除</span></span><br><span class="line"><span class="keyword">var</span> timer = setTimeOut(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1秒后将执行一次</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p><strong>清除延时器</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法 : clearTimeOut(timerId)</span></span><br><span class="line"><span class="comment">// 参数 : 延时器id</span></span><br><span class="line"><span class="comment">// 示例 :</span></span><br><span class="line">clearTimeOut(timer) <span class="comment">// 清除上面定义的延时器</span></span><br></pre></td></tr></table></figure>

<h3 id="setInterval-定时器"><a href="#setInterval-定时器" class="headerlink" title="setInterval 定时器"></a>setInterval 定时器</h3><blockquote>
<p>setInterval 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间间隔。 (每隔一段时间执行一段代码)</p>
<p>定时器除非清除，否则会一直执行下去。</p>
</blockquote>
<p><strong>设置定时器</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法 :var timerId = setInterval(func,dealy)</span></span><br><span class="line"><span class="comment">// 参数1 ： 重复执行的函数</span></span><br><span class="line"><span class="comment">// 参数2 : 每次间隔的毫秒数</span></span><br><span class="line"><span class="comment">// 返回 : 定时器的id,  用于清除</span></span><br><span class="line"><span class="comment">// 示例 :</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1s 之后开始重复执行</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p><strong>清除定时器</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法 : clearInterval(intervalId)</span></span><br><span class="line"><span class="comment">// 参数 : 定时器id</span></span><br><span class="line"><span class="comment">// 示例 :</span></span><br><span class="line"><span class="built_in">clearInterval</span>(timerId) <span class="comment">// 清除上面的定时器</span></span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>【短信验证码案例.html】</p>
<h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><blockquote>
<p>location 对象也是 window 的一个属性</p>
<p>location 其实对应的就是浏览器中的地址栏</p>
</blockquote>
<h3 id="常用属性和方法"><a href="#常用属性和方法" class="headerlink" title="常用属性和方法"></a>常用属性和方法</h3><ul>
<li>location.href : 控制地址栏的地址，实现页面跳转</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  location.href = <span class="string">&#x27;http://www.baidu.com&#x27;</span> <span class="comment">// 点击页面跳转到百度首页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[案例 : 注册成功，3 秒后跳转]</p>
<blockquote>
<p><strong>页面跳转：</strong></p>
<p><code>location.href = &#39;url地址&#39;</code></p>
<p><code>location.assign(&#39;url地址&#39;)</code></p>
<p><code>location.replace(&#39;url地址&#39;)</code> (不记录历史)</p>
</blockquote>
<ul>
<li>location.reload() 让页面重新加载</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  location.reload() <span class="comment">// 重新刷新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>location 的其他值</p>
<blockquote>
<p><code>http://www.bbb.com:8080/index.html?id=666&amp;psd=123#xxx</code></p>
<ul>
<li>location.hash //哈希值 其实就是锚点 ==&gt; #xxx</li>
<li>location.host //服务器 服务器名+端口号 =&gt; <span class="exturl" data-url="aHR0cDovL3d3dy5iYmIuY29tOjgwODAv">www.bbb.com:8080</span></li>
<li>location.hostname //服务器名 =&gt; <span class="exturl" data-url="aHR0cDovL3d3dy5iYmIuY29tLw==">www.bbb.com</span></li>
<li>location.pathname //路径名 =&gt; index.html</li>
<li>location.port //端口 =&gt; 8080</li>
<li>location.protocol //协议 =&gt; http</li>
<li><strong>location.search</strong> //参数 =&gt; ?id=666&amp;psd=123</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="其他对象"><a href="#其他对象" class="headerlink" title="其他对象"></a>其他对象</h2><ul>
<li>history 对象表示页面的历史</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随便打开一个网页 可以演示</span></span><br><span class="line"><span class="comment">// 后退：</span></span><br><span class="line">history.back()</span><br><span class="line">history.go(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 前进：</span></span><br><span class="line">history.forward()</span><br><span class="line">history.go(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>screen 对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(screen.width) <span class="comment">// 屏幕的宽度</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.height) <span class="comment">// 屏幕的高度</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.availWidth) <span class="comment">// 浏览器可占用的宽度</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.availHeight) <span class="comment">// 浏览器可占用的高度</span></span><br></pre></td></tr></table></figure>

<h2 id="缓动动画"><a href="#缓动动画" class="headerlink" title="缓动动画"></a>缓动动画</h2><h3 id="缓动动画初体验"><a href="#缓动动画初体验" class="headerlink" title="缓动动画初体验"></a>缓动动画初体验</h3><p>动画公式 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> step = (target - current) / <span class="number">10</span></span><br><span class="line">current += step</span><br></pre></td></tr></table></figure>

<p>[案例演示 : ]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 三步走</span><br><span class="line">- 获取当前位置</span><br><span class="line">- 累加小碎步</span><br><span class="line">- 重复赋值回去</span><br><span class="line">2. 定时器</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong> : 打开控制台, 查看盒子的结构行内样式 left, 发现并没有跑到 400px, 只能跑到 396.4/395.5</p>
<p><strong>原因</strong> : offsetLeft 获取值的时候, 只会获取整数 , (对小数部分会四舍五入,整数有时候往上取整,有时候往下取整); <strong>可以在获取的 offset 地方打印查看</strong></p>
<h3 id="缓动动画-移动-400-位置"><a href="#缓动动画-移动-400-位置" class="headerlink" title="缓动动画 - 移动 400 位置"></a>缓动动画 - 移动 400 位置</h3><p>动画公式 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> step = (target - current) / <span class="number">10</span></span><br><span class="line">step = <span class="built_in">Math</span>.ceil(step) <span class="comment">// 往上取整</span></span><br><span class="line">current += step</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么往上取整 :</span></span><br><span class="line"><span class="comment">// 1. 如果不取整，赋值为小数的话,下次取值还是会取个 整数回来，这就是之前的缺点</span></span><br><span class="line"><span class="comment">// 2. 往上取整的额原因是：(400-395)/10 = 0.5 如果往下取整为0，那就不会走了，所以</span></span><br><span class="line"><span class="comment">// 为了保证可以走，往上取整 取 1  步数 为 1</span></span><br></pre></td></tr></table></figure>

<p>案例演示 注意点 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>查看位置 : left有时候为 <span class="number">395.5</span>/ <span class="number">396.4</span></span><br><span class="line"><span class="number">2.</span>打印: <span class="function"><span class="params">offsetLeft</span>  =&gt;</span> <span class="number">395</span> / <span class="number">396</span></span><br><span class="line"><span class="number">3.</span>step为整数  往上取整</span><br></pre></td></tr></table></figure>

<h3 id="缓动动画-回到-0-点位置"><a href="#缓动动画-回到-0-点位置" class="headerlink" title="缓动动画 - 回到 0 点位置"></a>缓动动画 - 回到 0 点位置</h3><p>动画公式 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> step = (target - current) / <span class="number">10</span></span><br><span class="line">step = <span class="built_in">Math</span>.floor(step) <span class="comment">//往下取整</span></span><br><span class="line">current += step</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么往下取整 :</span></span><br><span class="line"><span class="comment">// 1. 如果不取整，赋值为小数的话,下次取值还是会取个整数回来，这就是之前的缺点</span></span><br><span class="line"><span class="comment">// 2. 往上取整的额原因是 : (0-5)/10 = -0.5 如果往上取整为0  那就不会走了，所以</span></span><br><span class="line"><span class="comment">// 为了保证可以走，往下取整 : 取 -1    步数 为 -1</span></span><br></pre></td></tr></table></figure>

<p>案例演示注意点 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 先把盒子 设置 left : 400px 位置;  回到<span class="number">0</span>位置</span><br><span class="line"><span class="number">2.</span> 查看位置 : left有时候为 <span class="number">4.5</span></span><br><span class="line"><span class="number">3.</span> 打印: <span class="function"><span class="params">offsetLeft</span>  =&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="number">4.</span> step为整数  往下取整</span><br></pre></td></tr></table></figure>

<h3 id="缓动动画-封装函数"><a href="#缓动动画-封装函数" class="headerlink" title="缓动动画 - 封装函数"></a>缓动动画 - 封装函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">element, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.timerId) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(element.timerId)</span><br><span class="line">  &#125;</span><br><span class="line">  element.timerId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前位置</span></span><br><span class="line">    <span class="keyword">var</span> current = element.offsetLeft</span><br><span class="line">    <span class="comment">// 2. 累加小碎步</span></span><br><span class="line">    <span class="keyword">var</span> step = (target - current) / <span class="number">10</span></span><br><span class="line">    <span class="comment">// 往上取整 ? 为什么，因为 0.5 如果网下取整也是0 ，不会走</span></span><br><span class="line">    step = step &gt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(step) : <span class="built_in">Math</span>.floor(step)</span><br><span class="line">    current += step <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 3. 重新赋值</span></span><br><span class="line">    element.style.left = current + <span class="string">&#x27;px&#x27;</span> <span class="comment">//400</span></span><br><span class="line">    <span class="keyword">if</span> (current == target) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(element.timerId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[案例 : 筋斗云]</p>
<p>[案例：开机提示关闭]</p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><h3 id="事件对象的概述"><a href="#事件对象的概述" class="headerlink" title="事件对象的概述"></a>事件对象的概述</h3><blockquote>
<p>在<strong>触发某个事件</strong>的时候，都会产生一个<strong>事件对象 Event</strong>，这个对象中<strong>包含所有与事件相关的一些信息</strong>，包括触发事件的元素，事件的类型以及其他与事件相关的信息</p>
</blockquote>
<p><strong>鼠标</strong>事件<strong>触发</strong>时，事件对象中会包含<strong>鼠标的位置信息</strong>。</p>
<p><strong>键盘</strong>事件<strong>触发</strong>时，事件对象中会包含<strong>按下的键相关的信息</strong>。</p>
<h3 id="获取事件对象"><a href="#获取事件对象" class="headerlink" title="获取事件对象"></a>获取事件对象</h3><p><strong>现代浏览器获取 : (掌握)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给一个形参即可</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e 就是事件对象，里面包含了事件触发时的一些信息</span></span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>低版本浏览器 (ie678): (了解)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// IE678 通过 window.event 获取事件对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>兼容性 :</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只要用到了事件对象，就要记得处理浏览器兼容性</span></span><br><span class="line">  <span class="comment">// 低版本IE event 不存在为undefined</span></span><br><span class="line">  e = e || <span class="built_in">window</span>.event</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件对象的常用属性"><a href="#事件对象的常用属性" class="headerlink" title="事件对象的常用属性"></a>事件对象的常用属性</h3><blockquote>
<p>事件对象中有很多很多的属性，但是很多属性并不常用。我们经常用到的是<strong>鼠标位置信息</strong>和<strong>键盘码</strong>相关的信息</p>
</blockquote>
<h4 id="鼠标位置信息"><a href="#鼠标位置信息" class="headerlink" title="鼠标位置信息"></a>鼠标位置信息</h4><ul>
<li><code>clientX</code> 与 <code>clientY</code> ： 相对于<strong>浏览器可视区</strong>左上角的位置（不随滚动条滚动而改变）</li>
<li><code>pageX</code> 与 <code>pageY</code> ：相对于<strong>网页内容</strong>（文档 document）左上角的位置</li>
<li><code>screenX</code> 与 <code>screenY</code> ：相对于<strong>屏幕</strong>左上角的位置</li>
<li><code>offsetX</code> 与 <code>offsetY</code> ：鼠标相对于<strong>事件源</strong>左上角的位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.clientX, e.clientY)</span><br><span class="line">  <span class="built_in">console</span>.log(e.pageX, e.pageY)</span><br><span class="line">  <span class="built_in">console</span>.log(e.screenX, e.screenY)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102205438.png"></p>
<p><strong>[案例 : 拖拽案例]</strong></p>
<h4 id="键盘码"><a href="#键盘码" class="headerlink" title="键盘码"></a>键盘码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键盘按下的那个键的键盘码</span></span><br><span class="line">e.keyCode</span><br></pre></td></tr></table></figure>

<h3 id="注册事件的两种方式"><a href="#注册事件的两种方式" class="headerlink" title="注册事件的两种方式"></a>注册事件的两种方式</h3><h4 id="on-事件名称"><a href="#on-事件名称" class="headerlink" title="on + 事件名称"></a>on + 事件名称</h4><blockquote>
<p>onclick、onmouseover 这种 on+事件名称的方式注册事件几乎所有的浏览器都支持</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">box.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 事件处理程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除事件</span></span><br><span class="line">box.onclick = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>on+事件名称注册事件的缺点：同一个元素同一类型的事件，只能注册一个，如果注册了多个，会出现覆盖问题</p>
<h4 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h4><blockquote>
<p>现代浏览器支持的注册事件的新方式，这种方式注册的事件不会出现覆盖问题</p>
</blockquote>
<p><strong>addEventListener 的语法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type：事件的类型：click mouseover  字符串类型，不带 on</span></span><br><span class="line"><span class="comment">// fn：函数，每次点击，执行这个函数</span></span><br><span class="line"><span class="comment">// useCapture: 可选，true：事件在捕获阶段执行，false: 事件在冒泡阶段执行(默认)</span></span><br><span class="line">element.addEventListener(type, fn, useCapture)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>removeEventListen 的语法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type：事件的类型</span></span><br><span class="line"><span class="comment">// fn：要移除的那个函数</span></span><br><span class="line">element.removeEventListener(type, fn)</span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>, fn)</span><br><span class="line"><span class="comment">// 注意 : 如果想让注册的事件能移除，不能用匿名函数</span></span><br></pre></td></tr></table></figure>

<p>低版本浏览器兼容问题: (了解)</p>
<blockquote>
<p>IE678 不支持 addEventListener 与 removeEventListen 两个方法，但是支持 attachEvent 与 detachEvnet</p>
</blockquote>
<p>attachEvent 的用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type: 事件类型，需要加上on</span></span><br><span class="line"><span class="comment">// fn: 需要执行的那个事件</span></span><br><span class="line">attachEvent(type, fn)</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>detachEvent 的用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">detachEvent(type, fn)</span><br></pre></td></tr></table></figure>

<h4 id="兼容性封装（了解）"><a href="#兼容性封装（了解）" class="headerlink" title="兼容性封装（了解）"></a>兼容性封装（了解）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 能力检测</span></span><br><span class="line">  <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">    element.addEventListener(type, fn)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">    element.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, fn)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果都不行，那就用on方式</span></span><br><span class="line">    element[<span class="string">&#x27;on&#x27;</span> + type] = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params">element, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">    element.removeEventListener(type, fn, <span class="literal">false</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">    element.detachEvent(<span class="string">&#x27;on&#x27;</span> + type, fn)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    element[<span class="string">&#x27;on&#x27;</span> + type] = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为冒泡</p>
<p>说白了就是：<strong>当我们触发了子元素的某个事件后，父元素对应的事件也会触发</strong></p>
<p>on 创建的事件默认为冒泡，无法修改</p>
<p><strong>[案例 : 弹窗案例]</strong></p>
<p><strong>阻止事件冒泡</strong> <code>e.stopPropagation()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">box.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.stopPropagation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：true =&gt; 捕获， false =&gt; 冒泡（默认）</span></span><br><span class="line">box.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, 参数<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><code>event.stopImmediatePropagation</code></p>
<p>阻止事件冒泡并且阻止相同事件的其他侦听器被调用<br>如果有多个相同类型事件的事件监听函数绑定到同一个元素，当该类型的事件触发时，它们会按照被添加的顺序执行。如果其中某个监听函数执行了 <code>event.stopImmediatePropagation()</code> 方法，则当前元素剩下的监听函数将不会被执行</p>
<p>阻止事件冒泡的兼容性封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopPropagation</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e &amp;&amp; e.stopPropagation) &#123;</span><br><span class="line">    e.stopPropagation() <span class="comment">// 标准浏览器</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span> <span class="comment">// 兼容 IE</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>事件冒泡是 ie 提出来的</p>
<p>路径 : 触发事件的目标元素(son) &gt; you &gt; father &gt; body &gt; document</p>
<p>事件捕获是火狐提出来的</p>
<p>路径 : document &gt; body &gt; father &gt; you &gt; 触发事件的目标元素 (son)</p>
<p>解析 : 事件的处理将从 DOM 层次的根开始，而不是从触发事件的目标元素开始，事件被从目标元素的所有祖先元素依次往下传递</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当 addEventListener 第三个参数为 true 时，表示事件捕获</span></span><br><span class="line">arr[i].addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="事件流的三个阶段"><a href="#事件流的三个阶段" class="headerlink" title="事件流的三个阶段"></a>事件流的三个阶段</h3><ol>
<li>事件的捕获阶段</li>
<li>事件的目标阶段（触发自己的事件）</li>
<li>事件的冒泡阶段</li>
</ol>
<p>事件有三个阶段 :</p>
<ul>
<li>捕获事件和冒泡事件都存在的话，首先发生的是捕获阶段，然后是目标阶段，最后才是冒泡阶段</li>
<li>addEventListener 第三个参数为是否捕获</li>
<li>如果为 true 时，表示该事件在捕获阶段发生</li>
<li>如果为 false 时，表示该事件在冒泡阶段发生</li>
<li>某一个事件只会执行一次</li>
</ul>
<h2 id="三大系列"><a href="#三大系列" class="headerlink" title="三大系列"></a>三大系列</h2><h3 id="offset-系列-重要"><a href="#offset-系列-重要" class="headerlink" title="offset 系列 (重要)"></a>offset 系列 (重要)</h3><blockquote>
<p>offset 系列用于用于<strong>获取元素自身的大小和位置</strong>，在 webapi 中有广泛应用<br>offset 系列主要有：offsetHeight、offsetWidth、offsetParent、offsetLeft、offsetTop</p>
</blockquote>
<p><strong>offsetHeight 与 offsetWidth</strong></p>
<ul>
<li>获取元素真实的高度和宽度 （内容大小 + border + padding）（关注盒子本身，不关注盒子内部内容）</li>
<li>获取到的是数值类型，方便计算</li>
<li>offsetHeight 与 offsetWidth 是只读属性，不能设置</li>
</ul>
<blockquote>
<p>style.height 与 style.width</p>
<ul>
<li>只能获取和设置行内样式</li>
<li>不包括内边距、边框和外边距</li>
<li>获取到的是字符串类型，需要转换</li>
</ul>
</blockquote>
<p><strong>offsetParent</strong></p>
<ul>
<li>获取离当前元素最近的<strong>定位父元素</strong>(absolute、relative)，如果没有，那就找 body</li>
</ul>
<blockquote>
<p>parentNode : 父节点（没有兼容性问题）</p>
<p>parentElement : 父元素</p>
</blockquote>
<p><strong>offsetLeft 与 offsetTop</strong></p>
<ul>
<li>获取元素自身与 offsetParent 真实的距离</li>
<li>获取到的是数值类型，方便计算</li>
<li>只读属性，只能获取，不能设置</li>
</ul>
<blockquote>
<p>style.left 与 style.top</p>
<ul>
<li>只能获取和设置行内样式</li>
<li>获取到的是字符串，需要转换</li>
</ul>
</blockquote>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102205502.png"></p>
<h3 id="scroll-系列"><a href="#scroll-系列" class="headerlink" title="scroll 系列"></a>scroll 系列</h3><blockquote>
<p>scroll 系列是用来获取<strong>盒子内容的大小和位置</strong></p>
<p>scroll 系列主要有 : scrollWidth、scrollHeight、scrollLeft、scrollTop</p>
</blockquote>
<p><strong>scrollWidth 与 scrollHeight</strong></p>
<ul>
<li>scrollWidth 与 scrollHeight 是盒子内容的宽度和高度。与盒子大小无关，仅仅与<strong>盒子的内容</strong>有关系（padding + 内容）</li>
<li>如果内容没有溢出，scrollHeight 就是盒子高度 (scrollWidth 同理) =&gt; 与 clientHeight、clientWidth 相同</li>
<li>如果内容超过盒子，scrollHieght 就是内容高度 (scrollWidth 同理)</li>
</ul>
<p><strong>scrollTop</strong></p>
<ul>
<li>scrollTop 用于获取内容垂直滚动的像素数。如果没有滚动条，那么 scrollTop 值是 0</li>
<li>内容超过盒子，盒子设置 overflow: scroll 就可出现滚动条</li>
<li>此属性是可读写的</li>
</ul>
<p><strong>scrollLeft</strong></p>
<ul>
<li>scrollLeft 用于获取内容水平滚动的像素数</li>
<li>此属性是可读写的</li>
<li>浏览器切忌这种出现水平滚动条，用户体验极差，避免</li>
</ul>
<p><strong>scrollX 与 scrollY</strong></p>
<ul>
<li><p>只读属性</p>
</li>
<li><p>scrollY：文档在垂直方向已滚动的像素值<br>pageYOffset 属性是 scrollY 属性的别名<br>为了跨浏览器兼容，请使用 window.pageYOffset 代替 window.scrollY</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102205527.png"></p>
<p><strong>onscroll 事件</strong></p>
<p>对于有滚动条的盒子，可以使用 onscroll 注册滚动事件，每滚动一像素，就会触发该事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = doucment.getElementById(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">div.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(div.scrollLeft)</span><br><span class="line">  <span class="built_in">console</span>.log(div.scrollTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景 : 获取页面被卷去的高度和宽度</strong></p>
<blockquote>
<p>通常来说，scroll 家族用的最多的地方就是用来获取页面 <strong>被卷去的高度</strong>，非常的常用</p>
</blockquote>
<ul>
<li>对于老式的浏览器，需要获取 html 或者 body 的 scrollTop</li>
<li>对于现在浏览器，使用 window.pageYOffset 进行获取</li>
</ul>
<p>页面被卷去的高度和宽度的兼容性封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给整个页面注册滚动事件</span></span><br><span class="line"><span class="built_in">document</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scrollTop = <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop || <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> scrollLeft = <span class="built_in">window</span>.pageXOffset || <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft || <span class="number">0</span></span><br><span class="line">  <span class="built_in">console</span>.log(scrollLeft, scrollTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>[案例 : 固定导航案例]</strong></p>
<h3 id="client-家族"><a href="#client-家族" class="headerlink" title="client 家族"></a>client 家族</h3><blockquote>
<p>clien t 家族用于获取盒子可视区的大小 (内容 + padding)</p>
<p>client 家族有 clientWidth、clientHeight、clientLeft、clientTop</p>
</blockquote>
<p><strong>clientWidth、clientHeight 可视区宽高</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102205558.png"></p>
<p><strong>clientTop</strong> 与 <strong>clientLeft</strong> 完全没有用，他们就是 borderTop 与 borderLeft</p>
<p><strong>onresize 事件：onresize 事件会在窗口被调整大小的时候发生。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 事件处理程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景 : client 系列一般用来获取页面的可视区宽高</strong></p>
<blockquote>
<p>低版本浏览器 : 获取的 html 和 body</p>
<p>高版本的浏览器 : window.innerWidth (掌握)（只读属性）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为求的是窗口大小所以用 window</span></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> W = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth</span><br><span class="line">  <span class="built_in">console</span>.log(W)</span><br><span class="line">  <span class="keyword">var</span> H = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">  <span class="built_in">console</span>.log(H)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/428.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/428.html" class="post-title-link" itemprop="url">sublime 插件、快捷键</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-09-12" itemprop="dateCreated datePublished" datetime="2018-09-12T22:32:42+00:00">2018-09-12</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9wYWNrYWdlY29udHJvbC5pby9wYWNrYWdlcy9TdWJsaW1lJTIwVHV0b3I=">Sublime Tutor</span> ：键盘快捷方式教程<br>Help &gt; Sublime Tutor</p>
</li>
<li><p>AlignTab ：自定义快捷键</p>
</li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li><code>Ctrl + X</code> 如果已经选中文本，则剪切该文本。如果未选中任何文本，则剪切光标所在行</li>
<li><code>Ctrl + Z</code> 撤消</li>
<li><code>Ctrl + Shift + V</code> 缩进粘贴</li>
<li><code>Ctrl + Shift + Z</code> 或 <code>Ctrl + Y</code> 恢复</li>
<li><code>Ctrl + L</code> Select line - Repeat to select next lines</li>
<li><code>Ctrl + D</code> Select word - Repeat select others occurrences</li>
<li><code>Ctrl + Shift + D</code> 如果已经选中文本，则复制该文本。如果未选中任何文本，则复制光标所在行</li>
<li><code>Ctrl + Enter</code> Insert line after</li>
<li><code>Ctrl + Shift + Enter</code> Insert line before</li>
<li><code>Alt + F3</code> 选择所有相同单词的实例</li>
<li><code>Tab</code> 或 <code>Ctrl + ]</code> 缩进</li>
<li><code>Shift + Tab</code> 或 <code>Ctrl + [</code> 取消缩进</li>
<li><code>Ctrl + Shift + K</code> Delete Line</li>
<li><code>Ctrl + KK</code> Delete from cursor to end of line</li>
<li><code>Ctrl + K + Backspace</code> Delete from cursor to start of line</li>
<li><code>Alt + Shift + W</code> 使用标签包裹选中部分</li>
<li><code>Ctrl + ←</code> 移动光标至上一个词</li>
<li><code>Ctrl + →</code> 移动光标至下一个词</li>
<li><code>Ctrl + Shift + ↓</code> Move line/selection down</li>
<li><code>Ctrl + Shift + ↑</code> Move line/selection up</li>
<li><code>Home</code> 移动光标至行首</li>
<li><code>End</code> 移动光标至行尾</li>
<li><code>Ctrl + Home</code> 移动光标至文档开头</li>
<li><code>Ctrl + End</code> 移动光标至文档结尾</li>
<li><code>Ctrl + M</code> 跳转到左/右圆括号、方括号、大括号</li>
<li><code>Ctrl + Shift + M</code> 选择括号内的内容</li>
<li><code>Ctrl + R</code> 跳转到定义</li>
<li><code>Ctrl + /</code> Comment/un-comment current line</li>
<li><code>Ctrl + Shift + /</code> Block comment current selection</li>
<li><code>Ctrl + N</code> 新建标签</li>
<li><code>Ctrl + PgUp</code> 向左切换标签</li>
<li><code>Ctrl + PgDn</code> 向右切换标签</li>
<li><code>Ctrl + W</code> 关闭标签</li>
<li><code>Ctrl + Shift + T</code> 重新打开标签</li>
<li><code>Shift + 鼠标右键</code> 竖向选择</li>
<li><code>Ctrl + Shift + &#39;</code> 选择与光标关联的开始和结束标签</li>
<li><code>Ctrl + Shift + A</code> 选择容器内内容</li>
<li><code>Ctrl + Shift + ;</code> 移除与你的光标相关的父标签(清除标记)</li>
<li><code>Ctrl + Shift + Y</code> 计算数学表达式</li>
<li><code>Alt + ↓&amp;↑</code> 以 0.1 的步长改变数字</li>
<li><code>Alt + Shift + ↓&amp;↑</code> 以 10 的步长改变数字</li>
<li><code>Ctrl + ↓&amp;↑</code> 以 1 的步长改变数字</li>
<li><code>Ctrl+K+U</code> <code>Ctrl+K+L</code> 改变大小写</li>
</ul>
<p><span class="exturl" data-url="aHR0cDovL3N1YmxpbWUuZW1wdHlzdGFjay5uZXQv">http://sublime.emptystack.net/</span></p>
<h2 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h2><p>1.</p>
<blockquote>
<p>“Error: 404 Not Found<br>Sorry, the requested URL ‘<span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo1MTAwNC92aWV3LzI5JiMzOTs=">http://127.0.0.1:51004/view/29&#39;</span> caused an error:<br>‘buffer_id(29) is not valid (closed or unsupported file format)’<br>NOTE: If you run multiple instances of Sublime Text, you may want to adjust the server_port option in order to get this plugin work again.”</p>
</blockquote>
<p>Quick Fix 1: Remove Strikethrough Extension</p>
<p><code>Sublime Text &gt; Preferences &gt; Package Settings &gt; OmniMarkupPreviewer &gt; Settings - User</code><br>paste the following to remove the strikeout package.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  &#x27;renderer_options-markdownrenderer&#x27;: &#123;</span><br><span class="line">    <span class="string">&quot;extensions&quot;</span>:[<span class="string">&quot;tables&quot;</span>,<span class="string">&quot;fenced_code&quot;</span>,<span class="string">&quot;codehilite&quot;</span>] ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Quick Fix 2: Fix the Strikethrough Extension (if you need it)</p>
<p>Find the python-markdown sublime package.</p>
<p><code>/Packages/OmniMarkupPreviewer/OmniMarkupLib/Renderers/libs/mdx_strikeout.py</code></p>
<p>Replace the makeExtension() method with the following:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeExtension</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> StrikeoutExtension(*args, **kwargs)</span><br><span class="line">Save, quit <span class="keyword">and</span> reload Sublime Text.</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/426.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/426.html" class="post-title-link" itemprop="url">Markdown 语法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-09-12" itemprop="dateCreated datePublished" datetime="2018-09-12T22:31:19+00:00">2018-09-12</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Markdown-基本语法"><a href="#Markdown-基本语法" class="headerlink" title="Markdown 基本语法"></a>Markdown 基本语法</h2><p>待…</p>
<h2 id="Markdown-使用技巧"><a href="#Markdown-使用技巧" class="headerlink" title="Markdown 使用技巧"></a>Markdown 使用技巧</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul>
<li>方法 1：连续两个以上空格+回车</li>
<li>方法 2：使用 html 语言换行标签：<code>&lt;br&gt;</code></li>
</ul>
<h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><ul>
<li>使用 align 属性</li>
<li>使用<code>&lt;center&gt;</code>标签（HTML5 不支持）</li>
</ul>
<h3 id="首行缩进两个字符"><a href="#首行缩进两个字符" class="headerlink" title="首行缩进两个字符"></a>首行缩进两个字符</h3><ul>
<li><code>&amp;nbsp;</code> 不换行空格，全称 No-Break Space</li>
<li><code>&amp;ensp;</code> 半角的空格，全称是 En Space</li>
<li><code>&amp;emsp;</code> 全角的空格，全称是 Em Space，占据的宽度正好是 1 个中文宽度</li>
</ul>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul>
<li><code>*斜体*或_斜体_</code></li>
<li><code>**粗体**</code></li>
<li><code>***加粗斜体***</code></li>
<li><code>~~删除线~~</code></li>
<li>字号与颜色：使用内嵌 HTML</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;#0099ff&quot;</span> <span class="attr">size</span>=<span class="string">&quot;3&quot;</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span>color=#0099ff size=3 face=&quot;黑体&quot;<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：<font color=#0099ff size=3 face="黑体">color=#0099ff size=3 face=”黑体”</font></p>
<h3 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h3><p>使用内嵌 HTML 借助 table，tr，td 等表格标签的 bgcolor 属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">&quot;orange&quot;</span>&gt;</span>背景色是：orange<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：<table><tr><td bgcolor=orange>背景色是：orange</td></tr></table></p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>在一行中用三个以上的星号 <code>*</code> 、减号 <code>-</code> 、底线 <code>_</code> 来建立一个分隔线，中间用空格隔开，行内不能有其他东西。（除第一个符号的左侧最多添加三个空格外三个相同符号两侧可以添加任意多个空格）</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><ul>
<li>行内式：<code>[文字](url &quot;title&quot;)</code></li>
<li>参考式：<code>[文字][1]</code> <code>[1]:url &quot;title&quot;</code></li>
<li>自动链接：<code>&lt;url&gt;</code>，将链接用&lt;&gt;包起来，Markdown 会自动把它转成链接。</li>
</ul>
<h3 id="图片："><a href="#图片：" class="headerlink" title="图片："></a>图片：</h3><ul>
<li>行内式：<code>![alt_text](url &quot;title&quot;)</code></li>
</ul>
<blockquote>
<p><code>alt_text</code>：图片的 alt 标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于 SEO，可以方便搜索引擎根据 <code>alt_text</code> 里面的关键词搜索到图片。 url：可以是图片的本地地址或者是网址。”title”：鼠标悬置于图片上会出现的标题文字，可以不写。</p>
</blockquote>
<ul>
<li><p>参考式：同上</p>
</li>
<li><p>使用 img 标签：<code>&lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;</code>，<code>&lt;div align=center&gt;&lt;/div&gt;</code> 实现居中</p>
</li>
</ul>
<h3 id="折叠按钮"><a href="#折叠按钮" class="headerlink" title="折叠按钮"></a>折叠按钮</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span></span><br><span class="line">    点击展开</span><br><span class="line">  <span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内部展示内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>

<details>
  <summary>
    点击展开
  </summary>

<p>设置小三角样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">summary</span>::-webkit-details-marker &#123;</span><br><span class="line">  color: <span class="number">#42b983</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="Markdown-编辑器"><a href="#Markdown-编辑器" class="headerlink" title="Markdown 编辑器"></a>Markdown 编辑器</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudHlwb3JhLmlvLw==">typora</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/421.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/421.html" class="post-title-link" itemprop="url">git 版本控制系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-09-12" itemprop="dateCreated datePublished" datetime="2018-09-12T22:28:19+00:00">2018-09-12</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/frontend/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么要有版本控制系统"><a href="#为什么要有版本控制系统" class="headerlink" title="为什么要有版本控制系统"></a>为什么要有版本控制系统</h2><p>在开发过程中，经常需要对一个文件进行修改甚至删除，但是我们又希望能够保存这个文件的历史记录，如果通过备份，那么管理起来会非常的复杂</p>
<h2 id="什么是版本控制系统"><a href="#什么是版本控制系统" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h2><blockquote>
<p>版本控制系统（Version Control System）:是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
</blockquote>
<p>版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。</p>
<h2 id="版本控制系统的分类"><a href="#版本控制系统的分类" class="headerlink" title="版本控制系统的分类"></a>版本控制系统的分类</h2><p>参考文章：<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YxLyVFOCVCNSVCNyVFNiVBRCVBNS0lRTUlODUlQjMlRTQlQkElOEUlRTclODklODglRTYlOUMlQUMlRTYlOEUlQTclRTUlODglQjY=">关于版本控制的介绍</span></p>
<h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102202248.png"></p>
<p>本地版本控制系统就是在一台机器上，记录版本的不同变化，保证内容不会丢失</p>
<ol>
<li>如果多人开发，每个人都在不同的系统和电脑上开发，没办法协同工作。</li>
</ol>
<h3 id="集中式版本控制系統"><a href="#集中式版本控制系統" class="headerlink" title="集中式版本控制系統"></a>集中式版本控制系統</h3><p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102202303.png"></p>
<p><code>svn</code> 是集中式的版本控制系统，集中式版本控制系统都有一个单一的集中管理的服务器（中央服务器），保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>
<ol>
<li>需要一个中央服务器来管理代码的的版本和备份</li>
<li>所有的用户电脑都是从中央服务器获取代码或者是将本地的代码提交到中央服务器</li>
<li>依赖与网络环境，如果连不上中央服务器，就无法提交和获取代码。</li>
</ol>
<h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102202325.png"></p>
<p><code>git</code> 是分布式的版本控制系统。分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份</p>
<ol>
<li>需要一台服务器作为代码仓库</li>
<li>每个用户电脑都是一个服务器（代码仓库），并且和代码仓库是镜像的，用户修改和获取代码都是提交到自己的服务器当中。</li>
<li>不需要网络就可以进行工作。</li>
<li>当连接网络时，用户可以选择将自己的服务器与代码仓库进行同步。</li>
</ol>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3Yy">git 官方中文文档</span></p>
<h2 id="Git-核心概念"><a href="#Git-核心概念" class="headerlink" title="Git 核心概念"></a>Git 核心概念</h2><ul>
<li><p>**<code>WorkSpace</code>**：<br>工作区，即从仓库中 checkout 出来的，需要通过 Git 进行版本控制的目录和文件，可以简单的理解为在电脑里真实看到的文件</p>
</li>
<li><p>**<code>Stage(Index)</code>**：<br>暂存区，或者叫做待提交更新区；在提交进入 Repository 之前，可以把所有的更新放在暂存区, 用 <code>git add</code> 的文件都在这里</p>
</li>
<li><p>**<code>Repository(Remote/Local)</code>**：<br>仓库，一个存放在远端/本地的版本库，用 <code>git commit</code> 提交的文件就到 Local Repository,用 <code>git push</code> 提交的文件就到 Remote Repository</p>
</li>
<li><p>**<code>.git</code>**：存放 Git 管理信息的目录，初始化仓库的时候会自动创建</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102202341.jpeg"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102202402.png"></p>
<h2 id="Git-初始设置"><a href="#Git-初始设置" class="headerlink" title="Git 初始设置"></a>Git 初始设置</h2><h3 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户名使用英文</span></span><br><span class="line"><span class="comment"># --global 全局设置</span></span><br><span class="line">git config --global user.name <span class="string">&#x27;your_name&#x27;</span></span><br><span class="line">git config --global user.email <span class="string">&#x27;your_email@example.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看账号信息</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置信息</span></span><br><span class="line">git config --<span class="built_in">unset</span> -- user.name</span><br></pre></td></tr></table></figure>

<p>全局设置会在 <code>~/.gitconfig</code> 中以如下形式输出设置文件，可以直接编辑这个文件来修改设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = your_name</span><br><span class="line">email = your_email@example.com</span><br></pre></td></tr></table></figure>

<p>每个仓库的 Git 配置文件都放在 <code>.git/config</code> 文件中，可以直接修改此文件<br><code>$ cat .git/config</code> 查看配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解决中文变成数字加百分号，也可以在设置中将编码修改为 utf-8</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="设置-SSH-Key"><a href="#设置-SSH-Key" class="headerlink" title="设置 SSH Key"></a>设置 SSH Key</h3><p>GitHub 上连接已有仓库时的认证，是通过使用了 SSH 的公开密钥认证方式进行的。现在我们来创建公开密钥认证所需的 SSH Key，并将其添加至 GitHub</p>
<p>运行下面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key(/Users/your_user_directory/.ssh/id_rsa):按回车键</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):输入密码</span><br><span class="line">Enter same passphrase again:再次输入密码</span><br></pre></td></tr></table></figure>

<p>输入密码后会出现以下结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/your_user_directory/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/your_user_directory/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:SHA256:hbn1zPihlVDe/Y2FvzzZU8l+AOSlVRlaOmro/nTQDGg cui3155@gmail.com(fingerprint值+your_email@example.com)</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|            o o++|</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">|        . . .   +|</span></span><br><span class="line"><span class="string">|         ...     |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure>

<p><code>id_rsa</code> 文件是私有密钥，<code>id_rsa.pub</code> 是公开密钥</p>
<h3 id="添加公开密钥"><a href="#添加公开密钥" class="headerlink" title="添加公开密钥"></a>添加公开密钥</h3><p>在 GitHub 中添加公开密钥，今后就可以用私有密钥进行认证了<br>点击右上角的账户设定按钮（Account Settings），选择 SSH Keys 菜单。点击 AddSSH Key 之后，在 Title 中输入适当的密钥名称。Key 部分请粘贴 id_rsa.pub 文件里的内容</p>
<p><code>id_rsa.pub</code> 的内容可以用如下方法查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa公开密钥的内容your_email@example.com</span><br></pre></td></tr></table></figure>

<p>完成以上设置后，就可以用手中的私人密钥与 GitHub 进行认证和通信了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">The authenticity of host <span class="string">&#x27;github.com (192.30.255.113)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is (fingerprint值).</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?输入yes</span></span><br><span class="line"><span class="string">Warning: Permanently added &#x27;</span>github.com,192.30.255.113<span class="string">&#x27; (RSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">Enter passphrase for key &#x27;</span>/c/Users/C.DESKTOP-3S4APJ4/.ssh/id_rsa<span class="string">&#x27;:</span></span><br></pre></td></tr></table></figure>

<p>出现如下结果即为成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hi cuilongjin! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

<h3 id="提高命令输出的可读性"><a href="#提高命令输出的可读性" class="headerlink" title="提高命令输出的可读性"></a>提高命令输出的可读性</h3><p>将 <code>color.ui</code> 设置为 <code>auto</code> 可以让命令的输出拥有更高的可读性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><code>~/.gitconfig</code> 中会增加下面一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[color]</span><br><span class="line">ui = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>这样一来，各种命令的输出就会变得更容易分辨。</p>
<h3 id="文件名大小写问题"><a href="#文件名大小写问题" class="headerlink" title="文件名大小写问题"></a>文件名大小写问题</h3><p>git 默认对文件名大小写不敏感</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 git 大小写敏感</span></span><br><span class="line">git config core.ignorecase <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者先删除文件在添加进去</span></span><br></pre></td></tr></table></figure>

<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>通过 Gravatar 服务</p>
<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 st 别名表示 status</span></span><br><span class="line">git config --global alias.st status</span><br><span class="line"></span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">&#x27;reset HEAD&#x27;</span></span><br><span class="line">git config --global alias.last <span class="string">&#x27;log -1&#x27;</span></span><br><span class="line"></span><br><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="搭建-Git-服务器"><a href="#搭建-Git-服务器" class="headerlink" title="搭建 Git 服务器"></a>搭建 Git 服务器</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxMzczOTUxNjMwNTkyOTYwNmRkMTgzNjEyNDg1NzhjNjdiODA2N2M4YzAxN2IwMDAvMDAxMzc1ODM3NzAzNjA1NzliYzRiNDU4ZjA0NGNlN2FmZWQzZGY1NzkxMjNlY2EwMDA=">搭建 Git 服务器</span></p>
<h3 id="配置多用户"><a href="#配置多用户" class="headerlink" title="配置多用户"></a>配置多用户</h3><p>根据不同邮箱生成对应的私钥公钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C email</span><br></pre></td></tr></table></figure>

<p>将公钥上传到对应的用户账号中</p>
<p>在 <code>.ssh</code> 目录创建 <code>config</code> 文件，配置私钥对应的服务器，每个账号单独配置一个 Host，每个 Host 要取一个别名，每个 Host 主要配置 HostName 和 IdentityFile 两个属性即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置用户1</span><br><span class="line">Host github</span><br><span class="line">HostName github.com</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line">User cuilongjin</span><br><span class="line"></span><br><span class="line"># 配置用户2</span><br><span class="line">Host gitlab</span><br><span class="line">HostName git.gitlab.net</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_gitlab</span><br><span class="line">User cuilongjin</span><br></pre></td></tr></table></figure>

<p>Host 的名字可以任意，不过这个会影响 git 相关命令，例如：</p>
<p>Host mygithub 这样定义的话，命令如下</p>
<p><code>git clone git@mygithub:cuilongjin/cuilongjin.git</code></p>
<p>即 git@ 后面紧跟的名字改为 mygithub</p>
<p>执行 <code>ssh -T git@github</code>、<code>ssh -T git@gitlab</code> 测试是否成功</p>
<p>配置局部 git 用户名和邮箱，如果没有局部配置，默认用全局配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name <span class="string">&quot;Your name&quot;</span></span><br><span class="line">git config user.email <span class="string">&quot;your_email@gmail.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者直接找到 <code>.git/config</code> 文件，添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = Your name</span><br><span class="line">email = your_email@gmail.com</span><br></pre></td></tr></table></figure>

<h2 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>如果初始化成功，执行了 <code>git init</code> 命令的目录下就会生成 <code>.git</code> 目录。这个 <code>.git</code> 目录里存储着管理当前目录内容所需的仓库数据</p>
<blockquote>
<p><code>mkdir project</code> 命令创建 project 空文件夹</p>
</blockquote>
<ul>
<li><code>pwd</code> 命令用于显示当前目录</li>
</ul>
<h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将指定文件夹添加到暂存区（目录中的所有文件，包括新增/修改/删除的文件）--not-all 忽略删除的</span></span><br><span class="line">git add 目录名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 指定文件 添加到暂存区 （文件可以是新增/修改/删除的）</span></span><br><span class="line">git add README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录下所有的js文件添加到暂存区（文件可以是新增/修改的，不包括删除的）</span></span><br><span class="line">git add *.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录及子目录下件 （文件可以是新增/修改/删除的）</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前仓库下所有的文件 （文件可以是新增/修改/删除的）</span></span><br><span class="line">git add -A</span><br><span class="line">git add --all</span><br></pre></td></tr></table></figure>

<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件从暂存区提交到仓库</span></span><br><span class="line">git commit -m <span class="string">&#x27;提交说明&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是一个已经暂存过的文件，可以快速提交，如果是未追踪的文件，那么命令将不生效。</span></span><br><span class="line">git commit -a -m <span class="string">&#x27;提交说明&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改最近的一次提交说明， 如果提交说明不小心输错了，可以使用这个命令</span></span><br><span class="line">git commit --amend -m <span class="string">&#x27;提交说明&#x27;</span></span><br></pre></td></tr></table></figure>

<p>-m 参数后的 <code>&#39;First commit&#39;</code> 称作提交信息，是对这个提交的概述,如果想要记述得更加详细，请不加 <code>-m</code> ，直接执行 <code>git commit</code> 命令，执行后编辑器就会启动。<br>在编辑器中记述提交信息的格式如下:<br>​ 第一行：用一行文字简述提交的更改内容<br>​ 第二行：空行<br>​ 第三行以后：记述更改的原因和详细内容</p>
<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立 README.md 文件作为管理对象</span></span><br><span class="line">touch README.md</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化日志输出格式</span></span><br><span class="line">git stauts -s (short)</span><br></pre></td></tr></table></figure>

<p><code>git status</code> 命令可以让我们时刻掌握仓库当前的状态，但不能看到具体修改了什么内容，需要用 <code>git diff</code> 这个命令来查看具体修改内容。</p>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前工作树和最新add之间（暂存区）的差别（difference）</span></span><br><span class="line">git diff</span><br><span class="line"><span class="comment"># 如果尚未用 `git add` 命令向暂存区添加任何东西，则程序只会显示工作树与最新提交状态之间的差别</span></span><br><span class="line"><span class="comment"># “+”号标出的是新添加的行，被删除的行则用“-”号标出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看README.md文件的修改</span></span><br><span class="line">git diff -- README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看工作树和最新提交的差别</span></span><br><span class="line">git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂存区与仓库区的不同</span></span><br><span class="line">git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个版本之间的不同</span></span><br><span class="line">git diff c265262 de4845b</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HEAD 是指向当前分支中最新一次提交的指针</p>
</blockquote>
<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前版本之前的提交信息</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">commit 9f129bae19b2c82fb4e98cde5890e52a6c546922</span><br><span class="line">Author: cuilongjin &lt;cuilongjin@gmail.com&gt;</span><br><span class="line">Date: Sun Oct 8 22:08:39 2017 +0900</span><br><span class="line">    First commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示提交信息的第一行</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline <span class="comment"># 完整显示版本号</span></span><br><span class="line">git <span class="built_in">log</span> --oneline  <span class="comment"># 只显示前7位版本号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定目录、文件的日志</span></span><br><span class="line">git <span class="built_in">log</span> 目录名或文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件的改动（q键退出命令）</span></span><br><span class="line">git <span class="built_in">log</span> -p 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有曾经提交的版本（包括被删除的）</span></span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图表形式显示</span></span><br><span class="line">git <span class="built_in">log</span> --graph --pretty=<span class="string">&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an %ae&gt;%Creset&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset -h		<span class="string">&#x27;查看帮助&#x27;</span></span><br><span class="line">--mixed				<span class="string">&#x27;reset HEAD and index&#x27;</span>(默认)</span><br><span class="line">--soft				<span class="string">&#x27;reset only HEAD&#x27;</span></span><br><span class="line">--hard  			<span class="string">&#x27;reset HEAD, index and working tree&#x27;</span></span><br><span class="line">--merge 			<span class="string">&#x27;reset HEAD, index and working tree&#x27;</span></span><br><span class="line">--keep 				<span class="string">&#x27;reset HEAD but keep local changes&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li> <code>HEAD</code> 表示当前版本，上一个版本就是 <code>HEAD^</code> ，上上一个版本就是 <code>HEAD^^</code> ，当然往上 100 个版本写 100 个^比较容易数不过来，所以写成 <code>HEAD~100</code></li>
<li> 使用 <code>commit_id</code> 回退 , <code>git reflog</code> 用来记录你的每一次命令和 <code>commit_id</code></li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br><span class="line">git reset --hard commit_id</span><br><span class="line">git reset HEAD [file]</span><br></pre></td></tr></table></figure>

<h3 id="git-checkout-–file"><a href="#git-checkout-–file" class="headerlink" title="git checkout –file"></a>git checkout –file</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- README.md</span><br></pre></td></tr></table></figure>

<p>把 README.md 文件在 <code>工作区的修改全部撤销</code> ，<strong>用版本库里的版本替换工作区的版本</strong></p>
<p>这里有两种情况：</p>
<ol>
<li><p>一种是 README.md 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态</p>
</li>
<li><p>一种是 README.md 已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态</p>
</li>
</ol>
<p>总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态，可用于<strong>撤销文件修改或恢复误删文件</strong></p>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:cuilongjin/git_test.git</span><br></pre></td></tr></table></figure>

<p>添加后，远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看远程库的信息</span></span><br><span class="line">git remote -v</span><br><span class="line">origin  git@github.com:cuilongjin/git_test.git (fetch)</span><br><span class="line">origin  git@github.com:cuilongjin/git_test.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定远程库的详细信息</span></span><br><span class="line">git remote show &lt;远程库&gt;</span><br></pre></td></tr></table></figure>

<p>上面显示了可以抓取和推送的 origin 的地址。如果没有推送权限，就看不到 push 的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除已有的 GitHub 远程库</span></span><br><span class="line">git remote rm origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程库名称</span></span><br><span class="line">git remote rename &lt;原远程库名&gt; &lt;新远程库名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取远程仓库的更新，并且与本地的分支进行合并</span></span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略</span></span><br><span class="line">git pull origin next 等同于 git fetch origin &amp;&amp; git merge origin/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支</span></span><br><span class="line"><span class="comment"># 加上参数 -p 就会在本地删除远程已经删除的分支</span></span><br><span class="line">$ git pull -p</span><br><span class="line"><span class="comment"># 等同于下面的命令</span></span><br><span class="line">$ git fetch --prune origin</span><br><span class="line">$ git fetch -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并 pull 两个不同的项目出现 fatal: refusing to merge unrelated histories</span></span><br><span class="line">git pull origin master ----allow-unrelated-histories</span><br></pre></td></tr></table></figure>

<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次推送分支时，加上 -u 参数，git 会把本地分支和远程分支关联起来，在以后的推送或者拉取时就可以简化命令</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有本地分支，表示删除远程分支</span></span><br><span class="line">git push origin :master</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ git push origin --delete master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以强制覆盖的方式推送修改后的 repo （重新上传 repo）（不指定分支即所有分支）</span></span><br><span class="line">git push origin --force --all</span><br></pre></td></tr></table></figure>

<blockquote>
<p>remote: error: GH007: Your push would publish a private email address.<br>解决方法——<span class="exturl" data-url="aHR0cDovL2dpdGh1Yi5jb20vc2V0dGluZ3MvZW1haWxz">http://github.com/settings/emails</span> 把 Keep my email address private 这一项去掉勾选即可。</p>
</blockquote>
<p>如果推送失败，则因为远程分支比你的本地更新，需要先用 <code>git pull</code> 拉取远程的新提交</p>
<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:cuilongjin/仓库名.git [指定文件夹]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认远程主机为 origin ， -o 指定主机名</span></span><br><span class="line">git <span class="built_in">clone</span> --o origin1 git@github.com:cuilongjin/仓库名.git</span><br></pre></td></tr></table></figure>

<p>Git 支持多种协议，包括 https，但通过 ssh 支持的原生 git 协议速度最快</p>
<p>从远程库 clone 时，默认情况下，只能看到本地的 master 分支<br>要在 dev 分支上开发，就必须创建远程 origin 的 dev 分支到本地，于是用这个命令创建本地 dev 分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地 dev 分支与远程 origin/dev 分支的链接</span></span><br><span class="line">git branch --set-upstream dev origin/dev</span><br></pre></td></tr></table></figure>

<p>克隆指定分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git clone -b|--branch 分支名或tag名 仓库地址</span></span><br></pre></td></tr></table></figure>

<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将某个远程仓库的更新，全部取回本地。默认取回所有分支（branch）的更新</span></span><br><span class="line">git fetch &lt;远程仓库&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回特定分支的更新</span></span><br><span class="line">git fetch &lt;远程仓库&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<p>git fetch 和 git pull 区别</p>
<ul>
<li><p>git pull 获取远程仓库的更新，并且与本地的分支进行合并</p>
</li>
<li><p>git fetch 所取回的更新，在本地主机上要用 “远程仓库/分支名” 的形式读取，即不会与本地分支合并</p>
</li>
</ul>
<h3 id="git-忽视文件"><a href="#git-忽视文件" class="headerlink" title="git 忽视文件"></a>git 忽视文件</h3><p>在仓库中，有些文件是不想被 git 管理的，比如数据的配置密码、写代码的一些思路等。git 可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了</p>
<p>忽略文件的原则是：</p>
<ul>
<li>忽略操作系统自动生成的文件，比如缩略图等</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 .class 文件</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件</li>
</ul>
<p>在仓库的根目录创建一个 <code>.gitignore</code> 的文件，文件名是固定的</p>
<p>将不需要被 git 管理的文件路径添加到 <code>.gitignore</code> 中，把 <code>.gitignore</code> 也提交到 Git，Git 就会自动忽略这些文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 忽视 index.txt 文件</span><br><span class="line">index.txt</span><br><span class="line"></span><br><span class="line"># 忽视 .gitignore 文件</span><br><span class="line">.gitignore</span><br><span class="line"></span><br><span class="line"># 忽视 css 下的 index.css 文件</span><br><span class="line">css/index.css</span><br><span class="line"></span><br><span class="line"># 忽视 css 下的所有的 css 文件</span><br><span class="line">css/*.css</span><br><span class="line"></span><br><span class="line"># 忽视 css 下的所有文件</span><br><span class="line">css/*.*</span><br><span class="line"></span><br><span class="line"># 忽视 css 文件夹</span><br><span class="line">css</span><br></pre></td></tr></table></figure>

<p>GitHub 已经为我们准备了各种配置文件 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9naXRpZ25vcmU=">https://github.com/github/gitignore</span></p>
<p>强制添加被 .gitignore 忽略的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 强制添加被.gitignore忽略的文件</span></span><br><span class="line">git add -f &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查哪个规则忽略了此文件，以便修订规则</span></span><br><span class="line">git check-ignore -v &lt;file&gt;</span><br><span class="line">.gitignore:x:xxx.xx    xxxxxx</span><br></pre></td></tr></table></figure>

<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>在 git 中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。git 中使用 HEAD 指向当前分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">* master</span><br><span class="line"></span><br><span class="line">-r 参数查看远程分支</span><br><span class="line">-a 查看所有分支(远程分支会用红色表示出来)</span><br></pre></td></tr></table></figure>

<p><code>*</code>（星号）表示当前所在的分支</p>
<ul>
<li>git checkout -b 创建、切换分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以 branch 为基础创建名为 feature-A 的分支</span></span><br><span class="line">git checkout -b feature-A &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>连续执行下面两条命令也能收到同样效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 feature-A 分支</span></span><br><span class="line">git branch feature-A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前分支切换为 feature-A 分支</span></span><br><span class="line">git checkout feature-A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换回上一个分支</span></span><br><span class="line">git checkout -</span><br></pre></td></tr></table></figure>

<ul>
<li>git branch -d 删除分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除本地 feature-A 分支</span></span><br><span class="line">git branch -d feature-A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行删除本地 feature-A 分支</span></span><br><span class="line">git branch -D feature-A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程 feature-A 分支</span></span><br><span class="line">git push origin :feature-A</span><br><span class="line">或 git push origin --delete feature-A</span><br></pre></td></tr></table></figure>

<ul>
<li>git branch -m 重命名分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名本地分支</span></span><br><span class="line">git branch -m old_branch new_branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名远程分支</span></span><br><span class="line"><span class="comment"># 重命名本地分支 -&gt; 删除远程分支 -&gt; 推送到远程分支</span></span><br></pre></td></tr></table></figure>

<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>合并分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 feature-A 合并到 master 上</span></span><br><span class="line"><span class="comment"># 首先切换到 master 分支，然后执行</span></span><br><span class="line">git merge [--squash] [--no-ff] -m <span class="string">&quot;描述&quot;</span> feature-A</span><br><span class="line">--squash <span class="comment"># 只是将&lt;branch&gt;中的修改内容迁移过来，而不保留其中的commit历史</span></span><br><span class="line">--no-ff <span class="comment"># 创建合并提交，为了在历史记录中明确记录下本次分支合并</span></span><br></pre></td></tr></table></figure>

<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把当前工作现场“储藏”起来</span></span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看存储的工作现场</span></span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure>

<p>恢复工作现场</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复工作现场，stash 内容并不删除</span></span><br><span class="line">git stash apply</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 stash 内容</span></span><br><span class="line">git stash drop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复的同时把 stash 内容也删了</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<p>恢复指定的 stash，用命令：<code>git stash apply stash@&#123;0&#125;</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxMzczOTUxNjMwNTkyOTYwNmRkMTgzNjEyNDg1NzhjNjdiODA2N2M4YzAxN2IwMDAvMDAxMzc1ODQwMDM4OTM5YzI5MTQ2N2NjN2M3NDdiMTgxMGFhYjJmYjg4NjM1MDgwMDA=">廖雪峰 Git 教程创建与合并分支</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxMzczOTUxNjMwNTkyOTYwNmRkMTgzNjEyNDg1NzhjNjdiODA2N2M4YzAxN2IwMDAvMDAxMzc1ODQxMDM2NDQ1N2I5ZTNkODIxZjQyNDRiZWIwZmQ2OWM2MWExODVhZTAwMDA=">廖雪峰 Git 教程分支管理策略</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxMzczOTUxNjMwNTkyOTYwNmRkMTgzNjEyNDg1NzhjNjdiODA2N2M4YzAxN2IwMDAvMDAxMzc2MDIzNTkxNzg3OTRkOTY2OTIzZTVjNDEzNGJjOGJmOThkZmIwM2FlYTMwMDA=">廖雪峰 Git 教程 Bug 分支</span></p>
<h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><ul>
<li>创建标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先切换到需要打标签的分支上</span></span><br><span class="line"><span class="comment"># 默认标签是打在最新提交的 commit 上的</span></span><br><span class="line">git tag v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对指定某一次提交打标签</span></span><br><span class="line">git tag v1.0 &lt;commit id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字</span></span><br><span class="line">git tag -a v1.0 -m <span class="string">&quot;version1.0 released&quot;</span> &lt;commit id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 -s 用私钥签名一个标签(需配置gpg密钥对)</span></span><br><span class="line">git tag -s v1.0 -m <span class="string">&quot;signed version1.0 released&quot;</span> &lt;commit id&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有标签</span></span><br><span class="line">git tag</span><br><span class="line">v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有标签信息</span></span><br><span class="line">git show</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 v1.0 标签信息</span></span><br><span class="line">git show v1.0</span><br><span class="line">commit id:xxx</span><br><span class="line">Author:xxx</span><br><span class="line">Date:xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>推送标签到远程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推送 v1.0 标签到远程</span></span><br><span class="line">git push origin v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送全部尚未推送的本地标签到远程</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<ul>
<li>删除标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除本地标签 v1.0</span></span><br><span class="line">git tag -d v1.0</span><br><span class="line"><span class="comment"># 删除远程标签 v1.0</span></span><br><span class="line">git push origin :refs/tags/v1.0</span><br><span class="line">或 git push origin --delete tag v1.0</span><br></pre></td></tr></table></figure>

<h2 id="git-仓库分离"><a href="#git-仓库分离" class="headerlink" title="git 仓库分离"></a>git 仓库分离</h2><p>将一个 git 仓库里的一部分文件转出作为一个独立的仓库并保留提交记录 commit log</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这就是那个大仓库 big-project</span><br><span class="line">git clone git@github.com:**/big-project.git</span><br><span class="line">cd big-project</span><br><span class="line"># 把所有 `source/page` 目录下的相关提交整理为一个新的分支 page</span><br><span class="line">git subtree split -P source/page -b page</span><br><span class="line"># 另建一个新目录并初始化为 git 仓库</span><br><span class="line">mkdir ../page</span><br><span class="line">cd ../page</span><br><span class="line">git init</span><br><span class="line"># 拉取旧仓库的 page 分支到当前的 master 分支</span><br><span class="line">git pull ../big-project page</span><br></pre></td></tr></table></figure>

<h2 id="快速克隆大项目"><a href="#快速克隆大项目" class="headerlink" title="快速克隆大项目"></a>快速克隆大项目</h2><p>克隆单个分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --branch &lt;branch_name&gt; &lt;remote-address&gt;</span><br></pre></td></tr></table></figure>

<p>只克隆最新的提交记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;remote-address&gt; --depth 1</span><br></pre></td></tr></table></figure>

<p>– depth 代表克隆的深度，–depth 1 代表只克隆最新一次提交记录以及这次提交之后的最新内容，不克隆历史提交，所造成的影响就是不能查看历史提交记录</p>
<p>克隆单个分支的最新一次提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --branch &lt;branch_name&gt; &lt;remote-address&gt; --depth 1</span><br></pre></td></tr></table></figure>

<h2 id="git-修改提交历史"><a href="#git-修改提交历史" class="headerlink" title="git 修改提交历史"></a>git 修改提交历史</h2><p>修改最后一条 commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>修改多条 commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~3 修改最近三次提交</span><br><span class="line">git rebase -i --root 修改所有提交</span><br><span class="line"></span><br><span class="line">git rebase -i  [startpoint]  [endpoint] 指定了一个编辑区间（不包含[startpoint]），如果不指定[endpoint]，则该区间的终点默认是当前分支 HEAD 所指向的 commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># edit 模式下</span></span><br><span class="line">git commit --amend --author=<span class="string">&quot;author &lt;email&gt;&quot;</span> <span class="comment"># 修改提交人信息</span></span><br><span class="line">git commit --amend  --date=<span class="string">&quot;commit_time&quot;</span> <span class="comment"># 修改时间 时间格式 Sat, 24 Dec 2016 18:12:09 +0800</span></span><br></pre></td></tr></table></figure>

<p>Commands</p>
<p><strong>p</strong>, pick = use commit: 直接使用 commit 不做任何修改，其中 p 是 pick 的缩写，以下雷同</p>
<p><strong>r</strong>, reword = use commit, but edit the commit message: 使用 commit，修改 commit 注释</p>
<p><strong>e</strong>, edit = use commit, but stop for amending :使用 commit，但是遇到此命令时会停止合并，可以修改提交信息</p>
<p><strong>s</strong>, squash = use commit, but meld into previous commit: 使用 commit，但是会合并到前一个 commit 中，默认保留所有的 commit 注释，并变为可以修改状态</p>
<p><strong>f</strong>, fixup = like “squash”, but discard this commit’s log message：和 squash 类似，但是会抛弃 commit 的 log 信息</p>
<p><strong>x</strong>, exec = run command (the rest of the line) using shell：使用 shell 运行命令</p>
<p><strong>d</strong>, drop = remove commit：丢弃 commit，（并删除该提交所做的修改）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82N2YyMGQxOTYwNWE=">https://www.jianshu.com/p/67f20d19605a</span></p>
<h2 id="git-bisect"><a href="#git-bisect" class="headerlink" title="git-bisect"></a>git-bisect</h2><p>git 有一个以二分法帮助定位问题的命令——bisect。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开始二分查找问题</span></span><br><span class="line">git bisect start</span><br><span class="line"><span class="comment"># 标记当前有问题</span></span><br><span class="line">git bisect bad</span><br><span class="line"><span class="comment"># 标记哪个 commit 或 tag 时是没问题的</span></span><br><span class="line">git bisect good v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时 git 会 checkout 两个点之间的某个 commit，</span></span><br><span class="line"><span class="comment"># 如果此时还是有问题：</span></span><br><span class="line">git bisect bad</span><br><span class="line"><span class="comment"># 如果此时没有问题：</span></span><br><span class="line">git bisect good</span><br><span class="line"><span class="comment"># 接着 git 会 checkout 下一个「有问题」和「没问题」之间的 commit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直到定位到问题，git 会提示：xxxxxxx is first bad commit</span></span><br></pre></td></tr></table></figure>

<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL0dpdC0lRTUlQjclQTUlRTUlODUlQjctJUU0JUJEJUJGJUU3JTk0JUE4LUdpdC0lRTglQjAlODMlRTglQUYlOTU=">https://git-scm.com/book/zh/v2/Git-工具-使用-Git-调试</span></p>
<h2 id="git-filter-branch"><a href="#git-filter-branch" class="headerlink" title="git filter-branch"></a>git filter-branch</h2><p>彻底删除不需要的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除 ./node_modules 目录</span></span><br><span class="line">git filter-branch -f --prune-empty --index-filter <span class="string">&quot;git rm --cached --ignore-unmatch -fr ./node_modules&quot;</span> -- --all</span><br></pre></td></tr></table></figure>

<p>修改提交用户名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git filter-branch -f --env-filter <span class="string">&quot;GIT_AUTHOR_NAME=your new author name&quot;</span> -- --all</span><br></pre></td></tr></table></figure>

<p>修改提交邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git filter-branch -f --env-filter <span class="string">&quot;GIT_AUTHOR_EMAIL=your new author email&quot;</span> -- --all</span><br></pre></td></tr></table></figure>

<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h3 id="git-add-的时候遇到warning-LF-will-be-replaced-by-CRLF-in-……"><a href="#git-add-的时候遇到warning-LF-will-be-replaced-by-CRLF-in-……" class="headerlink" title="git add .的时候遇到warning: LF will be replaced by CRLF in ……`"></a>git add .<code>的时候遇到</code>warning: LF will be replaced by CRLF in ……`</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config core.autocrlf</span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># true：添加文件到git仓库时，git将其视为文本文件。他将把crlf变成lf</span></span><br><span class="line"><span class="comment"># false：line-endings将不做转换操作。文本文件保持原来的样子</span></span><br><span class="line"><span class="comment"># input：把crlf转成lf，当有人Check代码时还是lf方式。因此在window操作系统下，不要使用这个设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CRLF (carriagereturnlinefeed)：表示句尾使用回车换行两个字符(即Windows编程时使用&quot;\r\n&quot;换行)</span></span><br><span class="line"><span class="comment"># LF(line feed)：表示句尾只使用换行(Unix Style)</span></span><br><span class="line"><span class="comment"># CR：表示只使用回车</span></span><br></pre></td></tr></table></figure>

<h3 id="Git-永久删除文件-包括历史记录"><a href="#Git-永久删除文件-包括历史记录" class="headerlink" title="Git 永久删除文件(包括历史记录)"></a>Git 永久删除文件(包括历史记录)</h3><p><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvcmVtb3Zpbmctc2Vuc2l0aXZlLWRhdGEtZnJvbS1hLXJlcG9zaXRvcnkv">https://help.github.com/articles/removing-sensitive-data-from-a-repository/</span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在仓库的根目录执行</span></span><br><span class="line">git filter-branch --force --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch 文件路径&#x27;</span> --prune-empty --tag-name-filter cat -- --all</span><br><span class="line"><span class="comment"># 文件路径相对于git仓库根目录</span></span><br><span class="line"><span class="comment"># 删除文件夹 添加 -r 命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以强制覆盖的方式推送修改后的 repo （不指定分支即所有分支）（重新上传 repo）</span></span><br><span class="line">git push origin --force --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制推送 tags</span></span><br><span class="line">git push origin --force --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理和回收空间</span></span><br><span class="line">rm -rf .git/refs/original/</span><br><span class="line">git reflog expire --expire=now --all</span><br><span class="line">git gc --prune=now</span><br><span class="line">git gc --aggressive --prune=now</span><br></pre></td></tr></table></figure>

<p>重新<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL0dpdC1CcmFuY2hpbmctUmViYXNpbmc=">绑定</span>，而不是合并创建的旧（受污染）存储库历史记录中的任何分支</p>
<ul>
<li>git 修改已提交的某一次的邮箱和用户信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git filter-branch -f --env-filter \</span><br><span class="line"><span class="string">&quot;GIT_AUTHOR_NAME=&#x27;Newname&#x27;; GIT_AUTHOR_EMAIL=&#x27;newemail&#x27;; \</span></span><br><span class="line"><span class="string">GIT_COMMITTER_NAME=&#x27;committed-name&#x27;; GIT_COMMITTER_EMAIL=&#x27;committed-email&#x27;;&quot;</span> HEAD</span><br></pre></td></tr></table></figure>

<h3 id="fork-的项目-A-与原项目-B-保持同步"><a href="#fork-的项目-A-与原项目-B-保持同步" class="headerlink" title="fork 的项目( A )与原项目 (B) 保持同步"></a>fork 的项目( A )与原项目 (B) 保持同步</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 A 克隆到本地做中转</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 B 远程仓库地址并拉取</span></span><br><span class="line">git remote add update &lt;B 远程仓库地址&gt;</span><br><span class="line">git fetch update master:updated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并并解决冲突</span></span><br><span class="line">git merge updated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接合并远程分支</span></span><br><span class="line">git merge update/master</span><br></pre></td></tr></table></figure>

<h3 id="远程分支删除以后，本地显示仍然存在的解决办法"><a href="#远程分支删除以后，本地显示仍然存在的解决办法" class="headerlink" title="远程分支删除以后，本地显示仍然存在的解决办法"></a>远程分支删除以后，本地显示仍然存在的解决办法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示所有分支：</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令查看远程分支和本地分支的对应关系</span></span><br><span class="line">git remote show origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会看到</span></span><br><span class="line">refs/remotes/origin/&lt;branch&gt; stale (use <span class="string">&#x27;git remote prune&#x27;</span> to remove)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行下面命令同步删除</span></span><br><span class="line">git remote prune origin</span><br><span class="line">或者</span><br><span class="line">git fetch -p</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wqdy.top/1662.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="c">
      <meta itemprop="description" content="分享各类资源、经验与技巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我全都要">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1662.html" class="post-title-link" itemprop="url">linux 入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <date title="创建时间：2018-09-12" itemprop="dateCreated datePublished" datetime="2018-09-12T14:41:31+00:00">2018-09-12</date>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/c/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnQuY24v">宝塔面板</span></p>
<p>neofetch</p>
<p>screenfetch</p>
<p>netdata linux 系统性能监测工具</p>
<p>htop 系统状况监控</p>
<p>nano linux下文本编辑器</p>
<p>grafana</p>
<h3 id="linux-目录表"><a href="#linux-目录表" class="headerlink" title="linux 目录表"></a>linux 目录表</h3><p>/ 根目录</p>
<p>/bin 、 /usr/bin 可执行二进制文件目录，如常用的命令 ls cat 等</p>
<p>/boot 放置系统启动时用到的一些文件，如内核文件</p>
<p>/dev 存放系统下的设备文件，访问该目录下的文件，相当于访问某个设备，常用的是挂载光驱<code>mount /dev/cdrom/mnt</code></p>
<p>/etc 系统配置文件，重要的配置文件有</p>
<h3 id="文件大小表示方式"><a href="#文件大小表示方式" class="headerlink" title="文件大小表示方式"></a>文件大小表示方式</h3><table>
<thead>
<tr>
<th>单位</th>
<th>英文</th>
</tr>
</thead>
<tbody><tr>
<td>字节</td>
<td>B (Byte)</td>
</tr>
<tr>
<td>千</td>
<td>K (KibiByte)</td>
</tr>
<tr>
<td>兆</td>
<td>M (MebiByte)</td>
</tr>
<tr>
<td>千兆</td>
<td>G (GigaByte)</td>
</tr>
<tr>
<td>太</td>
<td>T (TeraByte)</td>
</tr>
<tr>
<td>拍</td>
<td>P (PetaByte)</td>
</tr>
<tr>
<td>艾</td>
<td>E (ExaByte)</td>
</tr>
<tr>
<td>泽</td>
<td>Z (ZettaByte)</td>
</tr>
<tr>
<td>尧</td>
<td>Y (YottaByte)</td>
</tr>
</tbody></table>
<h3 id="linux-常用命令"><a href="#linux-常用命令" class="headerlink" title="linux 常用命令"></a>linux 常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>list</td>
<td>查看当前文件夹下的内容</td>
</tr>
<tr>
<td>pwd</td>
<td>print work directory</td>
<td>查看当前所在文件夹</td>
</tr>
<tr>
<td>cd[目录名]</td>
<td>change directory</td>
<td>切换文件夹</td>
</tr>
<tr>
<td>touch[文件名]</td>
<td>touch</td>
<td>如果文件不存在，新建文件<br />如果文件已经存在，修改文件的末次修改日期</td>
</tr>
<tr>
<td>mkdir[目录名]</td>
<td>make directory</td>
<td>创建目录</td>
</tr>
<tr>
<td>rm[文件名]</td>
<td>remove</td>
<td>删除指定的文件名</td>
</tr>
<tr>
<td>clear</td>
<td></td>
<td>清屏</td>
</tr>
</tbody></table>
<p><strong>ls 常用选项</strong></p>
<ul>
<li><code>-a</code> 显示所有目录和文件，包括隐藏文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -a</span></span><br><span class="line">. .. .xxx.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以.开头的文件/文件夹为隐藏文件/文件夹</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> . 代表当前目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .. 代表上一级目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 蓝色为目录，白色为文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>-l</code> 以列表方式显示文件的详细信息</li>
<li><code>-h</code> 配合-l 以人性化的方式显示文件大小</li>
</ul>
<p>选项可以合写，无顺序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -alh</span></span><br></pre></td></tr></table></figure>

<p>ls <strong>通配符</strong></p>
<ul>
<li><code>*</code> 代表任意个数个字符</li>
<li><code>？</code>代表任意一个字符</li>
<li><code>[]</code> 表示可以匹配字符组中的任意一个</li>
<li><code>[abc]</code> 匹配<code>a</code>、<code>b</code>、<code>c</code> 中的任意一个</li>
<li><code>[a-f]</code> 匹配 <code>a-f</code> 任意一个字符</li>
</ul>
<p><strong>cd 常用选项</strong></p>
<ul>
<li><p><code>cd</code>/<code>cd ~</code> 切换到当前用户的主目录</p>
</li>
<li><p><code>cd ..</code> 切换到上一级目录</p>
</li>
<li><p><code>cd -</code> 在最近两次工作目录间切换</p>
</li>
</ul>
<p><strong>mkdir</strong></p>
<ul>
<li><code>-p</code> 可以递归创建目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> madir -p a/b/c</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>同一目录下文件夹名称不能和文件名同名</p>
</blockquote>
<p><strong>rm</strong></p>
<blockquote>
<p>删除时直接删除，不放入回收站</p>
</blockquote>
<ul>
<li><p><code>-f</code> 强制删除，忽略不存在的文件，无需提示</p>
</li>
<li><p><code>-r</code> 递归的删除目录下的内容，或用于删除文件夹</p>
</li>
</ul>
<h3 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> [-options][paramete]</span><br></pre></td></tr></table></figure>

<p>command : 命令名，相应功能的英文单词或单词缩写<br>-options： 选项<br>paramete ：参数</p>
<h3 id="查阅帮助信息"><a href="#查阅帮助信息" class="headerlink" title="查阅帮助信息"></a>查阅帮助信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> --<span class="built_in">help</span></span><br><span class="line">$ man <span class="built_in">command</span></span><br><span class="line"><span class="comment"># man 是manual缩写,手册</span></span><br><span class="line"><span class="comment"># 使用man 时的操作键</span></span><br><span class="line"><span class="comment">#	空格 显示手册的下一屏</span></span><br><span class="line"><span class="comment">#	enter 一次滚动手册页的一行</span></span><br><span class="line"><span class="comment">#	b 回滚一屏</span></span><br><span class="line"><span class="comment">#	f 前滚一屏</span></span><br><span class="line"><span class="comment">#	q 退出</span></span><br><span class="line"><span class="comment">#	/word 搜索word字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="终端技巧"><a href="#终端技巧" class="headerlink" title="终端技巧"></a>终端技巧</h3><ul>
<li><p>自动补全</p>
<p>在敲出 文件/目录/命令的前几个字母后，按下 <code>tab</code> 键</p>
<ul>
<li>如果输入没有歧义，系统会自动补全</li>
<li>如果输入有歧义，再按一下 <code>tab</code> 键，系统会提示可能存在的命令</li>
</ul>
</li>
<li><p>曾经使用过的命令</p>
<p>按上下键可在曾经使用过的命令间切换，<code>Ctrl+c</code> 退出选择</p>
</li>
</ul>
<h3 id="文件和目录常用命令"><a href="#文件和目录常用命令" class="headerlink" title="文件和目录常用命令"></a>文件和目录常用命令</h3><h4 id="拷贝和移动文件"><a href="#拷贝和移动文件" class="headerlink" title="拷贝和移动文件"></a>拷贝和移动文件</h4><ul>
<li><p><code>tree [目录名]</code>： 以树状图列出文件目录结构</p>
<p><code>-d</code> 只显示目录，不显示文件</p>
</li>
<li><p><code>cp 源文件 目标文件</code>： copy 复制文件或者目录</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp  ~/Documemt/readme.txt  ./readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 ~/Documemt/ 目录下的 readme.txt 文件复制到./目录下并以readme.txt命名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果不修改文件名，只需要写目标路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp  ~/Documemt/readme.txt  ./</span></span><br></pre></td></tr></table></figure>

<p><code>-i</code> ：覆盖文件前提示 y 覆盖 n 不覆盖</p>
<p><code>-r</code> ：若给出的源文件是目录文件，将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</p>
<ul>
<li><code>mv 源文件 目标文件</code>：move 移动文件或目录/ 文件或目录重命名</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv  ~/Documemt/readme.txt  ./</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 ~/Documemt/ 目录下的 readme.txt 文件移动到./目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv readme.txt demo.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将readme.txt文件名修改为demo.txt</span></span><br></pre></td></tr></table></figure>

<p><code>-i</code> ：覆盖文件前提示 y 覆盖 n 不覆盖</p>
<h4 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h4><ul>
<li><p><code>cat</code> 文件名： <code>concatenate</code> 查看文件内容、创建文件、文件合并、追加文件内容等功能，会<strong>一次显示所有内容</strong>，适合内容较少的文本文件</p>
<p><code>-b</code>：对非空输出行编号</p>
<p><code>-n</code>：对输出的所有行编号</p>
<blockquote>
<p>linux 中还有一个 <code>nl</code> 命令和 <code>cat -b</code> 的效果等价</p>
</blockquote>
</li>
<li><p><code>more</code> 文件名：<strong>分屏显示文件内容</strong> ，按空格显示下一屏，适合查看内容较多的文本</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 more 时的操作键  和 man 相同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 空格 显示手册的下一屏</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> enter 一次滚动手册页的一行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b 回滚一屏</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> f 前滚一屏</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> q 退出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /word 搜索word字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>grep</code> 搜索文本 文件名： 搜索文本文件内容，输出包含该文本的行</p>
<blockquote>
<p>linux 中的文本搜索工具，允许对文本文件进行模式查找（正则表达式），如果搜索文本中间有空格可以使用引号包裹</p>
</blockquote>
<p><code>-n</code> 显示匹配行和行号</p>
<p><code>-v</code> 显示不包含匹配文本的所有行（相当于求反）</p>
<p><code>-i</code> 忽略大小写</p>
<p><code>^a</code> 行首，搜索以 a 开头的行</p>
<p><code>ke$</code> 行尾，搜索以 ke 结束的行</p>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p><code>echo 文字内容</code> ：会在终端中显示参数指定的文本，通常会和重定向联合使用</p>
</li>
<li><p>重定向 <code>&gt;</code> 和 <code>&gt;&gt;</code>：</p>
</li>
</ul>
<blockquote>
<p>linux 允许将命令执行结果重定向到一个文件，将本应显示在终端上的内容输出/追加到指定文件中，保存命令输出结果</p>
</blockquote>
<p><code>&gt;</code> 表示输出，会覆盖文件原有的内容</p>
<p><code>&gt;&gt;</code> 表示追加，会将文件追加到已有文件的末尾</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 a 文件并将 “hello world”输出到 a 文件中 ，与touch区别</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> hello world &gt; a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将命令 “ls -lh” 的结果输出到 a 文件中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lh &gt; a</span></span><br></pre></td></tr></table></figure>

<ul>
<li>管道 <code>|</code></li>
</ul>
<blockquote>
<p>linux 允许将一个命令的输出通过管道作为另一个命令的输入，另一个命令对第一个命令的输出进行二次处理</p>
<p>可以理解为现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 <code>|</code> 的左右分为两端，左端塞东西（写），右端取东西（读）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> more：分屏显示内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分屏显示命令 “ls -lha” 的输出结果</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lha ~ | more</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> grep：在命令执行结果的基础上查询指定文本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找 “ls -lha ~” 的结果中包含Do的行并显示</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lha ~ | grep Do</span></span><br></pre></td></tr></table></figure>

<h3 id="远程管理命令"><a href="#远程管理命令" class="headerlink" title="远程管理命令"></a>远程管理命令</h3><h4 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h4><p><code>shutdown 选项 时间</code></p>
<pre><code>`-r`  重新启动
</code></pre>
<blockquote>
<p>不指定选项和参数，默认表示一分钟之后关闭电脑</p>
<p>远程维护服务器时，最好不要关闭系统，而应该重新启动系统</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 常用命令示例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新启动电脑，now 表示现在</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown -r now</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统在今天20:00 关机</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown 20:00</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统十分钟后自动关机</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown +10</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消关机计划</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown -c</span></span><br></pre></td></tr></table></figure>

<h4 id="查看或配置网卡信息"><a href="#查看或配置网卡信息" class="headerlink" title="查看或配置网卡信息"></a>查看或配置网卡信息</h4><p><code>ifconfig</code>: <code>configure a network interface</code> 查看/配置计算机当前的网卡配置信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看网卡配置信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ifconfig</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网卡对应的IP地址</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ifconfig | grep inet</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 linux 中物理网卡通常以 <code>ensxx</code> 表示</p>
<p>127.0.0.1 本地环回/环回地址，一般用来测试本机网卡是否正常</p>
</blockquote>
<p><code>ping ip地址</code>： <code>ping</code> 检测到目标 ip 地址连接是否正常</p>
<p>ping 127.0.0.1 检查本地网卡是否工作正常</p>
<h4 id="远程登录和复制文件"><a href="#远程登录和复制文件" class="headerlink" title="远程登录和复制文件"></a>远程登录和复制文件</h4><ul>
<li><p><code>ssh 用户名@ip</code> ：<code>secure shell</code> 关机/重新启动</p>
</li>
<li><p><code>scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径</code>：<code>secure copy</code> 远程复制文件</p>
</li>
</ul>
<p><strong>SSH</strong> ：SSH 客户端是一种使用 Secure Shell (SSH) 协议连接到远程计算机的软件协议</p>
<ul>
<li><p>数据传输是加密的，可以防止远程管理过程中的信息泄露，也能防止 DNS 欺骗和 IP 欺骗</p>
</li>
<li><p>数据传输是压缩的，可以提高传输速度</p>
</li>
</ul>
<blockquote>
<p>有关 ssh 配置信息都保存在用户家目录下的 <code>.ssh</code>目录下</p>
</blockquote>
<h5 id="域名和端口号"><a href="#域名和端口号" class="headerlink" title="域名和端口号"></a>域名和端口号</h5><p><code>域名</code>：由一串用点分割的名字组成，例如 <code>www.baidu.com</code> ，是 IP 地址的别名，方便记忆</p>
<p><code>端口号</code>：通过 IP 地址可以找到网络上的计算机，通过端口号可以找到计算机上运行的程序</p>
<blockquote>
<p>SSH 服务器默认端口号为 22，Web 服务器为 80，HTTPS 为 443，FTP 服务器为 21，如果没有指定端口号，使用默认端口号</p>
</blockquote>
<h5 id="SSH-基本使用"><a href="#SSH-基本使用" class="headerlink" title="SSH 基本使用"></a>SSH 基本使用</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh [-p port] user@remote</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> user 远程服务器上的用户名，如果不指定默认当前用户</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> remote 远程机器的地址，可以是IP/域名，或者别名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> port 是SSH server 监听的端口，如果不指定，默认22</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 <span class="built_in">exit</span> 退出当前用户登录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh 在 linux 或 Unix 系统下可直接使用，win下需要安装软件 putty xshell</span></span><br></pre></td></tr></table></figure>

<h5 id="scp-基本使用"><a href="#scp-基本使用" class="headerlink" title="scp 基本使用"></a>scp 基本使用</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从远程服务器拷贝文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scp user@remoteip:文件名或路径 文件名或路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r 复制目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -P 指定端口是要用大写的 P</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传文件到服务器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scp 文件名或路径 user@remote ip:文件名或路径</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>scp</code> 命令只能在 <code>Linux</code> 或 <code>Unix</code> 下使用</p>
</blockquote>
<p>在 win 系统中需安装 filezilla 使用 FTP 进行文件传输</p>
<p>FileZilla 传输文件时，使用的是 <code>FTP</code> 服务而不是 <code>SSH</code> 服务，因此端口号应该为 <code>21</code></p>
<h5 id="ssh-高级"><a href="#ssh-高级" class="headerlink" title="ssh 高级"></a>ssh 高级</h5><ul>
<li>免密码登陆</li>
</ul>
<p>配置公钥：执行 <code>ssh-keygen</code> 即可生成 ssh 钥匙，一路回车即可</p>
<p><code>id_rsa.pub</code> 公钥 、 <code>id_rsa</code> 私钥</p>
<p>上传公钥到服务器：执行 <code>ssh-copy-id -p port user@remote</code>，公钥保存在服务器 <code>.ssh</code> 目录下</p>
<p><code>authorized_keys</code></p>
<blockquote>
<p>本地使用私钥对数据进行加密/解密，服务器使用公钥对数据进行加密/解密</p>
<p>非对称加密算法</p>
<p>使用公钥加密的数据，需要使用私钥解密</p>
<p>使用公私钥加密的数据，需要使用公钥解密</p>
</blockquote>
<ul>
<li>配置别名</li>
</ul>
<p><code>~/.ssh/config</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host vultr</span><br><span class="line">	HostName ip地址</span><br><span class="line">	User root</span><br><span class="line">	port 22</span><br></pre></td></tr></table></figure>

<p>直接使用 <code>ssh vultr</code> 即可实现登陆，<code>scp</code> 同样适用</p>
<h4 id="修改-ssh-配置允许自定义工具连接服务器"><a href="#修改-ssh-配置允许自定义工具连接服务器" class="headerlink" title="修改 ssh 配置允许自定义工具连接服务器"></a>修改 ssh 配置允许自定义工具连接服务器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到 root 角色</span></span><br><span class="line">sudo -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 SSH 配置文件 /etc/ssh/sshd_config</span></span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">PermitRootLogin yes <span class="comment"># 开启root用户访问</span></span><br><span class="line">PasswordAuthentication yes <span class="comment"># 开启密码登陆</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给root用户设置密码</span></span><br><span class="line">passwd root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启SSH服务使修改生效</span></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>

<h3 id="用户和权限的相关命令"><a href="#用户和权限的相关命令" class="headerlink" title="用户和权限的相关命令"></a>用户和权限的相关命令</h3><h4 id="用户和权限的基本概念"><a href="#用户和权限的基本概念" class="headerlink" title="用户和权限的基本概念"></a>用户和权限的基本概念</h4><ul>
<li><p>用户管理包括 <strong>用户</strong> 和 <strong>组</strong> 管理</p>
</li>
<li><p>在 linux 中可以指定每一个用户针对不同的文件或目录不同的权限</p>
</li>
<li><p>对<strong>文件/目录的权限</strong>包括</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>权限</th>
<th>英文</th>
<th>缩写</th>
<th>数字代号</th>
</tr>
</thead>
<tbody><tr>
<td>读</td>
<td>red</td>
<td>r</td>
<td>4</td>
</tr>
<tr>
<td>写</td>
<td>write</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>执行</td>
<td>excute</td>
<td>x</td>
<td>1</td>
</tr>
<tr>
<td>无</td>
<td></td>
<td>-</td>
<td>0</td>
</tr>
</tbody></table>
<p><strong>组</strong>：实际工作中，可以预先对组设置好权限，然后将不同的用户添加到不同的组中（简化了用户权限设置）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -l 扩展</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">-rw-rw-r-- 1 用户名 组名 大小 时间 名称</span><br><span class="line">drwxrwxr-x 2</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>rw-</td>
<td>rw-</td>
<td>r–</td>
<td>1</td>
<td>用户名</td>
<td>组名</td>
</tr>
<tr>
<td>d</td>
<td>rwx</td>
<td>rwx</td>
<td>r-x</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>文件/目录</td>
<td>当前用户权限</td>
<td>当前组所对应的权限</td>
<td>其他用户权限</td>
<td>硬链接数</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>硬链接数：表示有多少种方式可以访问到当前目录/文件，文件的硬链接数通常为 1，目录的硬链接数取决于该目录有多少个子目录。</p>
<h4 id="修改文件-目录权限-chmod"><a href="#修改文件-目录权限-chmod" class="headerlink" title="修改文件/目录权限 chmod"></a>修改文件/目录权限 <code>chmod</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +/-rwx 文件名|目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + 增加权限  - 删除权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接修改文件/目录的读、写、执行权限，但不能精确到 拥有者/组/其他</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x 文件名 // 增加文件可执行权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod -r 目录 // 删除目录可读权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录的可读权限：读取目录内容（如果没有此权限，可<span class="built_in">cd</span>，不能ls）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录的可写权限：修改目录内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录的可执行权限：对目录执行终端命令（如果没有此权限，甚至无法 <span class="built_in">cd</span> 到目录）</span></span><br></pre></td></tr></table></figure>

<p>chmod 高级用法</p>
<h4 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h4><ul>
<li><p><code>root</code> 账户用于系统的维护和管理，对操作系统的所有资源具有所有访问权限</p>
</li>
<li><p>不推荐直接使用 root 账户登录系统</p>
</li>
<li><p>在 linux 安装过程中，系统会自动创建一个标准用户账号</p>
</li>
</ul>
<p><strong>sudo</strong></p>
<ul>
<li><p><code>su</code> 是 <code>substitute user</code> 缩写，表示使用另一个用户身份</p>
</li>
<li><p><code>sudo</code> 命令用来以其他身份来执行命令，预设身份为 root</p>
</li>
<li><p>用户使用 sudo 时，需先输入密码，之后有五分钟的有效期，超过期限去重新输入密码</p>
</li>
</ul>
<h4 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h4><p><code>groupadd 组名</code> ：添加组</p>
<p><code>groupdel 组名</code> ：删除组</p>
<p><code>cat /etc/group</code> ：确认组信息</p>
<p><code>chgrp 组名 文件/目录名</code> ：修改文件/目录的所属组 -R 递归修改</p>
<blockquote>
<p>创建组/删除组的终端命令都需要通过 sudo 来执行</p>
<p>组信息保存在 /etc/group 文件中</p>
<p>/etc 目录是专门用来保存 系统配置信息的目录</p>
</blockquote>
<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p><strong>创建用户/设置密码/删除用户</strong></p>
<p><code>useradd -m -g 组 新建用户名</code> ：添加新用户</p>
<p>​-m 自动建立用户家目录</p>
<p>​-g 指定用户所在的组，否则会建立一个和用户名同名的组</p>
<p><code>passwd 用户名</code>：设置用户密码</p>
<p>​ 如果是普通用户，直接用 passwd 可以修改自己的账户密码</p>
<p><code>userdel -r 用户名</code>：删除用户</p>
<p>​-r 选项自动删除用户家目录</p>
<p><code>cat /etc/passwd | grep 用户名</code>：确认用户信息</p>
<p>​ 新建用户后，用户信息保存在 <code>/etc/passwd</code> 文件中</p>
<blockquote>
<p>创建用户/删除用户/修改其他用户密码 的命令都需要通过 <code>sudo</code> 执行</p>
<p>用户信息保存在 <code>/etc/passwd</code> 文件中</p>
</blockquote>
<p><strong>查看用户信息</strong></p>
<p><code>id [用户名]</code>：查看用户 UID 和 GID 信息</p>
<p><code>who</code> ：查看当前所有登陆的用户列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> who</span></span><br><span class="line">用户名  时间 (:0) # :0 表示当前电脑</span><br><span class="line">用户名  时间 (172.16.xx.xx)</span><br></pre></td></tr></table></figure>

<p><code>whoami</code> ：查看当前登录用户的账户名</p>
<p><strong>passwd 文件</strong> 由六个分号组成七个信息</p>
<ol>
<li>用户名</li>
<li>密码（x，表示加密的密码）</li>
<li>UID（用户标识）</li>
<li>GID（组标识）</li>
<li>用户全名</li>
<li>家目录</li>
<li>登录使用的 shell，就是登陆之后使用的终端，ubuntu 默认使用 <code>dash</code></li>
</ol>
<p><strong>usermod</strong></p>
<p>用来设置用户的主组/附加组 和登录 shell</p>
<p>主组：在用户新建时指定，在 <code>etc/passwd</code> 的第四列 GID 对应的组</p>
<p>附加组：在 <code>etc/group</code> 中最后一列表示该组的用户列表，用于指定用户的附加权限</p>
<blockquote>
<p>设置用户的附加组之后，需要重新登录才能生效</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改用户的主组</span></span><br><span class="line">$ usermod -g 组 用户名</span><br><span class="line"><span class="comment"># 修改用户的附加组</span></span><br><span class="line">$ usermod -G 组 用户名</span><br><span class="line"><span class="comment"># 修改用户登录shell</span></span><br><span class="line">$ usermod -s /bin/bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认使用 <code>useradd</code> 添加的用户是没有权限使用 <code>sudo</code> 以 <code>root</code> 身份执行命令的，使用以下命令将用户添加到 <code>sudo</code> 附加组中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usermod -G sudo 用户名</span><br></pre></td></tr></table></figure>

<p><strong>which</strong></p>
<blockquote>
<p><code>/etc/passwd</code> 是用于保存用户信息的文件</p>
<p><code>/usr/bin/passwd</code> 是用于修改用户密码的程序</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># which 可用于查看执行命令所在的位置</span></span><br><span class="line">$ <span class="built_in">which</span> ls</span><br><span class="line"><span class="comment"># /bin/ls</span></span><br><span class="line">$ <span class="built_in">which</span> useradd</span><br><span class="line"><span class="comment"># /usr/sbin/useradd</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>cd</code> 这个命令是内置在系统内核中的，没有独立文件，因此用 <code>which</code> 无法找到</p>
</blockquote>
<p><strong>bin 和 sbin</strong></p>
<p><code>/bin</code> (binary) 是二进制执行文件目录，主要用于具体应用</p>
<p><code>/sbin</code> (system binary) 是系统管理员专用的二进制文件目录，主要用于系统管理</p>
<p><code>/usr/bin</code> (user commands for applications) 后期安装的一些软件</p>
<p><code>/usr/sbin</code> (super user commands for applications) 超级用户的一些管理程序</p>
<blockquote>
<p>bin 存储普通可执行文件，sbin 存储跟系统管理相关的可执行文件</p>
</blockquote>
<h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p><code>su - 用户名</code>：切换用户，并且切换目录</p>
<p><code>-</code> 可以切换到用户家目录，否则保持位置不变</p>
<p><code>exit</code>： 退出当前登录用户</p>
<blockquote>
<p><code>su</code> 不接用户名，可以切换到 <code>roo</code>，不推荐，不安全</p>
</blockquote>
<p>exit 示意图：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102205719.png"></p>
<h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p>chowm 修改拥有者</p>
<p>chgrp 修改组</p>
<p>chmod 修改权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改文件/目录的拥有者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chown 用户名 文件名/目录名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归修改文件/目录的组</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chgrp -R 组名 文件名/目录名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归修改文件权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 755 三个数字分别代表 用户 u /组 g /其他用户 o 的权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod -R 755 文件名/目录名</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>r –&gt; 4 w –&gt; 2 x –&gt; 1 无权限 –&gt; 0 ，想要什么权限直接将数字相加</p>
</blockquote>
<h3 id="系统信息相关命令"><a href="#系统信息相关命令" class="headerlink" title="系统信息相关命令"></a>系统信息相关命令</h3><blockquote>
<p>查询服务器上当前系统日期和时间 / 磁盘空间占用情况 / 程序执行情况</p>
</blockquote>
<h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><p><code>date</code> ：查看系统时间</p>
<p><code>cal</code> ：<code>calendar</code> 查看日历， <code>-y</code> 选项可以查看一年的日历</p>
<h4 id="磁盘和空间目录"><a href="#磁盘和空间目录" class="headerlink" title="磁盘和空间目录"></a>磁盘和空间目录</h4><p><code>df -h</code> ：<code>disk free</code> 显示磁盘剩余空间 -h 以人性化的方式显示文件大小</p>
<p><code>du -h [目录名]</code> ：<code>disk usage</code> 显示目录占用空间情况，不指定目录默认表示当前目录</p>
<blockquote>
<p>-h 以人性化的方式显示文件大小</p>
</blockquote>
<h4 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h4><p>PID 进程代号</p>
<p><code>ps au</code> : <code>process status</code> 查看进程的详细状况，默认只显示当前用户通过终端启动的程序</p>
<p>​ps 选项(没有减号)</p>
<p>​<code>a</code> 显示终端上的所有进程，包括其他用户的进程</p>
<p>​<code>u</code> 显示进程的详细状态</p>
<p>​<code>x</code> 显示不是通过终端启动的进程</p>
<p><code>top</code> : 动态显示运行中的进程并且排序 ，输入 q 退出</p>
<p><code>kill [-9] 进程代号</code> : 终止指定代号的进程，<code>-9</code> 表示强行终止</p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><p><code>find [路径] -name “*.txt”</code> : 查找指定路径下扩展名为.txt 的文件，包括子目录</p>
<p>​ 如果省略路径，表示在当前文件夹下查找</p>
<h4 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h4><p><code>ln -s 被链接的源文件 链接文件</code> ：建立文件的软链接，类似于 Windows 下的快捷方式</p>
<p>注意：</p>
<ul>
<li><p>如果没有 <code>-s</code> 选项建立的是一个硬链接文件（两个文件占用相同大小的磁盘空间，几乎不用）</p>
</li>
<li><p>源文件要使用绝对路径，可以方便移动链接文件后，仍然能够正常使用</p>
</li>
</ul>
<h5 id="文件软硬链接示意图"><a href="#文件软硬链接示意图" class="headerlink" title="文件软硬链接示意图"></a>文件软硬链接示意图</h5><p><img data-src="https://cdn.jsdelivr.net/gh/cuilongjin/static@img/img/20210102205748.png"></p>
<ul>
<li><p>在 linux 中<strong>文件名</strong>和<strong>文件的数据</strong>是分开存储的</p>
</li>
<li><p>在 linux 中，只有文件的硬链接数为 0 文件才会被删除</p>
</li>
<li><p>在日常工作中几乎不会建立文件的硬链接</p>
</li>
</ul>
<h4 id="打包和解包"><a href="#打包和解包" class="headerlink" title="打包和解包"></a>打包和解包</h4><p>tar 是 Linux 中常用的备份工具，此命令可以把一系列文件打包到一个大文件中，也可以把一个打包的大文件恢复成一系列文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打包文件</span></span><br><span class="line">tar -cvf 打包文件.tar 被打包的文件/路径 (多个文件一次写在后面，用空格隔开)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解包文件</span></span><br><span class="line">tar -xvf 打包文件.tar</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>c</code> 生成档案文件，创建打包文件</p>
</li>
<li><p><code>x</code> 解开档案文件</p>
</li>
<li><p><code>v</code> 列出归档接档的详细过程</p>
</li>
<li><p><code>f</code> 指定档案文件名称， f 选项必须放在最后</p>
</li>
</ul>
<h4 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h4><p><strong>gzip</strong></p>
<ul>
<li><p><code>tar</code> 和 <code>gzip</code> 命令结合使用实现文件打包和压缩</p>
<ul>
<li><p><code>tar</code> 只负责打包，但不压缩</p>
</li>
<li><p>用 <code>gzip</code> 压缩 <code>ta</code>r 打包后的文件，扩展名为 <code>xxx.tar.gz</code></p>
</li>
</ul>
</li>
<li><p><code>tar</code> 命令中 <code>-z</code> 选项可以调用 <code>gzip</code></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 压缩文件</span></span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩文件/路径</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩文件</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩到指定路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C 解压到指定路径，（路径必须存在）</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 目标路径</span><br></pre></td></tr></table></figure>

<p><strong>bzip2</strong></p>
<ul>
<li><p><code>tar</code> 和 <code>bzip2</code> 命令结合使用实现文件打包和压缩（用法同 <code>gzip</code>）</p>
<ul>
<li><p><code>tar</code> 只负责打包，但不压缩</p>
</li>
<li><p>用 <code>bzip2</code> 压缩 <code>ta</code>r 打包后的文件，扩展名为 <code>xxx.tar.bz2</code></p>
</li>
</ul>
</li>
<li><p><code>tar</code> 命令中 <code>-j</code> 选项可以调用 <code>bzip2</code></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 压缩文件</span></span><br><span class="line">tar -jcvf 打包文件.tar.bz2 被压缩文件/路径</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩文件</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩到指定路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C 解压到指定路径，（路径必须存在）</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2 -C 目标路径</span><br></pre></td></tr></table></figure>

<h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><p><code>apt</code> : <code>Advanced Packaging Tool</code> ，linux 下安装包管理工具，可以方便的安装/卸载/更新软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装软件</span></span><br><span class="line">sudo apt install 软件包</span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载软件</span></span><br><span class="line">sudo apt remove 如软件名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新已安装的包</span></span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>

<h3 id="防火墙管理"><a href="#防火墙管理" class="headerlink" title="防火墙管理"></a>防火墙管理</h3><p>CentOS7 默认的防火墙不是 iptables,而是 firewalle</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加规则</span></span><br><span class="line">firewall-cmd --add-port=16343/tcp</span><br><span class="line">firewall-cmd --zone=public --add-port=16343/tcp --permanent （--permanent 永久生效，没有此参数重启后失效）</span><br><span class="line"><span class="comment"># 重新载入</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">firewall-cmd --zone=public --query-port=80/tcp</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启防火墙</span></span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="comment"># 列出端口信息</span></span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>

<p>使用 iptables</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先检查是否安装了iptables</span></span><br><span class="line">service iptables status</span><br><span class="line"><span class="comment"># 安装iptables</span></span><br><span class="line">yum install -y iptables</span><br><span class="line"><span class="comment"># 升级iptables</span></span><br><span class="line">yum update iptables</span><br><span class="line"><span class="comment"># 安装iptables-services</span></span><br><span class="line">yum install iptables-services</span><br><span class="line"><span class="comment"># 停止firewalld服务</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁用firewalld服务</span></span><br><span class="line">systemctl mask firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册iptables服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> iptables.service</span><br><span class="line"><span class="comment"># 开启 iptables 防火墙</span></span><br><span class="line">systemctl start iptables.service</span><br><span class="line"><span class="comment"># 重启iptables防火墙</span></span><br><span class="line">systemctl restart iptables.service</span><br><span class="line"><span class="comment"># 关闭 iptables 防火墙</span></span><br><span class="line">systemctl stop iptables.service</span><br><span class="line"><span class="comment"># 查看 iptables 防火墙状态</span></span><br><span class="line">systemctl status iptables.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看iptables现有规则</span></span><br><span class="line">iptables -L -n</span><br><span class="line"><span class="comment"># 允许所有</span></span><br><span class="line">iptables -P INPUT ACCEPT</span><br><span class="line"><span class="comment"># 清空所有默认规则</span></span><br><span class="line">iptables -F</span><br><span class="line"><span class="comment"># 清空所有自定义规则</span></span><br><span class="line">iptables -X</span><br><span class="line"><span class="comment"># 所有计数器归0</span></span><br><span class="line">iptables -Z</span><br><span class="line"><span class="comment"># 允许来自于lo接口的数据包(本地访问)</span></span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line"><span class="comment"># 开放22端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="comment"># 开放21端口(FTP)</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 21 -j ACCEPT</span><br><span class="line"><span class="comment"># 开放80端口(HTTP)</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line"><span class="comment"># 开放443端口(HTTPS)</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class="line"><span class="comment"># 允许ping</span></span><br><span class="line">iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT</span><br><span class="line"><span class="comment"># 允许接受本机请求之后的返回数据 RELATED,是为FTP设置的</span></span><br><span class="line">iptables -A INPUT -m state --state  RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="comment"># 其他入站一律丢弃</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line"><span class="comment"># 所有出站一律绿灯</span></span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line"><span class="comment"># 所有转发一律丢弃</span></span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line"><span class="comment">#保存上述规则</span></span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">iptables -P INPUT ACCEPT</span><br><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -Z</span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 21 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT</span><br><span class="line">iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">service iptables save</span><br><span class="line">systemctl restart iptables.service</span><br></pre></td></tr></table></figure>

<p>sudo -i 为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令。提示输入密码时该密码为当前账户的密码。没有时间限制。执行该命令后提示符变为“#”而不是“$”。想退回普通账户时可以执行“exit”或“logout” 。<br>su 切换到某某用户模式，提示输入密码时该密码为切换后账户的密码，用法为“su 账户名称”。如果后面不加账户时系统默认为 root 账户，密码也为超级账户的密码。没有时间限制。<br>sudo su 运行 sudo 命令给 su 命令提权，运行 su 命令。<br>sudo -i 运行结果 PWD=/root<br>sudo su 运行结果 PWD=/home/用户名（当前用户主目录）</p>
<p>sudo : 暂时切换到超级用户模式以执行超级用户权限，提示输入密码时该密码为当前用户的密码，而不是超级账户的密码。不过有时间限制，Ubuntu 默认为一次时长 15 分钟。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">c</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>本站为个人博客，站内所有软件资源均收集自互联网，本站仅做免费分享，不出售。本站内所有软件资源仅限个人用于学习和研究目的，不得将上述内容用于商业或者非法用途，否则，一切后果请用户自负。本站内所有软件必须在下载后的24个小时之内，从您的电脑中彻底删除。本站对任何资源不提供技术支持，遇到问题请自行研究或购买正版。本站信息来自网络，版权争议与本站无关。访问和下载本站内容，说明您已同意上述条款。


    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>





  <script class="next-config" data-name="nprogress" type="application/json">{&quot;enable&quot;:true,&quot;spinner&quot;:true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{&quot;enable&quot;:true,&quot;repo&quot;:&quot;cuilongjin&#x2F;hexo-blog&quot;,&quot;issue_term&quot;:&quot;pathname&quot;,&quot;theme&quot;:&quot;github-light&quot;,&quot;label&quot;:&quot;comment&quot;}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
