---
title: 手写题
id: 2041
categories:
  - 前端
date: 2022-02-18
updated: 2022-02-22
---

#### 数组去重
<details>
<summary>详情</summary>
1. 新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf 为-1 或 includes 为false）就加入该新数组中

```js
function unique(arr) {
  var newArr = []
  for (var i = 0; i < arr.length; i++) {
    if (newArr.indexOf(arr[i]) === -1) {
      newArr.push(arr[i])
    }
  }
  return newArr
}
```

2. 数组下标判断：如果当前数组的第 i 项在当前数组中第一次出现的位置不是 i，那么表示第 i 项是重复的，忽略掉。否则存入结果数组

```js
function unique(arr) {
  var newArr = []
  for (var i = 0; i < arr.length; i++) {
    if (arr.indexOf(arr[i]) === i) {
      newArr.push(arr[i])
    }
  }
  return newArr
}
```

- hash去重
```js
function Deduplication(arr) {
  var result = []
  var hashMap = {}
  for (var i = 0; i < arr.length; i++) {
    var temp = arr[i]
    if (!hashMap[temp]) {
      hashMap[temp] = true
      result.push(temp)
    }
  }
  return result
}
```

3. ES6 实现

```js
function unique(arr) {
  var x = new Set(arr)
  return [...x]
}
```
</details>

#### 冒泡排序
<details>
<summary>详情</summary>

```js
// 将数组中的数从小到大排列
var arr = [1, 4, 6, 7, 9, 3, 5, 8]
// var numi = 0
// var numj = 0
for (var j = 0; j < arr.length - 1; j++) {
  // numj += 1
  var flag = true
  for (var i = 0; i < arr.length - 1 - j; i++) {
    // document.write('(' + arr[i] + ',' + arr[i + 1] + ')')
    // numi += 1
    // 两两比较，如果前面的大于后面的，交换位置
    if (arr[i] > arr[i + 1]) {
      flag = false
      var temp
      temp = arr[i]
      arr[i] = arr[i + 1]
      arr[i + 1] = temp
      // document.write('交换了')
    }
  }
  // document.write('，arr=（' + arr + '）')
  // document.write('<br>')
  // 如果一趟下来，一次交换都没有做，说明就已经排好序，就不需要继续比
  if (flag) {
    break
  }
}
```
</details>


#### 实现 call apply bind 方法

<details>
<summary>详情</summary>

> call 和 apply 区别

**call：**

```js
Function.prototype.myCall = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  var args = Array.prototype.slice.apply(arguments, [1]) // 获取额外参数
  // var args = [...arguments].slice(1)
  context.fn = this
  var res = context.fn(...args)
  delete context.fn
  return res
}
```

context 为要绑定的 this，不传默认为 window
给 context 创建一个 fn 属性，并将值设置为需要调用的函数
调用 context.fn，并将额外参数 args 传递进去
删除 context 上的 fn 函数

**apply：**

```js
Function.prototype.myApply = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  let res
  if (!arguments[1]) {
    res = context.fn()
  } else if (arguments[1].constructor.name === 'Array') {
    res = context.fn(...arguments[1])
  } else {
    return console.error('Uncaught TypeError: CreateListFromArrayLike called on non-object')
    // throw 'Uncaught TypeError: CreateListFromArrayLike called on non-object'
  }
  delete context.fn
  return res
}
```

**bind：**
```js
Function.prototype.myBind = function() {
  var self = this // 保存原函数
  var args = Array.prototype.slice.call(arguments) // 参数转为数组
  // var args = [...arguments].slice(1) // 参数转为数组
  var context = args.shift() // 保存需要绑定的this上下文
  return function() {
    // 返回一个新函数
    self.apply(context, args.concat([].slice.call(arguments)))
  }
}
```

```js
function aaa(val, val1) {
  console.log(val)
  console.log(val1)
  console.log(this.name)
}
aaa()
aaa.myCall({ name: '123' }, '121', 122)
aaa.myApply({ name: '123' }, ['121', 122])
aaa.myBind({ name: '123' })('111', '222')
```
</details>
