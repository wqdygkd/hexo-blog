{"meta":{"title":"我全都要","subtitle":"搞快点","description":"分享各类资源、经验与技巧","author":"c","url":"https://wqdy.top","root":"/"},"pages":[{"title":"404","date":"23/02/2022","updated":"23/02/2022","comments":true,"path":"404/index.html","permalink":"https://wqdy.top/404/index.html","excerpt":"","text":""},{"title":"关于","date":"23/02/2022","updated":"23/02/2022","comments":false,"path":"about/index.html","permalink":"https://wqdy.top/about/index.html","excerpt":"","text":"如无特殊说明，所有百度网盘链接提取码均为 wqdy"},{"title":"bootstrap 框架","date":"11/12/2018","updated":"11/12/2018","comments":true,"path":"backup/bootstrap-框架.html","permalink":"https://wqdy.top/backup/bootstrap-%E6%A1%86%E6%9E%B6.html","excerpt":"","text":"Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷 bootstrap 中文网 特点： 组件简洁大方、代码规范精简、界面自定义性强 Bootstrap 是基于 HTML5 和 CSS3 开发的，它在 jQuery 的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分 jQuery 插件 Bootstrap 中包含了丰富的 Web 组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站 优点： 有自己的生态圈，不断的更新迭代 提供了一套简洁、直观、强悍的组件 标准化的 HTML+CSS 编码规范 让开发更简单，提高了开发效率 扩展性强，虽然界面组件样式已经定义好了，我们还可以自定义，修改默认样式 版本： 2.x.x 停止维护 优点：兼容性好 IE678 缺点：代码不够简洁、功能不够完善 3.x.x 目前使用最多（H5C3 很多东西） 优点：稳定，偏向于开发响应式布局，移动设备优先的 WEB 项目 缺点：放弃了 IE67，对 IE8 支持但是界面效果不友好 4.x.x 测试阶段 基本模板!&gt; 但凡看到 role属性 aria-*的属性 class=&#39;sr-only&#39;的标签 都可以直接删除，因为是给屏幕阅读器用的 &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;bootstrap基本模板&lt;/title&gt; &lt;!-- 引入 bootstrap 的核心样式文件 --&gt; &lt;link href=&quot;lib/bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;!-- html5shiv 是用来解决 IE8 以下浏览器不支持 HTML5 语义化标签的问题 --&gt; &lt;!-- respond 是用来解决 IE8 以下浏览器不支持媒体查询的问题，注意：respond 不支持 file 协议打开 --&gt; &lt;!-- 条件注释：IE浏览器专属 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- bootstrap 依赖于 jquery，因此需要在 bootstrap 之前引入jquery文件 --&gt; &lt;script src=&quot;lib/jquery/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入 bootstrap 的核心js文件 --&gt; &lt;script src=&quot;lib/bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 全局样式normalize.cssNormalize.css 是一种 CSS reset 的替代方案。经过@necolas 和@jon_neal 花了几百个小时来努力研究不同浏览器的默认样式的差异，这个项目终于变成了现在这样 官网 github 网址 normalize 的特点： 保护有用的浏览器默认样式而不是完全去掉它们 一般化的样式：为大部分 HTML 元素提供 修复浏览器自身的 bug并保证各浏览器的一致性 优化 CSS 可用性：用一些小技巧 Normalize.css 支持包括手机浏览器在内的超多浏览器，同时对 HTML5 元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。 Normalize.css 与 CSS reset 区别 布局容器Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。默认带了 15px 的 padding 值 .container 类用于固定宽度并支持响应式布局的容器 &lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt; .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器 &lt;div class=&quot;container-fluid&quot;&gt; ...&lt;/div&gt; 这两种容器类不能互相嵌套 栅格系统栅格系统，也叫网格系统，bootstrap 栅格系统把一个盒子分成 12 格 栅格参数：col-xx-yy xx：lg 大屏(≥1200px)、md 中屏(≥992px)、sm 小屏(≥768px)、xs 超小屏(&lt;768px) yy：取值范围为 1 - 12 表示占几格 col-xx-12：可以省略不写 列偏移：col-xx-offset-yy xx ：lg、md、sm、xs yy：取值范围为 1 - 12 表示往右偏移几格 列偏移：实际上是给当前元素增加了左侧的边距（margin） 多余列（column）的元素将作为一个整体单元被另起一行排列 .row用于抵消 .container容器的 15px 的 padding 值，实际上是给元素添加了 margin: -15px 可以在.row中嵌套column 列排序：.col-md-push-* 和 .col-md-pull-* 栅格系统常用类（总共 12 列） 类名 例子 解释 .col-xs-xx .col-xs-6 在超小屏幕（及以上）生效 .col-sm-xx .col-sm-6 在小屏幕（及以上）生效 .col-md-xx .col-md-6 在中屏幕（及以上）生效 .col-lg-xx .col-lg-3 在大屏幕及生效，占 1&#x2F;4 .col-lg-xx .col-lg-4 在大屏幕及生效，占 1&#x2F;3 .col-lg-xx .col-lg-5 在大屏幕及生效，占 1&#x2F;2 【案例：列嵌套.html】 &lt;div class=&quot;col-lg-4&quot;&gt; &lt;!-- 栅格系统无处不在，只要父盒子有宽度，就可以使用栅格系统 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-6&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 【案例：列偏移.html】 &lt;!-- 使用 .col-md-offset-* 类可以将列向右侧偏移--&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-3&quot;&gt;&lt;/div&gt; &lt;!-- col-lg-offset-3:在大屏下，这个div将向右侧偏移3个单位 --&gt; &lt;div class=&quot;col-lg-6 col-lg-offset-3&quot;&gt;&lt;/div&gt;&lt;/div&gt; 排版标题：h1 到 h6 标签、.h1 到 .h6 类、 &lt;small&gt; 标签或 .small 类用来标记副标题 文本：&lt;mark&gt;标记、&lt;del&gt;删除、&lt;s&gt;无用文本、&lt;ins&gt;插入文本、&lt;u&gt;下划线文本、 .small 类或&lt;small&gt; 小号文本、&lt;strong&gt;着重 对齐：text-left、text-center、text-right、text-justify、text-nowrap 按钮&lt;a&gt;、&lt;button&gt; 或 &lt;input&gt; 预定义样式：btn、btn-default、btn-primary(蓝)、btn-success(绿)、btn-info(浅蓝)、btn-warning(橙)、btn-danger(红)、btn-link(链接) 尺寸：btn-lg(大)、(默认)、btn-sm(小)、btn-xs(超小)btn-block (块元素 100%宽度) 激活状态：active 禁用状态：button 元素 添加 disabled 属性、链接&lt;a&gt;元素添加 .disabled 类（建议通过 JavaScript 代码来禁止链接的原始功能） 图片响应式图片：img-responsive 实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性 图片形状：img-rounded、img-circle、img-thumbnail 辅助类文本颜色：text-muted、text-muted、text-primary、text-success、text-info、text-warning、text-danger 背景颜色：bg-primary、bg-success、bg-info、bg-warning、bg-danger 关闭按钮：&lt;button type=&quot;button&quot; class=&quot;close&quot;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; 三角符号：&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; 快速浮动：pull-left、pull-right 让内容块居中：&lt;div class=&quot;center-block&quot;&gt;...&lt;/div&gt; 清除浮动：clearfix 显示隐藏内容：show、hidden、invisible 响应式工具 超小屏 小屏幕 中等屏幕 大屏幕桌面.visible-xs-* 可见 隐藏 隐藏 隐藏.visible-sm-* 隐藏 可见 隐藏 隐藏.visible-md-* 隐藏 隐藏 可见 隐藏.visible-lg-* 隐藏 隐藏 隐藏 可见.hidden-xs 隐藏 可见 可见 可见.hidden-sm 可见 隐藏 可见 可见.hidden-md 可见 可见 隐藏 可见.hidden-lg 可见 可见 可见 隐藏 * -&gt; block inline inline-block 推荐使用 hidden 相关的属性 bootstrap-validator 插件基于 bootstrap 的前端校验插件 http://bootstrapvalidator.votintsev.ru/api 引包引入 css 文件 &lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap/css/bootstrap.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap-validator/css/bootstrapValidator.css&quot; /&gt; 引入 js 文件 &lt;script src=&quot;lib/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;lib/bootstrap/js/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;lib/bootstrap-validator/js/bootstrapValidator.js&quot;&gt;&lt;/script&gt; 初始化表单校验插件bootstrap-validator 插件会在表单提交的时候进行校验，如果校验成功了，表单会继续提交，但是如果校验失败了，就会阻止表单的提交 // 使用表单校验插件$(formSelector).bootstrapValidator(&#123; // 1. 指定不校验的类型，默认为[&#x27;:disabled&#x27;, &#x27;:hidden&#x27;, &#x27;:not(:visible)&#x27;],可以不设置 excluded: [], // 全部校验 // 2. 指定校验时的图标显示，默认是bootstrap风格 feedbackIcons: &#123; valid: &#x27;glyphicon glyphicon-ok&#x27;, invalid: &#x27;glyphicon glyphicon-remove&#x27;, validating: &#x27;glyphicon glyphicon-refresh&#x27; &#125;, // 3. 指定校验字段 fields: &#123; username: &#123; // 设置校验规则 validators: &#123; // 不能为空 notEmpty: &#123; message: &#x27;&#x27; &#125;, stringLength: &#123; min: 6, max: 12, message: &#x27;&#x27; &#125;, // 正则校验 regexp: &#123; regexp: /^[a-zA-Z0-9_\\.]+$/, message: &#x27;用户名由数字字母下划线和.组成&#x27; &#125;, callback: &#123;&#125; &#125; &#125;, password: &#123;&#125; &#125;&#125;) 注册表单校验成功的事件当表单校验成功时，会触发success.form.bv事件，此时会提交表单，通常我们需要禁止表单的自动提交，使用 ajax 进行表单的提交 $(&#x27;#form&#x27;).on(&#x27;success.form.bv&#x27;, function(e) &#123; e.preventDefault() // 使用ajax提交逻辑 $.ajax(&#123;&#125;)&#125;) 获取 validator 实例(对象)当我们初始化好表单校验插件时，我们可以通过以下方法来获取表单校验的 validator 实例，通过 validator 实例调用一些方法来完成某些功能 // 获取表单校验实例var validator = $(&#x27;#form&#x27;).data(&#x27;bootstrapValidator&#x27;)// 使用表单校验实例可以调用一些常用的方法validator.methodName(params) 常用方法重置表单重置表单中设置过校验的内容，将隐藏所有错误提示和图标 // 重置表单，隐藏所有的错误提示和图标 传入参数 true 会将内容也清空validator.resetForm() 更新字段的状态BootstrapValidator 在用户输入内容的时候，会做校验，当调用 bootstrap 的插件的方法可以手动会改变字段值的状态 validator.updateStatus(field*, status*, validator) Parameter Type Description field String|jQuery The field name or field element status String Can be NOT_VALIDATED, VALIDATING, INVALID or VALID validator String The validator name. If null, the method updates validity result for all validators"},{"title":"jquery-fileupload 插件","date":"16/10/2018","updated":"16/10/2018","comments":true,"path":"backup/jquery-fileupload.html","permalink":"https://wqdy.top/backup/jquery-fileupload.html","excerpt":"","text":"github 地址：https://github.com/blueimp/jQuery-File-Upload 中文文档：http://www.jq22.com/jquery-info230 引包&lt;!-- jquery-fileupload依赖与jquery --&gt;&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- jquery ui小部件，上传插件依赖了jquery ui的小部件 --&gt;&lt;script src=&quot;js/vendor/jquery.ui.widget.js&quot;&gt;&lt;/script&gt;&lt;!-- 如果上传图片需要跨域，那么需要引入这个js文件，如果不跨域，则不需要引入 --&gt;&lt;script src=&quot;js/jquery.iframe-transport.js&quot;&gt;&lt;/script&gt;&lt;!-- jquery上传插件 --&gt;&lt;script src=&quot;js/jquery.fileupload.js&quot;&gt;&lt;/script&gt; html 结构&lt;!-- name指定图片上传时的name属性 --&gt;&lt;!-- data-url指定图片上传时的接口地址 --&gt;&lt;!-- multiple指定多文件上传 --&gt;&lt;input id=&quot;fileupload&quot; type=&quot;file&quot; name=&quot;files&quot; data-url=&quot;server/php/&quot; multiple /&gt; multiple 上传多文件（实质上是发送多次单文件异步上传请求） js 代码$(&#x27;#fileupload&#x27;).fileupload(&#123; dataType: &#x27;json&#x27;, // e：事件对象 // data：图片上传后的对象，通过data.result.picAddr 可以获取上传后的图片地址 done: function(e, data) &#123; console.log(data) &#125;&#125;)"},{"title":"jquery 中 AJAX 的全局事件","date":"16/10/2018","updated":"16/10/2018","comments":true,"path":"backup/jquery-中-ajax-的全局事件.html","permalink":"https://wqdy.top/backup/jquery-%E4%B8%AD-ajax-%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6.html","excerpt":"","text":"jquery 中 AJAX 的全局事件 ajax 提供了 6 个全局函数，会被页面中所有的 ajax 请求触发，在不同时间点会触发不同的全局事件。 https://api.jquery.com/category/ajax/global-ajax-event-handlers/ 在页面中会有很多的 ajax 请求，但是这些 ajax 请求都有相同的消息机制，比如我们需要在 ajax 请求发送之前弹出了一个提示框，提示”正在读取数据….” 在 ajax 请求成功时显示”获取数据成功…”,在 ajax 结束后隐藏提示框。如果不使用全局事件，那么需要在每一个 ajax 的 beforeSend、success、complete 回调函数中都加上相同的代码。 jquery 的全局事件需要给 document 注册（固定写法） $(document).ajaxStart(function() &#123;&#125;) 全局事件的执行时机 ajaxStart： 在第一个 ajax 请求开始时触发 first start ajaxSend： 在一个 ajax 请求开始之前触发（在 beforeSend 回调函数之后）one start ajaxSuccess： 在一个 ajax 请求成功之后触发（在 success 回调函数之后触发）one success ajaxComplete： 在一个 ajax 请求完成时触发（在 complete 回调函数之后触发） one complete ajaxError： 在一个 ajax 请求失败时触发（在 error 回调函数之后触发） ajaxStop： 在所有的 ajax 请求完成之后触发 all complete 若$.ajax() global 参数设置为 false，则 ajax 全局事件不会被触发，global 参数默认为 true"},{"title":"jquery","date":"16/10/2018","updated":"16/10/2018","comments":true,"path":"backup/jquery.html","permalink":"https://wqdy.top/backup/jquery.html","excerpt":"","text":"jQuery 基本介绍为什么要学 jQuery使用 JS 操作 DOM 的时候，会遇到以下的一些缺点： 获取元素的方法太少且长，麻烦 遍历伪数组很麻烦，通常要嵌套一大堆的 for 循环。注册的事件会覆盖 有兼容性问题 实现动画很麻烦 jQuery 初体验【让 div 显示与设置内容】 $(document).ready(function() &#123; $(&#x27;#btn1&#x27;).click(function() &#123; // 隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。 // show() 显示元素 $(&#x27;div&#x27;).show(200) &#125;) $(&#x27;#btn2&#x27;).click(function() &#123; // text() 设置文本内容 $(&#x27;div&#x27;).text(&#x27;我是内容&#x27;) &#125;) $(&#x27;#btn3&#x27;).click(function() &#123; // css(name, value); 设置样式 // name: 设置什么样式 // value ： 设置的值是多少 $(&#x27;div&#x27;).css(&#x27;fontSize&#x27;, 30) &#125;)&#125;) 使用 jQuery 的优点 获取元素的方式非常的简单，而且非常的丰富 jQuery 的隐式迭代特性，不再需要书写 for 循环语句 使用 jQuery 完全不用考虑兼容性问题 jQuery 提供了一系列动画相关的函数，使用非常方便 代码简单、粗暴 什么是 jQuery jQuery 是一个快速的、轻量的、功能丰富的 js 库 jQuery 的官网 http://jquery.com/ js 库：把一些常用到的方法写到一个单独的 js 文件，使用的时候直接去引用这 js 文件就可以了。（animate.js、common.js） 版本介绍官网下载地址：http://jquery.com/download/ jQuery 版本有很多，分为 1.x 2.x 3.x 大版本分类： 1.x 版本：能够兼容IE678浏览器（最终版本1.12.4）2.x 版本：不兼容IE678浏览器（最终版本2.2.4）3.x 版本：不兼容IE678，更加的精简（在国内不流行，因为国内使用 jQuery 的主要目的就是兼容IE678）,3.x 版本只是在原来的基础上增加了一些新的特性 关于压缩版和未压缩版 jquery.min.js：压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，采用了代码混淆，基本没有可阅读性 jquery.js：未压缩版本，适用于学习与开发环境，源码清晰，易阅读 入口函数入口函数的好处： 等待文档加载完成，不论代码是写在 body、head 中都可以正常去获取到元素 形成了一个沙箱，防止全局变量污染 两种写法： // 第一种写法$(document).ready(function() &#123;&#125;)// 第二种写法$(function() &#123;&#125;) 原生 JavaScript 的入口函数： window.onload = function() &#123;&#125; jQuery 入口函数与 js 入口函数的对比 JavaScript 的入口函数要等到页面中所有资源（包括图片、文件等外部资源）加载完成才开始执行。jQuery 的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。所以 jQuery 的入口函数要比 js 入口函数先执行 window.onload 存在覆盖问题；jq 的入口函数不存在覆盖问题 jQuery 使用步骤&lt;!-- 引包（引入js文件） --&gt;&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 写上入口函数 $(document).ready(function() &#123;&#125;) // 或者 $(function() &#123; // 在入口函数内部实现功能 &#125;)&lt;/script&gt; jquery 中的 $ 符号$ 来源于 jQuery ， 是个函数（查看 jQuery 源码中最后几行代码） // jquery 和 $ 是等价的jQuery === $ // true 作用：根据参数的不同， 作用是不同的 参数是个函数 $(function()&#123;&#125;) 作用是入口函数 参数是个 dom 对象 $(document) 作用是 dom 转 jq 参数是选择器 $(&#39;body&#39;) 作用是获取元素 参数是个 html 字符串 $(&#39;&lt;a&gt;123&lt;/a&gt;&#39;) 作用是创建节点 jQuery 对象与 DOM 对象基本概念： DOM 对象：使用 JavaScript 中的方法获取页面中的元素返回的对象就是 Dom 对象 jQuery 对象：jquery 对象就是使用 jquery 的方法获取页面中的元素返回的对象 jQuery 对象其实就是 DOM 对象的包装集（包装了 DOM 对象的集合），是一个 伪数组 jQuery 对象与 DOM 对象的区别： DOM 对象与 jQuery 对象的方法不能混用。dom 对象不能使用 jq 对象的方法，jq 对象也不能使用 dom 对象的属性和方法 DOM 对象可以和 jQuery 对象可以相互转化 DOM 对象转换成 jQuery 对象：【联想记忆：花钱】 // 将 dom 对象作为参数传递到 $() 里面去， 那么这个整体就是个jq对象var $obj = $(domObj) jQuery 对象转换成 DOM 对象： // 通过 $() 来获取到的元素返回的对象就是jq对象var $li = $(&#x27;li&#x27;)// 第一种方法,通过下标取出（推荐使用）$li[0]// 第二种方法$li.get(0) 【练习：隔行变色案例】 选择器jQuery 选择器jQuery 选择器是 jQuery 为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery 选择器返回的是 jQuery 对象 jQuery 选择器有很多，基本兼容了 CSS1 到 CSS3 所有的选择器，并且 jQuery 还添加了很多更加复杂的选择器 css 选择器jQuery 完全兼容 css 选择器 名称 用法 描述 ID 选择器 $(&#39;#id&#39;) 获取指定 id 的元素 类选择器 $(&#39;.class&#39;) 获取同一类 class 的元素 标签选择器 $(&#39;div&#39;) 获取同一类标签的所有元素 并集选择器 $(&#39;div, p, li&#39;) 使用逗号分隔，只要符合条件之一就可 交集选择器 $(&#39;div.redClass&#39;) 获取 class 为 redClass 的 div 元素 子代选择器 $(&#39;ul&gt;li&#39;) 使用 &gt; 号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(&#39;ul li&#39;) 使用空格，代表后代选择器，获取 ul 下的所有 li 元素，包括孙子等 过滤选择器这类选择器都带冒号 : 名称 用法 描述 :eq(index) $(&#39;li:eq(2)&#39;) 获取 li 元素中，选择索引号为 2 的元素，索引号 index 从 0 开始 :odd $(&#39;li:odd&#39;) 获取 li 元素中，选择索引号为奇数的元素 :even $(&#39;li:even&#39;) 获取 li 元素中，选择索引号为偶数的元素 :first $(&#39;li:first&#39;) 获取 li 元素中的第一个 :last $(&#39;li:last&#39;) 获取 li 元素中的最后一个 【案例：隔行变色】 筛选选择器(方法)筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器 主要是方法 名称 用法 描述 children(selector) $(&#39;ul&#39;).children(&#39;li&#39;) 获取当前元素的所有子元素中的 li 元素 find(selector) $(&#39;ul&#39;).find(&#39;li&#39;) 获取当前元素中的后代元素中的 li 元素 siblings(selector) $(&#39;#first&#39;).siblings(&#39;li&#39;) 查找兄弟节点，不包括自己本身 parent() $(&#39;#first&#39;).parent() 查找父亲 parents() $(&#39;#first&#39;).parents(&#39;&#39;) 查找所有祖宗（参数 指定具体祖宗） eq(index) $(&#39;li&#39;).eq(2) 相当于$(&#39;li:eq(2)&#39;)，index 从 0 开始 next() $(&#39;li&#39;).next() 找下一个兄弟 nextAll() $(&#39;li&#39;).nextAll() 找后面所有的兄弟 prev() $(&#39;li&#39;).prev() 找上一个兄弟 prevAll() $(&#39;li&#39;).prevAll() 找前面所有的兄弟 【案例：下拉菜单】【案例：突出展示】【案例：手风琴】【案例：淘宝精品】 补充mouseover 与 mouseenter mouseover 和 mouseoverenter 都有鼠标经过的意思，但是在注册鼠标经过事件的时候，推荐使用mouseenter mouseenter 与 mouseover 的不同 mouseover 与 mouseout 是一对事件，当鼠标经过当前元素或者当前元素的子元素的时候，会触发【事件冒泡】。 mouseenter 与 mouseleave 是一对事件，只有当鼠标经过当前元素时，事件会触发，鼠标经过子元素，mousenter 事件是不会触发的 index 方法index() 方法返回的是当前元素在所有兄弟元素里面的索引 区分 jQuery 与 JavascriptJavaScript 是一门编程语言，jQuery 仅仅是用 JavaScript 实现的一个 JavaScript 库，目的是简化我们的开发 jQuery 样式操作css 操作功能：设置或者修改样式，操作的是 style 属性 设置单个样式 // name：需要设置的样式名称// value：对应的样式值css(name, value)// 使用案例$(&#x27;#one&#x27;).css(&#x27;background&#x27;, &#x27;gray&#x27;) // 将背景色修改为灰色 设置多个样式 // 参数是一个对象，对象中包含了需要设置的样式名和样式值css(obj)// 使用案例$(&#x27;#one&#x27;).css(&#123; background: &#x27;gray&#x27;, width: &#x27;400px&#x27;, height: &#x27;200px&#x27;&#125;) 获取样式 // name: 需要获取的样式名称css(name)// 案例$(&#x27;div&#x27;).css(&#x27;background-color&#x27;) 注意： 设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值 获取操作的时候，如果是多个元素，那么只会返回第一个元素的值 class 操作 添加样式类 // 给所有的 div 添加 one 的样式$(&#x27;div&#x27;).addClass(&#x27;one&#x27;) 移除样式类 // 移除 div 中 one 类名$(&#x27;div&#x27;).removeClass(&#x27;one&#x27;) 判断是否有某个样式类 判断标准是： 只要有一个元素有指定的类名，就返回 true，所有的元素都没有该类名，就返回 false // 判断是否有 one 的样式类$(&#x27;div&#x27;).hasClass(&#x27;one&#x27;) 切换样式类 // 如果有，移除该类，如果没有，添加该类$(&#x27;div&#x27;).toggleClass(&#x27;one&#x27;) 【案例：tab 栏切换案例.html】 jQuery 属性操作attr 操作设置单个属性 // 第一个参数：需要设置的属性名// 第二个参数：对应的属性值attr(name, value)// 用法举例$(&#x27;img&#x27;).attr(&#x27;title&#x27;, &#x27;哈哈&#x27;) 设置多个属性 // 参数是一个对象，包含了需要设置的属性名和属性值$(&#x27;img&#x27;).attr(&#123; title: &#x27;hello&#x27;, alt: &#x27;hello&#x27;, style: &#x27;opacity: .5&#x27;&#125;) 获取属性 // 传需要获取的属性名称，返回对应的属性值var oTitle = $(&#x27;img&#x27;).attr(&#x27;title&#x27;) 移除属性 // 参数：需要移除的属性名$(&#x27;img&#x27;).removeAttr(&#x27;title&#x27;) 【案例：美女相册.html】 prop 操作在 jQuery1.6 之后，对于 checked、selected、disabled 这类 boolean 类型的属性来说，不能用 attr 方法，只能用 prop 方法 // 设置属性$(&#x27;input:checked&#x27;).prop(&#x27;checked&#x27;, true)// 获取属性$(&#x27;input:checked&#x27;).prop(&#x27;checked&#x27;) // 返回 true 或者 false 【案例：表格全选案例.html】 jQuery 动画jquery 提供了三组基本动画，这些动画都是标准的、有规律的效果，jquery 还提供了自定义动画的功能 三组基本动画 显示 (show) 与隐藏 (hide) 与切换 (slideToggle) 上滑 (slideUp) 与下滑 (slideDown) 与切换 (slideToggle)，效果与卷帘门类似 淡入 (fadeIn) 与淡出 (fadeOut) 与切换 (fadeToggle) // show() 系列show([speed], [easing], [callback])// speed(可选)：动画的执行时间// 1.如果不传，就没有动画效果。如果是 slide 和 fade 系列，会默认为 normal// 2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐)// 3.固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal// easing(可选)：动画效果，默认是 swing，秋千，提供了一个 linear 匀速的效果// callback(可选)：执行完动画后执行的回调函数// slide 系列，参数使用和show 是一样的，不传参数，默认有动画效果slideDown([speed], [easing], [callback])// fade 系列，参数使用和 show 是一样的，不传参数，默认有动画效果fadeIn([speed], [easing], [callback]) 【案例：下拉菜单动画版.html】【案例：京东轮播图(呼吸灯).html】 自定义动画animate：自定义动画（只支持数值型的动画） $(selector).animate(&#123; params &#125;, [speed], [easing], [callback])// &#123;params&#125;：要执行动画的 CSS 属性，带数字（必选），多个属性会同时执行// speed：执行动画时长（可选）// easing: 执行效果，默认为swing（缓动） linear（匀速）// callback：动画执行完后立即执行的回调函数（可选） 动画队列与停止动画在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行 // 有顺序的执行效果// 动画队列：// 像链式编程一样，通过 . 继续写动画，给元素添加了多个动画, 这多个动画会添加到元素的动画队列里面，按照顺序依次执行$(function() &#123; $(&#x27;div&#x27;) .animate(&#123; left: 800 &#125;, 1000) .animate(&#123; top: 300 &#125;, 1000) .animate(&#123; borderRadius: 50 &#125;, 1000) .slideUp(2000) .slideDown(2000)&#125;)// 好处：可以有顺序的执行动画效果// 坏处：bug 给元素不停的添加动画，元素就不停的运动 stop 方法 // 停止当前正在执行的动画，如果元素的动画队列里面有后续动画，后续动画会执行stop(clearQueue, jumpToEnd)// 第一个参数：可选，是否清除队列，true，表示清除掉，默认 false// 第二个参数：可选，是否跳转到当前正在执行的动画的最终效果，true，表示跳转， 默认false 【案例：手风琴特效】【案例：音乐导航】 jQuery 节点操作创建节点// $()// 括号内写 html 格式的字符串$(&#x27;&lt;span&gt;这是一个span元素&lt;/span&gt;&#x27;) 添加节点// appendA.append(B) // 把 B 添加到 A 里面去，B 作为 A 的最后一个子元素// appendToB.appendTo(A) // 作用同上，写法不同// prependA.prepend(B) // 把 B 添加到 A 里面去，B 作为 A 的第一个子元素// prependToB.prependTo(A) // 作用同上，写法不同// afterA.after(B) // 把 B 作为 A 的兄弟，添加在 A 的后面// beforeA.before(B) // 把 B 作为 A 的兄弟，添加在 A 的前面 【案例：城市选择案例】 清空节点与删除节点empty：清空指定节点的所有元素，自身保留(清理门户) $(&#x27;div&#x27;).empty() // 清空 div 的所有内容（推荐使用，会清除子元素上绑定的内容，源码）$(&#x27;div&#x27;).html(&#x27;&#x27;) // 使用 html 方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除 remove：删除节点，会把元素自身给删除掉 $(&#x27;div&#x27;).remove() // 删除 div 节点 克隆节点clone：克隆元素节点 $(&#x27;div&#x27;).clone() // 返回复制的 div 新元素，（默认不显示，需要配合 append 方法）// 新元素和原来的元素没有任何关系// clone(布尔类型参数)， 参数为true， 克隆元素的事件，默认值是false jQuery 特殊属性操作val()val 方法用于设置和获取表单元素的值，例如 input、textarea 的值 // 设置值$(&#x27;#name&#x27;).val(&#x27;张三&#x27;)// 获取值$(&#x27;#name&#x27;).val() 【案例：搜索框】 html() 与 text()html 方法相当于 innerHTML，text 方法相当于 innerText // 设置内容$(&#x27;div&#x27;).html(&#x27;&lt;span&gt;这是一段内容&lt;/span&gt;&#x27;)// 获取内容$(&#x27;div&#x27;).html()// 设置内容$(&#x27;div&#x27;).text(&#x27;&lt;span&gt;这是一段内容&lt;/span&gt;&#x27;)// 获取内容$(&#x27;div&#x27;).text() 区别：html 方法会识别 html 标签，text 方法会将内容直接当成字符串，并不会识别 html 标签 width() 与 height()设置或者获取 内容区域 的宽度和高度 // 带参数表示设置$(&#x27;div&#x27;).width(200)$(&#x27;div&#x27;).height(200)// 不带参数表示获取$(&#x27;div&#x27;).width()$(&#x27;div&#x27;).height() 获取 内容区域 + padding 的宽度和高度 $(&#x27;div&#x27;).innerWidth()$(&#x27;div&#x27;).innerHeight() 获取 内容区域 + padding + border 的宽度和高度 $(&#x27;div&#x27;).outerWidth()$(&#x27;div&#x27;).outerHeight() 获取 内容区域 + padding + border + margin 的宽度和高度 // 传入参数true$(&#x27;div&#x27;).outerWidth(true)$(&#x27;div&#x27;).outerHeight(true) 获取网页的可视区宽高 $(window).width()$(window).height() scrollTop 与 scrollLeft设置或者获取垂直滚动条的位置 // 传参表示设置，不传参表示获取$(window).scrollTop(2000)$(window).scrollLeft()// 实时的去获取到页面垂直卷曲的距离$(window).scroll(function() &#123; console.log($(window).scrollTop()) console.log($(window).scrollLeft())&#125;) 返回顶部固定写法 $goTop.click(function() &#123; $(&#x27;html, body&#x27;).animate( &#123; scrollTop: 0 &#125;, 1000 )&#125;) 【案例：固定菜单栏案例】【案例：小火箭返航案例】 offset 方法与 position 方法offset 方法获取元素距离 document 的位置，position 方法获取的是元素距离有定位的父元素的位置 // 获取元素距离 document 的位置，和父元素没有关系，返回值为对象：&#123;left:100, top:100&#125;$(selector).offset()// 获取相对于其最近的有定位的父元素的位置，返回值为对象$(selector).position() jQuery 事件机制JavaScript 中已经学习过了事件，但是 jQuery 对 JavaScript 事件进行了封装，增加并扩展了事件处理机制。jQuery 不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。 jQuery 事件发展历程(了解)简单事件绑定&gt;&gt; bind 事件绑定&gt;&gt; delegate 事件绑定 &gt;&gt;on 事件绑定(推荐) 简单方式事件注册 // jq 中简单方式注册相同的事件是不会被覆盖的$(&#x27;div&#x27;).click(function() &#123; alert(&#x27;2&#x27;)&#125;)$(&#x27;div&#x27;).click(null) // alert(&#x27;2&#x27;) 依然会执行 缺点：不能同时注册多个事件，无法解绑事件 bind 方式注册事件 // 第一个参数：事件类型，如果需要给元素注册多个事件，可以用空格隔开写上多个事件名// 第二个参数：事件处理函数$(&#x27;p&#x27;).bind(&#x27;click mouseenter&#x27;, function() &#123; // 事件响应方法&#125;) unbind 解绑事件（不用） $(&#x27;div&#x27;).unbind() // 不传参数解绑所有的事件$(&#x27;div&#x27;).unbind(&#x27;click&#x27;) // 解绑指定的事件 缺点：不支持动态事件绑定 delegate 注册委托事件 事件是注册给父元素的，由子元素去触发该事件 原理： 事件冒泡 优点：节省内存，支持动态绑定 // 第一个参数：要绑定事件的元素// 第二个参数：事件类型// 第三个参数：事件处理函数$(&#x27;div&#x27;).delegate(&#x27;p&#x27;, &#x27;click&#x27;, function() &#123; // 事件注册给了父元素 div，为所有的子元素 p 绑定事件， 由 p 去触发事件&#125;) undelegate 解绑事件（不用） $(&#x27;div&#x27;).undelegate() // 解绑所有的 delegate 事件$(&#x27;div&#x27;).undelegate(&#x27;click&#x27;) // 解绑所有的 click 事件 缺点：只能注册委托事件，因此注册时间需要记得方法太多了 on 注册事件(重点)jQuery 1.7 之后，jQuery 用 on 统一了所有事件的处理方法，强烈建议使用 on 注册简单事件 // 表示给 $(&#x27;div&#x27;) 绑定事件，并且由自己触发，不支持动态绑定$(&#x27;div&#x27;).on(&#x27;click&#x27;, function() &#123;&#125;) on 注册委托事件 // 表示给 $(&#x27;div&#x27;) 绑定代理事件，必须是它的内部元素 span 才能触发这个事件，支持动态绑定$(&#x27;div&#x27;).on(&#x27;click&#x27;, &#x27;span&#x27;, function() &#123;&#125;) on 注册事件的语法 // 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）// 第四个参数：handler，事件处理函数$(selector).on(events[,selector][,data],handler) off 解绑事件// 解绑匹配元素的所有事件，父元素子元素的所有事件都解绑了$(&#x27;div&#x27;).off()// 解绑匹配元素的所有 click 事件$(&#x27;div&#x27;).off(&#x27;click&#x27;)// 解绑子元素 p 的所有 click 事件, 父元素的click事件不会被解绑$(&#x27;div&#x27;).off(&#x27;click&#x27;, &#x27;p&#x27;) 触发事件// 点击 div 触发事件$(&#x27;div&#x27;).on(&#x27;click&#x27;, function() &#123; alert(2)&#125;)// 可由其他元素触发 div 的事件// 点击 btn 触发 div 的 click 事件$(&#x27;#btn&#x27;).on(&#x27;click&#x27;, function() &#123; // $(&#x27;div&#x27;).click() // 触发 div 的 click 事件 $(&#x27;div&#x27;).trigger(&#x27;click&#x27;) // trigger(type) 触发 div 的 click 事件&#125;) jQuery 事件对象jQuery 事件对象其实就是 js 事件对象的一个封装，处理了兼容性 // screenX 和 screenY 对应屏幕最左上角的值// clientX 和 clientY 距离页面左上角的位置（忽视滚动条）// pageX 和 pageY 距离页面最顶部的左上角的位置（会计算滚动条的距离）// event.keyCode 按下的键盘代码// event.data 存储绑定事件时传递的附加数据// event.stopPropagation() 阻止事件冒泡行为// event.preventDefault() 阻止浏览器默认行为// return false 既能阻止事件冒泡，又能阻止浏览器默认行为 注意：js 中的 return false 只能起到阻止浏览器的默认行为，jquery 中的 return false 既能阻止事件冒泡也能阻止浏览器的默认行为 【案例：钢琴版导航（加强)】 【案例：弹幕效果】 jQuery 特点隐式迭代基本概念隐式迭代：jQuery 在设置属性时会自动的遍历，因此我们不需要再遍历 jQuery 在执行设置性操作时，会给所有的元素都设置上相同的值 jQuery 在执行获取性操作时，只会返回第一个元素对应的值 如果想要给每一个元素都设置不同的值，需要手动进行遍历 jQuery 对象 each 方法遍历 jQuery 对象集合，为每个匹配的元素执行一个函数 语法： $(selector).each(function(index, element) &#123; // index 表示当前元素在所有匹配元素中的索引号 // element 表示当前元素 // this 在函数内部，this指向了element&#125;)$(&#x27;li&#x27;).each(function(index, ele) &#123; // $(ele).css(&#x27;backgroundColor&#x27;, arr[index]) $(this).css(&#x27;backgroundColor&#x27;, arr[index])&#125;) 链式编程链式编程的原理：设置性操作会返回一个 jQuery 对象，因此可以继续调用 jQuery 的方法 设置操作的时候，可以使用链式编程 获取操作的时候，无法使用链式编程，（因为没有返回 jq 对象） 链式编程不要太长，因为代码可读性差 prevObject: 返回上一次找到的jq对象end() // 上一次返回的 jq 对象（封装了 prevObject 属性） 【案例：五角星评分案例.html】 多库共存jQuery 使用 $作为标示符，但是如果与其他框架中的 $ 冲突时，jQuery 可以释放 $ 符的控制权 // noConflict() // 返回 $ 的功能var c = $.noConflict() // 释放 $ 的控制权,并且把 $ 的能力给了 c jQuery 插件插件：其实就是个 js 库，依赖于 jquery，而且在 jquery 的基础上新增一些功能 使用插件1. 先引入jQuery文件2. 在引入插件（如果有用到css的话，需要引入css）3. 使用插件 常用插件的使用 jquery.color.js animate 只支持数值型的动画，色值型的不支持，这个插件就可以让 animate 做色值型的动画 jquery.lazyload.js // 使用方法// html图片调用方法// 为图片加入样式 lazy 图片路径引用方法用 data-original// &lt;img class=&#x27;lazy&#x27; data-original=&#x27;img/1.jpg&#x27;&gt;// js出始化lazyload并设置图片显示方式$(function() &#123; $(&#x27;img.lazy&#x27;).lazyload(&#123; effect: &#x27;fadeIn&#x27;, placeholder: &#x27;img/2.jpg&#x27;, // 用图片提前占位,待图片加载时,占位图则会隐藏 effect: &#x27;fadeIn&#x27;, // 载入使用何种效果 threshold: 200, // 表示滚动条在离目标位置200的高度时开始加载图片,可以做到不让用户察觉 event: &#x27;click&#x27; // 事件触发时才加载 &#125;)&#125;) 制作 jQuery 插件制作 jQuery 插件的核心思想：给 jQuery 的原型增加方法即可。 $.fn.pluginName = function() &#123;&#125; 制作基本的 jQuery 插件（jquery.bgc.js） 制作手风琴插件 jQuery 架构看源码学习推荐看 1.7.0 版本，源码比较清晰 jq 的基本架构沙箱 ，减少全局污染 ;(function(window, undefined) &#123; // console.log(undefined) var jQuery = function() &#123;&#125; // 往外暴露 window.jQuery = window.$ = jQuery&#125;)(window)var jq = new jQuery() // ==&gt; 得到一个jq的实例对象console.log(jq) 参数 window 的作用： 减少对 window 的搜索过程 有利于代码压缩 参数 undefined 的作用： 参数 undefined 的值是 undefined undefined 这个数据类型的值在 ie678 中是可以被修改的，现在有 undefined 形参在这，在沙箱里面去使用 undefined 的时候，就不会去引用外面被修改的 undefined 的值 省去 new 操作// 省去 new 操作，得到一个jq的实例对象;(function(window, undefined) &#123; // jQuery 是 工厂函数， 里面干啥？ var jQuery = function(selector) &#123; // return new 构造函数 // 在 jq 里面，真正的构造函数是 init，而且 init 方法放在 jq 的原型上 // jQuery.fn.init ==&gt; 是从 jq 的原型上拿 init 方法 return new jQuery.fn.init(selector) // init 何种调用模式， 构造函数模式 &#125; jQuery.fn = jQuery.prototype = &#123; // 原型替换 constructor: jQuery, init: function(selector) &#123; // init 是真正的构造函数 // 获取元素 var ele = document.querySelectorAll(selector) // this ==&gt; init的实例对象 ;[].push.apply(this, ele) &#125;, css: function() &#123; console.log(&#x27;css is ok&#x27;) &#125; &#125; window.jQuery = window.$ = jQuery&#125;)(window)// 把 init 的构造函数的 prototype 改成 jquery 的原型// 目的： 让 init 的实例对象可以访问 jq 原型上的方法jQuery.fn.init.prototype = jQuery.fnvar $div = $(&#x27;div&#x27;) // init实例对象console.log($div)$div.css()"},{"title":"Date对象使用及常用的时间格式化代码块","date":"10/12/2019","updated":"10/12/2019","comments":true,"path":"backup/js-date对象使用及常用时间格式化代码块--获取本周,本月,本季度,本年,上月,上周,上季度,去年等.html","permalink":"https://wqdy.top/backup/js-date%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81%E5%9D%97--%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%91%A8,%E6%9C%AC%E6%9C%88,%E6%9C%AC%E5%AD%A3%E5%BA%A6,%E6%9C%AC%E5%B9%B4,%E4%B8%8A%E6%9C%88,%E4%B8%8A%E5%91%A8,%E4%B8%8A%E5%AD%A3%E5%BA%A6,%E5%8E%BB%E5%B9%B4%E7%AD%89.html","excerpt":"","text":"Date 对象整理一些时间格式化的方法 /** * 时间格式化 * @param &#123;date&#125; timeStamp 要格式化的时间对象 * @return &#123;string&#125; 2019年10月31日 16:22 */function format_date(timeStamp) &#123; let date = new Date(timeStamp) return date.getFullYear() + &#x27;年&#x27; + prefix_zero(date.getMonth() + 1) + &#x27;月&#x27; + prefix_zero(date.getDate()) + &#x27;日 &#x27; + prefix_zero(date.getHours()) + &#x27;:&#x27; + prefix_zero(date.getMinutes())&#125; /** * 数字格式化 * @param &#123;number&#125; num 要格式化的数值 * @return &#123;string&#125; 把小于10的数值前面加上0 */function prefix_zero(num) &#123; return num &gt;= 10 ? num : &#x27;0&#x27; + num&#125; /** * 昨天的字符串格式时间 * @return &#123;string&#125; 返回当前时间 - 1天 */function getYesterday() &#123; var d = new Date() d.setDate(d.getDate() - 1) return d.toLocaleString()&#125; /** * 明天的字符串格式时间 * @return &#123;string&#125; 返回当前时间 + 1天 */const getTomorrow = () =&gt; &#123; let d = new Date() d.setDate(d.getDate() + 1) return d.toLocalString()&#125; /** * 获得本周的开始日期 * @param &#123;number&#125; start 不传默认一周以周日开始 1 表示以周一开始 * @return &#123;date&#125; timeStamp 时间戳 */function getWeekDate(start = 0) &#123; let d = new Date(&#x27;2019-12-15&#x27;) let D = d.getDate() if (start == 0) &#123; return d.setDate(D - d.getDay()) &#125; else &#123; let W = d.getDay() || 6 return d.setDate(D - W + 1) &#125;&#125; /** * 获得最近一周时间段 * @return &#123;date[]&#125; */function getLastWeek() &#123; let d = new Date() let D = d.getDate() d.setDate(D - 7) return [d, new Date()]&#125; /** * 获得某月的天数 * @param &#123;number&#125; year 年 * @param &#123;number&#125; month 月 从 0 开始 * @return &#123;number&#125; 某月的天数, 不传参数为当月天数 */function getMonthDays(year, month) &#123; let d = new Date() year = year || d.getFullYear() month = month || d.getMonth() var monthStart = new Date(year, month, 1) var monthEnd = new Date(year, month + 1, 1) var days = (monthEnd - monthStart) / (1000 * 60 * 60 * 24) return days&#125; /** * 获得本月的开始或结束日期 * @param &#123;number&#125; isEnd 不传默认本周的开端日期 1 本周的结束日期 * @return &#123;date&#125; timeStamp 时间戳 */function getMonthDate(isEnd = 0) &#123; let d = new Date() d.setDate(1) if (isEnd) &#123; d.setDate(d.getDate() + getMonthDays() - 1) return d &#125; return d&#125; /** * 倒计时时间格式化 * @param &#123;date&#125; timeStamp 要格式化的时间对象 * @return &#123;string&#125; * 若时间大于1天 返回 n天n小时n分钟 * 若时间小于1天，大于1小时 返回 n小时n分钟n秒 * 若时间小于1小时，大于1分钟 返回 n分钟n秒 * 若时间小于1分钟 返回 n秒 */function format_time(timeStamp) &#123; let day = Math.floor(timeStamp / (24 * 3600 * 1000)) let leave1 = timeStamp % (24 * 3600 * 1000) let hours = Math.floor(leave1 / (3600 * 1000)) let leave2 = leave1 % (3600 * 1000) let minutes = Math.floor(leave2 / (60 * 1000)) let leave3 = leave2 % (60 * 1000) let seconds = Math.floor(leave3 / 1000) if (day) return day + &#x27;天&#x27; + hours + &#x27;小时&#x27; + minutes + &#x27;分&#x27; if (hours) return hours + &#x27;小时&#x27; + minutes + &#x27;分&#x27; + seconds + &#x27;秒&#x27; if (minutes) return minutes + &#x27;分&#x27; + seconds + &#x27;秒&#x27; if (seconds) return seconds + &#x27;秒&#x27; return &#x27;时间到！&#x27;&#125; dayjs 库轻量的处理时间和日期的 JavaScript 库 参考文档 github 中文文档 在本页面打开控制台即可体验 dayjs 的 api 使用 dayjs 获取本周,上周,本月,上月,本季度,上季度,本年,去年时间 // let date = dayjs(&#x27;2020-01-16&#x27;)let date = dayjs()let day = date.day() // 1 星期let currentWeekStartlet currentWeekEnd// 本周if (day &gt; 0) &#123; currentWeekStart = date.startOf(&#x27;week&#x27;).add(1, &#x27;day&#x27;)&#125; else &#123; currentWeekStart = date.startOf(&#x27;week&#x27;).subtract(6, &#x27;day&#x27;)&#125;currentWeekEnd = currentWeekStart.add(6, &#x27;day&#x27;)// 上周let lastWeekStart = currentWeekStart.subtract(7, &#x27;day&#x27;)let lastWeekEnd = currentWeekStart.subtract(1, &#x27;day&#x27;)// 本月 上月let currentMonthStart = date.date(1)let lastMonthStart = date.subtract(1, &#x27;month&#x27;).date(1)let nextMonthStart = date.add(1, &#x27;month&#x27;).date(1)let currentMonthEnd = nextMonthStart.subtract(1, &#x27;day&#x27;)let lastMonthEnd = currentMonthStart.subtract(1, &#x27;day&#x27;)// 本季度,上季度// 本年 去年let currentYearStart = date.month(0).date(1)let currentYearEnd = date.month(11).date(31)let lastYear = date.subtract(1, &#x27;year&#x27;)let lastYearStart = date.subtract(1, &#x27;year&#x27;).month(0).date(1)let lastYearEnd = lastYearStart.month(11).date(31)let computedDate = &#123; currentWeekStart: currentWeekStart.format(&#x27;YYYY-MM-DD&#x27;), currentWeekEnd: currentWeekEnd.format(&#x27;YYYY-MM-DD&#x27;), lastWeekStart: lastWeekStart.format(&#x27;YYYY-MM-DD&#x27;), lastWeekEnd: lastWeekEnd.format(&#x27;YYYY-MM-DD&#x27;), currentMonthStart: currentMonthStart.format(&#x27;YYYY-MM-DD&#x27;), currentMonthEnd: currentMonthEnd.format(&#x27;YYYY-MM-DD&#x27;), lastMonthStart: lastMonthStart.format(&#x27;YYYY-MM-DD&#x27;), lastMonthEnd: lastMonthEnd.format(&#x27;YYYY-MM-DD&#x27;), currentYearStart: currentYearStart.format(&#x27;YYYY-MM-DD&#x27;), currentYearEnd: currentYearEnd.format(&#x27;YYYY-MM-DD&#x27;), lastYearStart: lastYearStart.format(&#x27;YYYY-MM-DD&#x27;), lastYearEnd: lastYearEnd.format(&#x27;YYYY-MM-DD&#x27;)&#125;console.log(computedDate)"},{"title":"浏览器切换标签离开当前页面时改变 title 提示","date":"27/09/2019","updated":"27/09/2019","comments":true,"path":"backup/js-浏览器切换标签离开当前页面时改变-title-提示.html","permalink":"https://wqdy.top/backup/js-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%87%E6%8D%A2%E6%A0%87%E7%AD%BE%E7%A6%BB%E5%BC%80%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2%E6%97%B6%E6%94%B9%E5%8F%98-title-%E6%8F%90%E7%A4%BA.html","excerpt":"","text":"document.addEventListener(&#x27;visibilitychange&#x27;, function() &#123; if (document.visibilityState == &#x27;hidden&#x27;) &#123; normal_title = document.title document.title = &#x27;离开了&#x27; &#125; else document.title = normal_title&#125;)"},{"title":"js 中编码（encode）和解码（decode）的三种方法","date":"09/07/2019","updated":"09/07/2019","comments":true,"path":"backup/js-编码（encode）和解码（decode）的三种方法.html","permalink":"https://wqdy.top/backup/js-%E7%BC%96%E7%A0%81%EF%BC%88encode%EF%BC%89%E5%92%8C%E8%A7%A3%E7%A0%81%EF%BC%88decode%EF%BC%89%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95.html","excerpt":"","text":"js 中编码（encode）和解码（decode）的三种方法js 对文字进行编码涉及 3 个函数：escape、encodeURI、encodeURIComponent，相应 3 个解码函数：unescape、decodeURI、decodeURIComponent escape()函数 定义和用法：escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串语法：escape(string)参数：string 必需，要被转义或编码的字符串。返回值：已编码的 string 的副本。其中某些字符被替换成了十六进制的转义序列说明：该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： -_.!~*&#39;() ，其他所有的字符都会被转义序列替换 encodeURI()函数 定义和用法：encodeURI() 函数可把字符串作为 URI 进行编码语法：encodeURI(URIstring)参数：URIstring 必需，一个字符串，含有 URI 或其他要编码的文本。返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：-_.!~*&#39;() ，该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,# encodeURIComponent() 定义和用法：encodeURIComponent() 函数可把字符串作为 URI 组件进行编码语法：encodeURIComponent(URIstring)参数：URIstring 必需，一个字符串，含有 URI 组件或其他要编码的文本返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：-_.!~*&#39;()，其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的 说明： encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号 传递参数时需要使用 encodeURIComponent，这样组合的 url 才不会被#等特殊字符截断"},{"title":"移动端、PC端、小程序常用的UI框架","date":"28/02/2020","updated":"28/02/2020","comments":true,"path":"backup/移动端、pc端、小程序常用的ui框架.html","permalink":"https://wqdy.top/backup/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E3%80%81pc%E7%AB%AF%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%9A%84ui%E6%A1%86%E6%9E%B6.html","excerpt":"","text":"移动端 UI 库Vant UI (vue)官方地址：https://youzan.github.io/vant/#/zh-CN/ github 地址：https://github.com/youzan/vant 12.8k 优点：用来做移动端商城很不错 PC 端 UI 库Element UI (vue)官方地址：http://element-cn.eleme.io/#/zh-CN/component/installation github 地址：https://github.com/ElemeFE/element 44k iView UI (vue)官方地址：http://iview.talkingdata.com/#/components/guide/install github 地址：https://github.com/iview/iview 23.1k Ant Design (react)官方地址：https://ant.design/docs/react/introduce-cn github 地址：https://github.com/ant-design/ant-design 56.9k 小程序 UI 库Vant Weapp官方地址：https://youzan.github.io/vant-weapp/#/intro github 地址：https://github.com/youzan/vant-weapp 11.9k 优点：组件丰富，合适做商城类小程序 Color UI官方地址：https://www.color-ui.com/ github 地址：https://github.com/weilanwl/ColorUI 7.8k 优点：样式好看 设计动效Ant Motion官方地址：https://motion.ant.design/index-cn github 地址：https://github.com/ant-design/ant-motion/ 3.6k 数据可视化DataV(Vue 组件库)官方地址：http://datav.jiaminghi.com/ github 地址：https://github.com/DataV-Team/DataV 1.4k Echarts(Vue 组件库)github 地址：https://github.com/apache/incubator-echarts 39.6k 模板vue-element-admin(pc 后台管理 vue2.0+element)演示地址：https://panjiachen.github.io/vue-element-admin/ github 地址：https://github.com/PanJiaChen/vue-element-admin 49.8k 使用文档：https://panjiachen.github.io/vue-element-admin-site/zh/ 博客系列教程地址：https://segmentfault.com/a/1190000009275424 iView-admin(pc 后台管理 vue2.0+iView)演示地址：https://admin.iviewui.com/ github 地址：https://github.com/iview/iview-admin 14.2k 使用文档：https://lison16.github.io/iview-admin-doc/"},{"title":"标签","date":"22/12/2017","updated":"22/12/2017","comments":false,"path":"tags/index.html","permalink":"https://wqdy.top/tags/index.html","excerpt":"","text":""},{"title":"PHP","date":"25/10/2018","updated":"25/10/2018","comments":true,"path":"backup/后端/php.html","permalink":"https://wqdy.top/backup/%E5%90%8E%E7%AB%AF/php.html","excerpt":"","text":"服务器什么是服务器？ 通过安装服务器软件，提供服务 的计算机 服务器可以从硬件、软件(系统软件、应用软件)几个角度描述。 按硬件描述： 服务器就是一台超级计算机(配置很高)。按操作系统划分： 在硬件上安装了什么操作系统，就可以称为该系统的服务器​ 例如: linux 服务器、windows 服务器、unix 服务器等。按软件划分： 在操作系统中安装了什么软件，就可以称作该软件的服务器 iis tomcat​ 例如: web 服务器、数据库服务器、邮件服务器等。 什么是 Web 服务器Web 服务器就是安装了 Web 服务软件，web 服务器的作用是能够提供网站服务的服务器。淘宝、京东、新浪等等 常见的 Web 软件：Apache、Nginx、IIS、Tomcat、Node 等。Apache 服务器、Nginx 服务器、IIS 服务器、Tomcat 服务器、Node 服务器 Apache 是世界使用排名第一的 Web 服务器软件。我们将编写好的 html、css、js 等文件存入 apache，就能够通过网络来访问这些文件了 PS: web 服务器又叫做 http&#x2F;httpd 服务器 phpStudy 介绍 phpStudy 是一个 PHP 调试环境的程序集成包 该程序包集成最新的 Apache+PHP+MySQL 安装 phpStudy，一定不能有中文，否则肯定启动不起来 **注意: **将要访问的文件(html,php,img 等)，放到安装路径下的 www 目录下，通过浏览器就可以访问到了 phpStudy 的错误解决如果 phpStudy 启动发生错误，参数下列几点。 一是防火墙拦截 二是 80 端口已经被别的程序占用，如 IIS 等 三是没有安装 VC9 运行库,php 和 apache 都是 VC9 编译 PHP 基础(重点)PHP 简介PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。主要适用于 Web 领域的开发 ，能够完成 动态网页 的制作 PHP 特点 PHP 是目前最流行的网站开发语言（B&#x2F;S 结构）之一 PHP 是一种在服务器端执行的嵌入 HTML 文档的脚本语言 支持几乎所有流行的 数据库 以及操作系统 源码开放、免费（free) php 是世界上最好的语言 动态网站与静态网站(了解) 静态网站：使用浏览器端语言进行编程，网站由静态代码（HTML,CSS,JS）组成。 动态网站 ：网页通过服务器的程序(php 等)动态生成。用户可以和服务器进行交互（可以根据用户输入的不同信息，返回不同的运行结果） 总结 动态网站的 动 指的是网站 数据的动 而不是 视觉上的动 软件架构(了解) 软件架构可以分为 BS 架构与 CS 架构 C&#x2F;S 架构Client&#x2F;Server 架构，即客户端&#x2F;服务器架构。需要安装对应的客户端软件，才能获取服务器的服务 常见的 CS 架构：QQ、LOL、微信等 特点： 需要安装才能使用 性能高效，使用更加稳定和流畅 B&#x2F;S 架构Broswer&#x2F;Server 架构，即浏览器&#x2F;服务器架构。随着 Internet 的兴起，无需安装专门客户端软件，通过浏览器去请求服务器 不需要安装，只需要浏览器即可。 相比 CS 架构，性能相对较差，没有那么流畅和稳定 php 基本语法结构// 避免使用中文目录和中文文件名// 文件以.php后缀结尾，所有程序包含在&lt;?php 这里是代码 ?&gt;// php页面无法直接打开需要运行在服务器环境当中// 末尾必须加分号，不然就报错了（最后一行可以不加分号）&lt;?php echo &quot;hello world&quot;;?&gt; 输出中文乱码问题：如果使用 echo 输出中文，可能会乱码 &lt;?php // 解决中文乱码的问题 header(&quot;content-Type:text/html;charset=utf-8&quot;); // 返回HTML文档文本并设置编码集 echo &quot;hello world&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;大家好，我是一名摄影工作者&quot;;?&gt; PHP 运行原理HTML 运行原理 在浏览器的 URL 地址栏中输入 www.baidu.com/index.html 地址，点回车。请求就发送给百度服务器。 百度服务器找到 index.html 文件，并将文件的内容返回给浏览器 浏览器接收到 index.html 中的内容，渲染到页面上。 同理: localhost&#x2F;a.html , 则会返回 本机 web 服务器根目录下 a.html 文件的内容。浏览器拿到内容后进行渲染。 PHP 运行原理apache 不认识 php浏览器也不认识 php 在浏览器地址栏中输入 localhost&#x2F;index.php ,点回车之后。将请求发送给 apache 服务器 服务器找到 index.php 文件之后，转发给 php 解释器 php 解释器将 index.php 文件中的 php 代码全部转为字符串，再返回给 apache apache 将处理好的字符串返回给浏览器，浏览器渲染后就可以看到页面 变量 php 是一门弱类型语法，变量的类型可以随意改变。变量其实就是存储数据的容器 变量的命名规则 不需要关键字进行声明，变量在第一次赋值的时候被创建 必须以 $ 符号开始 $ 后面的命名规则与 js 的变量命名规则一致 变量操作声明变量 声明变量的时候也一定要同时赋值,否则变量无法声明成功 // 变量在声明的时候一定要同时赋值,否则变量无法声明成功$name = &quot;呵呵&quot;;echo $name; 删除变量 unset() unset($name); // 销毁指定的变量 判断变量是否设置值 isset() isset($name);echo isset($name); // 用 echo 打印，如果为 true 会打印出 1 ， 如果为 false 打印空var_dump(isset($name)); // 会打印出 bool(true)/bool(false) 变量未设置或者设置为 null，返回 false（认为变量没有设置），其余情况全部为 true。一般用来判断变量是否设置，因为变量未设置，无法直接使用。(变量先赋值，在使用！） 判断变量是否为空 empty() var_dump(empty($name)); // 为空打印出 bool(true)，不为空则打印 bool(false) PHP 中认为变量的值为：&quot;&quot;、0、&quot;0&quot;、null、false、[] 时，变量虽然赋值了，但是无实际的意义，为空。 数据类型 php 数据类型: 8 种数据类型 基本数据类型: 布尔, 字符串, 整数, 浮点数 复合数据类型:数组, 对象 特殊的类型:resource(资源) null 简单数据类型输出语句//1. echo 输出简单数据类型//2. print_r 输出数据结构，一般用于输出复杂类型。print_r($arr); // print_r 是一个函数，不要忘记小括号//3. var_dump 输出完整的数据结构，包括类型，一般用于精准调试var_dump($arr); 字符串$str = &quot;php是世界上是最好的语言&quot;;echo $str; 字符串连接符 php 中，+ 号只有算数的功能，并不能拼串，拼串使用 . $name = &quot;大象&quot;;echo &quot;大家好，我是&quot; . $name . &quot;，今年18岁&quot;; php 中的单引号与双引号 //1. 字符串的定义可以使用单引号，也可以使用双引号//2. 双引号可以解析变量//3. 单引号的性能会高于双引号（了解）$name = &quot;大象&quot;;$desc = &#x27;很帅&#x27;;$str = &#x27;$name 很帅&#x27;;echo $str; // $name 很帅$str = &quot;$name 很帅&quot;;echo $str; // 大象 很帅 整数$num = 100;echo $num; 浮点型$float = 11.11;echo $float; 布尔类型$flag = true;// 当布尔类型值为true时，输出1echo $flag;$flag = false;// 当布尔类型为false时，输出空字符串echo $flag; 数组 在 php 中，数组分为两种，索引数组 和 关联数组 计算数组长度的方法：count(数组名)； 索引数组（类似与 JS 中的数组） $arr = array(&quot;张飞&quot;,&quot;赵云&quot;,&quot;马超&quot;);echo $arr; // Array // echo 只能打印基本数据类型// 使用 print_r() 打印print_r($arr); // Array ([0] =&gt; 张飞 [1] =&gt; 赵云 [2] =&gt; 马超)echo $arr[0]; // 张飞 关联数组（类似与 JS 中的对象） // 属性名必须用引号引起来$arr = array(&quot;name&quot;=&gt;&quot;zhangsan&quot;, &quot;age&quot;=&gt;18);print_r($arr); // Array ( [name] =&gt; zhangsan [age] =&gt; 18 )echo $arr[&quot;name&quot;]; 二维数组与多维数组 数组中的每个元素又是一个数组二维数组的存取元素，需要两次访问，依次确定行和列 $arr[x][y]; 多维数组数组里面嵌套了两层以上的数组 对象(了解) 在 php 以及其他高级语言中，都有类的概念，表示一类对象，跟 js 中构造函数类似。 //定义一个类（类似js的构造函数）class Person &#123; public $name = &quot;小明&quot;; private $sex = &quot;男&quot;;&#125;$zs = new Person;print_r($zs);//打印对象的结构信息 Person Object ([name] =&gt; 小明[sex:Person:private] =&gt; 男 )echo $zs-&gt;name; // 对象中取值用 -&gt;echo $zs-&gt;sex; // 私有属性，无法获取 流程控制分支结构(if&#x2F;switch)基本上来说，所有语言的 if..else 语法都是一样 $age = 17;if ($age &gt;= 18) &#123; echo &quot;终于可以抽烟喝酒烫头了&quot;;&#125; else &#123; echo &quot;哎......&quot;;&#125;//===================switch(变量)&#123; case 值1: 程序块1； break; case 值2: 程序块2； break; ... default: 程序块&#125; 循环结构(while &#x2F; for &#x2F; do…while)while(判断表达式)&#123; 程序块;&#125;for(赋值表达式; 判断表达式; 步进表达式)&#123; 程序块;&#125;do&#123; 程序块&#125; while(判断表达式) 遍历索引数组 $arr = array(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;, &quot;田七&quot;, &quot;王八&quot;);// 获取数组的长度： count($arr)for($i = 0; $i &lt; count($arr); $i++) &#123; echo $arr[$i]; echo &quot;&lt;br&gt;&quot;;&#125; foreach 语句结构 用来遍历数组(关联数组和索引数组均可)。 foreach($arr as $key =&gt; $value)&#123; 程序体&#125;foreach($arr as $value)&#123; 程序体&#125; $arr : 要遍历的数组 $key: 键，可以是任意变量名 $value: 值，可以是任意变量名 //遍历关联数组$arr = array( &quot;name&quot;=&gt;&quot;zs&quot;, &quot;age&quot;=&gt;18, &quot;sex&quot;=&gt;20);foreach($arr as $k =&gt; $v) &#123; echo $k . &quot;=&quot; . $v . &quot;&lt;br&gt;&quot;;&#125; 函数 注意，在 php 中函数不能重复声明 php 中函数的语法与 js 中函数的语法基本一样，不同点在于 函数名大小写不敏感 函数的形参可以设置默认值 &lt;?php header(&quot;content-Type:text/html;charset=utf-8&quot;); function sayHello ($name=&quot;周杰伦&quot;) &#123; echo &quot;大家好，我是$name&quot;; echo &quot;&lt;br&gt;&quot;; [return 返回值;] &#125; sayHello(); // 不传参数，会使用默认值 sayHello(&quot;大象&quot;); // 传参数，默认值不生效?&gt; 在 php 中函数不能重复声明 函数体内的变量只在函数体内有效 函数体外的变量只在函数体外有效 &lt;?php $age = 18 function fn()&#123; $name = &#x27;大象&#x27;; echo $name; // 有效 echo $age; // 无效 &#125; fn(); echo $name; // 无效 echo $age; // 有效?&gt; 常量保存不会发生改变的数据(如：3.1415， 路径等)时，最好使用常量。 常量的使用方法： define(常量名, 常量值, [是否区分大小写]);// 默认 false 区分大小写， true 不区分大小写define(&quot;PI&quot;, 3.1415, true);echo PI;echo pi; 注意: 一般在实际工作中，常量都用大写，常量不能被重新赋值 PHP 内置函数数学函数 max(),min() 分别返回一组数的最大值及最小值； abs() 返回绝对值。 floor() 向下取整。 ceil() 向上取整。 round() 四舍五入。 rand() 返回随机整数，可以取到两端的值。 日期函数 time() 返回当前的时间戳 (1970 到现在的时间的秒数) date(format,time) 格式化一个本地时间或日期 格式：Y(年) m(月) d(日) H(时) i(分) s 秒 $time = time(); // 获取时间戳echo date(&#x27;Y-m-d H:i:s&#x27;,$time); // 格式化时间戳// Y, m, d, H, i, s 分别代表 年 月 日 时 分 秒 默认时区会不太正确, 我们在东八区, 比 0 时区会多八小时 路径: D:\\phpStudy\\php\\php-5.4.45在php.ini里加上找到date.timezone项，设置date.timezone = &quot;PRC&quot;，重启环境就ok了。PRC: 中华人民共和国 字符串函数 str_replace(查找的值，替换的值，执行替换操作的字符) 字符串替换（会把符合的值全部替换） trim(字符串); 去除首尾空白字符 explode(分割符，执行分割的字符串); 使用一个字符分割一个字符串，返回一个数组(类似 split) implode(连接符，执行连接的数组); 将数组根据连接符拼接成字符串(类似 join) substr(字符串，起始索引，截取长度); 截取字符串，注意中文占 3 个字节长度 strchr(字符串，标识字符); 从左向右找标识字符，返回该字符后全部字符(包括该字符) strrchr(字符串，标识字符); 从右向左找标识字符，返回该字符后全部字符(包括该字符) 主要用于获取后缀名 补充查找数组中是否含有指定内容 // in_array(查找的内容, 数组) 如果查找到返回 true ，查找不到返回 falseresult = in_array($uname, $arr);// 可用来判断用户名是否已存在数据库中 从数组中随机获取数据 // array_rand(被操作的数据, 数据长度) 返回一个随机的下标$arr = array_rand($results, 2); // 返回一个数组，随机两个下标$index = array_rand($results, 1); // 返回一个随机的下标$results[$index]; // 用来随机获取数组中的一项 页面动态渲染 PHP 本身支持与 HTML 混编 混编的文件后缀必须为 .php， Apache 才会调用 PHP 解析 PHP 与 HTML 混编时，服务器中的 PHP 引擎 只会执行 php 标签内部的 PHP 代码，非 PHP 的代码(PHP 标签外部的内容)直接忽略，最后会将 PHP 的执行结果和非 PHP 代码 一起返回给浏览器,由浏览器进行解析 一个 php 页面当中,可以写多个 php 语法结构,但是 php 语法结构 不能嵌套 &lt;?php header(&#x27;content-type:text/html;charset=utf-8&#x27;); echo 2+3; // php的引擎 只会执行php代码块中代码，代码块外面的代码会被忽略最后 服务器会将php执行的结果和代码块外面的内容一起返回给浏览器，由浏览器进行解析?&gt;// 在php语法结构外面， 可以写 html ，会直接在浏览器中渲染&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度一下&lt;/a&gt; include 文件引入介绍：不同的页面中有相同的代码部分，可以将其分离为单个文件。需要调用时，include 引入对应的文件即可调用。提高代码的复用率。类似于 js 中 script 标签导入, 可以用于函数复用 语法 // 可以是html、php或其他类型的页面include | include_once &quot;文件的路径&quot; include 与 include_once 区别 include 可以重复引入文件 include_once 只引入一次，防止多次引入文件 如果文件中有函数，include 重复引入会报错，include_once 不会报错 PHP 数据读写到文件(数据持久化)程序运行过程中，数据存储在内存中的，程序结束, 数据会销毁 如果希望可以永久存储某些数据，可以将数据存储在硬盘上（存储在文件中） 将数据由内存存储到硬盘的过程，称为数据持久化； file_get_contents(path) 根据路径读取文件内容, 返回一个字符串 file_put_contents(path,$str) 将一个字符串写入到一个文件中。(只能存储字符串) file_put_contents(string $file, string $data[, constants flag]);参数1: 文件路径参数2: 要写入文件的字符串参数3: 可选参数，默认不写，新内容覆盖原文件中的内容；FILE_APPEND 是向文件中追加内容返回值: 写入文件的字符串长度(不用记) 使用 file_put_contents 存储数组的时候，会丢失数据 $arr = [&#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27;];$arr1 = [&#x27;name&#x27;=&gt;&#x27;zs&#x27;, &#x27;age&#x27;=&gt;18];file_put_contents(&quot;02-test.txt&quot;, $arr); // zslswwfile_put_contents(&quot;02-test.txt&quot;, $arr1); // zs18 把一个数组，转成一个 json 格式的字符串 json_encode($data) 将 PHP 数组转成 JSON 格式字符串。 json_decode($str,true) 将 JSON 字符串, 转换为 PHP 数组。（不传 true, 有可能转完之后是个对象, 传了 true,一定是数组） 表单处理 表单（form）：表单用于收集用户输入信息，并将数据提交给服务器。是一种常见的与服务端数据交互的一种方式 action: 指定表单的提交地址（如果提交到当前页面，action 可以为空） method: 指定表单的提交方式，get&#x2F;post，默认 get input 的数据想要提交到后台，必须指定 name 属性，后台通过 name 属性获取值 想要提交表单，不能使用 input:button 必须使用 input:submit php 获取表单数据// $_GET 是 PHP 系统提供的一个超全局变量，是一个数组，里面存放了表单通过 get 方式提交的数据// $_POST 是 PHP 系统提供的一个超全局变量，是一个数组，里面存放了表单通过 post 方式提交的数据 get 与 post 的区别 get 方式数据会拼接在 url 地址的后面 (?username&#x3D;pp&amp;password&#x3D;123456)地址栏有长度限制，因此 get 方式提交数据大小不会超过 4k post 方式数据不会在 url 中显示，相比 get 方式，post 更安全提交的数据没有大小限制，可用于文件上传 文件上传html 要求 文件上传的提交方式必须是 post 方式 需要给 form 指定 enctype=&quot;multipart/form-data&quot; 指定 name 属性，后台才能获取到 php 相关 文件上传时，通过 $_FILES 才能获取到，这是一个二维数组。 Array( [photo] =&gt; Array ( [name] =&gt; 001.jpg // 文件名字 [type] =&gt; image/jpeg // 文件类型 // 上传图片保存的位置 [tmp_name] =&gt; C:\\Users\\Jepson\\AppData\\Local\\Temp\\phpF2A0.tmp [error] =&gt; 0 // 上传错误码, 错误码为 0 表示没有错误 [size] =&gt; 6000 // 文件大小, 单位字节, 大小 6kb 左右 )) 上传文件时，文件会临时保存在服务器上，如果文件最终没有保存，那么临时文件会被删除，保证服务器安全。 sleep(10) 可以让代码延迟 10 秒钟才执行。 move_uploaded_file($path, $newPath); 可以转存临时文件，真正把文件存储起来 unlink(filename,context) 删除文件，若成功，则返回 true，失败则返回 false // 保存图片的完整代码// 思路:// 1. 在文件上传成功的情况下, 进行图片的保存 error == 0// 2. 获取临时文件路径// 3. 随机生成新的文件名, 注意文件中后缀名是不能改变的// 4. 根据新的文件名, 转移临时文件$file = $_FILES[&#x27;photo&#x27;];// 判断上传是否成功if ( $file[&#x27;error&#x27;] == 0 ) &#123; // 上传成功 // 1. 获取临时文件路径 $ftemp = $file[&#x27;tmp_name&#x27;]; // 2. 随机生成新的文件名, 后缀不能随便起, 要获取一下 $name = $file[&#x27;name&#x27;]; $text = strrchr($name, &#x27;.&#x27;); // 为了防止重复, 生成随机的文件名以当前时间秒数+随机数组成 $newName = time().rand(10000,99990).$text; // 3. 进行转存 move_uploaded_file($ftemp, &quot;./upload/$newName&quot;);&#125; 学生信息管理系统 1.0基本功能 学生添加功能 展示学生信息功能 删除学生信息 // array_splice(数组, 开始的下标, 截取长度) 将匹配到的数据截取掉，会改变原来的数组array_splice($arr, $_GET[&quot;index&quot;], 1);// 添加内容到数组：将 $stuArr 添加到数组 $arr 中$arr[] = $stuArr; Mysql 数据库数据库概念专门用来存储、管理数据的仓库 英文：Database, DB。 数据库的分类 关系型数据库: 基于表，表与表之间可以存在关系，可以进行多表查询的存储方式，适合较为复杂的存储 如: MySQL, SQL Server, oracle 表结构: 每一行代表一条数据 — 记录 每一列都是一类数据 — 字段 订单编号 商品名称 价格 数量 100123 华为 mate10 4999 2 100124 花裙子 499 1 订单编号 用户 配送地址 100123 隔壁老王 北京市京顺路 99 号 100124 隔壁老宋 北京市清华大学 1 号楼 非关系型数据库: 基于键值对的存储方式，数据之间没有耦合性，特点执行效率高 如：mongodb // 类似对象的键值对形式&#123; &quot;username&quot;: &quot;gblw&quot;, &quot;password&quot;: 123456, &quot;uid&quot;: 007&#125; MySQL 数据库软件 MySQL 数据库软件中可以有多个数据库,每一个数据库中可以有多个表 可视化工具 navicat MySQL 只是一个数据库软件，如果我们要创建数据库，或对数据库进行增删改查，刚开始可以用可视化工具来操作，让我们更加直观的了解数据库 安装 navicat让 navicat 和 MySQL 建立连接点击左上角 连接 &#x3D;&gt; MySQL &#x3D;&gt; 常规 &#x3D;&gt; 端口 3306 &#x3D;&gt; 数据库表的操作数据库的数据类型 也就是数据库中可以存储的数据类型(又叫做字段类型) 字段类型 整型 int ​ 存储如年龄，产品数量，编号等。 小数类型 float , decimal 重量，工资，奖金，价格等使用 decimal 类型，实现小数的精确存储,一般用来存储与钱有关的数字。3.333333331 字符串型 varchar(M)，char(M) M 为该字段可以存储的最多字符数(字节) ，如 varchar(10)最大可以存储 10 个字节 varchar 一般用来存储长度变化比较大的字符串，如文章标题，商品名称 char 存储长度比较固定的字符串，如手机号，身份证号，序列号，邮编 此外可以使用 text 类型，存储较长的字符串，无需指定字符串的具体长度 日期时间型 datetime, date(年月日)，time(时分秒) 字段约束 字段约束: 字段数据的属性规则（特征） not null 不为空，可以限制字段值不能为空 default 默认值，可以设置字段的默认值，在没有录入时自动使用默认值填充。 primary key 主键 ：唯一标识，不能重复，不能为空 设置字段为主键，主键字段的值不能重复，不能为空。而且一个数据表中只能设置一个字段为主键，作为每行记录的唯一身份信息（索引）。 auto_increment 自动增长 设置字段为自动增长，默认从 1 开始自动分配编号。自增长字段必须为一个 key（索引，数据结构，便于快速查找数据，相当于书的目录），一般与 primary key 结合使用。类型必须为整型。 unique key 不能重复 唯一键，设置字段的值为唯一的，可以设置多个字段为唯一键。唯一键字段的值可以为空。 创建数据表 注意 创建表时，每个表必须有一个主键 SQL-操作数据库的语言 SQL：structured Query Language 结构化查询语言。 通过这个语言可以对数据库进行增删改查 SQL 编写注意点: 注释用 -- , 语句结束加分号 ; 基本用法：增删改查 插入数据 insert -- insert into 表名 (字段列表) values (值列表)insert into book (name, age, sex) values (&#x27;zs&#x27;,&#x27;18&#x27;,&#x27;m&#x27;); 修改数据 update -- update 表名 set 字段名称1=值1,字段名称2=值2,... where 条件-- 如果不加条件会修改表中所有对应的字段update book set name=&#x27;ls&#x27;, age=&#x27;30&#x27; where id=10; 删除数据 delete -- delete from 表名 where 条件delete from book -- 会删除所有数据delete from book where id=10; 查询数据 select -- select 字段列表 from 表名select name, age from book -- 只查询表中 name 和 author 的信息-- select * from 表名 where 条件 * 表示所有字段select * from book where id = 2;select * from book where name=&#x27;zs&#x27; and age=20; 高级用法 where 条件 查询时，不添加 where 条件, 返回数据表所有行。需要添加限定条件，只返回需要的行。 -- select 字段列表 from 表名 where 条件；-- 条件 : =, &gt;, &lt;, &gt;=, &lt;=, and, or like 模糊匹配 % 通配符 -- 查找姓张的人select * from 表名 where name like &#x27;张%&#x27;;​ in 语法：一次查询多个符合条件的数据 -- select * from 表名 where 字段 in (value1,value2,value3);select * from stu where name in (&#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27;); -- 查找name值为zs, ls, ww 的数据 count() 获取返回数据的总条数 -- 查询满足条件数据的总条数-- select count(*) from 表名 where 条件 order 排序 -- select * from 表名 order by 字段名称; 默认升序-- select * from 表名 order by age; -- 按照年龄来排序-- select * from 表名 order by 字段名称 desc; desc 表示降序 limit 对结果集进行截取 一般用于取数据的前几条 -- select * from 表名 limit 截取的起始索引，截取的长度 联合查询（多个表联合查询） select 字段列表 from 表A join 表B on 表A.字段=表B.字段 where 条件join 将表A和表B联合起来on 根据什么字段把表A和表B联合起来select * from teacher join class on class.id=teacher.classid; -- 老师表和班级表联合查询select teacher.*, class.classname from teacher join class on class.id=teacher.classid; -- 老师表和班级表联合查询,但只显示老师表的全部内容和班级表的名称-- 注意: 多表联合查询时,字段要写明是那个表的字段 如 表.字段名 PHP 操作数据库连接数据库基本步骤 连接数据库 准备 sql 语句 执行 sql 语句 获取执行的结果并分析 关闭数据库 操作数据库常用 API mysqli_connect(IP, 用户名，密码，数据库名)，端口号 连接数据库 mysqli_query($link, $sql) 执行 SQL 语句 mysqli_error($link); 返回错误描述 mysqli_close($link); 关闭连接 mysqli_fetch_assoc($res); 从结果集中取得一行作为关联数组返回 mysqli_num_rows($res); 返回结果集的行数 sql 操作 使用 PHP 发送 SQL 语句前，可以先打印 SQL 语句，检查语句的正确性。 修改数据库的数据时, 使用变量拼接 SQL 语句&#x3D;，字段的值为字符串类型时，需要在变量的两侧使用单、双引号包裹。可以将所有的字段外面都使用双引号包含。 // 1. 连接数据库// mysqli_connect(ip地址, 用户名, 密码, 数据库的名称, 端口号);// 执行结果// 1. 连接成功, 返回一个数据库连接对象// 2. 连接失败, 返回 false// @ 表示错误抑制符, 可以抑制错误的输出$link = @ mysqli_connect(&#x27;127.0.0.1&#x27;, &#x27;root&#x27;, &#x27;root&#x27;, &#x27;study&#x27;, 3306);// var_dump($link);// 如果数据库连接失败if ( !$link ) &#123; echo &quot;数据库连接失败&quot;； return false; // 程序结束, die 方法, 终止当前程序执行, 输出一段语句 die(&quot;数据库连接失败&quot;);&#125;echo &quot;数据库连接成功&lt;br&gt;&quot;;// 2. 准备 sql 语句: 删除一条数据$sql = &quot;delete from stu where id = 14&quot;;$name = &quot;gblw&quot;;$age = 31;$sq2 = &quot;insert into stu (name, age) values (&#x27;$name&#x27;, $age)&quot;;// sql 语句一般用双引号包裹// 如果语句中含有拼接的变量，需要用单引号包裹// 3. 让数据库执行 sql 语句, 并分析结果// mysqli_query(数据库连接对象, 要执行的sql语句)// 非查询语句：执行成功返回 true, 执行失败返回 false// 4. 根据结果不同做逻辑判断if ( mysqli_query( $link, $sql ) ) &#123; // 如果删除的数据不存在，也会返回 true， echo &quot;删除成功&quot;;&#125;else &#123; // sql 语句错误，才会返回 false echo &quot;删除失败&quot;; // mysqli_error 可以查看错误消息 echo mysqli_error($link);&#125;// 查询语句： 成功返回结果集, 失败返回 false// 数据查询不到也会返回结果集，只是数据条数为 0，sql 语句有错误才会返回 false$res2 = mysqli_query( $link, $sq2 );// $res2 是返回的结果集,是一个对象，表面上看没有我们要的数据,如果我们想要数据,需要调用mysqli_fetch_assoc($res2)去获取// 结果集中 field_count 表示字段数，num_rows 表示查询到的数据条数// 注意: mysqli_fetch_assoc($res2)执行一次,只会从结果集中拿一条数据出来(执行几次就拿出几条数据)// 4. 根据结果不同做逻辑判断if ( !$res ) &#123; echo mysqli_error( $link ); die(&#x27;数据库查询失败&#x27;);&#125;// mysqli_fetch_assoc 查询成功, 从结果集中取数据, 以关联数组的形式返回// 一次只取一条数据, 如果没取到, 返回 null$arr = [];while( $row = mysqli_fetch_assoc( $res ) ) &#123; // 将值推到数组中 $arr[] = $row;&#125;// 也可以采用 for 循环遍历// mysqli_num_rows($res) 方法返回获取到的数据条数 ，for($i = 0; $i &lt; mysqli_num_rows($res); $i++)&#123; // echo $i; $arr[] = mysqli_fetch_assoc($res);&#125;// echo &#x27;&lt;pre&gt;&#x27;;// print_r($arr);// echo &#x27;&lt;/pre&gt;&#x27;;// 5. 关闭数据库连接 (挂电话)mysqli_close( $link ); 数据库工具函数的封装 为了提高代码的复用性，把数据增删改的操作封装成一个方法 // 定义常量define( &#x27;HOST&#x27;, &#x27;127.0.0.1&#x27; );define( &#x27;UNAME&#x27;, &#x27;root&#x27; );define( &#x27;PWD&#x27;, &#x27;root&#x27; );define( &#x27;DB&#x27;, &#x27;test02&#x27; );define( &#x27;PORT&#x27;, 3306 );// 非查询语句封装// 封装一个执行非查询语句的方法, 提高代码的复用性// 参数: $sql 要执行的 sql 语句// 返回值: true / falsefunction my_exec( $sql ) &#123; // 1. 连接数据库 $link = @ mysqli_connect( HOST, UNAME, PWD, DB, PORT); if( !$link ) &#123; echo &#x27;数据库连接失败&#x27;; return false; &#125; // 2. 准备 sql 语句, 就是传递过来的 $sql // 3. 执行 sql 语句, 分析结果 if ( mysqli_query( $link, $sql ) ) &#123; // 执行成功 mysqli_close( $link ); // 关闭数据库 return true; &#125; else &#123; // 执行失败 mysqli_close( $link ); // 关闭数据库 return false; &#125;&#125;// 查询语句的封装// 参数: $sql 要执行的 sql 语句// 返回值:// (1) 成功, 返回数据(二维数组)// (2) 失败, 返回 falsefunction my_query( $sql ) &#123; // 1. 建立连接 $link = @ mysqli_connect( HOST, UNAME, PWD, DB, PORT ); if ( !$link ) &#123; echo &quot;数据库连接失败&quot;; return false; &#125; // 2. 准备 sql 语句 $sql // 3. 执行 sql 语句, 分析结果 $res = mysqli_query( $link, $sql ); // 结果集 或者 false if ( !$res ) &#123; echo &quot;获取数据失败&lt;br&gt;&quot;; echo mysqli_error($link); mysqli_close( $link ); return false; &#125; // 得到结果集, 将结果集的所有内容取出到数组中 $arr = []; while ( $row = mysqli_fetch_assoc($res) ) &#123; $arr[] = $row; &#125; mysqli_close( $link ); return $arr; // 返回结果数组&#125; 学生管理系统 2.0基本功能 添加学生功能 展示学生列表功能 删除学生功能 查看学生详情 更新学生数据 实现思路注册功能思路： 表单设计，点击提交按钮向服务器提交表单数据 在后台获取表单提交的数据，保存到数据库中 先获取表单的标签的数据 保存上传的图片（并保存图片存储的路径） 将表单的数据和图片的路径一起保存到数据库中 保存完成，跳转到列表页，查看新添加的数据 展示功能思路： 先从数据库中获取数据（二维数组 arr） 遍历二维数组，将数组中数据渲染到页面中 删除功能思路： 获取要删除数据的 id 根据 id 删除数据库中指定的数据 删除完毕，返回列表页 详情展示功能 获取要查看详情数据的 id 根据 id 通过联合查询，获取到需要用数据 把数据显示在页面中 点击返回按钮，可以返回到列表页 更新数据思路：更新数据的思路&#x3D;先渲染再提交 获取要查看详情数据的 id 把对应 id 的数据填充到修改页面中 点击修改按钮，获取表单的数据，提交给服务器 在服务器更新数据 更新完成后跳转到列表页 隐藏域表单：和其他表单标签一样，只是看不到而已&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&lt;?php echo $data[&#x27;id&#x27;] ?&gt;&quot; /&gt;"},{"title":"gulp 前端自动化环境","date":"12/12/2018","updated":"12/12/2018","comments":true,"path":"backup/自动化/gulp-前端自动化环境.html","permalink":"https://wqdy.top/backup/%E8%87%AA%E5%8A%A8%E5%8C%96/gulp-%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83.html","excerpt":"","text":"前端自动化环境实现一些简单的功能： 1. 版本控制2. 编译SASS3. 检查JS4. 图片合并5. 压缩CSS6. 压缩JS... 这些都是每个 Web 项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。 构建工具： Gulp、Grunt、Webpack、… gulp 环境Gulp 是基于 Node.js 的，需要要安装 Node.js 安装 # 4.0 版本# 检查 node 环境$ node -v# 全局安装 gulp$ npm install -g gulp$ gulp -v #4.0# 切换到你的在项目根文件夹下，运行$ npm install gulp# 安装 gulp 功能插件依赖包$ npm install gulp-less gulp-sass gulp-concat gulp-connect gulp-rename 配置新建 gulpfile.js 配置文件放在项目根目录下 // gulp3.x 配置不能直接在 4.0 上使用// gulp4.0 配置内容// 引入 gulpconst gulp = require(&#x27;gulp&#x27;)// 引入组件const less = require(&#x27;gulp-less&#x27;)const fileinclude = require(&#x27;gulp-file-include&#x27;)const connect = require(&#x27;gulp-connect&#x27;)// 启动 servefunction serve() &#123; connect.server(&#123; root: &#x27;./&#x27;, port: &#x27;8888&#x27;, // 启用https // https: true, livereload: true &#125;)&#125;// 编译 lessfunction compileLess() &#123; return ( gulp // &#x27;!./**&#x27; 忽略文件 .src([&#x27;./less/*.less&#x27;, &#x27;!./less/_*.less&#x27;]) .pipe(less()) .pipe(gulp.dest(&#x27;./public/css&#x27;)) )&#125;// html 刷新function refreshHtml() &#123; return gulp.src(&#x27;./*.html&#x27;).pipe(connect.reload())&#125;// 引入外部 html 文件function compileHtml() &#123; return gulp .src([&#x27;./*.html&#x27;, &#x27;!./_*.html&#x27;]) .pipe( fileinclude(&#123; prefix: &#x27;@@&#x27; &#125;) ) .pipe(gulp.dest(&#x27;./public&#x27;))&#125;// 在 html 中使用 `@@include(&#x27;_header-aside.html&#x27;)` 引入公共 html 结构// 监听文件变化function watch() &#123; gulp.watch([&#x27;./less&#x27;], compileLess) gulp.watch([&#x27;./image&#x27;], compileImg) gulp.watch([&#x27;./js&#x27;], compileJs) gulp.watch([&#x27;./*.html&#x27;], compileHtml) gulp.watch([&#x27;./public&#x27;], refreshHtml)&#125;// 默认任务，执行 gulp 会自动执行的任务gulp.task(&#x27;default&#x27;, gulp.parallel(serve, watch))// 复制 lib 文件夹function copyLib() &#123; return gulp.src(&#x27;./lib/**/*&#x27;).pipe(gulp.dest(&#x27;./dest/lib&#x27;))&#125;// 清空 dest 文件夹function clean() &#123; return del([&#x27;./dest&#x27;])&#125; 运行 gulp 任务# 执行定义的 default 任务# $ gulp default$ gulp# 单独运行 sass 任务$ gulp less !./** 忽略文件 gulp.parallel() –并行运行任务 gulp.series() –运行任务序列 插件其他 gulp 插件参考gulp-imagemin: 压缩图片gulp-minify-css: 压缩cssgulp-uglify: 压缩jsgulp-concat: 合并文件gulp-rename: 重命名文件gulp-htmlmin: 压缩htmlgulp-clean: 清空文件夹del: 删除文件 gulp-connect 启动服务本机可以打开，局域网下手机打不开解决办法 connect.server(&#123; host: &#x27;0.0.0.0&#x27; 或 host: &#x27;::&#x27;&#125;) 在 gulp 3.x 版本中报错会暂停监听需重新开启任务，4.0 修复了此问题 https://www.tuicool.com/articles/nAzqiaN"}],"posts":[{"title":"","slug":"前端/js/常用js-常用正则","date":"23/02/2022","updated":"23/02/2022","comments":true,"path":"ckzzh3h6700h20coggsgw8gk7.html","link":"","permalink":"https://wqdy.top/ckzzh3h6700h20coggsgw8gk7.html","excerpt":"","text":"常用正则. - 除换行符以外的所有字符。^ - 字符串开头。$ - 字符串结尾。\\d,\\w,\\s - 匹配数字、字符、空格。\\D,\\W,\\S - 匹配非数字、非字符、非空格。[abc] - 匹配 a、b 或 c 中的一个字母。[a-z] - 匹配 a 到 z 中的一个字母。[^abc] - 匹配除了 a、b 或 c 中的其他字母。aa|bb - 匹配 aa 或 bb。? - 0 次或 1 次匹配。* - 匹配 0 次或多次。+ - 匹配 1 次或多次。&#123;n&#125; - 匹配 n次。&#123;n,&#125; - 匹配 n次以上。&#123;m,n&#125; - 最少 m 次，最多 n 次匹配。(expr) - 捕获 expr 子模式,以 \\1 使用它。(?:expr) - 忽略捕获的子模式。(?=expr) - 正向预查模式 expr。(?!expr) - 负向预查模式 expr。 任意正负数字 ^(\\-|\\+)?\\d+(\\.\\d+)?$邮箱 ^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$最多保留2位小数的非负数字匹配中文 ^[\\u4e00-\\u9fa5]*$ 常用正则表达式校验数字的表达式 n 位的数字：^\\d&#123;n&#125;$ 至少 n 位的数字：^\\d&#123;n,&#125;$ m-n 位的数字：^\\d&#123;m,n&#125;$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ 带 1-2 位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(\\.[0-9]&#123;2&#125;)?$ 非零的正整数：^[1-9]\\d*$ 非零的负整数：^-[1-9]\\d*$ 非负整数：^\\d+$ 非正整数：^-[1-9]\\d*|0$ 校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$ 英文和数字：^[A-Za-z0-9]+$ 长度为 3-20 的所有字符：^\\.&#123;3,20&#125;$ 由 26 个英文字母组成的字符串：^[A-Za-z]+$ 由 26 个大写英文字母组成的字符串：^[A-Z]+$ 由 26 个小写英文字母组成的字符串：^[a-z]+$ 由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26 个英文字母或者下划线组成的字符串：^\\w+$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 钱的输入格式：有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]$这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9])$一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9])$这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})(.[0-9]{1,2})?$1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3}))(.[0-9]{1,2})?$备注：这就是最终结果了,别忘了”+”可以用”“替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里","categories":[],"tags":[]},{"title":"常用js —— 闭包","slug":"前端/js/常用js —— 闭包","date":"20/02/2022","updated":"20/02/2022","comments":true,"path":"2039.html","link":"","permalink":"https://wqdy.top/2039.html","excerpt":"","text":"闭包(closure)的概念 闭包是函数和声明该函数的词法环境的组合 在 js 中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，产生闭包 产生闭包的条件：有两个函数，是嵌套关系，内部函数引用了外部函数的变量 闭包的作用： 私有变量，保护数据安全 持久化数据 // 闭包的基本模型function outer() &#123; var num = 10 function inner () &#123; num++ console.log(num) &#125; return inner // 把inner函数给返回出去，让外部能够调用inner函数&#125;// 并不一定是有返回函数才算是产生了闭包var f3function f1() &#123; var a = 2 f3 = function() &#123; console.log(a) &#125;&#125;f1()f3() // 2 闭包的应用计数器需求：统计一个函数的调用次数 var count = 0function fn() &#123; count++ console.log(&#x27;我被调用了，调用次数是&#x27; + count)&#125;fn()fn()fn()// 缺点：count是全局变量，不安全 使用闭包解决这个问题 function outer() &#123; var count = 0 // 私有变量, 将 count 保护起来了 function add() &#123; count++ console.log(&#x27;当前count&#x27; + count) &#125; return add&#125;var result = outer()result() 缓存的私有化计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。 缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。 function outer() &#123; // 缓存 var arr = [] var fbi = function(n) &#123; if (n == 1 || n == 2) &#123; return 1 &#125; if (arr[n]) &#123; return arr[n] &#125; else &#123; var temp = fbi(n - 1) + fbi(n - 2) arr[n] = temp //存入缓存 return temp &#125; &#125; return fbi&#125;var fbi = outer()console.log(fbi(40)) 闭包存在的问题 正常情况下：函数在调用的时候，去开辟一块内存空间用来执行内部的代码，当函数调用结束的时候，要销毁开辟的空间，节省内存闭包占用的内存是不会被释放的，因此，如果滥用闭包，会造成内存泄漏的问题。闭包很强大，但是只有在必须使用闭包的时候才使用 js 的垃圾回收机制(了解) 内存：计算机中所有程序的运行都是在内存 中进行的，因此内存的性能对计算机的影响非常大，运行程序需要消耗内存，当程序结束时，内存会得到释放。 javascript 分配内存：当我们定义变量，javascript 自动分配内存存储数据。无论是值类型或者是引用类型，都需要存储在内存中。 垃圾回收：当代码执行结束，分配的内存已经不需要了，这时候需要将内存进行回收，在 javascript 语言中，垃圾回收机器会帮我们回收不再需要使用的内存。 引用记数法清除引用记数垃圾收集：如果没有引用指向某个对象（或者是函数作用域），那么这个对象或者函数作用域就会被垃圾回收机制回收。 var o = &#123; name: &#x27;zs&#x27;&#125;// 对象被 o 变量引用，引用记数 1var obj = o // 变量被 o 和 obj 引用，引用记数 2o = 1 // o 不在引用对象了，引用记数 1obj = null // obj 不在引用对象了，引用记数 0，可以被垃圾回收了 引用计数法无法解决循环引用导致的内存泄露 function fn() &#123; var obj1 = &#123;&#125; // 引用计数为 2 var obj2 = &#123;&#125; // 引用计数为 2 obj1.a = obj2 obj2.b = obj1&#125;fn() // 销毁fn调用开辟的空间， 但是由于引用计数考虑到两个对象都不是零引用的对象，就不能够被垃圾回收机制给回收掉 标记清除法清除使用引用计数法进行垃圾回收的时候，会出现循环引用导致内存泄漏的问题。因此现代的浏览器都采用标记清除法来进行垃圾回收。 这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象 Window）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。 从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。 闭包占用内存释放当闭包的功能不在需要使用了，将这个变量指向 null， 这样闭包占用的内存就可以被回收掉了 function outer() &#123; var count = 0 function fn() &#123; count++ console.log(&#x27;执行次数&#x27; + count) &#125; return fn&#125;var result = outer()result()result = null // 当函数 fn 没有被变量引用了，那么函数 fn 就会被回收，函数 fn 一旦被回收，那么 outer调用形成的作用域也就得到了释放","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"总结 —— 获取一个对象的类型(类型识别)","slug":"前端/js/总结 —— 获取一个数据的类型(类型识别)","date":"20/02/2022","updated":"20/02/2022","comments":true,"path":"2040.html","link":"","permalink":"https://wqdy.top/2040.html","excerpt":"","text":"typeof // 只能查看基本数据类型的类型instanceof // 判断对象的具体类型constructor.name // 获取对象的具体类型 适用于任何类型的检测Object.prototype.toString.call(&#x27;str&#x27;) // &#x27;[object String]&#x27; 适用于任何类型的检测 typeof 用于查看基本数据的数据类型， number string boolean undefined null 比较特殊，结果是 object 如果查看复杂数据类型，返回的都是 object 类型 函数的结果是 function // typeof 判断// 简单类型typeof 12 // &#x27;number&#x27;typeof &#x27;abc&#x27; // &#x27;string&#x27;typeof true // &#x27;boolean&#x27;typeof undefined // &#x27;underfined&#x27;typeof null // &#x27;object&#x27;// 复杂类型 (引用类型)typeof function() &#123;&#125; // &#x27;function&#x27;typeof [] // &#x27;object&#x27;typeof &#123;&#125; // &#x27;object&#x27; instanceof 判断 // 语法object instanceof constructor 用来检测 constructor.prototype 是否存在于参数 object 的原型链中 不能用于类型识别 // instanceof 判断var simpleStr = &#x27;This is a simple string&#x27;var myString = new String()var newStr = new String(&#x27;String created with constructor&#x27;)var myObj = &#123;&#125;var myNonObj = Object.create(null)var myArr = []var myFn = function() &#123;&#125;simpleStr instanceof String // 返回 false, 检查原型链会找到 undefinedmyString instanceof String // 返回 truenewStr instanceof String // 返回 truemyString instanceof Object // 返回 truemyObj instanceof Object // 返回 true, 尽管原型没有定义;(&#123;&#125; instanceof Object) // 返回 true, 同上myNonObj instanceof Object // 返回 false, 一种创建对象的方法，这种方法创建的对象不myArr instanceof Array // truemyArr instanceof Object // truemyFn instanceof Object // truemyFn instanceof Function // true constructor.name Undefined&#x2F;Null 没有 constructor 属性 var myArr = []var myFn = function() &#123;&#125;var myObj = &#123;&#125;let myDate = new Date()// 原型的构造函数myArr.constructor.name // ArraymyFn.constructor.name // ObjectmyObj.constructor.name // FunctionmyDate.constructor.name // Date// 自定义构造函数function Teacher(name, age) &#123; this.name = name this.age = age&#125;var tea = new Teacher(&#x27;zs&#x27;, 18)tea.constructor.name // Teacher Object.prototype.toString 适用于任何类型的检测，不能识别自定义对象类型 Object.prototype.toString.call(&#x27;str&#x27;).slice(8, -1) // String// 正则 =&gt; RegExp// 时间对象 =&gt; Date// 字符串 =&gt; String// 对象 =&gt; Object// 数组 =&gt; Array// 自定义构造函数function Teacher(name, age) &#123; this.name = name this.age = age&#125;var tea = new Teacher(&#x27;zs&#x27;, 18)Object.prototype.toString.call(tea) // &#x27;[object Object]&#x27;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"手写题","slug":"前端/面试/手写题","date":"18/02/2022","updated":"22/02/2022","comments":true,"path":"2041.html","link":"","permalink":"https://wqdy.top/2041.html","excerpt":"","text":"数组去重 详情 1. 新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf 为-1 或 includes 为false）就加入该新数组中 function unique(arr) &#123; var newArr = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (newArr.indexOf(arr[i]) === -1) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125; 数组下标判断：如果当前数组的第 i 项在当前数组中第一次出现的位置不是 i，那么表示第 i 项是重复的，忽略掉。否则存入结果数组 function unique(arr) &#123; var newArr = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (arr.indexOf(arr[i]) === i) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125; hash去重function Deduplication(arr) &#123; var result = [] var hashMap = &#123;&#125; for (var i = 0; i &lt; arr.length; i++) &#123; var temp = arr[i] if (!hashMap[temp]) &#123; hashMap[temp] = true result.push(temp) &#125; &#125; return result&#125; ES6 实现 function unique(arr) &#123; var x = new Set(arr) return [...x]&#125; 冒泡排序 详情 // 将数组中的数从小到大排列var arr = [1, 4, 6, 7, 9, 3, 5, 8]// var numi = 0// var numj = 0for (var j = 0; j &lt; arr.length - 1; j++) &#123; // numj += 1 var flag = true for (var i = 0; i &lt; arr.length - 1 - j; i++) &#123; // document.write(&#x27;(&#x27; + arr[i] + &#x27;,&#x27; + arr[i + 1] + &#x27;)&#x27;) // numi += 1 // 两两比较，如果前面的大于后面的，交换位置 if (arr[i] &gt; arr[i + 1]) &#123; flag = false var temp temp = arr[i] arr[i] = arr[i + 1] arr[i + 1] = temp // document.write(&#x27;交换了&#x27;) &#125; &#125; // document.write(&#x27;，arr=（&#x27; + arr + &#x27;）&#x27;) // document.write(&#x27;&lt;br&gt;&#x27;) // 如果一趟下来，一次交换都没有做，说明就已经排好序，就不需要继续比 if (flag) &#123; break &#125;&#125; 实现 call apply bind 方法 详情 call 和 apply 区别 call： Function.prototype.myCall = function(context) &#123; if (typeof this !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;Error&#x27;) &#125; context = context || window var args = Array.prototype.slice.apply(arguments, [1]) // 获取额外参数 // var args = [...arguments].slice(1) context.fn = this var res = context.fn(...args) delete context.fn return res&#125; context 为要绑定的 this，不传默认为 window给 context 创建一个 fn 属性，并将值设置为需要调用的函数调用 context.fn，并将额外参数 args 传递进去删除 context 上的 fn 函数 apply： Function.prototype.myApply = function(context) &#123; if (typeof this !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;Error&#x27;) &#125; context = context || window context.fn = this let res if (!arguments[1]) &#123; res = context.fn() &#125; else if (arguments[1].constructor.name === &#x27;Array&#x27;) &#123; res = context.fn(...arguments[1]) &#125; else &#123; return console.error(&#x27;Uncaught TypeError: CreateListFromArrayLike called on non-object&#x27;) // throw &#x27;Uncaught TypeError: CreateListFromArrayLike called on non-object&#x27; &#125; delete context.fn return res&#125; bind： Function.prototype.myBind = function() &#123; var self = this // 保存原函数 var args = Array.prototype.slice.call(arguments) // 参数转为数组 // var args = [...arguments].slice(1) // 参数转为数组 var context = args.shift() // 保存需要绑定的this上下文 return function() &#123; // 返回一个新函数 self.apply(context, args.concat([].slice.call(arguments))) &#125;&#125; function aaa(val, val1) &#123; console.log(val) console.log(val1) console.log(this.name)&#125;aaa()aaa.myCall(&#123; name: &#x27;123&#x27; &#125;, &#x27;121&#x27;, 122)aaa.myApply(&#123; name: &#x27;123&#x27; &#125;, [&#x27;121&#x27;, 122])aaa.myBind(&#123; name: &#x27;123&#x27; &#125;)(&#x27;111&#x27;, &#x27;222&#x27;)","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"常用js —— 作用域与预解析","slug":"前端/js/常用js —— 作用域与预解析","date":"16/02/2022","updated":"16/02/2022","comments":true,"path":"2038.html","link":"","permalink":"https://wqdy.top/2038.html","excerpt":"","text":"作用域 作用域：变量起作用的区域，也就是说：变量定义后，可以在哪个范围内使用该变量 全局作用域 ：在 script 标签内，函数外的区域就是全局作用域，在全局作用内声明的变量叫做全局变量 。全局变量可以在任意地方访问。（if&#x2F;while&#x2F;for 语句中声明的变量也是全局变量） 函数作用域 ：在函数内的区域叫做函数作用域，在函数作用域内声明的变量叫做局部变量 ，局部变量只有在当前函数内才能访问到。 自由变量：对于一个函数来说，函数内部没有声明该变量，但在函数内部有访问该变量。对于这个函数来说， 该变量就是一个自由变量。 隐式全局变量：没有使用 var 定义的变量也是全局变量，叫做隐式全局变量。 var num = 11function fn() &#123; var num1 = 22 num2 = 33 num = 33 console.log(num1)&#125;fn()console.log(num)// console.log(num1)console.log(num2) 变量的查找规则： 函数内部可以使用函数外部的变量 有局部变量就用局部变量，没有局部变量就用全局变量。 函数作用域是在函数定义的时候作用域就确定下来了，和函数在哪调用无关 var num = 123function f1() &#123; console.log(num)&#125;function f2() &#123; var num = 456 f1()&#125;f2() // 123 作用域链作用域链：只要是函数，就会形成一个作用域，如果这个函数被嵌套在其他函数中，那么外部函数也有自己的作用域，这个一直往上到全局环境，就形成了一个作用域链 变量的搜索原则：从当前作用域开始查找，一直查询到全局作用域，如果存在，就返回。如果在全局中也没有找到该变量会报错 // 1.var num = 10fn1()function fn1() &#123; console.log(num) // undefined var num = 20 console.log(num) // 20&#125;console.log(num) // 10// 2var num = 10fn1()function fn1() &#123; console.log(num) // 10 num = 20 console.log(num) // 20&#125;console.log(num) // 20// 3var num = 123function f1(num) &#123; console.log(num) // 456 undefined&#125;function f2() &#123; var num = 456 f1(num) f1()&#125;f2()// 4var num1 = 10var num2 = 20function fn(num1) &#123; num1 = 100 num2 = 200 num3 = 300 console.log(num1) // 100 console.log(num2) // 200 console.log(num3) // 300 var num3&#125;fn()console.log(num1) // 10console.log(num2) // 200console.log(num3) // error 预解析预解析过程：js 解析器在执行代码前，会把所有变量的声明和函数的声明提升到当前作用域的顶部。例如var a = 11其实会分为var a 和a = 11两部分，其中var a会被提升 预解析规则: var 声明的变量：只提升声明，不会提升赋值 函数声明：整体提升 先提升 var 声明的变量，后提升函数声明 遇到重名的 var 声明， var 声明会被忽略，值会保留 遇到重名的函数声明，后者会覆盖前者 如果 var 声明和函数声明同名，函数声明会把 var 声明覆盖 // 函数预解析// 1.function fn() &#123; console.log(a) // undefined&#125;fn()var a = 1// 2.var n = 45function fn5() &#123; console.log(n) // undefined n = 20 console.log(n) // 20 var n = 0 console.log(n) // 0&#125;fn5()console.log(n) // 45// 3.console.log(b) // 函数体var b = 23function b() &#123; console.log(b)&#125;console.log(b) // 23// b() // 报错// 4.console.log(c) // 函数体c() // 嘿嘿var c = function() &#123; comsole.log(&#x27;哈哈&#x27;)&#125;function c() &#123; console.log(&#x27;嘿嘿&#x27;)&#125;// 5.console.log(fn1) // 函数体fn1()function fn1() &#123; console.log(&#x27;哈哈&#x27;) // 哈哈&#125;console.log(fn2) // undefinedfn2() // 报错var fn2 = function() &#123; console.log(&#x27;嘿嘿&#x27;)&#125;// 对于函数表达式，函数的调用必须在表达式声明之后fn2() // 嘿嘿// 6.// 只有用 var 声明的变量才会预解析console.log(d) // 报错d = 5// 7.console.log(e)console.log(f) // 报错 f is not definedvar e = (f = 10)console.log(f) // 10// 8.if (&#x27;a&#x27; in window) &#123; var a = &#x27;abc&#x27;&#125;console.log(a) // abc 不要在一个作用域内重复的声明相同的变量和函数","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"常用js —— 函数","slug":"前端/js/常用js —— 函数","date":"16/02/2022","updated":"16/02/2022","comments":true,"path":"2037.html","link":"","permalink":"https://wqdy.top/2037.html","excerpt":"","text":"函数的参数arguments 对象里保存了所有的实参，是一个伪数组 定义函数的三种方式 函数声明 fn() // 函数声明可以先调用，在声明function fn() &#123; console.log(&#x27;这是函数声明&#x27;)&#125; 函数表达式 var fn = function() &#123; console.log(&#x27;这是函数表达式&#x27;)&#125;fn() // 函数表达式必须先声明，再调用 构造函数 Function // 函数也是对象，可以使用 Function 构造函数 new 出来// 相当于var fn = function () &#123;&#125;var fn = new Function()// 语法：new Function(arg1,arg2,arg3..,body)// 所有的参数都是字符串类型// 前面可以定义任意多个形参，最后一个参数是代码体var fn = new Function(&#x27;alert(1)&#x27;)fn()var fn1 = new Function(&#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;alert(a1 + a2)&#x27;)fn1(1, 2) Function 属性 length：获取形参的长度 name：获取函数的名字，此属性不允许修改 Function.length // 1Function.prototype.length // 0(function() &#123;&#125;).length // 0(function(a) &#123;&#125;).length // 1(function(...args) &#123;&#125;).length // 0(function(a, b = 1, c) &#123;&#125;).length // 1 Function.prototype 成员 arguments：已废弃，获取函数的实参，现在推荐的做法是使用函数内部可用的 arguments 对象来访问函数的实参 caller: 已废弃，用于获取当前函数是在哪个函数中调用的 constructor：指向当前构造函数，Function call：调用函数，重新指定 this apply：调用函数，重新指定 this bind：重新指向 this，返回一个新的函数，不调用 toString : 得到函数的字符串格式 function a() &#123;&#125;a.toString() // &#x27;function a() &#123;&#125;&#x27;// 获取数据类型return Object.prototype.toString.call(obj).slice(8, -1) // &#x27;[object 构造函数]&#x27; 函数的四种调用模式分析 this 指向问题 任何函数都有属于自己的 this this 是动态的，this 在函数声明的时候是确定不了的，只有当函数被调用了才能够确定 this 的指向，this 的指向和函数在哪被调用没有关系 分析 this 的问题的思路： 1. this 是属于哪个函数 2. 这个函数是何种调用模式 函数调用模式如果一个函数不是一个对象的属性时，就是被当做一个函数来进行调用的。此时 this 指向了 window function fn() &#123; console.log(this) // 指向 window&#125;fn() 方法调用模式当一个函数被保存为对象的一个属性时，我们称之为一个方法。当一个方法被调用时，this 被绑定到当前对象通过点语法或者中括号语法来访问方法，都是属于方法调用模式 var f = function() &#123; console.log(this)&#125;var obj = &#123; fn: f &#125;var arr = [f]obj.fn() // objobj[&#x27;fn&#x27;]() // objarr[0]() // arr 也是方法调用模式 构造函数调用模式如果函数是通过 new 关键字进行调用的，此时 this 被绑定到创建出来的新对象上 function Person() &#123; console.log(this)&#125;var p = new Person() // this 指向 p 总结：分析 this 的问题，主要就是区分函数的调用模式，看函数是怎么被调用的 // 1.var age = 38var obj = &#123; age: 18, getAge: function() &#123; console.log(this.age) &#125;&#125;var f = obj.getAgef() // window ==&gt; 38// 2.var age = 38var obj = &#123; age: 18, getAge: function() &#123; console.log(this.age) // obj ==&gt; 18 function foo() &#123; console.log(this.age) // window ==&gt; 38 &#125; foo() &#125;&#125;obj.getAge()// 3.var length = 10var age = 18function fn() &#123; console.log(this.length)&#125;var arr = [fn, &#x27;222&#x27;]fn() // 10arr[0]() // 2// 4.var length = 10function fn() &#123; console.log(this.length)&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn() // window ==&gt; 10 arguments[0]() // argument ==&gt; 3 &#125;&#125;obj.method(fn, 10, 5)// 5.let len = 10function fn() &#123; console.log(this.len)&#125;fn() // window ==&gt; undefinedlet Person = &#123; len: 5, say: function() &#123; fn() // window ==&gt; undefined arguments[0]() // arguments ==&gt; undefined &#125;&#125;Person.say(fn)// 6.var obj = &#123; bar: function() &#123; var x = () =&gt; this return x &#125;&#125;// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。// 将返回的函数的引用赋值给fn。var fn = obj.bar()// 直接调用fn而不设置this，// 通常(即不使用箭头函数的情况)默认为全局对象// 若在严格模式则为undefinedconsole.log(fn() === obj) // true// 但是注意，如果你只是引用obj的方法，而没有调用它var fn2 = obj.bar// 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。console.log(fn2()() == window) // true 方法借用模式上下文调用模式也叫方法借用模式，分为 apply，call ，bind任何函数都可以调用 apply，call ，bind 这三个方法 call 方法call 方法可以调用一个函数，并且可以指定这个函数的 this 指向call 方法也可以和 () 一样，进行函数调用第一个参数：指定函数的 this，如果不传，则 this 指向 window；其余参数：和函数的参数列表一模一样 // 调用函数function fn() &#123; console.log(1)&#125;fn.call() // 1// 改变 this 指向function fn() &#123; console.log(this)&#125;fn.call(&#123; name: &#x27;zs&#x27; &#125;) // &#123; name: &#x27;zs&#x27; &#125; apply 方法 apply()方法的作用和 call()方法类似，只有一个区别，就是apply()方法接受的是一个包含多个参数的数组。而call()方法接受的是若干个参数 function fn(n1, n2) &#123; console.log(this) console.log(n1 + n2)&#125;fn.apply(&#123; name: &#x27;zs&#x27; &#125;, [10, 20]) // &#123;name: &#x27;zs&#x27;&#125;, 30// apply 的特性：平铺性，把数组中的每一项取出来作为函数的实参 bind 方法bind() 方法创建一个新的函数、可以绑定新的函数的 this 指向 返回值：新的函数(不会被调用)参数：新函数的 this 指向，绑定后，无论使用何种调用模式，this 都不会改变 var fn = function() &#123; console.log(this)&#125;var newFn = fn.bind([1, 2, 3])// newFn 是 bind 创建并返回出来的console.log(newFn)newFn() // this ==&gt; [1,2,3] 如果对一个函数进行多次 bind，那么上下文会是什么呢 let a = &#123;&#125;let fn = function() &#123; console.log(this)&#125;fn.bind().bind(a)() // =&gt; ? 如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式 // fn.bind().bind(a) 等于let fn2 = function fn1() &#123; return function() &#123; return fn.apply() &#125;.apply(a)&#125;fn2() 可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window 特殊的 this 指向 定时器中的 this 指向了 window，因为定时器的 function 最终是由 window 来调用的 事件中的 this 指向的是当前的元素，在事件触发的时候，浏览器让当前元素调用了 function call apply bind 第一个参数表示要绑定的 this，不传、传 null或者 undefined，this 均指向 window，但在严格模式下，不传指向 undefined，传 null 指向 null，传 undefined 指向 undefined 递归函数递归的要求：1. 自己调用自己 2. 要有结束条件（出口） // 计算斐波那契数列function fn(n) &#123; if (n == 1 || n == 2) &#123; return 1 &#125; return fn(n - 1) + fn(n - 2)&#125;console.log(fn(12))","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"常用js —— 原型","slug":"前端/js/常用js —— 原型","date":"15/02/2022","updated":"15/02/2022","comments":true,"path":"2036.html","link":"","permalink":"https://wqdy.top/2036.html","excerpt":"","text":"原型Javascript 规定，每一个函数都有一个 prototype 属性，属性值是一个对象，这个对象就叫做原型（原型对象），这个对象的所有属性和方法，都会被构造函数的实例继承 这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上 function Person (name, age) &#123; this.name = name this.age = age&#125;console.log(Person.prototype)Person.prototype.sayName = function () &#123; console.log(this.name)&#125;var p1 = new Person(...)var p2 = new Person(...)console.log(p1.sayName === p2.sayName) // true 这时所有实例的 sayName() 方法，其实都指向同一个内存地址 __proto__任意对象都有 __proto__ 属性，这个属性指向了构造函数的 prototype 属性，也就是原型对象 获取原型对象： 通过 构造函数.prototype 可以获取 通过 实例.__proto__ 可以获取（隐式原型） 它们指向了同一个对象 构造函数.prototype === 实例.__proto__ 注意：__proto__是浏览器的一个隐藏（私有）属性，IE 浏览器不支持，不要通过它来修改原型里的内容，如果要修改原型中的内容，使用 构造函数.prototype 去修改 constructor 属性默认情况下，原型对象中只包含了一个属性：constructor，constructor 属性指向了当前原型对象的构造函数 function Person() &#123;&#125;console.log(Person.prototype)console.log(Person.prototype.constructor) // 构造函数本身var p = new Person()console.log(p)// p 实例对象没有constructor 属性， 该属性来源于原型上console.log(p.constructor == Person.prototype.constructor) // true 构造函数、实例、原型三者之间的关系构造函数：构造函数就是一个函数，配合 new 可以新建对象 实例：通过构造函数实例化出来的对象我们把它叫做构造函数的实例。一个构造函数可以有很多实例 原型：每一个构造函数都有一个属性prototype，函数的 prototype 属性值就是原型。通过构造函数创建出来的实例能够直接使用原型上的属性和方法 原型三角关系： 构造函数和原型 构造函数，通过 prototype 属性访问原型 原型通过 constructor 属性访问到构造函数 构造函数 和 实例对象 构造函数可以创建实例对象 实例对象不能直接访问到构造函数 原型 和 实例对象关系 实例对象可以直接访问到原型上的所有成员 实例对象可以间接的访问到构造函数（通过原型上的 constructor 属性） 原型链任何一个对象，都有原型对象，原型对象本身又是一个对象，所以原型对象也有自己的原型对象，这样形成的链式结构，就是原型链 绘制对象的原型链结构： var p = new Person()// p ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; nullvar o = new Object()// o ==&gt; Object.prototype ==&gt; nullvar arr = new Array()// arr ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; nullvar date = new Date()// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null// Math 是个内置对象，不是个构造函数// Math ==&gt; Object.prototype ==&gt; null 总结：Object.prototype 是原型链的尽头，Object.prototype 的原型是 null 函数的原型链结构函数是由 new Function 创建出来的，因此函数也是一个对象，所有的函数都是 Function 的实例 Person &#x3D;&#x3D;&gt; Function.prototype &#x3D;&#x3D;&gt; Object.prototype &#x3D;&#x3D;&gt; null Function.prototype 类型是个函数 完整版原型链图一 图二 所有函数都是 new Function 创建出来的，因此 所有函数.__proto__ 都是 Function.prototype 所有对象都是 new Object 创建出来的，因此 所有对象.__proto__ 都是 Object.prototype 参考链接","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"常用js —— 继承","slug":"前端/js/常用js —— 继承","date":"15/02/2022","updated":"15/02/2022","comments":true,"path":"2035.html","link":"","permalink":"https://wqdy.top/2035.html","excerpt":"","text":"ES5实现继承的六种方式原型链利用原型链让一个引用类型继承另一个引用类型的属性和方法。 function SuperType () &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;;// 子类 SubTypefunction SubType () &#123; this.subProperty = false;&#125;SubType.prototype = new SuperType();SubType.prototype.getSubValue = function () &#123; return this.subProperty;&#125;;// 实例var instance = new SubType();console.log(instance);console.log(instance.getSuperValue()); // trueconsole.log(instance instanceof SubType); // trueconsole.log(instance instanceof SuperType); // trueconsole.log(instance instanceof Object); // trueconsole.log(SubType.prototype.isPrototypeOf(instance)); // trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); // trueconsole.log(Object.prototype.isPrototypeOf(instance)); // true 缺点： 来自原型对象的引用属性是所有实例共享的。 创建子类实例时，无法向父类构造函数传参。 举例如下： // 1. 来自原型对象的引用属性是所有实例共享的// 父类function SuperType () &#123; this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];&#125;// 子类function SubType () &#123;&#125;SubType.prototype = new SuperType();// 实例var instance1 = new SubType();instance1.colors.push(&#x27;black&#x27;);console.log(instance1.colors); // [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;]var instance2 = new SubType();console.log(instance2.colors); // [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;]// 因为修改colors是修改的SubType.prototype.colors，所以所有的实例都会更新 // 2. 创建子类实例时，无法向父类构造函数传参// 调用父类是在 SubType.prototype = new SuperType()// 新建子类实例调用 new SubType()// 所以无法再new SubType() 的时候给父类 SuperType() 传参 借用构造函数在子类构造函数的内部通过call()以及apply()调用父类构造函数。 // 父类 SuperTypefunction SuperType (name) &#123; this.name = name; this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]; this.getName = function () &#123; return this.name; &#125;&#125;// 子类function SubType (name) &#123; // 继承了SuperType，同时还传递了参数 SuperType.call(this, name); // 实例属性 this.age = 20;&#125;// 实例var instance1 = new SubType(&#x27;Tom&#x27;);instance1.colors.push(&#x27;black&#x27;);console.log(instance1.name); // &quot;Tom&quot;console.log(instance1.getName()); // &quot;Tom&quot;console.log(instance1.age); // 20console.log(instance1.colors); // [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;]var instance2 = new SubType(&#x27;Peter&#x27;);console.log(instance2.name); // &quot;Peter&quot;console.log(instance2.getName()); // &quot;Peter&quot;console.log(instance2.age); // 20console.log(instance2.colors); // [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;] 可以看到，借用构造函数实现继承，解决了原型链继承的两个问题，既可以在新建子类实例的时候给父类构造函数传递参数，也不会造成子类实例共享父类引用变量。 但是你注意到了吗，这里我们把父类方法也写在了SuperType()构造函数里面，可以像前面一样写在SuperType.prototype上吗？ 答案是不可以，必须写在SuperType()构造函数里面。因为这里是通过调用SuperType.call(this)来实现继承的，并没有通过new生成一个父类实例，所以如果写在prototype上，子类是无法拿到的。 缺点：如果方法都在构造函数中定义，那么就无法复用函数。每次构建实例时都会在实例中保留方法函数，造成了内存的浪费，同时也无法实现同步更新，因为每个实例都是单独的方法函数。如果方法写在prototype上，就只会有一份，更新时候会做到同步更新。 组合继承将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 // 父类function SuperType (name) &#123; this.name = name; this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125;// 子类function SubType (name, age) &#123; // 继承父类实例属性 SuperType.call(this, name); // 子类实例属性 this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function () &#123; console.log(this.age);&#125;;// 实例var instance1 = new SubType(&#x27;Tom&#x27;, 20);instance1.colors.push(&#x27;black&#x27;);console.log(instance1.colors); // [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;]instance1.sayName(); // &quot;Tom&quot;instance1.sayAge(); // 20var instance2 = new SubType(&#x27;Peter&#x27;, 30);console.log(instance2.colors); // [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]instance2.sayName(); // &quot;Peter&quot;instance2.sayAge(); // 30 缺点： 调用了两次父类构造函数，一次通过SuperType.call(this)调用，一次通过new SuperType()调用。 原型式继承不使用严格意义上的构造函数，借助原型可以基于已有的对象创建新的对象，同时还不必因此创建自定义类型。 // 在object函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。// 从本质上讲，object()对传入其中的对象执行了一次浅复制。function object (o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name: &#x27;Tom&#x27;, friends: [&#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;]&#125;;var anotherPerson = object(person);anotherPerson.name = &#x27;Greg&#x27;;anotherPerson.friends.push(&#x27;Rob&#x27;);var yetAnotherPerson = object(person);yetAnotherPerson.name = &#x27;Linda&#x27;;yetAnotherPerson.friends.push(&#x27;Barbie&#x27;);console.log(anotherPerson.friends); // [&#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27;]console.log(yetAnotherPerson.friends); // [&#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27;]console.log(person.friends); // [&#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27;] Object.create()在传入一个参数的情况下与前面写的object()方法的行为相同 var person = &#123; name: &#x27;Tom&#x27;, friends: [&#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;]&#125;;var anotherPerson = Object.create(person);anotherPerson.name = &#x27;Greg&#x27;;anotherPerson.friends.push(&#x27;Rob&#x27;);var yetAnotherPerson = Object.create(person, &#123; name: &#123; value: &#x27;Linda&#x27;, enumerable: true &#125;&#125;);yetAnotherPerson.friends.push(&#x27;Barbie&#x27;);console.log(anotherPerson.friends); // [&#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27;]console.log(yetAnotherPerson.friends); // [&#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27;]console.log(person.friends); // [&#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27;] 缺点：和原型链继承一样，所有子类实例共享父类的引用类型。 寄生式继承寄生式继承是与原型式继承紧密相关的一种思路，创建一个仅用于封装继承过程的函数，该函数内部以某种形式来做增强对象，最后返回对象 function object (o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function createAnother (o) &#123; var clone = object(o); clone.sayHi = function () &#123; console.log(&#x27;Hi&#x27;); &#125; return clone;&#125;var person = &#123; name: &#x27;Tom&#x27;, friends: [&#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); // &quot;Hi&quot;anotherPerson.friends.push(&#x27;Rob&#x27;);console.log(anotherPerson.friends); // [&#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;]var yerAnotherPerson = createAnother(person);console.log(yerAnotherPerson.friends); // [&#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;] 缺点： 和原型链式继承一样，所有子类实例共享父类引用类型。 和借用构造函数继承一样，每次创建对象都会创建一次方法。 寄生组合式继承将寄生式继承和组合继承相结合，解决了组合式继承中会调用两次父类构造函数的缺点。 组合继承在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是 SuperType 的实例属性，只不过现在位于 SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 其背后的基本思路是：不必为了指定子类型的原型而调用父类的构造函数，我们需要的无非就是父类原型的一个副本而已。本质上，就是使用寄生式继承来继承父类的prototype，然后再将结果指定给子类的prototype。 function object(o) &#123; function F() &#123; &#125; F.prototype = o; return new F();&#125;function inheritPrototype(SubType, SuperType) &#123; var prototype = object(SuperType.prototype); // 创建对象 prototype.constructor = SubType; // 增强对象 SubType.prototype = prototype; // 指定对象&#125;// 父类function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125;;// 子类function SubType(name, age) &#123; // 继承父类实例属性 SuperType.call(this, name); // 子类实例属性 this.age = age;&#125;// 继承父类方法inheritPrototype(SubType, SuperType);// 子类方法SubType.prototype.sayAge = function () &#123; console.log(this.age);&#125;;// 实例var instance1 = new SubType(&#x27;Tom&#x27;, 20);instance1.colors.push(&#x27;black&#x27;);instance1.sayAge(); // 20instance1.sayName(); // &quot;Tom&quot;console.log(instance1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var instance2 = new SubType(&#x27;Peter&#x27;, 30);instance2.sayAge(); // 30instance2.sayName(); // &quot;Peter&quot;console.log(instance2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;] 寄生组合式继承的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了再SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变。因此，还能够正常使用instanceof和isPrototypeOf()。 ES6实现继承// 父类class SuperType &#123; constructor(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; &#125; sayName() &#123; console.log(this.name); &#125;;&#125;// 子类class SubType extends SuperType &#123; constructor(name, age) &#123; // 继承父类实例属性和prototype上的方法 super(name); // 子类实例属性 this.age = age; &#125; // 子类方法 sayAge() &#123; console.log(this.age); &#125;&#125;// 实例var instance1 = new SubType(&#x27;Tom&#x27;, 20);instance1.colors.push(&#x27;black&#x27;);instance1.sayAge(); // 20instance1.sayName(); // &quot;Tom&quot;console.log(instance1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var instance2 = new SubType(&#x27;Peter&#x27;, 30);instance2.sayAge(); // 30instance2.sayName(); // &quot;Peter&quot;console.log(instance2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"常用js —— object对象操作","slug":"前端/js/常用js —— object对象操作","date":"14/02/2022","updated":"14/02/2022","comments":true,"path":"2034.html","link":"","permalink":"https://wqdy.top/2034.html","excerpt":"","text":"删除对象属性 如果删除成功，返回true，删除失败，返回falsevar 声明的全局变量不能被删除 delete obj.name // 删除obj的name属性// var 声明的全局变量不能被删除var num = 12str = &#x27;hello&#x27;delete window.num // false 删除失败delete window.str // true 删除成功console.log(num) // 12console.log(str) // 报错 str is not undefined 判断一个属性是否是对象的一个属性 key in obj // 返回布尔值 从原型链继承的属性会返回 trueobj.hasOwnProperty(key) // 判断某个key是否是这个对象本身的属性 for..in 遍历对象 会枚举原型链中的属性 // 遍历对象for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; console.log(key) // 键 console.log(obj[key]) // 值 &#125;&#125; Object.prototype 成员constructor: 指向了构造函数 ObjecthasOwnProperty(): 返回一个布尔值，判断对象自身是否具有该属性isPrototypeOf(): 返回一个布尔值，用于测试一个对象是否存在于另一个对象的原型链上propertyIsEnumerable(): 返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性toString()/toLocaleString(): 返回对象的字符串格式valueOf(): 返回对象的原始值 hasOwnProperty var obj = &#123; name: &#x27;zs&#x27; &#125;// 判断name属性是不是obj自己提供的obj.hasOwnProperty(&#x27;name&#x27;) // trueobj.hasOwnProperty(&#x27;toString&#x27;) // false hasOwnProperty 与 in 的区别 in 操作符：判断对象能否访问到该属性（不管这个属性是自己提供的，还是从原型上继承来的），如果可以访问到，都会返回 true hasOwnProperty：该属性必须是自己提供，才返回 true，否则返回 false isPrototypeOf // 判断 A 对象是否在 B 对象的原型链上 ,回一个布尔值A.isPrototetypeOf(B)function Person() &#123;&#125;var p = new Person()// p 的原型链：// p ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; nullPerson.isPrototypeOf(p) // false Person 是构造函数Person.prototype.isPrototypeOf(p) // trueObject.prototype.isPrototypeOf(p) // true isPropertyOf 与 instanceof 运算符的区别 instanceof 运算符用来测试一个对象的原型链中是否存在一个构造函数的 prototype 属性。作用和 isPrototypeOf 类似 语法： 实例对象 instanceof 构造函数 作用：构造函数的 prototype 属性是否在实例对象的原型链上 A.isPrototypeOf(B) 判断 A 是否在 B 的原型链上 A： 是一个原型对象 B instanceof A 判断 A 的 prototype 是否在 B 的原型链上 A：是一个构造函数 Array.isPrototypeOf([]) // falseArray.prototype.isPrototypeOf([]) // true[] instanceof Array // true[] instanceof Array.prototype // 语法错误 propertyIsEnumerable function Person(name) &#123; this.name = name&#125;Person.prototype.age = 19var p = new Person(&#x27;lw&#x27;)p.propertyIsEnumerable(&#x27;name&#x27;) // truep.propertyIsEnumerable(&#x27;age&#x27;) // false toString/toLocaleString 返回对象的字符串格式 每个内置对象的原型上都有属于自己的 toString 方法 var obj = &#123; name: &#x27;zs&#x27; &#125;// obj ==&gt; Object.prototype ==&gt; nullobj.toString() // &#x27;[object Object]&#x27;obj.toLocaleString() // &#x27;[object Object]&#x27;var arr = [1, 2, 3]// arr ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; null// toString() toString()// Array.prototype 含有自己的 toString 方法arr.toString() // &#x27;1,2,3&#x27;arr.toLocaleString() // &#x27;1,2,3&#x27;var date = new Date()// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null// toString() toString()// Date.prototype 含有自己的 toString 方法date.toString() // Wed Oct 10 2018 16:00:51 GMT+0800 (中国标准时间)date.toLocaleString() // 2018/10/10 下午4:00:51 得到的是本地时间格式 valueOf() 返回值为该对象的原始值，如果对象没有原始值，则 valueOf 将返回对象本身 对象 返回值 Array 返回数组对象本身 Boolean 布尔值 Date 时间戳 Function 函数本身 Number 数字值 Object 对象本身 （这是默认情况） String 字符串值 var obj = &#123; name: &#x27;zs&#x27; &#125;// obj ==&gt; Object.prototype ==&gt; nullobj.valueOf() // &#123; name: &#x27;zs&#x27; &#125;var arr = [1, 2, 3]// arr ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; nullarr.valueOf() // [1, 2, 3]var date = new Date()// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null// Date.prototype 含有 valueOf 方法date.valueOf() // 时间戳 valueOf 和 toString 的应用 当对象在参与运算和比较的时候，js 内部会自动的调用 valueOf 和 toString 方法 调用规则： 默认先调用 vauleOf， 尝试将对象转成简单数据类型， 如果没有转成简单数据类型， 会继续在调用 toString 方法 如果 valueOf 和 toString 方法都没有转成简单数据类型，会报错 Object 静态方法Object.assign()Object.create()Object.defineProperty()Object.entries()Object.freeze()Object.getPrototypeOf()Object.is()Object.isFrozen()Object.keys()Object.values() Object.assign(target, ...sources) 用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象 const o1 = &#123; a: 1 &#125;const o2 = &#123; b: 2 &#125;const o3 = &#123; c: 3 &#125;const obj = Object.assign(o1, o2, o3)console.log(obj) // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1) // &#123; a: 1, b: 2, c: 3 &#125;obj === o1 // true const v1 = &quot;abc&quot;const v2 = trueconst v3 = 10const v4 = Symbol(&quot;foo&quot;)const obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4)// 原始类型会被包装，null 和 undefined 会被忽略。// 注意，只有字符串的包装对象才可能有自身可枚举属性。console.log(obj) // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125; Object.create(proto, [propertiesObject]) 创建一个新对象，使用现有的对象来提供新创建的对象的__proto__ // 语法Object.create(proto[, propertiesObject])// 参数：proto 一个对象,新创建对象的原型对象// 参数：propertiesObject 要添加到新创建对象的可枚举属性// 返回值：一个新对象，带着指定的原型对象和属性var obj = Object.create(proto)console.log(obj) Object.defineProperty(obj, prop, descriptor) 在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 let obj = &#123;&#125;Object.defineProperty(obj, &#x27;name&#x27;, &#123; configurable: true, // 表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。默认为 false value: &#x27;c&#x27;, // 配置该属性的默认值 默认为 undefined writable: true, // 配置该属性是否可以被修改， 默认值是false， 不可修改 enumerable: true // 配置该属性是否可枚举， 默认值是false， 不可枚举 // 默认为 undefined // set: function (newVal) &#123; // console.log(&#x27;赋值了&#x27;, newVal) // &#125;, // 默认为 undefined // get: function () &#123; // console.log(&#x27;取值了&#x27;) // &#125;&#125;) 如果一个描述符同时拥有 value 或 writable 和 get 或 set 键，则会产生一个异常 Object.entries(obj) 返回一个给定对象自身可枚举属性的键值对数组 将Object转换为Map new Map(Object.entries(obj)) Object.freeze() 接受一个对象作为参数，并返回一个相同的不可变的对象，冻结一个对象后该对象的原型也不能被修改 可以阻止修改对象的值，但是不能阻止引用的修改 只是做了层浅冻结，具有嵌套属性的对象实际上并未冻结 Object.getPrototypeOf 返回指定对象的原型 Object.is() Object.is() 方法判断两个值是否是相同的值。比较时不会做类型转换，这与 == === 运算符的判定方式都不一样 Object.is(+0, -0) // falseObject.is(0, -0) // falseObject.is(0, +0) // trueObject.is(-0, -0) // trueObject.is(undefined, undefined) // trueObject.is(null, null) // trueObject.is(Number.NaN, Number.NaN) // trueObject.is(Number.NaN, NaN) // trueObject.is(NaN, NaN) // trueObject.is(NaN, 0 / 0) // true Object.isFrozen() Object.keys(obj) 返回一个由一个给定对象的自身可枚举属性组成的数组 Object.values(obj) 返回一个给定对象自身的所有可枚举属性值的数组","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"常用js —— array数组操作","slug":"前端/js/常用js —— array数组操作","date":"13/02/2022","updated":"13/02/2022","comments":true,"path":"2033.html","link":"","permalink":"https://wqdy.top/2033.html","excerpt":"","text":"Arraynew Array(4) // [empty × 4]new Array(&#x27;4&#x27;) // [&#x27;4&#x27;] 基本方法 arr.join() 将数组的值拼接成字符串 不传参数，默认用逗号进行拼接，返回拼接好的字符串 arr.push() 从后面添加一个或多个元素，多个参数逗号隔开，返回新数组的 length arr.push(arr1) // 把 arr1 当成一个整体放到 arr 里 arr.pop() 从数组的后面删除元素，返回删除的那个元素 arr.unshift() 从数组的前面的添加元素，，多个参数逗号隔开，返回新数组的 length arr.shift() 从数组的最前面删除元素，返回删除的那个元素 arr.reverse() 翻转数组 arr.sort() 排序 sort 方法可以传递一个函数作为参数，这个参数用来控制数组如何进行排序 arr.sort(function(a, b) &#123; // 参数为 true 时，即返回值 &gt; 0 时，交换位置 // return a - b // 从小到大排序 return b - a // 从大到小排序&#125;) arr.concat() 数组合并，返回一个新数组，原数组不受影响 a.concat(b) // [...a, ...b] arr.slice() 数组切分，复制数组的一部分到一个新数组，并返回这个新数组，原数组不受影响 // slice(begin, end) 包含 begin，不包含 end， begin 和 end 为下标// slice(begin) 只有一个参数时，为开始参数，截取到末尾// slice() 没有参数，全部截取// 可以为负数，会将字符串的长度与对应的负数相加，结果作为参数，-1 表示从后数第一个var newArr = arr.slice(begin, end) arr.splice() 删除或者增加数组元素，修改原数组，返回删除的内容（数组形式） // start: 开始位置 deletedCount: 删除的个数（如果不删除为 0）items: 替换的内容, 可为多个arr.splice(start) // 删除原数组 start 位置之后的项（包含 start），返回删除的内容arr.splice(start, deletedCount, [items]) // items 将作为 arr 的一项 arr.indexOf() 返回数组中某个元素第一次出现的位置，如果找不到，返回 -1 // fromIndex 表示从 fromIndex 下标开始查找arr.indexOf(&#x27;zs&#x27;[, fromIndex]) arr.lastIndexOf() 从后面开始查找数组中元素出现位置,即查找某元素最后一次出现的位置，如果找不到，返回 -1 arr.lastIndexOf(&#x27;zs&#x27;[, fromIndex]) arr.forEach() 返回值: undefined除了抛出异常以外，没有办法中止或跳出 forEach() 循环不支持 return 操作输出，return 只用于控制循环是否跳出当前循环 遍历时会自动忽略 empty 值 arr.forEach(function(item, index, arr) &#123;&#125;, thisArg)// item 必需。数组中正在处理的当前元素// index 可选。数组中正在处理的当前元素的索引// arr 可选。当前数组// thisArg 可选。当执行回调函数时用作this的值var arr = [&#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27;]arr.forEach(function(item, index, arr) &#123; console.log(item) console.log(this)&#125;) arr.map() var newArr = arr.map(function(item, index) &#123; // item 必需。数组中正在处理的当前元素 // index 可选。数组中正在处理的当前元素的索引 // arr 可选。当前数组 // 使用 return 操作输出，会循环数组每一项，并返回新的每一项组成的数组 return item * 2&#125;)// 不修改原数组// 返回一个新数组，新数组的每一项乘以 2 arr.filter() var newArr = arr.filter(function(item, index) &#123; // 参数同 map // 使用 return 操作输出，会循环数组每一项，并返回判断为 true 的每一项组成的数组 return item &gt; 2 &amp;&amp; item &lt; 5 // return 后是判断条件&#125;)// 不修改原数组// 返回一个新数组，新数组每一项满足 2 &lt; item &lt; 5 arr.some() var newArr = arr.some(function(item, index) &#123; // 参数同 map // 返回布尔值，只要有一项满足条件就返回 true，否则返回 false return item &gt; 2 // return 后是判断条件&#125;)// 不修改原数组 arr.every() var newArr = arr.every(function(item, index) &#123; // 参数同 map // 返回布尔值，只有所有项都满足条件才返回 true，否则返回f alse return item &gt; 2 // return 后是判断条件&#125;)// 不修改原数组 arr.includes() 判断数组是否含有某值，输出 true 或 false var flag = arr.includes(5) arr.find() 使用 return 操作输出，会循环数组每一项，当循环到满足条件时则跳出循环，输出当前数组元素如果全不满足返回 undefined var newArr = arr.find(function(item, index) &#123; return item &gt; 2&#125;)// 不修改原数组 arr.findIndex() 使用 return 操作输出，会循环数组每一项，当循环到满足条件时则跳出循环，输出当前数组元素的下标如果全不满足返回 -1 var index = arr.findIndex(function(item, index) &#123; return item &gt; 2&#125;)// 不修改原数组 arr.reduce() var new1 = arr.reduce(function(accumulator, current, index, array) &#123; // accumulator 第一次为数组第一项，之后为上一操作的结果 // current 数组的当前项 // index 当前项的序列 // array 可选。当前数组 // initialValue 可选。作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错 // 使用 return 操作输出 return accumulator + current // 返回数组每一项的和&#125;[, initialValue])// 不修改原数组 // 扁平化数组var arr2 = [ [1, 2, 3], [4, 5], [6, 7] ]var new2 = arr2.reduce(function(accumulator, current, index) &#123; return accumulator.concat(current)&#125;) // 对象数组叠加计算var arr3 = [ &#123; price: 1, count: 1 &#125;, &#123; price: 2, count: 2 &#125;]var new3 = arr3.reduce(function(accumulator, current, index) &#123; return accumulator + current.price * current.count // 当需要操作第一项的时候，利用 reduce(callbreak()&#123;&#125;,往数组第一项前添加一项，如:0)&#125;, 0) // 在原数组第一项添加为 0，不改变原数组 arr.fill() 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引 arr.fill(value[, start[, end]]) arr.flat() 扁平化数组按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回 var newArray = arr.flat([depth])// 使用 Infinity，可展开任意深度的嵌套数组var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]]arr4.flat(Infinity) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// 会移除数组中的空项var arr4 = [1, 2, , 4, 5]arr4.flat() // [1, 2, 4, 5] 伪数组 伪数组也叫类数组 伪数组其实就是一个对象，但是跟数组一样，伪数组也会有length属性，也有0, 1, 2, 3等属性 伪数组并没有数组的方法，不能使用push/pop等方法 伪数组可以跟数组一样进行遍历，通过下标操作 常见的伪数组：arguments、document.getElementsByTagName的返回值、jQuery对象 var obj = &#123; 0: &#x27;zs&#x27;, 1: &#x27;ls&#x27;, 2: &#x27;ww&#x27;, length: 3&#125; 伪数组借用数组的方法 // 给 obj 添加一项Array.prototype.push.call(obj, &#x27;zl&#x27;)// 把 obj 中的每一项使用 &#x27;-&#x27; 拼接起来返回一个字符串Array.prototype.join.call(obj, &#x27;-&#x27;) 将伪数组转换成真数组 // 借用数组的方法Array.prototype.slice.call(obj)[].slice.call(obj)// 使用es6中数组的from方法：从一个类似数组或可迭代对象中创建一个新的数组实例Array.from(obj)// 对于函数的arguments参数可以使用扩展运算符[...arguments]","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"常用js —— string字符串操作","slug":"前端/js/常用js —— string字符串操作","date":"12/02/2022","updated":"13/02/2022","comments":true,"path":"2032.html","link":"","permalink":"https://wqdy.top/2032.html","excerpt":"","text":"String 对象https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String 操作字符串的方法不会改变原来的字符串，需要新字符串去接收 查找指定字符串 str.indexOf(searchString[, position]) // 获取某个字符串第一次出现的位置，如果没有，返回-1。可选参数position可设置从str的某个指定的位置开始查找str.lastIndexOf(searchString[, position]) // 从后面开始查找某个字符串第一次出现的位置。如果没有，返回-1str.search(regexp) // 输出第一次出现位置，找不到输出-1str.match(regexp) // 输出匹配到的第一个字符，匹配不到返回 nullstr.match(regexp/g) // 全部输出str.startsWith(str1) // 判断 str 字符串是否以 str1 字符串开头，若符合返回 true // 等价于判断 str.indexOf(str1) === 0str.endsWith(str1) // 判断 str 字符串是否以 str1 字符串结尾，若符合返回 true // 等价于判断 str.indexOf(str1) === str.length - str1.length str.includes(searchString[, position]) 用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false str.trim() 去除字符串两边的空格，内部空格不会去除 大小写转换 str.toUpperCase() 全部转换成大写字母str.toLowerCase() 全部转换成小写字母 字符串拼接与截取 字符串拼接 可以用 concat，用法与数组一样，但是一般都用 + str.slice(start, end) 从 start 开始，end 结束，并且取不到 end，没有 end 则截取从 start 到末尾start 和 end 都不是必选，str.slice() 与 str.slice(0) 等价 截取全部，start 和 end 可以是任意参数，参数应该是先调用Number()， 结果是NAN转换成0输出， 结果是整数直接输出， 结果是小数，再调用parseInt() 转化为整数输出start 和 end 可以是负数，会将字符串的长度与对应的负数相加，结果作为参数，如果还是负数，不会递归继续与字符长度相加，取 0 str.substring(params1, params2) 以两个参数中较小一个作为起始位置，较大的参数作为结束位置，不包括结束位置，只有一个参数则截取到末尾params1, params2 都不是必选，str.substring() 与 str.substring(0) 等价 截取全部可以是任意参数，参数应该是先调用Number()， 结果是NAN转换成0输出， 结果是整数直接输出， 结果是小数，再调用parseInt() 转化为整数输出可以是负数，负参数会被直接转换为 0 str.substr(start, length) 从 start 开始，截取 length 个字符，没有 length 则截取到末尾可以是任意参数，参数应该是先调用Number()， 结果是NAN转换成0输出， 结果是整数直接输出， 结果是小数，再调用parseInt() 转化为整数输出start 参数为负参数时，会将参数与字符串长度相加后的结果作为参数，如果还是负数，不会递归继续与字符长度相加，取 0length 参数为负数时，会被转化为 0 ，即截取长度为 0 字符串切割 str.split(separator[, limit]) // 将字符串分割成数组var str = &#x27;zs,ls,ww&#x27;var arr = str.split(&#x27;,&#x27;, 1) // [&#x27;zs&#x27;]var arr = str.split() // [&#x27;zs,ls,ww&#x27;] 字符串替换 // 语法str.replace(regexp|substr, replacement)// 参数：regexp/substr: 需要替换的内容 replacement: 替换文本或生成替换文本的函数 默认只替换第一个匹配子串str.replace(/regexp/g, replacement) // 全部替换str.replace(/ /g, &#x27;&#x27;) // 将全部空格去掉// replaceAll 全部替换 replace() 方法的参数 replacement 可以是函数。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。 str.charAt(pos) pos参数可以是任意, 参数应该是先调用Number()， 结果是NAN转换成0输出，结果是整数直接输出，结果是小数，再调用 Math.ceil() 转化为整数输出str.charAt() &#x3D;&#x3D;&#x3D; str.charAt(0) 如果pos小于0或者大于等于字符串的长度str.length，返回空字符串 padEnd() padStart() padEnd() padStart() 方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。padStart()从当前字符串的左侧开始填充，padEnd()从当前字符串的右侧开始填充 寻找重复最多的字符以及个数 var str = &#x27;shdshdfjkfjfdgjkjdksgjskdjfsfsfsfjksjkfdkjf&#x27;var arr = str.split(&#x27;&#x27;).sort()str = arr.join(&#x27;&#x27;)var count = 0var char = 0var reg = /(\\w)\\1+/gstr.replace(reg, function(a, b, c, d) &#123; console.log(a, b, c, d) // a 匹配模式的字符串 b 与模式中的子表达式匹配的字符串 c 匹配在 str 中出现的位置 d str 本身 if (a.length &gt; count) &#123; count = a.length char = b &#125;&#125;)console.log(str)console.log(&#x27;最多的字符为:&#x27; + char + &#x27;;个数为:&#x27; + count)","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"安卓手机高版本抓包方案","slug":"前端/调试/安卓手机高版本抓包方案","date":"07/12/2021","updated":"07/12/2021","comments":true,"path":"2031.html","link":"","permalink":"https://wqdy.top/2031.html","excerpt":"","text":"安卓7.0以后，每个应用可以自定义可信 CA 集，默认情况下，应用只会信任系统级的证书，不再信任用户级的证书。通过Fiddler&#x2F;Charles安装的证书属于用户级的证书，因此会被视作不安全的证书，导致无法正常抓包 解决方案修改APP配置文件允许信任用户证书，但前提是可以获取到APP的源码将证书安装到系统证书中，但需要root权限安装好用户证书，系统已root，安装re文件管理器，使用re文件管理器将证书移动到系统证书文件夹 用户证书路径：&#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added&#x2F;&lt;证书Hash值&gt;.编号系统证书路径：&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts 方法1: 使用adb连接 Copy执行: adb push 0dd2455e.0 &#x2F;sdcard adb shell su mount -o remount,rw &#x2F;system#mount -o rw,remount &#x2F;system cp &#x2F;sdcard&#x2F;0dd2455e.0 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F; chmod 644 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;0dd2455e.0 使用第三方文件管理器(推荐) 下载酷安市场app –&gt; 分别搜索 Syslock 和 RE管理器 并下载安装(其他应用市场下载也可以)给 Syslock 和 RE管理器 root权限(以小米为例:安全中心–&gt;应用管理–&gt;权限–&gt;ROOT权限管理–&gt;找到应用并开启)打开Syslock并解锁 &#x2F;system (每次重启后都得开启一次)将文件拷贝至手机中使用RE管理器将文件拷贝到 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts 下修改文件权限到此然后重启手机。就可以正常抓https数据包了。也可以到手机 设置-&gt;安全-&gt;信任凭据–&gt;系统 查看。 安卓模拟器（兼容性差，很多应用闪退）安卓虚拟机 VMOS，官网: http://www.vmos.cn/，该方案相对简单vmos 设置wifi代理 找到 vmos 主屏右下角的设置 — 其他设置 — 网络 adb (记录 ip+端口) 连接vmos: adb connect ip+端口 打开wlan设置: adb shell am start -a android.intent.action.MAIN -n com.android.settings/.wifi.WifiSettings 长按 wifi，修改网络，添加代理","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"js 中的数据类型转换","slug":"前端/js/js-数据类型转换","date":"12/09/2021","updated":"12/09/2021","comments":true,"path":"2029.html","link":"","permalink":"https://wqdy.top/2029.html","excerpt":"","text":"转换成字符串 调用 toString() 方法 （显式转换） var a = 1a.toString() // &#x27;1&#x27; null 、undefined 没有 toString() 方法 调用 String() 构造函数（显式转换） String(1) // &#x27;1&#x27; 直接和字符串做加法运算（隐式转换） // 任意数据类型的变量和字符串做加法运算结果都是字符串1 + &#x27;&#x27; // &#x27;1&#x27;true + &#x27;&#x27; // &#x27;true&#x27; 引用类型转换成字符串 [].toString() // &#x27;&#x27;[1, 2].toString() // &#x27;1,2&#x27;(&#123;&#125;).toString() // &quot;[object Object]&quot;[1, &#x27;123&#x27;, [], undefined, null, NaN, true ].toString() // &quot;1,123,,,,NaN,true&quot; 转换成数值 Number() Number(&#x27;123&#x27;) // 123Number(&#x27;123c&#x27;) // NaN// 如果字符串不能转换成合法数字，转换结果为 NaN 使用 parseInt() parseInt(&#x27;12.3&#x27;) // 12 只保留整数parseInt(&#x27;15xyz&#x27;) // 15parseInt(&#x27;15x6yz&#x27;) // 15// 如果字符串里有非法的数字，会逐个转换，直到遇到无法转化的字符串为止 使用 parseFloat() 完成 parseFloat(&#x27;12.34&#x27;) // 12.34 可以保留小数位 让字符串和数字做除了加法以外的运算（隐式转换） var d = &#x27;345&#x27;+d === 345 // trued - 0 === 345 // trued * 1 === 345 // trued / 1 === 345 // true 引用类型转换成数值 // 空数组为 0，存在一个元素且可转换成数字，则转换成该数字，其他情况为 NaN+[] // 0+[&#x27;2&#x27;] // 2+[&#x27;1&#x27;, &#x27;2&#x27;] // NaN+&#123;&#125; // NaN 转换成布尔值0, NaN, 空字符串，undefined, null, false 会被转换成为 false 使用 Boolean() 完成 Boolean(123) // true// 对于数字类型来说：一般的数字都转换成为 true，0、NaN 会被转换成为 falseBoolean(&#x27;123&#x27;) // trueBoolean(&#x27; &#x27;) // trueBoolean(&#x27;&#x27;) // false// 字符串中只有空的字符串会被转换成为 falseBoolean(undefined) // falseBoolean(null) // false 使用 !! !!2 // true 自动转换 if (&#x27;&#x27;) &#123; console.log(&#x27;哈哈&#x27;) &#125; 变量转换表 Value Boolean Number String undefined false NaN “undefined” null false 0 “null” true true 1 “true” false false 0 “false” “” false 0 “” “123” true 123 “123” “1a” true NaN “1a” 0 false 0 “0” 1 true 1 “1” Infinity true Infinity “Infinity” NaN false NaN “NaN” {} true NaN “[object Object]” 数组 true 空数组为 0，存在一个元素且为数字转数字，其他 NaN [1, ‘123’, [], undefined, null, NaN, true ] &#x3D;&gt; “1,123,,,,NaN,true”","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"总结 —— parseInt 和 parseFloat","slug":"前端/js/总结 —— parseInt和parseFloat","date":"12/09/2021","updated":"20/02/2022","comments":true,"path":"2030.html","link":"","permalink":"https://wqdy.top/2030.html","excerpt":"","text":"语法 parseInt() 函数解析一个字符串参数，指定该字符串为指定基数的进制值，并返回一个 10 进制的整数，如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN 参考 parseInt parseInt(string, radix) string 要被解析的值，如果参数不是一个字符串，则将其转换为字符串 radix 基数，表示进制，介于 2 和 36 之间的整数，参数 radix 的值为undefined、0 或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。如果输入的 string 以 “0x”或 “0x”（一个0，后面是小写或大写的X）开头，那么radix被假定为16，字符串的其余部分被解析为十六进制数。如果输入的 string以 “0”（0）开头， radix被假定为10（十进制）。如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。 parseInt(&#x27;123&#x27;, 5) // 将 &#x27;123&#x27; 看作 5 进制数，返回十进制数 38parseInt(&#x27;4215213&#x27;, 5) // 4 * 5^2 + 2 * 5^1 + 1 * 5^0 = 111 返回 111parseInt(&#x27;0x123&#x27;) // 291[1, 2, 3].map(parseInt) // [1, NaN, NaN]// [1, 2, 3].map(parseInt(item, index)) parseFloat() 函数解析一个字符串参数并返回一个浮点数，如果给定值不能被转换成数值，则会返回 NaN parseFloat(&#x27;3.14&#x27;) // 3.14parseFloat(&#x27;0x123&#x27;) // 0// [1, 2, 3].map(parseFloat) // [1, 2, 3] 问题parseInt(0.0000005) === 5// 如果 parseInt 第一个参数不是字符串，会将其转换成字符串// 小于 10-6 的浮点数以指数表示// parseint 从 float 的指数法中提取整数String(0.0000005) // =&gt; &#x27;5e-7&#x27;parseInt(5e-7) // =&gt; 5parseInt(&#x27;5e-7&#x27;) // =&gt; 5parseInt(1111111111111111111111) // =&gt; 1parseInt(999999999999999999999) // =&gt; 1parseInt((5e-7).toFixed()) // =&gt; 0parseFloat(9999999999999999) // 10000000000000000","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"Babel 入门","slug":"前端/工程化/babel","date":"28/07/2021","updated":"28/07/2021","comments":true,"path":"2028.html","link":"","permalink":"https://wqdy.top/2028.html","excerpt":"","text":"Babel与Polyfill的关系和区别Babel 默认只转换新的 js 句法（syntax），而不转换新的 API，例如箭头函数等Polyfill 用于实现浏览器并不支持的原生API的代码，如新增的方法等 Babel Babel的安装，配置 创建 babel.config.js 文件，内容如下 babel.config.js 是Babel执行时会默认在当前目录寻找的Babel配置文件，除了babel.config.js，我们也可以选择用.babelrc或.babelrc.js这两种配置文件 module.exports = &#123; presets: [&quot;@babel/env&quot;]&#125; 安装如下包 npm i -D @babel/cli @babel/core @babel/preset-env @babel&#x2F;cli是Babel命令行转码工具，如果我们使用命令行进行Babel转码就需要安装它。 @babel&#x2F;cli依赖@babel&#x2F;core，因此也需要安装@babel&#x2F;core这个Babel核心npm包。 @babel&#x2F;preset-env这个npm包提供了ES6转换ES5的语法转换规则，我们在Babel配置文件里指定使用它。如果不使用的话，也可以完成转码，但转码后的代码仍然是ES6的，相当于没有转码。 创建 index.js 文件，如下 const fn = (num) =&gt; num + 1new Promise(() =&gt; &#123;&#125;) 执行命令 npx babel index.js -o output.js 输出结果为 &quot;use strict&quot;;var fn = function fn(num) &#123; return num + 1;&#125;;new Promise(() =&gt; &#123;&#125;); 可以看到，ES6的箭头函数语法转换成了 ES5 的函数定义语法，但是并没有对ES6的Promise进行转换。因为Babel默认只转换新的 js 语法（箭头函数，解构…），而不转换新的 API。新的API分类两类，一类是Promise、Map、Symbol、Proxy、Iterator等全局对象及其对象自身的方法，例如Object.assign，Promise.resolve；另一类是新的实例方法，例如数组实例方法[1, 2, 3].find((item) &#x3D;&gt; item &lt; 2) polyfill 安装 npm install --save @babel/polyfill 在 index.js 中引入 import &#39;@babel/polyfill&#39; 执行命令 npx babel index.js -o output.js 输出结果 &quot;use strict&quot;;require(&quot;@babel/polyfill&quot;);var fn = function fn(num) &#123; return num + 1;&#125;;new Promise(function () &#123;&#125;); 输出结果中 require(&quot;@babel/polyfill&quot;); import被编译成了require，如果想要编译出来的模块引入规范还是import，则可以在preset-env的配置项中添加”modules”: false即可 有时候我们项目里并没有用到那么多的新增API，但是 @babel&#x2F;polyfill 会把所有浏览器环境的的polyfill都引入，整个包的体积就会很大，我们想要对目标环境按需引入相应的polyfill应该怎么办呢，这个时候我们就可以使用 preset-env 的配置项中的 useBuiltIns 属性来按需引入 polyfill。 module.exports = &#123; presets: [ [ &quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false, // 用来设置是否把ES6的模块化语法改成其它模块化语法 &quot;useBuiltIns&quot;: &quot;usage&quot;, &#125; ] ]&#125; 使用useBuiltIns:”usage”后，Babel除了会考虑目标环境缺失的API模块，同时考虑我们项目代码里使用到的ES6特性，且不需要在项目入口处手动引入polyfill import &quot;core-js/modules/es6.object.to-string.js&quot;;import &quot;core-js/modules/es6.promise.js&quot;;var fn = function fn(num) &#123; return num + 1;&#125;;new Promise(function () &#123;&#125;); 可以看到 多了 import &quot;core-js/... 的引用，因为 @babel&#x2F;polyfil 是由core-js2和regenerator-runtime组成的一个集成包，Babel 7.4.0 之后已经弃用了 @babel&#x2F;polyfill，所以core-js官方现在推荐我们使用polyfill的时候直接引入core-js和regenerator-runtime&#x2F;runtime这两个包完全取代 @babel&#x2F;polyfil core-jsbabel-polyfill","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"Babel","slug":"Babel","permalink":"https://wqdy.top/tags/Babel/"},{"name":"Polyfill","slug":"Polyfill","permalink":"https://wqdy.top/tags/Polyfill/"}]},{"title":"vue 中 hock 的使用","slug":"前端/vue/vue中hock的使用","date":"13/05/2021","updated":"13/05/2021","comments":true,"path":"2026.html","link":"","permalink":"https://wqdy.top/2026.html","excerpt":"","text":"在 Vue 组件中，可以用过 $on, $once 去监听所有的生命周期钩子函数，如监听组件的 updated 钩子函数可以写成 this.$on(‘hook:updated’, () &#x3D;&gt; {}) 使用$.once(‘hook:beforeDestory’,() &#x3D;&gt; {})清理定时器https://cn.vuejs.org/v2/guide/components-edge-cases.html#程序化的事件侦听器 const timer = setInterval(() =&gt; &#123; console.log(&#x27;1&#x27;)&#125;, 1000)// 直接在需要定时器的方法或者生命周期函数中声明并销毁this.$once(&#x27;hook:beforeDestory&#x27;, () =&gt; &#123; clearInterval(timer) timer = null&#125;) 在父组件监听子组件的生命周期方法&lt;!-- 父组件中 --&gt;&lt;child-component @hook:mounted=&quot;handleChildMounted&quot; /&gt; 监听第三方组件数据的变化，但是组件又没有提供change事件，可以在外部监听组件的updated钩子函数 &lt;child-component @hook:updated=&quot;handleChildUpdated&quot; /&gt;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wqdy.top/tags/vue/"},{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"js 中的操作符","slug":"前端/js/js-操作符","date":"27/04/2021","updated":"12/09/2021","comments":true,"path":"2025.html","link":"","permalink":"https://wqdy.top/2025.html","excerpt":"","text":"typeof 操作符 是一个操作符而不是函数，圆括号可以使用，但不是必需的 var numtypeof num // undefinedtypeof num1 // undefined// 对未初始化和未声明的变量执行 typeof 操作符都返回 undefined 值var num = 1typeof num // numbervar num = &#x27;1&#x27;typeof num // stringvar flag = truetypeof flag // bolleantypeof true // booleantypeof null // object ==&gt; null 被认为是一个空的对象引用var cat = &#123; name: &#x27;kitty&#x27; &#125;typeof cat // object 算数操作符 + 、- 、* 、/ 、% 对于加法 转换方向: 布尔值 -&gt; 数值 -&gt; 字符串， 数组&#x2F;对象 -&gt; 字符串除加法以外 转换方向：字符串 -&gt; 数值，布尔值 -&gt; 数值, 数组 -&gt; 数值 var num = 5 + 6 // 11var num = 5 % 2 // 1 取余数var num = 5 % -2 // 1var num = -5 % 2 // -1 只与左边值的符号有关// 数字与字符串相加，数字会转换成字符串，返回字符串var num = &#x27;5&#x27; + 6 + 7 // &#x27;567&#x27;var num = 5 + 6 + &#x27;7&#x27; // &#x27;117&#x27;// 数值与布尔值相加，布尔值转化成数值，false 转成 0，true 转成 1var num = 5 + true // 6// 字符串与布尔值相加，布尔值转化成字符串var num = &#x27;1&#x27; + true // &#x27;1true&#x27;&#x27;a&#x27; + +&#x27;b&#x27; // -&gt; &#x27;a&#x27; + +&#x27;b&#x27; -&gt; &#x27;aNaN&#x27;4 * &#x27;3&#x27; // 12true + true // 21 / 0 // Infinity0 / 0 // NaN 赋值操作符 赋值运算符左边不能是常量或表达式 var age = 10var num = age++ // num = 10 age = 11 (先将变量中的值取出做赋值操作,再自身+1)var age = 10var num = ++age // num = 11 age = 11 (先自身+1,然后再将+1后的结果赋值)var num = 5console.log(num++) // 5console.log(++num) // 7var x = 3var y = x++ + ++x + x * 10 // x = 3// y = 3 + ++x + x * 10 // x = 4// y = 3 + 5 + x * 10 // x = 5// y = 58 关系操作符 &gt; 、&lt; 、&gt;= 、&lt;= == 相等 、!= 不相等 、=== 全等 、!== 不全等 in instanceof &gt; 、&lt; 、&gt;= 、&lt;= 、==、!= 在比较前先执行类型转换 如果有一个操作数是布尔值，则在比较相等性前先将其转换为数值 -&gt; false 转换为 0，true 转换为 1 如果一个操作数是字符串，另一个操作数是数值，则在比较相等性前将字符串转换为数值 如果两个值都是字符串，则按照字符串的字符编码进行逐位比较 如果一个数是对象，另一个不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则比较 如果两个操作数都是对象，则比较它们是否指向同一个对象 null 和 undefined 是相等的 在比较相等性之前，不能将 null 和 undefined 转换为其他任何值 在比较大小之前，null，undefined 会被 Number()强制转换成数字类型 Number(null) -&gt; 0, Number(undefined) -&gt; NaN 如果有一个操作符是 NaN，则相等操作符返回 false，不相等操作符返回 true；即使两个操作数都是 NaN，也一样 === 全等、!== 不全等两个操作数在未经转换的情况下相等返回 true，不相等返回 false 0 == false // true1 == true // true2 == true // falsefalse == &#x27;0&#x27; // true&#x27;&#x27; == 0 // true&#x27;4&#x27; == 4 // truenull == undefined // trueundefined == 0 // falsenull &gt;= 0 // truenull &lt;= 0 // truenull == 0 // falsenull &gt;= false // truenull &lt;= false // truenull == false // false&#x27;NaN&#x27; == NaN // false5 == NaN // falseNaN == NaN // falseNaN != NaN // true[] != [] // true[] == ![] // true0 == [] // true1 == [] // false1 == [1] // true0 + [] // &#x27;0&#x27;0 + &#123;&#125; // &quot;0[object Object]&quot;&#123;&#125; + [] === 0 // true &#123;&#125; 被解析为空的 block， + 被解析为正号运算符，结果等于 +[][] + &#123;&#125; === &quot;[object Object]&quot; // true [] 被解析为数组，后续的 + 被解析为加法运算符(&#123;&#125; + []) // &#x27;[object Object] 括号会阻止js将&#123;&#125;识别为block，因此他的运算结果与 []+&#123;&#125; 一致console.log(&#123;&#125; + []) // &#x27;[object Object] 当表达式作为参数传递给函数时，不会被默认为新的blockconsole.log(&#123;&#125; + [] === 0) // false[] + &#123;&#125; === &#123;&#125; + [] // true-0 === 0 // true&#x27;4&#x27; === 4 // falseundefined === null // false in 判断对象是否能够访问到该属性 instanceof 判断一个对象是否是另一个对象的实例 逻辑操作符 ! 非、&amp;&amp; 与、|| 或 ! 对 Boolean 值取反 var flag = truealert(!flag) // falsealert(!0) // truealert(![]) // falsealert(!&#x27;&#x27;) // truealert(!![]) // truealert(!!1) // true &amp;&amp; 如果第一个值转换成 boolean 值之后为 true， 则输出第二个值；如果第一个值转换成 boolean 值之后为 false，则输出第一个值，且第二个值不在执行。（取第一个为 false 的值，如果都为 true ，则输出最后一个值。） var result = true &amp;&amp; 3 // 3var result = 1 &amp;&amp; 3 // 3var result = [] &amp;&amp; &#x27;&#x27; // &#x27;&#x27;var result = false &amp;&amp; 3 // falsevar result = &#x27;&#x27; &amp;&amp; 3 // &#x27;&#x27;var result = null &amp;&amp; true // nullvar num = 0var result = &#x27;&#x27; &amp;&amp; num++ // &#x27;&#x27; num = 0 &amp;&amp; 使用场景 function animate(fn) &#123; fn &amp;&amp; fn()&#125;// 不传参数不会报错animate() || 如果第一个值转换成 boolean 值之后为 true， 则输出第一个值，且第二个值不在执行；如果第一个值转换成 boolean 值之后为 false，则输出第二个值，以此类推，（取第一个为 true 的值，如果都为 false ，则输出最后一个值。） var result = true || 3 // truevar result = 1 || 3 // 1var result = [] || &#x27;&#x27; // []var result = false || 0 // 0var result = &#x27;&#x27; || 3 // 3var result = num || true // truevar num = 0var result = 3 || num++ // 3 num=0 || 使用场景 // 1.兼容性问题：var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop// 2. 函数的参数默认值function sum(n) &#123; n = n || 10 // 给形参 n 设置默认值 console.log(n + 10)&#125;sum() 操作符的优先级从高到低如下： () 优先级最高 一元运算符 ++ – ! 算数运算符 先 * &#x2F; % 后 + - 关系运算符 &gt; &gt;&#x3D; &lt; &lt;&#x3D; 相等运算符 &#x3D;&#x3D; !&#x3D; &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D; 逻辑运算符 先 &amp;&amp; 后 || 赋值运算符 &#x3D; 空值合并操作符 ??注意与或操作符区别 var a = b ?? c// 当且仅当 b 为 null 或 undefined 时，返回 c，否则返回 b// 等价于var aif ( b === null || b === undefined )&#123; a = c&#125; else &#123; a = b&#125; 可选链操作符 ?.在引用为空(nullish) (null 或者 undefined) 的情况下不会引起错误，会短路返回值，返回 undefined // 访问属性、调用方法obj?.customMethod?.()// 数组取值arr?.[5]// 短路计算let obj1 = nulllet a = 0let prop1 = obj1?.[a++] // a =&gt; 0let obj2 = 0let b = 0let prop2 = obj2?.[b++] // b =&gt; 1","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"支持天翼云，百度云等网盘的挂载工具","slug":"其他/云盘/支持天翼云，百度云等网盘的挂载工具","date":"20/03/2021","updated":"20/03/2021","comments":true,"path":"2024.html","link":"","permalink":"https://wqdy.top/2024.html","excerpt":"","text":"CTListCTList是萌咖大佬基于go语言写的天翼云网盘的目录列表程序。CTList支持多用户，支持WebDav，整个站点目录支持在nPlayer、PotPlayer播放器以及ES文件浏览器中使用。 参考链接：https://www.moerats.com/archives/1028/ sharelistsharelist是reruin大佬node.js开发的云盘目录程序，前端页面简洁美观可挂载：Google Drive，One Drive，天翼云，和彩云，蓝奏云，本地文件，WebDAV，SFTP，Teambition，Baidu，Aliyun Drive 项目地址：https://github.com/reruin/sharelist","categories":[],"tags":[{"name":"天翼云","slug":"天翼云","permalink":"https://wqdy.top/tags/%E5%A4%A9%E7%BF%BC%E4%BA%91/"}]},{"title":"使用 github actions 将 github 项目自动同步到 gitee 并自动部署 Gitee Pages","slug":"其他/使用github-action将github项目自动同步到gitee并部署gitee-page","date":"03/03/2021","updated":"03/03/2021","comments":true,"path":"2023.html","link":"","permalink":"https://wqdy.top/2023.html","excerpt":"","text":"由于 github Pages 和 netlify 的访问速度慢，所以现在将博客部署到 Gitee Pages 先使用 wearerequired&#x2F;git-mirror-action 将 GitHub 仓库同步到 Gitee 仓库，再使用 yanglbme&#x2F;gitee-pages-action 实现 Gitee Pages 的自动部署。 配置秘钥 使用命令 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 生成 SSH Key(⚠️注意此处不要设置密码) 在 GitHub 项目的「​Settings -&gt; Secrets」路径下配置好命名为 GITEE_RSA_PRIVATE_KEY 和 GITEE_PASSWORD 的两个密钥。其中：GITEE_RSA_PRIVATE_KEY 存放 id_rsa 私钥；GITEE_PASSWORD 存放 Gitee 帐号的密码 在 GitHub 的个人设置页面「Settings -&gt; SSH and GPG keys」​ 配置 SSH 公钥（即：id_rsa.pub），命名随意 在 Gitee 的个人设置页面「安全设置 -&gt; SSH 公钥」​ 配置 SSH 公钥（即：id_rsa.pub），命名随意 示例name: Sync to Giteeon: push: branches: [main, gh-pages]jobs: build: runs-on: ubuntu-latest steps: - name: Sync to Gitee uses: wearerequired/git-mirror-action@master env: # 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY SSH_PRIVATE_KEY: $&#123;&#123; secrets.GITEE_RSA_PRIVATE_KEY &#125;&#125; with: # 注意替换为你的 GitHub 源仓库地址 source-repo: git@github.com:cuilongjin/hexo-blog.git # 注意替换为你的 Gitee 目标仓库地址 destination-repo: git@gitee.com:cuilongjin/hexo-blog.git - name: Build Gitee Pages uses: yanglbme/gitee-pages-action@main with: # 注意替换为你的 Gitee 用户名 gitee-username: cuilongjin # 注意在 Settings-&gt;Secrets 配置 GITEE_PASSWORD gitee-password: $&#123;&#123; secrets.GITEE_PASSWORD &#125;&#125; # 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错 gitee-repo: cuilongjin/hexo-blog # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在） branch: gh-pages","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"github actions","slug":"github-actions","permalink":"https://wqdy.top/tags/github-actions/"},{"name":"github pages","slug":"github-pages","permalink":"https://wqdy.top/tags/github-pages/"},{"name":"gitee pages","slug":"gitee-pages","permalink":"https://wqdy.top/tags/gitee-pages/"}]},{"title":"苹果手机越狱相关资源","slug":"其他/苹果手机越狱相关","date":"26/02/2021","updated":"26/02/2021","comments":true,"path":"2022.html","link":"","permalink":"https://wqdy.top/2022.html","excerpt":"","text":"越狱工具checkra1n iPhone 5s -iPhone X, iOS 12.0 and upunc0ver iOS 11.0 - 13.5 软件源Ai-小苹果：http://apt.cydiabc.top雷锋源：http://apt.abcydia.comreprovision 作者源：https://repo.incendo.wsFlex3官方源：http://getdelta.coFilza官方源：http://tigisoftware.com/cydiaAudioRecorder XS 通话录音官方源：http://limneos.net/repoLiberty Lire官方屏蔽越狱源：http://ryleyangus.com/repo多⽶米诺⻣骨牌：http://apt.wxhbts.comAppsync官方源：https://cydia.akemi.aisnowboard官⽅方源：http://sparkdev.me贴吧源：https://apt.cydiaba.cnApp Admin官⽅方源：http://beta.unlimapps.com","categories":[],"tags":[{"name":"越狱","slug":"越狱","permalink":"https://wqdy.top/tags/%E8%B6%8A%E7%8B%B1/"}]},{"title":"Adobe Zii 苹果Mac端Adobe软件通用破解工具","slug":"其他/软件/Adobe-Zii-苹果Mac端Adobe软件通用破解工具","date":"30/01/2021","updated":"30/01/2021","comments":true,"path":"2021.html","link":"","permalink":"https://wqdy.top/2021.html","excerpt":"","text":"软件简介： Adobe Zii 是一个苹果 Ma 端 Adobe 全家桶的通用破解程序，支持 CC 2019，CC 2020，CC 2021。 安装说明： 1. 关闭您的互联网连接2. 安装 Adobe 软件，并点击试用3. 然后关闭所有 Adobe 软件，启动 Adobe Zii 最新版本4. 点击“PATCH或DRG”按钮，Zii Patcher 将扫描并修补 MAC 中已安装的所有可访问的 Adobe 软件程序 版本： Adobe Zii 6.0.6 版本可在 Adobe CC 2021 上运行，完美支持以下版本： Adobe Acrobat DC v20.012.20048 – 20.013.20074Adobe After Effects 2020 v17.5-17.6Adobe Animate 2021 v21.0.0 – 21.0.2Adobe Audition 2020 v13.0.11 – 13.0.13Adobe Bridge 2021 v11.0.1Adobe Character Animator 2020 v3.4Adobe Dimension v3.4.1Adobe Dreamweaver 2021 v21.0.0 – 21.1.0Adobe Illustrator 2021 v25.0.0 – 25.1.0Adobe InCopy 2021 v16.0.0 – 16.0.2Adobe InDesign 2021 v16.0.0 – 16.0.2Adobe Lightroom Classic v10.0 – 10.1.1Adobe Media Encoder 2020 v14.5 – 14.8Adobe Photoshop 2021 v22.0.0 – 22.1.1Adobe Prelude 2020 v9.0.1 – 9.0.3Adobe Premiere Pro 2020 v14.5 – 14.8Adobe Premiere Rush v1.5.34 – 1.5.44Adobe XD v34.0.12 – 36.0.32Adobe Photoshop Elements 2021Adobe Premiere Elements 2021 Adobe Zii 5.3.1 版本可在 Adobe CC 2020 上运行，完美支持以下版本： Adobe Acrobat DC v19.021.20047 – 20.012.20048Adobe Acrobat DC v19.021.20047 – 20.012.20048Adobe After Effects 2020 v17.0 – 17.1.4Adobe Animate 2020 v20.0 – 20.5.1Adobe Audition 2020 v13.0 – 13.0.10Adobe Bridge 2020 v10.0 – 10.1.1Adobe Character Animator 2020 v3.0 – 3.3.1Adobe Dimension v3.0 – 3.4Adobe Dreamweaver 2020 v20.0-20.2Adobe Illustrator 2020 v24.0-24.3Adobe InCopy 2020 v15.0-15.1.2Adobe InDesign 2020 v15.0-15.1.2Adobe Lightroom Classic v9.0 – 9.4Adobe Media Encoder 2020 v14.0 – 14.4Adobe Photoshop 2020 v21.0-21.2.4Adobe Prelude 2020 v9.0 – 9.0.1Adobe Premiere Pro 2020 v14.0-14.4Adobe Premiere Rush v1.2.12 – 1.5.29Adobe XD v24.0 – 33.1.12Adobe Photoshop Elements 2020 – 2020.1（内部版本20200120.m.139570）Adobe Premiere Elements 2020 – 2020.1 Adobe Zii 4.5.0 版本可在 Adobe CC 2019 上运行，完美支持以下版本： 整个Adobe CC 2015 任何版本Adobe CC 2017 任何版本Adobe CC 2018 任何版本Adobe CC 2019 任何版本Adobe Acrobat DC 19.x – 19.021.20049Adobe Illustrator CC 2019 v23.1.1Adobe InCopy CC 2019 v14.0.2Adobe InDesign CC 2019 v14.0.3Adobe Prelude CC 2019 v8.1.1Adobe Premiere Pro CC 2019 v13.1.5Adobe Premiere Rush CC v1.2.8Adobe Photoshop CC 2019 v20.0.7Adobe After Effects CC 2019 v16.1.3Adobe Media Encoder CC 2019 v13.1.5Adobe Lightroom Classic CC 2019 v8.4.1Adobe Lightroom CC 2019 v2.3Adobe Audition CC 2019 v12.1.5Adobe Bridge CC 2019 v9.1.0.338Adobe Dreamweaver CC 2019 v19.2.1Adobe XD CC v23.1.32.2Adobe Character Animator CC 2019 v2.1.1Adobe Animate CC 2019 v19.2.1Acrobat DC v19.010.20099Adobe Dimension CC v2.1Adobe Premiere Rush CC v1.1 下载链接：百度云","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[{"name":"adobe","slug":"adobe","permalink":"https://wqdy.top/tags/adobe/"},{"name":"软件","slug":"软件","permalink":"https://wqdy.top/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"破解","slug":"破解","permalink":"https://wqdy.top/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"JetBrains 系列产品激活工具","slug":"其他/软件/JetBrains系列产品激活工具","date":"09/01/2021","updated":"09/01/2021","comments":true,"path":"2016.html","link":"","permalink":"https://wqdy.top/2016.html","excerpt":"","text":"下载地址： 适用于2020.3.1及以下版本链接：https://pan.baidu.com/s/1VXTHaC2ChvXb6l5YA9iApw提取码：wqdy","categories":[],"tags":[{"name":"JetBrains","slug":"JetBrains","permalink":"https://wqdy.top/tags/JetBrains/"}]},{"title":"VMware Workstation Pro v16.1.0 虚拟机软件及永久许可证","slug":"其他/软件/vmware","date":"07/01/2021","updated":"07/01/2021","comments":true,"path":"2015.html","link":"","permalink":"https://wqdy.top/2015.html","excerpt":"","text":"VMware Workstation 官网下载地址 VMware Workstation Pro 16.1.0 Build 17198959https://download3.vmware.com/software/wkst/file/VMware-workstation-full-16.1.0-17198959.exeVMware Workstation Pro 16.0.0 Build 16894299https://download3.vmware.com/software/wkst/file/VMware-workstation-full-16.0.0-16894299.exeVMware Workstation Pro 15.0.0 Build 10134415https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.0.0-10134415.exeVMware Workstation Pro 14.1.3 Build 9474260https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.3-9474260.exeVMware Workstation Pro 12.5.9 Build 7535481https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.9-7535481.exeVMware Workstation 10.0.7 Build 2844087https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.7-2844087.exe 激活许可证 VMware Workstation Pro 16 激活许可证ZF3R0-FHED2-M80TY-8QYGC-NPKYFYF390-0HF8P-M81RQ-2DXQE-M2UT6ZF71R-DMX85-08DQY-8YMNC-PPHV8VMware Workstation Pro 15 激活许可证UY758-0RXEQ-M81WP-8ZM7Z-Y3HDAVF750-4MX5Q-488DQ-9WZE9-ZY2D6UU54R-FVD91-488PP-7NNGC-ZFAX6YC74H-FGF92-081VZ-R5QNG-P6RY4YC34H-6WWDK-085MQ-JYPNX-NZRA2FG78K-0UZ15-085TQ-TZQXV-XV0CDZA11U-DVY97-M81LP-4MNEZ-X3AW0YU102-44D86-48D2Z-Z4Q5C-MFAWDFC7D0-D1YDL-M8DXZ-CYPZE-P2AY6VMware Workstation Pro 14 激活许可证FF31K-AHZD1-H8ETZ-8WWEZ-WUUVACV7T2-6WY5Q-48EWP-ZXY7X-QGUWDVMware Workstation Pro 12 激活许可证5A02H-AU243-TZJ49-GTC7K-3C61NVF5XA-FNDDJ-085GZ-4NXZ9-N20E6UC5MR-8NE16-H81WY-R7QGV-QG2D8ZG1WH-ATY96-H80QP-X7PEX-Y30V4AA3E0-0VDE1-0893Z-KGZ59-QGAVFZC3TK-63GE6-481JY-WWW5T-Z7ATAVMware Workstation Pro 10 激活许可证1Z0G9-67285-FZG78-ZL3Q2-234JG4C4EK-89KDL-5ZFP9-1LA5P-2A0J0HY086-4T01N-CZ3U0-CV0QM-13DNU 解锁安装 macos Auto-Unlocker 支持 Pro 16：https://github.com/paolo-projects/auto-unlocker/releases 下载完成后，解压 Unlocker.zip 文件放置于 VMware 根目录，并选择以管理员身份运行 Unlocker.exe 文件 可能需要关闭VMware的一切服务，包括正在运行的VMware 下载地址：链接：https://pan.baidu.com/s/1pyTC89kIVjIDAocMAZbP4Q提取码：wqdy unlockerhttps://github.com/DrDonk/unlocker","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[{"name":"vmware","slug":"vmware","permalink":"https://wqdy.top/tags/vmware/"}]},{"title":"优秀的命令行工具","slug":"其他/优秀的命令行工具","date":"27/12/2020","updated":"27/12/2020","comments":true,"path":"2012.html","link":"","permalink":"https://wqdy.top/2012.html","excerpt":"","text":"tldr快速查看命令的使用示例 安装 npm i -g tldr 使用 # 查看git的使用示例tldr git thefuck快速修正命令行手误","categories":[],"tags":[]},{"title":"使用 patch-package 来科学修改 node_modules 里的文件","slug":"前端/前端库/使用patch-package来科学修改node_modules里的文件","date":"15/12/2020","updated":"15/12/2020","comments":true,"path":"2001.html","link":"","permalink":"https://wqdy.top/2001.html","excerpt":"","text":"当我们使用npm包时，需要修改部分源码做自定义功能，但是直接修改node_modules里面的文件，重新安装包后做的修改就没有了。一般常用办法有两个： 将代码下载到本地，修改后手动引入 fork别人的代码到自己仓库，修改后，从自己仓库安装 但是这样做比较麻烦，而且更新不方便。我们可以使用 patch-package 来管理修改 以 hexo-theme-next 为例 修改 node_modules 里面的代码 安装patch-package：npm i patch-package --save-dev 执行命令：npx patch-package hexo-theme-next 第一次使用 patch-package 会在项目根目录生成 patches 文件夹，里面有修改过的文件 diff 记录 当这个包被重新安装后，可以使用如下方式让修改生效 方式一：执行命令：git apply --ignore-whitespace patches/hexo-theme-next+8.0.1.patch 方式二：在 package.json，新增命令 postinstall: &quot;scripts&quot;: &#123;+ &quot;postinstall&quot;: &quot;patch-package&quot;&#125; 执行：npm run postinstall 该命令也会在每次 npm install 时自动执行","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"使用 github 仓库作为图床，并用 jsDelivr 加速","slug":"其他/使用github仓库作为图床，并用jsDelivr加速","date":"09/12/2020","updated":"09/12/2020","comments":true,"path":"2007.html","link":"","permalink":"https://wqdy.top/2007.html","excerpt":"","text":"github+JSDelivr 创建一个仓库来存储需要存放的静态资源 使用JSDelivr加速加载Github资源 形式为 https://cdn.jsdelivr.net/gh/&#123;Github用户名&#125;/&#123;Github仓库名&#125;@&#123;版本名&#125;/&#123;仓库下资源路径&#125; 其中版本名可以是当前仓库的 Release 或分支名 例如 github 链接为 https://github.com/cuilongjin/static/blob/main/test.txt 则使用JSDelivr加速链接为 https://cdn.jsdelivr.net/gh/cuilongjin/static@img/test.txt 使用 picgo 进行图片上传 picgo 一款图片上传的工具，目前支持SM.MS图床，七牛图床，腾讯云COS，阿里云OSS，Imgur，又拍云，GitHub等图床github地址：https://github.com/Molunerfinn/PicGo配置手册：https://picgo.github.io/PicGo-Doc/zh/guide/插件：https://github.com/PicGo/Awesome-PicGo 配置 github图床 仓库名为第一步创建的仓库，分支名随意，我的为 maintoken 获取地址: https://github.com/settings/tokens，点击 Generate new token ,复选框为你这个 token 的权限，勾选 repo 即可存储路径为仓库目录，可以随意自定义域名根据需要设置，这里我们设置为 jsdelivr 加速域名，形式为 https://cdn.jsdelivr.net/gh/&#123;Github用户名&#125;/&#123;Github仓库名&#125;@&#123;版本名&#125; 使用 npm+JSDelivr需要将当前仓库发布为npm包 去 npm 官网注册个账号去,然后 npm loginnpm publish 如果你的包名为 @your-name/your-package 时需要 --access public 参数，原因是当包名以 @your-name 开头时，npm publish 会默认发布为私有包，但是 npm 的私有包需要付费 请注意，如果你之前用过淘宝镜像，那么请先手动切回官方源 npm config set registry https://registry.npmjs.org 发布成功之后，可以通过以下方式访问文件 https://cdn.jsdelivr.net/npm/(yourpackagename)@(version)/(file) 其他一些镜像 unpkg https://www.unpkg.com知乎出品 https://unpkg.zhimg.com/百度 https://code.bdstatic.com/npm/饿了么 https://shadow.elemecdn.com/npm/ 当文件有更新时，需要更新发布 # 删除指定的版本npm unpublish 包名@版本号# 重新发布npm publish 配置 github action 自动发布 name: npm Packageon: push: branches: - mainjobs: publish-npm: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node uses: actions/setup-node@v2.1.2 with: node-version: &#x27;12.x&#x27; - run: npm unpublish @cuilongjin/static@1.0.0 - run: npm publish env: NODE_AUTH_TOKEN: $&#123;&#123;secrets.npm_token&#125;&#125;","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://wqdy.top/tags/github/"},{"name":"图床","slug":"图床","permalink":"https://wqdy.top/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"jsDelivr","slug":"jsDelivr","permalink":"https://wqdy.top/tags/jsDelivr/"}]},{"title":"在vue的template中如何使用scss变量","slug":"前端/vue/在vue的template中如何使用scss变量","date":"06/11/2020","updated":"06/11/2020","comments":true,"path":"2000.html","link":"","permalink":"https://wqdy.top/2000.html","excerpt":"","text":"在 scss 中使用 :export 暴露变量 $color: #009A61;//暴露css:export &#123; color: $color;&#125; 在 script 中引入变量 import variables from &#x27;@/assets/styles/variables.scss&#x27; 在 computed 中缓存暴露变量 computed: &#123; variables() &#123; return variables &#125;&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"Window 10 下终端配置与美化","slug":"其他/win10下终端美化","date":"01/11/2020","updated":"01/11/2020","comments":true,"path":"2017.html","link":"","permalink":"https://wqdy.top/2017.html","excerpt":"","text":"WSL &#x2F; MSYS2 &#x2F; Cygwin &#x2F; PowerShell7 Fluent Terminal &#x2F; Windows Terminal WSL 配置 zshwsl 下 git clone 报错：GnuTLS recv error (-110): The TLS connection was non-properly terminated. 安装 zshapt install -y zsh 安装 oh-my-zshsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;# 如果无法安装，使用下面这种方式sh -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh@master/tools/install.sh)&quot; 配置插件插件列表 https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins zsh-syntax-highlightingzsh-autosuggestionszsh-proxy # 安装 zsh-syntax-highlighting 插件git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting# 安装 zsh-autosuggestions 插件git clone https://github.com/zsh-users/zsh-autosuggestions.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestionsgit clone https://github.com/sukkaw/zsh-proxy.git ~/.oh-my-zsh/custom/plugins/zsh-proxy# 安装 zsh-proxy 插件git clone https://github.com/sukkaw/zsh-proxy.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-proxy 修改 ~&#x2F;.zshrc，在 plugins 中添加 zsh-syntax-highlighting # 编辑 ~/.zshrcvim ~/.zshrc# 在 plugins 后括号里添加安装的插件名字plugins=(git zsh-syntax-highlighting zsh-autosuggestions)# 刷新下配置source ~/.zshrc zsh-proxy 主题主题列表 推荐两款主题 pure主题agnoster PowerShell 7+ 配置 oh-my-posh &amp; posh-githttps://zhuanlan.zhihu.com/p/137595941https://zhuanlan.zhihu.com/p/137251716 安装 Fira Code 字体Fira Code","categories":[],"tags":[{"name":"zsh","slug":"zsh","permalink":"https://wqdy.top/tags/zsh/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://wqdy.top/tags/oh-my-zsh/"},{"name":"Fluent Terminal","slug":"Fluent-Terminal","permalink":"https://wqdy.top/tags/Fluent-Terminal/"},{"name":"Windows Terminal","slug":"Windows-Terminal","permalink":"https://wqdy.top/tags/Windows-Terminal/"},{"name":"PowerShell","slug":"PowerShell","permalink":"https://wqdy.top/tags/PowerShell/"}]},{"title":"百度网盘资源下载工具合集","slug":"其他/云盘/百度网盘资源下载工具","date":"15/09/2020","updated":"15/09/2020","comments":true,"path":"1966.html","link":"","permalink":"https://wqdy.top/1966.html","excerpt":"","text":"整理备份百度网盘资源下载工具，低调使用。 2021.01.30 Kinhdown 可用 2020年9月20日 PD卢本伟修改版3.5版本更新 KinhdownKinhdown电报群电报频道下载地址：蓝奏云在线解析：KD官方 PD卢本伟修改版github官网Telegram群 无言仰慕不起-稳定版PD新城旧梦版https://www.itxcjm.top/76/ 下载地址：蓝奏云 6盘小白羊版github B站MBRjun的网页复刻版https://pan.mbrjun.cn/ 不支持文件夹下载 github 在线解析(已关闭)http://pan.naifei.cc/? PanDownloadPanDownload","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[{"name":"下载","slug":"下载","permalink":"https://wqdy.top/tags/%E4%B8%8B%E8%BD%BD/"},{"name":"百度网盘","slug":"百度网盘","permalink":"https://wqdy.top/tags/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"}]},{"title":"使用wget或者curl下载文件","slug":"运维/使用wget或者curl下载文件","date":"11/08/2020","updated":"11/08/2020","comments":true,"path":"1947.html","link":"","permalink":"https://wqdy.top/1947.html","excerpt":"","text":"下载 github release 文件下载编译好的软件包（需要有编译的包） # wgetwget --no-check-certificate --content-disposition https://github.com/ctripcorp/apollo/releases/download/v1.5.1/apollo-adminservice-1.5.1-github.zip# curlcurl -LJO https://github.com/ctripcorp/apollo/releases/download/v1.5.1/apollo-adminservice-1.5.1-github.zip 下载源码压缩包 wget -q https://github.com/git/git/archive/v${GIT_VERSION}.tar.gzwget -O git-master.zip https://github.com/git/git/archive/${GIT_BRANCH}.zip 下载仓库中的单个文件 点击文件进去，右上角有个raw，点击进去后地址栏就是该文件的下载地址直接 wget 地址 即可下载","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://wqdy.top/c/uncategorized/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wqdy.top/tags/linux/"}]},{"title":"谷歌团队盘使用相关教程合集","slug":"其他/云盘/谷歌团队盘使用相关教程合集","date":"09/08/2020","updated":"09/08/2020","comments":true,"path":"1944.html","link":"","permalink":"https://wqdy.top/1944.html","excerpt":"","text":"获取谷歌团队盘免费团队盘：https://wqdy.top/1207.html GSuite 教育子号购买：https://ip.ci/product/5.html 资源转存开源项目rclone rclone 客户端 gclone 为 Google Drive 操作增加自动切换账户和命令行根目录 id 操作支持 AutoRclone 解决每日 750G 限制 gd-utils Google Drive 百宝箱 支持统计、去重、telegram bot iCopy iCopy Docker 一键启动版 shell-bot gclone 实用脚本合集 转存 自动分类整理 清空回收站 备份同步 搭建教程AutoRclone 配合 Gclone 在 Google Drive 账号之间、谷歌团队盘之间快速拷贝、传输学习资料 iCopy 和 fclone 和 TG-bot 构建 gd 转存保姆教程 使用 VPS 搭建 fclone_shell_bot 文章转存 Telegram 机器人教程 第四代谷歌网盘 Clone 术：Fclone FClone 机器人及安装过程 iCopy——让Google Drive文件转存更加简单 文件解压unzip -O GBK -P $(echo -n 密码 | iconv -f utf-8 -t gbk) file.zip 解压中文编码文件unar -e GBK /gdrive/disk/zidian2/77个WPA密码字典包/\\’’*.rar’’ 在线挂载 GD 网盘https://github.com/reruin/sharelist https://github.com/maple3142/GDIndex https://github.com/Aicirou/goindex-theme-acrou 界面不错、多盘、搜索 https://github.com/alx-xlx/goindex https://github.com/LeeluPradhan/G-Index https://github.com/yanzai/goindex 资源群组https://groups.google.com/forum/#!forum/mailacid 印尼群组 https://groups.google.com/forum/#!forum/tlob_share TLOB 图库群组 https://t.me/newPan 150T 已整理刮削的小姐姐团队盘 https://t.me/gdurl 各种 Google Drive 资源，包括大电影，小电影，电子书，无损音乐等 其他Linux 测试网速 https://github.com/chiakge/Linux-NetSpeed 清空及删除团队回收站垃圾箱文件 rclone delete xxx: --drive-trashed-only --drive-use-trash=false --verbose=3 --fast-list 在线 查看文件数：https://gdurl.viegg.com/api/gdrive/count?fid=1lDa7gqv8e6xGKJdmkk-bV0kt2w_07A5r Colaboratory 脚本运行： https://colab.research.google.com/","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Google Drive","slug":"Google-Drive","permalink":"https://wqdy.top/tags/Google-Drive/"}]},{"title":"微信小程序常用代码段","slug":"前端/微信小程序/微信小程序常用代码段","date":"24/07/2020","updated":"24/07/2020","comments":true,"path":"1931.html","link":"","permalink":"https://wqdy.top/1931.html","excerpt":"","text":"检查小程序更新https://developers.weixin.qq.com/miniprogram/dev/api/base/update/UpdateManager.html 在 app.js 中添加如下代码 // app.jsApp(&#123; onLaunch: function () &#123; this.checkNewVersion() &#125;, checkNewVersion: function () &#123; let self = this // 检查版本更新 // 获取小程序更新机制兼容 if (wx.canIUse(&#x27;getUpdateManager&#x27;)) &#123; const updateManager = wx.getUpdateManager() updateManager.onCheckForUpdate(function (res) &#123; // 请求完新版本信息的回调 console.log(res) if (res.hasUpdate) &#123; updateManager.onUpdateReady(function () &#123; wx.showModal(&#123; title: &#x27;更新提示&#x27;, content: &#x27;新版本已经准备好，是否重启应用？&#x27;, success: function (res) &#123; if (res.confirm) &#123; // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.applyUpdate() &#125; else if (res.cancel) &#123; // 如果需要强制更新，则给出二次弹窗 wx.showModal(&#123; title: &#x27;更新提示&#x27;, content: &#x27;本次更新可能会导致旧版本无法正常访问，请使用新版本&#x27;, showCancel: false, // 不显示取消按钮 success: function (res) &#123; if (res.confirm) &#123; // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.applyUpdate() &#125; else if (res.cancel) &#123; // 重新回到版本更新提示 self.checkNewVersion() &#125; &#125; &#125;) &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123; // 新的版本下载失败 wx.showModal(&#123; title: &#x27;已经有新版本了&#x27;, content: &#x27;新版本已经上线啦~，请您删除当前小程序，重新搜索打开&#x27; &#125;) &#125;) &#125; &#125;) &#125; else &#123; // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示 wx.showModal(&#123; title: &#x27;提示&#x27;, content: &#x27;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&#x27; &#125;) &#125; &#125;&#125;) 微信开发者工具上可以通过「编译模式」下的「下次编译模拟更新」开关来调试","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://wqdy.top/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"解决阿里云服务器无法访问 raw.githubusercontent.com","slug":"运维/解决阿里云服务器无法访问-raw-githubusercontent-com","date":"23/07/2020","updated":"23/07/2020","comments":true,"path":"1912.html","link":"","permalink":"https://wqdy.top/1912.html","excerpt":"","text":"原因是因为dns污染，没法找到正确的ip，可以通过修改host解决 访问这里获取正确的ip地址 打开服务器的 hosts 文件 vim /etc/hosts# 添加这一行内容获取到的ip raw.githubusercontent.com# 或者直接添加下面这一行199.232.68.133 raw.githubusercontent.com 保存退出，ping 一下试试","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"免费申请SSL证书，为网站启用 HTTPS","slug":"运维/免费申请ssl证书，为网站启用-https","date":"22/07/2020","updated":"22/07/2020","comments":true,"path":"1909.html","link":"","permalink":"https://wqdy.top/1909.html","excerpt":"","text":"Let’s Encrypt官方网站：https://letsencrypt.org/ 现提供通配符 SSL 证书，需使用 certbot 或 acme.sh 手动发行 certbotgithub：https://github.com/certbot/certbot 安装 EPEL EPEL (Extra Packages for Enterprise Linux)是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供额外的软件包 yum -y install epel-release 安装 certbot yum -y install certbot 申请 SSL 证书 certbot certonly --standalone -d www.test.org 证书文件在 &#x2F;etc&#x2F;letsencrypt&#x2F; 文件夹下 acme.shacme.sh 实现了 acme 协议, 可以从 letsencrypt 生成免费的证书 github：https://github.com/acmesh-official/acme.sh/wiki/说明 宝塔面板支持一键配置 宝塔SSL,Let&#39;s Encrypt免费证书 freessl提供免费HTTPS证书申请 https://freessl.cn/ FiloSottile&#x2F;mkcerthttps://github.com/FiloSottile/mkcert 生成本地 HTTPS 加密证书（localhost 127.0.0.1） 其他HTTPS 网站检测 https://myssl.com/ 参考文章： https://teddysun.com/527.html","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"ssl","slug":"ssl","permalink":"https://wqdy.top/tags/ssl/"}]},{"title":"微信小程序中使用less","slug":"前端/微信小程序/微信小程序中使用less","date":"14/07/2020","updated":"14/07/2020","comments":true,"path":"1895.html","link":"","permalink":"https://wqdy.top/1895.html","excerpt":"","text":"安装 npm install -g wxss-cli 然后在小程序目录，监听此目录以下所有 css 及 less 文件并实时保存文件后转换为 wxss # 监听文件会自动将此目录下 css,less 文件编译为 wxsswxss ./pages 新建的 less 文件最终不会上传至小程序","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://wqdy.top/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"less","slug":"less","permalink":"https://wqdy.top/tags/less/"}]},{"title":"Linux screen 命令——多重视窗管理程序","slug":"运维/linux-screen-命令","date":"12/07/2020","updated":"12/07/2020","comments":true,"path":"1887.html","link":"","permalink":"https://wqdy.top/1887.html","excerpt":"","text":"Screen 是一个全屏窗口管理器。 安装apt install screen# 或yum install screen 使用screen -S &lt;name&gt; # 新建一个作业名为 name 的窗口，(标注 screen 窗口)screen -ls # 显示目前所有的 screen 作业screen -d &lt;name&gt; # 将指定的 screen 作业离线screen -h &lt;行数&gt; # 指定视窗的缓冲区行数screen -r &lt;name&gt; # 恢复指定的 screen 作业screen -d -r &lt;name&gt; # 离线当前作业并回到 name 这个作业# 当需要运行脚本、执行程序时，在命令前添加 screen 即可ctrl + A + D # 将当前 screen detach 到后台screen -X -S &lt;name&gt; quit # 删除指定 screen 进入一个 screen session 后，可能你开始跑一些程序，这时不能在命令行输入任何东西，可以使用快捷键 ctrl + A + D 将当前 screen detach 到后台 使用问题问题：linux 在进入 screen 模式下之后，发现是无法在终端使用鼠标滚轮进行上下翻页拉动的，无法查看上面的终端输出内容了 解决办法 进入回滚模式（可以操作鼠标滚轮上下翻页）：先按Ctrl+a键，然后释放，然后再按[键即可进入翻页模式。切换回之前模式：Ctrl+c ubuntu 下源码编译安装 screen 最新版下载地址：http://ftp.gnu.org/gnu/screen/ # 下载wget -c https://ftp.gnu.org/gnu/screen/screen-4.8.0.tar.gz# 解压tar -xzvf screen-4.8.0.tar.gzcd screen-4.8.0# 安装依赖apt install gcc g++ make make-guile# 编译mkdir build &amp;&amp; cd build../configure# 安装make &amp;&amp; make install验证一下screen -h 问题： 如果报错：checking whether the C compiler works... no # 安装 g++apt install g++ 如果报错，信息如：configure: error: !!! no tgetent - no screen 需要先安装 ncurses 下载地址 https://ftp.gnu.org/gnu/ncurses # 下载依赖包ncurseswget -c https://ftp.gnu.org/gnu/ncurses/ncurses-6.2.tar.gz# 解压安装tar -xzvf ncurses-6.2.tar.gzcd ncurses-6.2mkdir build &amp;&amp; cd build../configuremake &amp;&amp; sudo make install","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wqdy.top/tags/linux/"},{"name":"screen","slug":"screen","permalink":"https://wqdy.top/tags/screen/"}]},{"title":"Snap2HTML – 生成 html 文件列表","slug":"其他/软件/snap2html-生成-html-文件列表","date":"09/07/2020","updated":"09/07/2020","comments":true,"path":"1857.html","link":"","permalink":"https://wqdy.top/1857.html","excerpt":"","text":"Snap2HTML 可以帮你将硬盘下的文件整理成一个 html 格式的树状视图列表，类似于 Windows 资源管理器，带有文件大小、日期、数量等常用信息，右上角还提供了搜索功能，方便你去整理或查找，或者是向基友们分享一下你的收藏 github地址 https://github.com/rlv-dan/Snap2HTML 官网地址 https://www.rlvision.com/snap2html/about.php 百度云链接: https://pan.baidu.com/s/1XVvgMX4TKTOZSvEay8xvnQ 提取码: pbi3","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[]},{"title":"UsbEAm Hosts Editor [多平台 hosts 修改] V3.50","slug":"其他/usbeam-hosts-editor-多平台-hosts-修改-v3-50","date":"05/07/2020","updated":"05/07/2020","comments":true,"path":"1853.html","link":"","permalink":"https://wqdy.top/1853.html","excerpt":"","text":"UsbEAm Hosts Editor 是一款能够提升 origin、steam、uplay 等游戏平台下载速度的工具，同时也可以有效的解决一些游戏或者平台出现的各种网络错误，帮玩家能够顺利的登录平台，顺利进行游戏。 UsbEAm Hosts Editor 还可以为 github 加速，提高网页浏览的速度和代码下载的速度 使用方法： 点击左下角的游戏手柄（或者点击鼠标右键），弹出菜单 在弹出的菜单上选择要检测的项目。里面包含了多个流行的游戏平台，每个平台还有下载、浏览等子菜单 接着会出现一大堆 IP，先别急着去用，先点击 检测延迟，然后选择延迟最低的地址，点击应用选中即可 也可以点击 编辑Hosts，手工对 Hosts 进行编辑 如果某些安全软件弹出阻止情况，请忽略放过，不然无法修改 软件下载 百度云：https://pan.baidu.com/s/1CYNEbqxkH-8vzdxWDOOE2g 提取码：p1ee","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[{"name":"hosts","slug":"hosts","permalink":"https://wqdy.top/tags/hosts/"}]},{"title":"Scrcpy - 开源免费在电脑显示手机画面并控制手机的工具(投屏/录屏/免Root)","slug":"其他/软件/scrcpy-开源免费在电脑显示手机画面并控制手机的工具","date":"04/07/2020","updated":"04/07/2020","comments":true,"path":"1813.html","link":"","permalink":"https://wqdy.top/1813.html","excerpt":"","text":"Scrcpygithub: https://github.com/Genymobile/scrcpy Scrcpy 可以将安卓手机的画面投屏到电脑桌面显示上并进行操控。简单地说，就是可以让你在电脑上控制手机！它支持鼠标控制、键盘输入、电脑剪切板复制粘贴、拖放文件传输到手机、以及拖放 APK 文件进行安装。跨平台支持 Win、Mac、Linux，可通过 USB 数据线或 WiFi 进行连接 Scrcpy 投屏效果非常理想，画面清晰流畅，基本无明显延迟，可以自定义视频码率，支持自动横屏，操作很灵敏，实用性非常的高 你可以方便地利用 Scrcpy 来测试 APP 应用、玩游戏、高效完成一些需要在手机上进行的复杂工作、更高效地办公；也能更方便地进行 Android 屏幕录像、截屏；甚至还能方便你上班时摸鱼划水。应用场景非常多，无论是开发者还是普通个人用户都相当的实用。如果经常有电脑上操控手机的需求，那么 Scrcpy 可谓是妥妥的神器！ Scrcpy 是一款命令行工具，没有图形界面，无需 ROOT 手机，也不需在手机上安装 APP，只需在系统设置里启用“USB 调试”( adb 调试) 即可 几款 Scrcpy-GUI 工具Scrcpy 本身是个命令行软件，对很多人来说用起来并不是那么方便……。 Scrcpy-GUI Scrcpy-GUI 是一个能专门为 Scrcpy 提供可视化的操作界面的外挂工具 Scrcpy-GUI 也是免费开源的，同时也能跨平台支持 Windows、macOS 和 Linux 等系统 github：https://github.com/Tomotoes/scrcpy-gui 使用文档： https://github.com/Tomotoes/scrcpy-gui/blob/master/README.zh_CN.md Scrcpy-GUI 只是图形界面（它不包含 Scrcpy 本身），你需要先安装好 Scrcpy，之后就能使用 GUI 界面进行连接使用了 Scrcpy_GUI 酷安@晨钟酱 下载链接 百度云：https://pan.baidu.com/s/14f8ffCapvPrU2eMWwBWK0A 提取码：64l0 https://www.coolapk.com/feed/15973938?shareKey=YWE5NWFkMTg1N2Y2NWU1ODFlOWQ~&amp;shareUid=739982&amp;shareFrom=com.coolapk.market_10.0.1 安卓投屏 下载地址 蓝奏云：https://www.lanzous.com/b009vk8ze 密码:gu2t 百度云：https://pan.baidu.com/s/1E41IIgyU1vvERkhxFh0eGg 提取码：zfqd QtScrcpy 开源地址：https://github.com/barry-ran/QtScrcpy","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://wqdy.top/tags/%E5%AE%89%E5%8D%93/"},{"name":"投屏","slug":"投屏","permalink":"https://wqdy.top/tags/%E6%8A%95%E5%B1%8F/"}]},{"title":"WordPress简单实现隐藏外链，外链通过go界面进行跳转","slug":"其他/wordpress/wordpress简单实现隐藏外链，外链通过go界面进行跳转","date":"03/07/2020","updated":"03/07/2020","comments":true,"path":"1833.html","link":"","permalink":"https://wqdy.top/1833.html","excerpt":"","text":"网站外链跳转时通过 go 界面进行对 seo 比较友好，既美观又可以避免权重的流失。 简单的实现 在 wordpress 的根目录下，新建一个 go.php 文件，在 go.php 里面输入以下代码 &lt;?php$t_url = preg_replace(&#x27;/^url=(.*)$/i&#x27;,&#x27;$1&#x27;,$_SERVER[&quot;QUERY_STRING&quot;]);if(!empty($t_url)) &#123; preg_match(&#x27;/(http|https):\\/\\//&#x27;,$t_url,$matches); if($matches)&#123; $url=$t_url; $title=&#x27;页面正在安全跳转中,请稍候&#x27;; &#125; else &#123; preg_match(&#x27;/\\./i&#x27;,$t_url,$matche); if($matche)&#123; $url=&#x27;http://&#x27;.$t_url; $title=&#x27;页面正在安全跳转中,请稍候&#x27;; &#125; else &#123; $url=&#x27;//wqdy.top/&#x27;; $title=&#x27;参数错误，正在返回首页&#x27;; &#125; &#125;&#125; else &#123; $title=&#x27;参数缺失，正在返回首页&#x27;; $url=&#x27;//wqdy.top/&#x27;;&#125;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=&#x27;&lt;?php echo $url;?&gt;&#x27;;&quot;&gt;&lt;title&gt;&lt;?php echo $title;?&gt;&lt;/title&gt;&lt;style&gt;body &#123;background:#000&#125;.loading &#123; -webkit-animation:fadein 2s; -moz-animation:fadein 2s; -o-animation:fadein 2s; animation:fadein 2s&#125;@-moz-keyframes fadein &#123;from &#123;opacity:0&#125;to &#123;opacity:1&#125;&#125;@-webkit-keyframes fadein &#123;from &#123;opacity:0&#125;to &#123;opacity:1&#125;&#125;@-o-keyframes fadein &#123;from &#123;opacity:0&#125;to &#123;opacity:1&#125;&#125;@keyframes fadein &#123;from &#123;opacity:0&#125;to &#123;opacity:1&#125;&#125;.spinner-wrapper &#123; position:absolute; top:0; left:0; z-index:300; height:100%; min-width:100%; min-height:100%; background:#3498db&#125;.spinner-text &#123; position:absolute; top:50%; left:50%; margin-left:-200px; margin-top: 2px; color:#fff; letter-spacing:1px; font-weight:700; font-size:36px; font-family:Arial&#125;.spinner &#123; position:absolute; top:50%; left:50%; display:block; margin-left:-270px; width:1px; height:1px; border:25px solid rgba(100,100,100,0.2); -webkit-border-radius:50px; -moz-border-radius:50px; border-radius:50px; border-left-color:transparent; border-right-color:transparent; -webkit-animation:spin 1.5s infinite; -moz-animation:spin 1.5s infinite; animation:spin 1.5s infinite&#125;@-webkit-keyframes spin &#123;0%,100% &#123;-webkit-transform:rotate(0deg) scale(1)&#125;50% &#123;-webkit-transform:rotate(720deg) scale(0.6)&#125;&#125;@-moz-keyframes spin &#123;0%,100% &#123;-moz-transform:rotate(0deg) scale(1)&#125;50% &#123;-moz-transform:rotate(720deg) scale(0.6)&#125;&#125;@-o-keyframes spin &#123;0%,100% &#123;-o-transform:rotate(0deg) scale(1)&#125;50% &#123;-o-transform:rotate(720deg) scale(0.6)&#125;&#125;@keyframes spin &#123;0%,100% &#123;transform:rotate(0deg) scale(1)&#125;50% &#123;transform:rotate(720deg) scale(0.6)&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;loading&quot;&gt; &lt;div class=&quot;spinner-wrapper&quot;&gt; &lt;span class=&quot;spinner-text&quot;&gt;页面正在安全跳转中,请稍候&lt;/span&gt; &lt;span class=&quot;spinner&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 则外链跳转形式为： &#123;本站地址&#125;/go.php?&#123;外链地址&#125; 给外部链接加上 go 跳转，在主题目录下的 functions.php 中添加如下代码 add_filter(&#x27;the_content&#x27;,&#x27;the_content_nofollow&#x27;,999);function the_content_nofollow($content) &#123; preg_match_all(&#x27;/&lt;a(.*?)href=&quot;(.*?)&quot;(.*?)&gt;/&#x27;,$content,$matches); if($matches)&#123; foreach($matches[2] as $val)&#123; if(strpos($val,&#x27;://&#x27;)!==false &amp;&amp; strpos($val,home_url())===false &amp;&amp; !preg_match(&#x27;/\\.(jpg|jepg|png|ico|bmp|gif|tiff)/i&#x27;,$val))&#123; $content=str_replace(&quot;href=\\&quot;$val\\&quot;&quot;, &quot;href=\\&quot;&quot;.home_url().&quot;/go.php?url=$val\\&quot; &quot;,$content); &#125; &#125; &#125; return $content;&#125;","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/tags/wordpress/"}]},{"title":"pm2 - node 进程管理工具","slug":"后端/pm2-node-进程管理工具","date":"01/07/2020","updated":"01/07/2020","comments":true,"path":"1800.html","link":"","permalink":"https://wqdy.top/1800.html","excerpt":"","text":"安装 $ npm install pm2 -g 使用 $ pm2 list # 显示所有进程状态$ pm2 start &lt;js文件路径&gt;.js # 同 node &lt;js文件路径&gt;.js$ pm2 start &lt;json描述文件路径&gt;.json$ pm2 start &lt;python文件路径&gt;.py --interpreter python$ pm2 start &lt;sh文件路径&gt;.sh --interpreter bash$ pm2 start ./node_modules/&lt;某模块名称&gt;/&lt;模块主文件路径&gt;.js$ pm2 start &lt;某种方式&gt; -- --param_name param_value$ pm2 start npm -- start # 同 npm start$ pm2 start npm -- run &lt;scriptname&gt; # 同 npm run &lt;scriptname&gt;$ pm2 start npm --watch --name &lt;taskname&gt; -- run &lt;scriptname&gt; # --name 指定任务名 --watch监听文件变化$ pm2 start yarn -- start$ pm2 start yarn -- run &lt;scriptname&gt;$ pm2 stop &lt;app_name|namespace|id|&#x27;all&#x27;|json_conf&gt; # 停止进程 all 停止所有进程$ pm2 restart &lt;app_name|namespace|id|&#x27;all&#x27;|json_conf&gt; # 重启进程 all 重启所有进程$ pm2 delete &lt;app_name|namespace|id|&#x27;all&#x27;|json_conf&gt; # 删除进程 all 删除所有进程$ pm2 reload all # 重载所有进程$ pm2 describe &lt;id|app_name&gt; # 进程详情$ pm2 monit # 进程日志、详情# 更新 PM2# Install latest PM2 version$ npm install pm2@latest -g# Save process list, exit old PM2 &amp; restore all processes$ pm2 update","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://wqdy.top/tags/nodejs/"},{"name":"pm2","slug":"pm2","permalink":"https://wqdy.top/tags/pm2/"}]},{"title":"全网视频万能解析工具、视频下载工具 -- youtube-dl，CR TubeGet，Allavsoft","slug":"其他/全网视频解析下载工具 -- youtube-dl，CR TubeGet，Allavsoft","date":"26/06/2020","updated":"26/06/2020","comments":true,"path":"1802.html","link":"","permalink":"https://wqdy.top/1802.html","excerpt":"","text":"youtube-dl – 一款犀利的全网视频下载利器github：https://github.com/ytdl-org/youtube-dl 下载：https://github.com/ytdl-org/youtube-dl/releases CR TubeGet 基于 youtube-dl 封装并做功能扩展的一款视频下载软件CR TubeGet 功能：1、支持 2000+站点视频下载，支持 YouTube、BiliBili 等主流视频站点2、支持下载脚本扩展，加入 youtube-dl 不支持的站点下载3、支持 200+播放列表，甚至搜索引擎(google、bing、baidu、yahoo、yandex、ask)之视频搜索列表，支持自定义视频列表4、支持 YouTube 8k 分辨率，支持 Mp3 等音频下载，支持批量下载5、支持视频 URL、文本文件拖放下载，支持剪切板视频 URL 监测功能7、内置视频页面支持快捷下载8、支持 aria2 下载器加速下载，支持 annie、you-get 下载组件9、支持视频格式无损转换、字幕烧录 下载地址 v0.9.2.4 版起，未注册版本只能下载 99 个视频如果希望继续使用免费版本，请下载 v0.9.2.3 版，该没有任何功能上的限制，有着视频下载的基本功能，若您下载油管及 B 站，相信其功能可以满 软件发布官网：http://www.cr-soft.net/ 百度云：https://pan.baidu.com/s/1E_fGDHhGKn7sWCEt7fMtGQ 提取码：m3fk AllavsoftAllavsoft 视频下载器，是一个流行的快速在线视频下载和转换器，可将下载的视频转换为几乎所有流行的视频和音频格式。作为一款国外的软件，支持非常多的国内视频网站下载，包括但不限于优酷、土豆、爱奇艺等，更多支持网站请点击 这里 进行查看。 破解教程 https://www.bilibili.com/video/av85631611/ 下载地址 百度云：https://pan.baidu.com/s/1VwGCcssxOvn-U4GWFec9KQ 提取码：5r2x 硕鼠下载http://www.flvcd.com/","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[{"name":"下载","slug":"下载","permalink":"https://wqdy.top/tags/%E4%B8%8B%E8%BD%BD/"}]},{"title":"nuxt.js 学习笔记","slug":"前端/nuxt-js-学习笔记","date":"21/06/2020","updated":"21/06/2020","comments":true,"path":"1782.html","link":"","permalink":"https://wqdy.top/1782.html","excerpt":"","text":"nuxtNuxt.js 是一个基于 Vue.js 的通用应用框架。 官网：https://nuxtjs.org/中文：https://zh.nuxtjs.org/ https://www.nuxtjs.cn/ nuxt 渲染流程在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。 asyncData 方法https://zh.nuxtjs.org/api/ 用于在渲染组件之前异步获取数据，在服务端或路由更新之前被调用。在这个方法被调用的时候，第一个参数被设定为当前页面的上下文对象，你可以利用 asyncData 方法来获取数据并返回给当前组件。 注意：由于 asyncData 方法是在组件 初始化 前被调用的，所以在方法内是没有办法通过 this 来引用组件的实例对象。asyncData 只在首屏被执行，其它时候相当于 created 或 mounted 在客户端渲染页面。 fetch 方法在 2.12 版本之前： fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据。警告: 您无法在内部使用 this 获取组件实例，fetch 是在组件初始化之前被调用 在 2.12 版本中，fetch 有大更新，fetch(context)已被弃用，可以在 fetch() 中直接使用 this，参考：https://nuxtjs.org/api/pages-fetch 参考 2：https://juejin.im/post/5ecb813751882543184598fehttps://zh.nuxtjs.org/blog/understanding-how-fetch-works-in-nuxt-2-12/ contexthttps://zh.nuxtjs.org/api/context 服务端上下文对象，可以在 asyncData fetch plugins middlewares modules store/nuxtServerInit 等特殊的 Nuxt 生命周期区域中使用 nuxt 配置配置启动端口以下两者都可以配置启动端口 第一种 nuxt.config.js : module.exports = &#123; server: &#123; port: 8000, host: &#x27;127.0.0.1&#x27; &#125;&#125; 第二种 package.json :&quot;config&quot;: &#123; &quot;nuxt&quot;: &#123; &quot;port&quot;: &quot;8000&quot;, &quot;host&quot;: &quot;127.0.0.1&quot; &#125;&#125;, 引入 element-uinpm i element-ui 修改 nuxt.config.js module.exports = &#123; plugins: [&#x27;@/plugins/element-ui&#x27;], transpile: [/^element-ui/]&#125; 创建 plugins/element-ui.js import Vue from &#x27;vue&#x27;import Element from &#x27;element-ui&#x27;Vue.use(Element) 环境变量https://zh.nuxtjs.org/api/configuration-env package.json &#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;nuxt&quot;, &quot;build:test&quot;: &quot;cross-env BASE_URL=testxxx nuxt build&quot;, &quot;build:production&quot;: &quot;cross-env BASE_URL=productionxxx nuxt build&quot; &#125;&#125; nuxt.config.js module.exports = &#123; env: &#123; baseUrl: process.env.BASE_URL &#125;&#125; 我们可以通过以下两种方式来使用 baseUrl 变量： 通过 process.env.baseUrl通过 context.env.baseUrl 自定义路由配置在 Nuxt.js 中，路由是基于文件结构自动生成，无需配置。自动生成的路由配置可在 .nuxt&#x2F;router.js 中查看。 配置路由以 .html 结尾 nuxt.config.js export default &#123; router: &#123; middleware: &#x27;router&#x27;, extendRoutes(routes, resolve) &#123; routes.push(&#123; name: &#x27;case&#x27;, path: &#x27;/case.html&#x27;, component: resolve(__dirname, &#x27;pages/case/_id.vue&#x27;) &#125;) routes.forEach((element) =&gt; &#123; let path = element.path if (path !== &#x27;/&#x27; &amp;&amp; !path.includes(&#x27;.html&#x27;)) &#123; path = path + &#x27;.html&#x27; element.path = path &#125; &#125;) &#125; &#125;&#125; axios 配置使用 Axios，并配置全局拦截器，处理跨域 安装依赖 npm install @nuxtjs/axios @nuxtjs/proxy --save // nuxt.config.jsmodule.exports = &#123; modules: [&#x27;@nuxtjs/axios&#x27;], // 不需要加入@nuxtjs/proxy axios: &#123; proxy: true, prefix: &#x27;/api&#x27;, // baseURL credentials: true &#125;, proxy: &#123; &#x27;/api/&#x27;: &#123; target: &#x27;http://127.0.0.1:8080&#x27;, // 代理地址 changeOrigin: true, pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125; &#125; &#125;&#125; 组件中使用 &lt;script&gt;export default &#123; asyncData (&#123; app, $axios &#125;) &#123; // app.$axios == $axios console.log(app.$axios) &#125;, created () &#123; console.log(this.$axios) &#125;&#125;&lt;/script&gt; 设置全局拦截器：新建一个&#x2F;plugins&#x2F;axios.js export default function (&#123; $axios &#125;) &#123; const axios = $axios // 基本配置 axios.defaults.timeout = 10000 axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27; // 请求回调 axios.onRequest((config) =&gt; &#123;&#125;) // 返回回调 axios.onResponse((res) =&gt; &#123;&#125;) // 错误回调 axios.onError((error) =&gt; &#123;&#125;)&#125; 然后在 plugins 配置它 plugins: [ &#123; src: &#x27;@/plugins/axios&#x27;, mode: &#x27;client&#x27;, &#125;, 配置 css 预处理器安装依赖 npm i -D less less-loader 无需配置，模板内直接使用 &lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt; token 的设置与存储在前后端分离的项目中，一般都会存放到本地存储中。但 Nuxt.js 不同，由于服务端渲染的特点，部分请求在服务端发起，我们无法获取 localStorage 或 sessionStorage。 可以使用 cookie，并借助 cookie-universal-nuxt 模块（该模块只是帮助我们注入，主要实现依赖 cookie-universal），不管在服务端还是客户端，cookie-universal-nuxt 都为我们提供一致的 api，它内部会帮我们去适配对应的方法。 安装 cookie-universal-nuxt npm run cookie-universal-nuxt --save nuxt.config.js : module.exports = &#123; modules: [&#x27;cookie-universal-nuxt&#x27;]&#125; 访问 $cookies 进行使用： // 服务端：// 获取app.$cookies.get(&#x27;name&#x27;)// 设置app.$cookies.set(&#x27;name&#x27;, &#x27;value&#x27;)// 删除app.$cookies.remove(&#x27;name&#x27;)// 客户端：// 获取this.$cookies.get(&#x27;name&#x27;)// 设置this.$cookies.set(&#x27;name&#x27;, &#x27;value&#x27;)// 删除this.$cookies.remove(&#x27;name&#x27;) 之后需要改造下 axios，让它在请求时带上验证信息： &#x2F;plugins&#x2F;axios.js : export default function (&#123; app: &#123; $axios, $cookies &#125; &#125;) &#123; $axios.interceptors.request.use((config) =&gt; &#123; // 头部带上验证信息 config.headers[&#x27;X-Token&#x27;] = $cookies.get(&#x27;token&#x27;) || &#x27;&#x27; return config &#125;) $axios.interceptors.response.use((response) =&gt; &#123; if (/^[4|5]/.test(response.status)) &#123; return Promise.reject(response.statusText) &#125; return response.data &#125;)&#125; middleware 中间件使用https://zh.nuxtjs.org/api/pages-middleware 全局配置: 这种中间件使用是注入到全局的每个页面中 nuxt.config.js : module.exports = &#123; router: &#123; middleware: [&#x27;auth&#x27;] &#125;&#125; 如果你希望中间件只运行于某个页面，可以配置页面的 middleware 选项： export default &#123; middleware: &#x27;auth&#x27;&#125; 使用 keep-alivehttps://github.com/nuxt/nuxt.js/tree/dev/examples/with-keep-alive layouts&#x2F;default.vue: 直接给 Nuxt 添加 keep-alive 虽然可以实现页面缓存，但是每次页面切换时都会去请求接口 https://juejin.im/post/5cff5f02e51d4510624f97ab 分离 cssnuxt.config.js build: &#123;extractCSS: true, optimization: &#123; splitChunks: &#123; chunks: &#x27;all&#x27;, &#125;, &#125;,&#125; head 配置meta: [ &#123; charset: &#x27;utf-8&#x27; &#125;, &#123; name: &#x27;viewport&#x27;, content: &#x27;width=device-width, initial-scale=1&#x27; &#125;, &#123; name: &#x27;author&#x27;, content: &#x27;cuilongjin&#x27; &#125;, &#123; &#x27;http-equiv&#x27;: &#x27;X-UA-Compatible&#x27;, content: &#x27;IE=edge&#x27; &#125;,],link: [ &#123; rel: &#x27;icon&#x27;, type: &#x27;image/x-icon&#x27;, href: &#x27;/logo.png&#x27;, &#125;,],script: [ &#123; src: &#x27;/moveheader.js&#x27;, // 引入 js 路径 &#125;, &#123; innerHTML: &#x27;console.log(&#x27;1&#x27;)&#x27; // 直接引入 js 代码 &#125;,],// 如果使用innerHTML直接引入 js 代码，代码中的引号会被转换为实体字符，导致代码不能正常执行，所以需要配置此项__dangerouslyDisableSanitizers: [&#x27;script&#x27;], 添加百度统计代码在 plugins 目录下新建 baidu.js 文件，内容如下：注意修改xxxxxxxxxxx编号 /* ** 只在生产模式的客户端中使用 */if (process.client &amp;&amp; process.env.NODE_ENV === &#x27;production&#x27;) &#123; // 百度统计脚本 var _hmt = _hmt || [] ;(function () &#123; const hm = document.createElement(&#x27;script&#x27;) hm.src = &#x27;https://hm.baidu.com/hm.js?xxxxxxxxxxx&#x27; const s = document.getElementsByTagName(&#x27;script&#x27;)[0] s.parentNode.insertBefore(hm, s) &#125;)()&#125;export default (&#123; app: &#123; router &#125;, store &#125;) =&gt; &#123; // 每次路由变更时进行pv统计 if (process.client &amp;&amp; process.env.NODE_ENV === &#x27;production&#x27;) &#123; router.afterEach((to, from) =&gt; &#123; var _hmt = _hmt || [] ;(function () &#123; const hm = document.createElement(&#x27;script&#x27;) hm.src = &#x27;https://hm.baidu.com/hm.js?xxxxxxxxxxx&#x27; const s = document.getElementsByTagName(&#x27;script&#x27;)[0] s.parentNode.insertBefore(hm, s) &#125;)() &#125;) &#125;&#125; 在 nuxt-config.js 中添加 plugins: [ &#123; src: &#x27;~plugins/baidu.js&#x27;, mode: &#x27;client&#x27; &#125;, ], 兼容 ie9 ie10其他参考 demo掘金教程 window.__NUXT__ 如何去掉 vue 实例中 通过 this.$nuxt.context 访问 context nuxt generate 动态路由配置 nuxt 配置自定义 webpack loader 处理图片 css","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"nuxt","slug":"nuxt","permalink":"https://wqdy.top/tags/nuxt/"}]},{"title":"rrweb-io - 利用现代浏览器所提供的强大 API 录制并回放任意 Web 界面中的用户操作","slug":"前端/前端库/rrweb-io-利用现代浏览器所提供的强大-api-录制并回放任意-web","date":"18/06/2020","updated":"18/06/2020","comments":true,"path":"1754.html","link":"","permalink":"https://wqdy.top/1754.html","excerpt":"","text":"https://github.com/rrweb-io/rrweb","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"前端工具库","slug":"前端工具库","permalink":"https://wqdy.top/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%BA%93/"}]},{"title":"js 图像处理库","slug":"前端/前端库/js-图像处理库","date":"17/06/2020","updated":"17/06/2020","comments":true,"path":"1730.html","link":"","permalink":"https://wqdy.top/1730.html","excerpt":"","text":"merge-images 合并图像github 地址：https://github.com/lukechilds/merge-images Cropper.js 图片裁剪工具github 地址：https://github.com/fengyuanchen/cropperjs示例地址：https://fengyuanchen.github.io/cropperjs/ grade.js 根据图片的两种主要颜色生成背景渐变github 地址：https://github.com/benhowdle89/grade示例地址：https://benhowdle89.github.io/grade/ Compressor.js 图像压缩github 地址：https://github.com/fengyuanchen/compressorjs示例地址：https://fengyuanchen.github.io/compressorjs/","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"},{"name":"前端工具库","slug":"前端工具库","permalink":"https://wqdy.top/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%BA%93/"}]},{"title":"wordpress 修改文章id","slug":"其他/wordpress/wordpress-修改文章id","date":"16/06/2020","updated":"16/06/2020","comments":true,"path":"1737.html","link":"","permalink":"https://wqdy.top/1737.html","excerpt":"","text":"update wp_posts set id = 430 where id = 404;update wp_term_relationships set object_id = 430 where object_id = 404;update wp_postmeta set post_id = 430 where post_id = 404;update wp_comments set comment_post_ID = 430 where comment_post_ID = 404;","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/tags/wordpress/"}]},{"title":"获取页面向左、向上卷动的距离","slug":"前端/js/js-获取页面向左、向上卷动的距离","date":"28/05/2020","updated":"28/05/2020","comments":true,"path":"1553.html","link":"","permalink":"https://wqdy.top/1553.html","excerpt":"","text":"如果页面指定了 DTD，即指定了 DOCTYPE 时，使用 document.documentElement.scrollTop&#x2F;Left 可以获取到正确的结果 页面没有 DTD，即没指定 DOCTYPE 时，使用 document.body.scrollTop&#x2F;Left 可以获取到正确的结果 获取页面向左、向上卷动的距离的兼容性方式 function getScroll() &#123; return &#123; left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0, top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 &#125;&#125; document.body 与 document.documentElement 区别 document.body 返回 dom 中的 body 节点即 &lt;body&gt;document.documentElement 返回 dom 中的 root 节点即 &lt;html&gt; 设置页面卷曲距离 // X: 向左卷曲距离// Y: 向上卷曲距离window.scrollTo(X, Y)","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"开启 windows 下 Ubuntu 子系统的 SSH 服务","slug":"其他/开启-windows-下-Ubuntu-子系统的-SSH-服务","date":"25/05/2020","updated":"25/05/2020","comments":true,"path":"1503.html","link":"","permalink":"https://wqdy.top/1503.html","excerpt":"","text":"# 卸载openssh-clientsudo apt-get remove openssh-client # 卸载openssh-client并重新安装# 安装ssh服务sudo apt-get install ssh# 理论上包含了 openssh-server 和客户端 openssh-client，如果安装出现异常，请独立安装这两个# 修改配置vi /etc/ssh/sshd_configPort = 22 # 默认是22端口，如果和windows端口冲突或你想换成其他的否则不用动#ListenAddress 0.0.0.0 # 如果需要指定监听的IP则去除最左侧的井号，并配置对应IP，默认即监听PC所有IPPermitRootLogin yes # 如果你需要用 root 直接登录系统则此处改为 yesPasswordAuthentication yes # 将 no 改为 yes 表示使用帐号密码方式登录# 设置密码passwd root# 启动 ssh 服务service ssh start# sudo /etc/init.d/ssh start# 查看 ssh 状态service ssh status 局域网内的其他终端无法连接: 不要忘了，还要配置防火墙开启端口才能被其他 PC 访问","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://wqdy.top/tags/ssh/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://wqdy.top/tags/ubuntu/"},{"name":"win10","slug":"win10","permalink":"https://wqdy.top/tags/win10/"}]},{"title":"AutoRclone 配合 Gclone 在 Google Drive 账号之间、谷歌团队盘之间快速拷贝、传输学习资料","slug":"其他/云盘/AutoRclone配合Gclone在GoogleDrive账号之间、谷歌团队盘之间快速拷贝、传输学习资料","date":"23/05/2020","updated":"23/05/2020","comments":true,"path":"1472.html","link":"","permalink":"https://wqdy.top/1472.html","excerpt":"","text":"将实现的功能从本地服务器传输到 Google Team Drive从他人分享的链接拷贝到 Google Team Drive从一个 Google Team Drive 传输到另一个 Google Team Drive以上都不受 750G 流量限制 如果没有团队盘，可以参考这里自助申请 本文以 ubuntu 为例，当然直接在本地 Windows 上也是可以的 安装 Python3apt-get updateapt-get install git python3 python3-pip -y 若出现如下问题 Command “python setup.py egg_info” failed with error code 1 in &#x2F;tmp&#x2F;pip-build-bx50pf21&#x2F;progress&#x2F;You are using pip version 8.1.1, however version 20.1.1 is available.You should consider upgrading via the ‘pip install –upgrade pip’ command. 解决：更新 pip3 pip3 install --upgrade pip 安装 AutoRclonegit clone https://github.com/xyou365/AutoRclone &amp;&amp; cd AutoRclone &amp;&amp; pip3 install -r requirements.txt 生成 Service Accounts打开链接：https://developers.google.com/drive/api/v3/quickstart/python 登陆 google 账号，点击 Enable the Drive API，在弹出的页面中勾选 yes ，点击 NEXT， 稍等片刻，继续点击 CREATE，出现如下页面表示成功 点击 DOWNLOAD CLIENT CONFIGUTATION 按钮，下载 credentials.json 文件，然后将下载的 credentials.json 放到 AutoRclone 目录下 如果你用的是 Xshell 可以使用 rz 来上传文件 apt install lrzsz -yrz # 回车会打开窗口，选择文件上传即可rz 文件 # 下载文件 之后分三种情况 1、之前没有创建过项目 直接运行： python3 gen_sa_accounts.py --quick-setup 5 以上命令含义：创建 6 个项目（项目0到项目5），开启相关的服务，创建 600 个 service accounts，将 600 个 service accounts 的授权文件下载到 accounts 文件夹下面 2、已有 N 个项目，需要创建新的 python3 gen_sa_accounts.py --quick-setup 2 --new-only 以上命令含义：额外创建 2 个项目（项目 N+1 到项目 N+2），开启相关的服务，创建 200 个 service accounts（2 个项目，每个项目 100 个），将 200 个 service accounts 的授权文件下载到 accounts 文件夹下面 3、使用已有项目，不创建新的 python3 gen_sa_accounts.py --quick-setup -1 注意以上命令会覆盖掉已有的 service accounts 我这里是第一种情况，运行 python3 gen_sa_accounts.py --quick-setup 1，创建两个项目 出现如下报错 /usr/local/lib/python3.5/dist-packages/requests/__init__.py:91: RequestsDependencyWarning: urllib3 (1.13.1) or chardet (3.0.4) doesn&#39;t match a supported version! 解决方法，安装 requests 模块 sudo pip3 install requests 出现如下图 打开链接，并登陆你的 Google 账号（提示不安全，不用管，一路允许） 得到授权代码 复制生成的 code 到终端，回车 如上图所示，显示Press Enter to retry, 原因是谷歌账号未开启 Service Usage API，复制提供的链接地址，到浏览器打开，开启 Service Usage API 服务 启用成功后回车，等待完成 接着，你就会发现你的 AutoRclone 文件下面的 accounts 文件夹下会有很多的 json 文件。 将 service accounts 加入 Google Groups 可以直接将 service accounts 加入到Team Drivepython3 add_to_team_drive.py -d SharedTeamDriveSrcID为了便于管理 service accounts，我们创建 Google Group，将 Google Group 邮箱添加到 Team Drive 我们这一步需要将刚刚生成的数以百计的 Service Accounts 添加到 Google Group 中 创建 Google Group打开链接：https://groups.google.com/ ，创建群组： 批量提取 Service Accounts 如果是 GSuite Admin 账号，可以使用如下方式直接添加进群组 将生成的json文件保存到 credentials 文件夹中 在管理控制台中为您的组织创建组。创建群组后，您将拥有一个例如的地址&#115;&#97;&#x40;&#x79;&#111;&#x75;&#x72;&#100;&#111;&#x6d;&#97;&#x69;&#x6e;&#46;&#99;&#111;&#109; 运行 python3 add_to_google_group.py -g sa@yourdomain.com 对于普通账号，生成 Service Accounts 后，直接运行以下命令： cat ~/AutoRclone/accounts/*.json | grep &quot;client_email&quot; | awk &#x27;&#123;print $2&#125;&#x27;| tr -d &#x27;,&quot;&#x27; | sed &#x27;N;N;N;N;N;N;N;N;N;/^$/d;G&#x27; &gt; ~/email.txt 运行后，会自动提取 Service Accounts 邮箱账户，并保存到 ~&#x2F;email.txt 文件中，同时还很贴心地每 10 个邮箱账户就隔开一行，方便复制。 添加到 Google Group将 email.txt 文件下载到本地 回到 Group 页面，右上角 管理成员： 左侧 直接添加成员，将 Service Accounts 邮箱复制粘贴 10 个，点击 添加：(注意每次只能添加 10 个，每 24 小时只能添加 100 个) 重复以上步骤，将 100 个邮箱添加进去 将 Google Group 邮箱添加到 Team Drive点击关于，找到群组邮箱： 复制下来，添加到 Google Team Drive 成员中 添加完成后，基本就完成所有设置了 如何使用首先将 service accounts 加入到目标 Team Drive cd ~/AutoRclone# 将以下 SharedTeamDriveDstID 替换为你团队盘 IDpython3 add_to_team_drive.py -d SharedTeamDriveDstID 查看团队盘 ID： 打开你的团队盘，查看浏览器上的链接，比如： https://drive.google.com/drive/u/2/folders/0AICYh4X7BkjVUk9PVA 以上链接中，0AICYh4X7BkjVUk9PVA 就是 ID 回车后，再次回车： 直接使用先安装 rclone rclone 安装教程可以参考 https://wqdy.top/1243.html Linux 环境 curl https://rclone.org/install.sh | sudo bash Windows 环境 直接去 rclone 官网下载 rclone，然后最好将 rclone.exe 所在目录加入系统环境变量 如若将共享链接（https://drive.google.com/drive/u/2/folders/10zOvIf8yBmIuZgBfC3rcDKWHIlODZjXF）里的文件保存到自己的 Team Drive 中的 myfolder 文件夹中 则命令为 python3 rclone_sa_magic.py -s 10zOvIf8yBmIuZgBfC3rcDKWHIlODZjXF -d 0AICYh4X7BkjVUk9PVA -dp myfolder -b 1 -e 600 详细的使用命令可以看这里：https://github.com/xyou365/AutoRclone#step-5-start-your-task 配合 Gclone 使用gclone 其实就是 rclone 的加强版，为 Google Drive 操作增加自动切换账户和命令行根目录 id 操作支持，其他功能与原版 rclone 相同 安装 gclonebash &lt;(wget -qO- https://git.io/gclone.sh) 你可以选择将 gclone 重命名为 rclone，方便使用：cp &#x2F;usr&#x2F;bin&#x2F;gclone &#x2F;usr&#x2F;bin&#x2F;rclone 以下内容都是以没有重命名为例，如果你进行了重命名，将以下命令中出现的 gclone 改为 rclone 配置 gclone首先需要先记下 &#x2F;root&#x2F;AutoRclone&#x2F;accounts&#x2F; 中的其中一个文件： ls /root/AutoRclone/accounts 回车后会显示很多 .json 后缀的文件名，复制其中一个文件名，记下文件路径，比如： /root/AutoRclone/accounts/0120894537c1c99c605fe240141af661b44d0c22.json 然后进行 gclone 的配置 gclone 在使用上跟 rclone 是一致的，配置过程也几乎一样，可以参考 https://rclone.org/drive/ 运行以下命令进行配置： gclone config 配置过程中，需要注意的是，当出现 service_account_file 选项时，填入以上记下的 .json 文件 当出现 service_account_file_path 时，填入 &#x2F;root&#x2F;AutoRclone&#x2F;accounts&#x2F; 记住配置的 name：gdrive 之后就配置完成了 使用 gclone 复制文件作者 Github 提供的文档：https://github.com/donwa/gclone/blob/master/README_zh.md 复制共享链接文件到团队盘 gclone copy gdrive:&#123;目录id&#125; gdrive:&#123;目录id&#125; --drive-server-side-across-configs -v 以上命令中: gdrive 是你配置 gclone 时设置的 name 目录 id 是共享链接中链接中的最后部分，比如：https://drive.google.com/drive/u/2/folders/1gVAP22Ug5fz0pSe4THZV10078UbNaTob，1gVAP22Ug5fz0pSe4THZV10078UbNaTob 就是目录 id –drive-server-side-across-configs 用于谷歌盘之间传输时使用，不走服务器流量，传输速度也更快 -v 用于查看传输过程的 ERROR，NOTICE 和 INFO 消息 日志级别-q - 仅生成 ERROR 消息。-v - 生成 ERROR，NOTICE 和 INFO 消息，推荐此项。-vv - 生成 ERROR，NOTICE，INFO和 DEBUG 消息。–log-level LEVEL - 标志控制日志级别。 输出日志到文件使用 –log-file&#x3D;FILE 将 Error，Info 和 Debug 消息以及标准错误重定向到 FILE，这里的 FILE 是你指定的日志文件路径。 命令使用示例： gclone copy gdrive:&#123;18SukoSc0ni0nyU779w82eoo_deLKfbZR&#125; gdrive:&#123;1j4z3UH1thdNB8dOhTUgb0uRHxQaDYL1T&#125; --drive-server-side-across-configs -v 目标位置除了使用 id 外，也可以直接使用目录，比如： gclone copy gdrive:&#123;18SukoSc0ni0nyU779w82eoo_deLKfbZR&#125; gdrive:movie/电影合集 --drive-server-side-across-configs -v 传输本地文件到团队盘 gclone copy /root/Downloads/xxx gdrive:movie/电影合集 -v 常见报错 报错 Failed to copy: failed to make directory: googleapi: Error 404: File not found: 1n-Ya6sagIrGskenJIzWcmKE1ATjxeqYx., notFound 有可能是源日流量 10T 被榨干了 报错 googleapi: Error 403: The file limit for this shared drive has been exceeded., teamDriveFileLimitExceeded 团队盘有限制 40w 文件&#x2F;文件夹，回收站中的文件也计算在 40w 之内，可以新增团队盘，或删除小文件并删除回收站 谷歌云端硬盘 API 不公开清空回收站的方法，但它有一个删除方法可以永久删除文件，而不经过回收站 https://developers.google.com/drive/v2/reference/files/delete","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Google Drive","slug":"Google-Drive","permalink":"https://wqdy.top/tags/Google-Drive/"},{"name":"AutoRclone","slug":"AutoRclone","permalink":"https://wqdy.top/tags/AutoRclone/"},{"name":"Gclone","slug":"Gclone","permalink":"https://wqdy.top/tags/Gclone/"}]},{"title":"用 tMM 刮削影片信息，让 KODI、Jellyfin、PLEX、使用本地媒体电影墙！","slug":"其他/用-tmm-刮削影片信息，让-kodi、jellyfin、plex、使用本地媒体电","date":"20/05/2020","updated":"20/05/2020","comments":true,"path":"1469.html","link":"","permalink":"https://wqdy.top/1469.html","excerpt":"","text":"当使用 pt 或者各种 bt 网站，下载了很多电影以后，使用 NAS 上的 plex 或者 jellyfin 刮削不出来海报怎么办？ 而今天就将推荐大家使用这款 tinyMediaManager 软件，该软件功能非常强大，可以刮削电影、电影系列、电视剧等，还可以重建nfo文件和批量重名文件、文件夹。支持Win&#x2F;Mac&#x2F;Linux。通过他自动匹配家里的电影资源库，让自己的，不论 KODI，还是 jellyfin，还是 emby、plex 都能用上完美的电影墙！ windows 下使用下载和安装 tinyMediaManager下载地址 https://www.tinymediamanager.org/download/ 如果提示需要 java 环境，下载安装即可 使用打开软件 当提示设置影片档案文件夹时，可以先不添加，直接下一步 当提示元数据刮削的时候，选择 themoviedb.org，不管是电影和电视剧都选他即可 打开设置，添加电影和电视剧目录，其他默认 设置好了以后，点击更新 全选已添加的影片信息，点击右键，搜索并刮削所选电影 - 自动匹配：会自动下载封面和影片信息 其中有可能遇到需要您手动搜索的影片，手动搜索一下中文名字即可 当影片完全搜索不出来的时候，也可以到豆瓣电影里面搜索一下这个影片，记住它的 imdb 链接的后面一串数字，比如：tt7286456 直接搜索这个序列号，也是可以获取影片资料的 电视剧的搜索方式和电影的搜索方式是一模一样的，而且电视剧会将每一集都进行信息整理和分类 全部更新完毕后，可以看到影片的文件夹里观看，下载了 nfo 影片信息，海报封面图，logo 等 linux 下使用使用docker安装 https://hub.docker.com/r/romancin/tinymediamanager docker pull romancin/tinymediamanagerdocker run -d --name=tinymediamanager \\-v /share/Container/tinymediamanager/config:/config \\-v /home/gdrive:/media \\-e GROUP_ID=0 -e USER_ID=0 -e TZ=Europe/Madrid \\-p 5800:5800 \\-p 5900:5900 \\romancin/tinymediamanager:latest 浏览以 http://your-host-ip:5800 即可访问 TinyMediaManager GUI 解决中文无法正常显示的问题 添加 ENABLE_CJK_FONT&#x3D;1 环境变量 docker run -d --name=tinymediamanager \\-v /share/Container/tinymediamanager/config:/config \\-v /home/gdrive:/media \\-e GROUP_ID=0 -e USER_ID=0 -e TZ=Europe/Madrid -e ENABLE_CJK_FONT=1 \\-p 5800:5800 \\-p 5900:5900 \\romancin/tinymediamanager:latest 使用 Jellyfin 加载 tinyMediaManager 整理的影片只需要设置 Jellyfin 媒体库，取消掉所有的刮削器即可（一定要取消掉，否则依然会无法显示影片信息，甚至连影片都可能不会出现在影视墙上）","categories":[{"name":"NAS","slug":"NAS","permalink":"https://wqdy.top/c/NAS/"},{"name":"软件","slug":"NAS/software","permalink":"https://wqdy.top/c/NAS/software/"}],"tags":[{"name":"jellyfin","slug":"jellyfin","permalink":"https://wqdy.top/tags/jellyfin/"},{"name":"plex","slug":"plex","permalink":"https://wqdy.top/tags/plex/"}]},{"title":"Ubuntu 下关于 Transmission daemon 的安装与配置","slug":"其他/ubuntu-下关于-transmission-daemon-的安装与配置","date":"19/05/2020","updated":"19/05/2020","comments":true,"path":"1449.html","link":"","permalink":"https://wqdy.top/1449.html","excerpt":"","text":"介绍Transmission 是一个强大的 BitTorrent 开源客户端，官方网站上提供了多个版本可以下载，包括：Mac、GTK+、QT、web 版本。 Transmission 支持 DHT、Magnet Link、uTP 以及 PEX 等特性。尤其是支持 Magnet Link 磁力链接下载十分重要，因为目前网上很多资源都是采用这种方式来分享的，而不是传统的.torrent 文件 在 Ubuntu 的发行版中，Transmission 软件包下面包含多个套件，这些套件的名字很容易搞混淆，它们分别是： transmission-gtk: GTK+界面的 Transmission BT 客户端。 transmission-qt: QT 界面的 Transmission BT 客户端。 transmission-cli: 命令行界面的 Transmission BT 客户端，与 QT、GTK+版本功能一样，是命令行下一个完备的 BT 客户端。 transmission-daemon: 是一个 Transmission 的后台守护程序，本身不具备操作指令，只能通过 Web 客户端或者 transmission-remote-cli 来进行控制。这个程序特别适合安装在服务器上或者嵌入式系统中，以及一些没有显示器的设备上。 transmission-remote-cli: 用来控制 transmission-daemon 的命令套件，本身不具备下载 BT 的功能，只能够配合 daemon 使用。 这些套件不必都安装上，根据我的需求，只需要安装 transmission-daemon 即可 Transmission 的安装打开终端，输入以下命令安装： sudo apt-get updatesudo apt-get install transmission-daemon 安装过程中会顺带把 transmission-cli 也安装上，安装完毕后系统会多出如下一些命令行工具 transmission-cli： 独立的命令行客户端。 transmission-create： 用来建立.torrent 种子文件的命令行工具。 transmission-daemon： 后台守护程序。 transmission-edit： 用来修改.torrent 种子文件的 announce URL。 transmission-remote： 控制 daemon 的程序。 transmission-show：查看.torrent 文件的信息。 安装好后，Transmission-daemon 有一些默认设置(参考链接)。 默认配置目录清单 启动初始化脚本 &#x2F;etc&#x2F;init.d&#x2F;transmission-daemon基本配置文件 &#x2F;etc&#x2F;default&#x2F;transmission-daemon详细配置文件目录 &#x2F;var&#x2F;lib&#x2F;transmsision-daemon&#x2F;info&#x2F;settings.json下载存储目录 &#x2F;var&#x2F;lib&#x2F;transmission-daemon&#x2F;downloads settings.json： 主要的配置文件，设置 daemon 的各项参数，包括 RPC 的用户名密码配置。它实际上是一个符号链接，指向的原始文件是&#x2F;etc&#x2F;transmission-daemon&#x2F;settings.json。里面的参数解释可以参考官网的配置说明。torrents&#x2F;： 用户存放.torrent 种子文件的目录,凡是添加到下载任务的种子，都存放在这里。.torrent 的命名包含,种子文件本身的名字和种子的 SHA1 HASH 值。resume&#x2F;： 存放了.resume 文件，.resume 文件包含了一个种子的信息，例如该文件哪些部分被下载了，下载的数据存储的位置等等。blocklists&#x2F;： 存储被屏蔽的 peer 的地址。dht.dat： 存储 DHT 节点信息。 如果使用另外一个用户来运行 transmission-daemon 的话，会在该用户的目录下，创建一个.config&#x2F;transmission-daemon 的文件夹，配置目录 https://github.com/transmission/transmission/wiki/Configuration-Files 运行# 启动sudo service transmission-daemon start# 停止sudo service transmission-daemon stop Transmission 的配置配置主要是通过修改&#x2F;var&#x2F;lib&#x2F;transmission-daemon&#x2F;info&#x2F;settings.json 文件中的参数来实现的。注意：在编辑 Transmission 的配置文件的时候，需要先关闭 daemon 进程，否则编辑的参数将会被恢复到原来的状态。 配置 RPC最关键的就是要配置 RPC，因为无论是 Web 界面还是 CLI 都是通过 RPC 协议和 daemon 来进行交互的。 打开文件&#x2F;var&#x2F;lib&#x2F;transmission-daemon&#x2F;info&#x2F;settings.json，修改配置参数如下： &#123; &quot;rpc-authentication-required&quot;: true, &quot;rpc-bind-address&quot;: &quot;0.0.0.0&quot;, &quot;rpc-enabled&quot;: true, &quot;rpc-host-whitelist&quot;: &quot;&quot;, // rpc 主机白名单 &quot;rpc-host-whitelist-enabled&quot;: true, //rpc 主机白名单是否开启，若需要任意主机都能访问，建议false &quot;rpc-password&quot;: &quot;123456&quot;, &quot;rpc-port&quot;: 9091, &quot;rpc-url&quot;: &quot;/transmission/&quot;, &quot;rpc-username&quot;: &quot;transmission&quot;, &quot;rpc-whitelist&quot;: &quot;*&quot;, // rpc 主机白名单 &quot;rpc-whitelist-enabled&quot;: true //rpc 主机白名单是否开启，若需要任意主机都能访问，建议false&#125; 我将用户名设置为了 transmission，密码设置为了 123456，whitelist 设置成了”*”，表示任何 IP 都可以通过 RPC 协议访问这个 daemon。需要注意的是 password 设置成了明文。当启动 daemon 之后，daemon 会自动检测密码设置。如果发现密码配置被修改了，daemon 会自动计算修改后的密码的 HASH 值，并用这个 HASH 值替换掉配置文件中的明文密码，这样会更安全。 输入service transmission-daemon start启动程序后，打开 settings.json，会看到 rpc-password 一项被改为了 HASH 值。 &#123; &quot;rpc-password&quot;: &quot;&#123;5f4bd5498bddd9aa2ad8f4d475dcebe23e9d8c8bsorspnUE&quot;&#125; settings.json 里面还有很多参数可以配置，包括上传&#x2F;下载速度的限制、DHT 的配置、端口设置等等，详细的参数解释可以参考官网的配置说明 使用 Web 界面控制 Transmission daemon经过上述配置后，我们就可以通过 Web 界面来访问和控制 Transmission daemon 了。在浏览器里面输入以下地址 http://127.0.0.1:9091/transmission/web/ 浏览器提示你输入刚才配置的用户名和密码，就可以成功登陆 Web 管理界面。界面和桌面版的 GUI 程序有点像，操作起来很方便。 其他问题在本机使用 http://&lt;your.server.ip.addr&gt;:9091/transmission/web/ 访问出现 403:Forbidden 解决修改配置 &#123; &quot;rpc-whitelist&quot;: &quot;127.0.0.1&quot;, &quot;rpc-whitelist-enabled&quot;: true&#125; 将 rpc-whitelist设置为 &quot;*&quot;或将 rpc-whitelist-enabled 设置为 false 在局域网其他机器上使用 http://&lt;your.server.ip.addr&gt;:9091/transmission/web/ 访问时无法访问解决修改配置 &#123; &quot;rpc-host-whitelist&quot;: &quot;&quot;, // rpc 主机白名单 &quot;rpc-host-whitelist-enabled&quot;: true //rpc 主机白名单是否开启，若需要任意主机都能访问，建议false&#125; 将 rpc-host-whitelist设置为 &quot;*&quot;或将 rpc-host-whitelist-enabled 设置为 false 原始界面，没有汉化，也比较简单，可以使用 transmission-web-control 加强 Transmission Web 的操作能力 wget -N https://github.com/ronggang/transmission-web-control/raw/master/release/install-tr-control-cn.shbash install-tr-control-cn.sh 安装完成之后刷新浏览器即可看到新的 ui，如果没有看到可能是浏览器缓存，ctrl + f5 强制刷新一下，如果还是没有看到，可以尝试使用 root 用户运行 或尝试使用 bash install-tr-control-cn.sh /usr/share/transmission &#x2F;usr&#x2F;share&#x2F;transmission 为 Transmission Web 所在目录","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"Jellyfin开启硬件加速","slug":"其他/nas/jellyfin开启硬件加速","date":"16/05/2020","updated":"16/05/2020","comments":true,"path":"1424.html","link":"","permalink":"https://wqdy.top/1424.html","excerpt":"","text":"之前使用群晖 Docker 折腾 Jellyfin，解决了个人音视频收藏的基本需求，但仍有不足，比如说视频播放的时候，CPU 占用会很高（软解吃 CPU），并且会卡顿。 解决方案1、查看系统是否支持显卡硬解转码 使用 SSH 登录群晖系统，运行命令ls /dev/dri，若输出 card0、renderD128，则说明支持显卡硬解。 2、给容器提权 在群群 Docker 容器中找到 Jellyfin 的容器，编辑容器的常规设置，必须勾选使用高权限执行容器。 3、添加环境 在环境中添加两项，分别是 PUID 值填写为 0 ，PGID 值填写为 0 4、启用 VAAPI 硬件加速 Docker 中启动容器，打开 Jellyfin 网页端，依次进入控制台-&gt;播放，在硬件选项中选择 VAAPI 保存设置即可。 使用效果前后对比： 可以看到 CPU 占用明显降低了，播放也不卡顿了，效果还是非常明显的。","categories":[{"name":"NAS","slug":"NAS","permalink":"https://wqdy.top/c/NAS/"}],"tags":[{"name":"jellyfin","slug":"jellyfin","permalink":"https://wqdy.top/tags/jellyfin/"}]},{"title":"终端命令行下使用代理","slug":"其他/终端命令行下使用代理","date":"16/05/2020","updated":"16/05/2020","comments":true,"path":"1404.html","link":"","permalink":"https://wqdy.top/1404.html","excerpt":"","text":"设置注意 一定要加 http://，直接写域名或者 IP 不行 http 和 https 都要设置 cmd，Bash，PowerShell 设置的方式不同 设置的代理只在当前 cmd 窗口下有效，窗口关闭后会失效，新建的窗口也不生效 cmd# set http_proxy=http://IP:PORTset http_proxy=http://127.0.0.1:1080set https_proxy=http://127.0.0.1:1080# 如果有用户名密码需要设置，否则不需要设置set http_proxy_user=userset http_proxy_pass=passset https_proxy_user=userset https_proxy_pass=pass# 恢复set http_proxy=set https_proxy= Bash# Ubuntu 下命令为 exportexport http_proxy=http://127.0.0.1:1080 PowerShell$env:HTTP_PROXY=&quot;http://127.0.0.1:1080&quot; 验证 如果想验证是否成功配置了代理的话，用 ping 命令是不可以的（ping的协议不是http，也不是https，是ICMP协议） curl -vv http://www.google.com，用这条命令来验证，如果返回如下结果表示代理设置成功。 参考链接https://github.com/shadowsocks/shadowsocks-windows/issues/1489https://gist.github.com/famousgarkin/c5138b1e13ac41920d22","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"使用群晖Docker安装Jellyfin家庭影院","slug":"其他/nas/群晖-docker-安装-jellyfin-家庭影院","date":"10/05/2020","updated":"10/05/2020","comments":true,"path":"1365.html","link":"","permalink":"https://wqdy.top/1365.html","excerpt":"","text":"plex 和 emby，这两个软件是不错，但是因为收费，不得不放弃之。 jellyfin开源地址：https://github.com/jellyfin/jellyfin 安装 Docker在群辉套件中心搜索 docker 并安装 安装 jellyfin 打开 docker，点击注册表，搜索 jellyfin，双击第一个进行安装：如果有提示 请选择标签，直接点 latest 选择就好，点击映像，会看到 jellyfin，等待下载完成 进入群晖的文件管理器里面，在 docker 文件夹内新建一个名字叫 jellyfin 的文件夹 打开控制编办，创建共享文件夹，比如 video，用来保存电影 镜像下载好了后，我们进入到映像里，选择下载的 jellyfin，点启动 点击高级设置，然后点击卷，添加文件夹，将 jellyfin 和 video 文件夹都添加上：将video文件夹装载到 /media下，将docker/jellyfin 装载到 /config 点击端口设置，默认是 8096，设置一样的即可 设置完成后，点击应用 -&gt; 点下一步 -&gt; 点击应用 -&gt;点击容器，可以看到 jellyfin 服务已经运行成功了！ docker 下安装 jellyfin 完成 设置 jellyfin 在浏览器中输入这个 nas 的 IP 加上端口号 8096，如IP:8096，就进入到了 jellyfin 设置页面，默认是英文，先设置成中文，点击 Next 然后要求设置一下账号和密码，简单设置一下即可，点击 Next 添加媒体库，暂时先不添加，直接点 Next 跳过 然后选择语言，选择 Chinese，然后下面的国家，选择 people’s Republic of china，点击 Next 默认，点击 Next 点击 Finish 这个时候进入到了登录页面，输入用户密码进入到 jellyfin 里面，因为没有设置媒体库，所以没有内容 设置媒体库 点击左上角 -&gt; 控制台 -&gt; 媒体库 -&gt; 添加媒体库 这里有一些分类，比如电影，音乐，电视剧等，会刮削一些媒体对应的内容，这里先选择了电影，将右上角的显示高级设置打开，依次设置名称、文件夹、语言，文件夹选择/media 这个文件夹里面你存放电影的文件夹（这个&#x2F;media，就是我们之前设置的 video 文件夹） 将媒体图像保存到文件夹打勾，这样会将刮削的封面直接放到你电影的文件夹里 其他默认，点击确定后，就开始自动扫描媒体库了，这个过程，会自动根据电影的文件名在网上进行刮削，制作电影墙 扫描媒体是一个很慢的过程，我们再添加一下电视节目的类型，比如电视剧，连续剧都放到这个目录下，还是老规矩，元数据里的全部打勾，将媒体保存到文件夹里也打勾 到此，基础的 jellyfin 就设置好了，只要返回主页就能看到自己的电影了！ 插件设置 除了媒体库和转码设置，还有一个字幕插件，有些我们下的国外的电影，是没有字幕的，拥有了这个插件，可以进行自动下载匹配的字幕。点击到插件选项，右边往下移，找到 open subtitles 这个， 点击安装版本进行安装 安装后，提示要重启 jellyfin 服务， 我们进入到 docker 里，将这个容器进行重启，重启后，点到插件，就可以看到这个插件了 进入这个插件，填上账号密码就 ok 了，账号没有的话，点击下面的 register 注册一下 其它设置端口设置 多用户，权限控制 其他问题演员照片不显示添加host13.225.69.117 api.themoviedb.org","categories":[{"name":"NAS","slug":"NAS","permalink":"https://wqdy.top/c/NAS/"}],"tags":[{"name":"jellyfin","slug":"jellyfin","permalink":"https://wqdy.top/tags/jellyfin/"},{"name":"docker","slug":"docker","permalink":"https://wqdy.top/tags/docker/"},{"name":"群辉","slug":"群辉","permalink":"https://wqdy.top/tags/%E7%BE%A4%E8%BE%89/"}]},{"title":"解锁网易云音乐客户端变灰歌曲","slug":"其他/解锁网易云音乐客户端变灰歌曲","date":"30/04/2020","updated":"30/04/2020","comments":true,"path":"1339.html","link":"","permalink":"https://wqdy.top/1339.html","excerpt":"","text":"项目地址：https://github.com/nondanee/UnblockNeteaseMusic食用指南：https://github.com/nondanee/UnblockNeteaseMusic/issues/22 特性： 使用 QQ &#x2F; 虾米 &#x2F; 百度 &#x2F; 酷狗 &#x2F; 酷我 &#x2F; 咪咕 &#x2F; JOOX 音源替换变灰歌曲链接 (默认仅启用一、五、六) 为请求增加 X-Real-IP 参数解锁海外限制，支持指定网易云服务器 IP，支持设置上游 HTTP &#x2F; HTTPS 代理 完整的流量代理功能 (HTTP &#x2F; HTTPS)，可直接作为系统代理 (同时支持 PAC) 在 windows 本地使用安装 node.js去 node.js 官网下载安装即可 启动服务git clone https://github.com/nondanee/UnblockNeteaseMusic.git #克隆项目仓库cd UnblockNeteaseMusicnode app.js 或 $ npx @nondanee/unblockneteasemusic 或 $ npm install -g @nondanee/unblockneteasemusic$ unblockneteasemusic 网易云客户端连接使用在网易云客户端内设置代理：右上角设置 &gt; 自定义代理 &gt; 地址 127.0.0.1 端口 8080确定重启客户端后，即可开始使用 PAC 自动代理脚本地址 http://127.0.0.1:8080/proxy.pac 以上是在本地 window 上使用的方法，如果想给手机稳定使用，可以参考如下方式 全端解决方案需要一台服务器 安卓等其它设备安装 pm2 npm -g install pm2 pm2 部署： pm2 start app.js --name UnblockNeteaseMusic -- -s -p 8080 ios 设备ios 配置经验分享：https://github.com/nondanee/UnblockNeteaseMusic/issues/368 ios 需要一个域名，并配置反代 nginx 配置： server &#123; listen 443 ssl http2; server_name your_domain; # 改为你自己的域名 ssl_certificate 1_your_domain_bundle.crt; # 改为自己申请得到的 crt 文件的名称 ssl_certificate_key 2_your_domain.key; # 改为自己申请得到的 key 文件的名称 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://localhost:8080; # 代理到 Unblock 服务地址 &#125;&#125; pm2 部署： pm2 start app.js --name UnblockNeteaseMusic -- -s -p 8080 -e https://unblockneteasemusic.ayyy.club iOS 搭配 Shadowrocket 连接代理 Shadowrocket 右上角加号添加节点 -&gt; 类型选择 HTTP -&gt; 服务器填写你的服务器公网 IP -&gt; 端口填写你启动服务的端口号（默认为 8080） -&gt; 点击配置 -&gt; 点击本地文件 -&gt; default.conf -&gt; 编辑配置 添加三条规则 选项选择你刚刚添加的节点 USER-AGENT: NeteaseMusic*DOMAIN-SUFFIX: 163.comDOMAIN-SUFFIX: 126.net pm2 常用命令pm2 stop UnblockNeteaseMusic # 停止服务pm2 restart UnblockNeteaseMusic # 重启服务pm2 pull UnblockNeteaseMusic # 更新服务到最新代码pm2 show UnblockNeteaseMusic # 查看服务的参数信息pm2 log UnblockNeteaseMusic # 查看服务日志pm2 ls # 查看已部署的服务列表pm2 monit # 监控服务状态pm2 flush # 清理所有日志文件pm2 update # 更新 pm2 状态 一键打卡刷满 300 听歌量https://today.nange.cn/ 使用方法参考 https://www.nange.cn/unlock-netease-music.html","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"网易云音乐","slug":"网易云音乐","permalink":"https://wqdy.top/tags/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"}]},{"title":"苹果应用共享","slug":"其他/苹果应用共享","date":"26/04/2020","updated":"26/04/2020","comments":true,"path":"1334.html","link":"","permalink":"https://wqdy.top/1334.html","excerpt":"","text":"胖森微信公众号 （共享 AppleId（免费））ProcreateGoodNotes5P 站助手ShuQuantumultQuantumult XShadowrocket aneeo.com （AppleId）旧版应用AppleId 租用（收费）应用代购 app.ignition.fun 打火机，广告太多不推荐 （在线安装）越狱应用 野心玩家 app.ambier.cn （在线安装）越狱应用 Uncover checkra1n福利应用 bc 工具 id.cydias.top （在线安装）越狱应用 Uncover checkra1n 有趣工具箱微信小程序 （在线安装）越狱应用 宅哥玩机 （在线安装）越狱应用福利应用","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[]},{"title":"WordPress 博客绑定多个域名，并实现多个域名独立访问","slug":"其他/wordpress/wordpress-博客绑定多个域名，并实现多个域名独立访问","date":"26/04/2020","updated":"26/04/2020","comments":true,"path":"1331.html","link":"","permalink":"https://wqdy.top/1331.html","excerpt":"","text":"WordPress 博客默认是不能实现多个域名独立访问的，即使我们绑定了多个域名，访问时也会自动跳转到安装站点时默认的域名 我们只需修改站点根目录下的 wp-config.php 文件，添加如下代码： define(&#x27;WP_SITEURL&#x27;, &#x27;https://&#x27; . $_SERVER[&#x27;HTTP_HOST&#x27;]);define(&#x27;WP_HOME&#x27;, &#x27;https://&#x27; . $_SERVER[&#x27;HTTP_HOST&#x27;]); 即可","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/tags/wordpress/"},{"name":"域名","slug":"域名","permalink":"https://wqdy.top/tags/%E5%9F%9F%E5%90%8D/"}]},{"title":"magnetW一款开源的磁力链接聚合搜索工具--支持win/mac","slug":"其他/软件/magnetw一款开源的磁力链接聚合搜索工具-支持win-mac","date":"25/04/2020","updated":"25/04/2020","comments":true,"path":"1289.html","link":"","permalink":"https://wqdy.top/1289.html","excerpt":"","text":"开源地址：https://github.com/xiandanin/magnetW下载地址：https://github.com/xiandanin/magnetW/releases 欢迎 star","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[]},{"title":"web 中媒体资源自动播放问题","slug":"前端/web-中媒体资源自动播放问题","date":"23/04/2020","updated":"23/04/2020","comments":true,"path":"1276.html","link":"","permalink":"https://wqdy.top/1276.html","excerpt":"","text":"问题媒体资源 添加 autoplay 在移动端不会生效 通过监听 scroll 事件 手动调用 play 方法会报如下错误：Uncaught (in promise) DOMException: play() failed because the user didn’t interact with the document first. ios 端报如下错误：Uncaught (in promise) NotAllowedError:The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission. 自动播放政策Chrome 浏览器的自动播放政策在 2018 年 4 月更改： 始终允许静音自动播放。 用户已与页面进行了交互（单击，点击等）。 详细政策不一一列举了，访问 https://goo.gl/xX8pDD 查看详情 Web 开发人员的最佳做法重点：永远不要假设视频会播放，并且在视频未实际播放时也不要显示暂停按钮。 您应该始终查看 play 函数返回的 Promise，看它是否被拒绝： var promise = document.querySelector(&#x27;video&#x27;).play()if (promise !== undefined) &#123; promise .then((_) =&gt; &#123; // Autoplay started! &#125;) .catch((error) =&gt; &#123; // Autoplay was prevented. // Show a &quot;Play&quot; button so that user can start playback. &#125;)&#125; 使用静音的自动播放功能，并让他们选择取消静音 &lt;video id=&quot;video&quot; muted autoplay&gt;&lt;/video&gt;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"收集整理一些微软windows和office激活工具","slug":"其他/软件/microsoft-激活脚本","date":"22/04/2020","updated":"22/04/2020","comments":true,"path":"936.html","link":"","permalink":"https://wqdy.top/936.html","excerpt":"","text":"HWIDGEN是一款由国外 Nsane 论坛会员 s1ave77 制作的 Windows 10 数字权利激活工具，可以自动获取 Windows 10 数字许可证 数字许可证（在 Windows 10 版本 1511 中称为数字授权）是 Windows 10 的一种激活方法，该方法不需要输入产品密钥。在同一台电脑上主要硬件（应该是 CPU 和主板）不变化的情况下，重新安装系统时无需再次输入密钥，系统会在自动连接到微软服务器进行激活。 支持的 win10 版本：家庭版（HWID&#x2F;KMS3）家庭单语言版（HWID&#x2F;KMS3）专业版（HWID&#x2F;KMS3）专业教育版（HWID&#x2F;KMS3）专业工作站版（HWID&#x2F;KMS3）教育版（HWID&#x2F;KMS3）企业版（HWID&#x2F;KMS3）企业版 S 2015（HWID）企业版 S 2016（HWID&#x2F;KMS3）企业版 S（KMS19™） 下载地址https://www.aiowares.com/showthread.php?tid=246 百度云：链接：https://pan.baidu.com/s/111rJZHaOFJrpOdOKXW5Vcw 提取码：3o1c W10 数字许可激活 C#版是一款由吾爱破解论坛 angelkyo 编写的 Windows 10 数字权利激活工具，跟 HWIDGen 类似 下载地址https://www.52pojie.cn/thread-742884-1-1.html 百度云：链接：https://pan.baidu.com/s/1OsoR_Zpu_BF7m0Plw8mUEA 提取码：a1ru 离线 KMS 激活工具 HEU KMS Activator v19.6.2 正式版一款简洁高效的 KMS 激活工具，适用于 Windows、Office 及 VL 版本，无需联网即可一键激活，离线全自动激活软件， KMS 服务是微软公司对 Windows 以及 Office 等的批量授权服务，可以利用 KMS 激活局域网中的产品。而这款工具是利用在系统内部搭建 KMS 服务器，因此无论是 Windows 还是 Office 都可轻易进行激活。 功能：Heu KMS 几乎支持所有 Vl 批量授权版本可以通过搭建内置的 KMS 服务器进行手动激活产品支持对 Windows 系统以及 Office 办公软件备份激活信息 下载地址百度云：链接：https://pan.baidu.com/s/1gAGqEHEMjUa4IDx4tYNXag 提取码：vrfc Microsoft 激活脚本（MAS）：一组脚本，用于使用 HWID &#x2F; KMS38 &#x2F;在线 KMS 激活方法激活 Microsoft 产品，重点是开放源代码，较少的防病毒检测和用户友好性。原贴地址（需要登录）：https://www.nsaneforums.com/topic/316668-microsoft-activation-scripts/ 开源地址https://gitlab.com/massgrave/microsoft-activation-scriptshttps://github.com/massgravel/Microsoft-Activation-Scripts 下载地址https://github.com/massgravel/Microsoft-Activation-Scripts/releases 百度云：链接：https://pan.baidu.com/s/1JKEYAfgJj9msfW81bhbKjw 提取码：21di","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://wqdy.top/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"office","slug":"office","permalink":"https://wqdy.top/tags/office/"},{"name":"windows","slug":"windows","permalink":"https://wqdy.top/tags/windows/"},{"name":"激活","slug":"激活","permalink":"https://wqdy.top/tags/%E6%BF%80%E6%B4%BB/"}]},{"title":"google TeamDrive 免费无限容量团队盘申请","slug":"其他/云盘/google-teamdrive-免费无限容量团队盘申请","date":"22/04/2020","updated":"22/04/2020","comments":true,"path":"1207.html","link":"","permalink":"https://wqdy.top/1207.html","excerpt":"","text":"Google Drive 团队盘，不是增加你本身空间，是增加一个团队盘在你名下，你账号是 15G 依然是 15G，但是存在团队盘里的不算你的占用。 申请地址：http://leon.educationhost.cloud/https://td.fastio.me/https://gd.zxd.workers.dev/ All Saints CofE Junior Schoolhttps://teamdrive.xcpx.workers.dev/ swccd.eduhttps://gd.404edu.workers.dev/ 台灣教育部 输入团队盘名称，随便你自己取，建议英文格式。Gmail 邮箱地址建议用自己的小号。弄好这两样后点击提交即可，等提示创建成功就 OK 了。 登陆 Google Drive 后你会发现在 My Drive(我的云端硬盘) 下面多出了一个 Shared drives(共享云端硬盘) 的菜单按钮 无限空间方式： 教育版无限空间 卖给你支持 GApps 的学校的邮箱账号密码，简单直接，没啥好说的，登上去就有了 不给你邮箱，让你提供自己的 Gmail 账号，然后他给你拉进去。详细讲就是他新开一个“share drive”然后把你拉进去，你们俩就共享这个“share drive”的无限空间了。(记得将自己设置成管理员，并把拉你的人从 share drive 中删除) 如果买了邮箱也建议自己按照上面方式 2 那样给自己的 Gmail 分配无限空间，因为买的教育邮箱可能来路不正，可能被封，而分配出去的 share drive 是不受影响的。 从 G Suit 获取的无限空间跟上面的教育网那个类似的，只是是商业的用途，按月交钱，不同档次支持的用户数不同。同样是把你拉进去就可以用无限空间了。这玩意儿人家只要不续费了你就完犊子了。管理员是可以随意查看账号中的内容","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Google Drive","slug":"Google-Drive","permalink":"https://wqdy.top/tags/Google-Drive/"}]},{"title":"GoIndex 部署 CloudFlare Workers 实现无需科学上网访问 Google Drive 文件","slug":"其他/云盘/goindex-部署-cloudflare-workers-实现无需科学上网访问-google-drive-文件","date":"22/04/2020","updated":"22/04/2020","comments":true,"path":"1223.html","link":"","permalink":"https://wqdy.top/1223.html","excerpt":"","text":"04&#x2F;27 更新 解决 workers 无法正常访问 作者删除了 github 仓库， GoIndex 依赖的 js 资源加载失败，导致网页打开是一片空白 解决方法； 首先到 GitHub Fork 一份 goindex，可以直接 fork 我的， 登录 CF，打开 workers，选中项目，找到以下代码，我的是在 21 行，替换成有效的即可（可以是你 fork 的，也可以直接使用我的） &lt;script src=&quot;//cdn.jsdelivr.net/combine/gh/jquery/jquery@3.2/dist/jquery.min.js,gh/donwa/goindex@$&#123;authConfig.version&#125;/themes/$&#123;authConfig.theme&#125;/app.js&quot;&gt;&lt;/script&gt; 替换成 &lt;script src=&quot;//cdn.jsdelivr.net/combine/gh/jquery/jquery@3.2/dist/jquery.min.js,gh/cuilongjin/goindex/themes/$&#123;authConfig.theme&#125;/app.js&quot;&gt;&lt;/script&gt; 原文 利用 GoIndex 程序，以及 CloudFlare，可以将 Google Drive 文件以目录形式（类似 OneIndex 部署 OneDrive 网盘）列出，可直链调用网盘图片、音频、视频文件等，也可以下载，流量走 CloudFlare ，网速由 CloudFlare 决定 项目地址： https://github.com/donwa/goindex demo： https://index.gd.workers.dev/ 安装部署方案 1 1、在本地安装 rclone2、按照 https://rclone.org/drive/ 流程进行授权3、执行 rclone config file 查看 rclone.conf 路径。找到 root_folder_id 和 refresh_token 记录下来4、下载 https://github.com/donwa/goindex 中的 index.js 并填入 root 和 refresh_token5、复制代码 到 CloudFlare 部署 安装部署方案 2 作者不会记录 refresh_token，但为避免纠纷，建议有条件的同学使用方案 1 进行部署1、访问https://install.gd.workers.dev/2、授权认证后，生成部署代码3、复制代码 到 CloudFlare 部署 目录 id：例如 google 网盘链接为https://drive.google.com/drive/folders/1rrDnupW_1qxRnQf-jy_0PN_GqNK8SEk2，则目录 id 为 1rrDnupW_1qxRnQf-jy_0PN_GqNK8SEk2 部署 CloudFlare 绑定自定义域名 https://github.com/donwa/goindex/issues/4","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"安装 rclone 并挂载 Google drive","slug":"其他/云盘/安装-rclone-并挂载-google-drive","date":"22/04/2020","updated":"22/04/2020","comments":true,"path":"1243.html","link":"","permalink":"https://wqdy.top/1243.html","excerpt":"","text":"todo:https://www.cnblogs.com/mysummerday/p/12661263.html#_caption_1./rclone.exe mount secret:/ Q: --cache-dir G:\\OneDrive --vfs-cache-mode writes &amp; Fatal error: failed to mount FUSE fs: mount stopped before calling Init: mount failed: cgofuse: cannot find winfsp 安装 rclone 并挂载 Googledrive安装 rcloneLinux 环境 curl https://rclone.org/install.sh | sudo bash Windows 环境 直接去 rclone 官网下载 rclone，最好将 rclone.exe 所在目录加入系统环境变量 配置 rclone 详细配置参考 https://rclone.org/drive/ rclone config No remotes found - make a new onen) New remotes) Set configuration passwordq) Quit confign/s/q&gt; n # 新建name&gt; gdrive # 名称，后面要用到Type of storage to configure.Enter a string value. Press Enter for the default (&quot;&quot;).Choose a number from below, or type in your own value 1 / 1Fichier \\ &quot;fichier&quot; 2 / Alias for an existing remote \\ &quot;alias&quot; 3 / Amazon Drive \\ &quot;amazon cloud drive&quot; 4 / Amazon S3 Compliant Storage Provider (AWS, Alibaba, Ceph, Digital Ocean, Dreamhost, IBM COS, Minio, etc) \\ &quot;s3&quot; 5 / Backblaze B2 \\ &quot;b2&quot; 6 / Box \\ &quot;box&quot; 7 / Cache a remote \\ &quot;cache&quot; 8 / Citrix Sharefile \\ &quot;sharefile&quot; 9 / Dropbox \\ &quot;dropbox&quot;10 / Encrypt/Decrypt a remote \\ &quot;crypt&quot;11 / FTP Connection \\ &quot;ftp&quot;12 / Google Cloud Storage (this is not Google Drive) \\ &quot;google cloud storage&quot;13 / Google Drive \\ &quot;drive&quot;14 / Google Photos \\ &quot;google photos&quot;15 / Hubic \\ &quot;hubic&quot;16 / In memory object storage system. \\ &quot;memory&quot;17 / JottaCloud \\ &quot;jottacloud&quot;18 / Koofr \\ &quot;koofr&quot;19 / Local Disk \\ &quot;local&quot;20 / Mail.ru Cloud \\ &quot;mailru&quot;21 / Mega \\ &quot;mega&quot;22 / Microsoft Azure Blob Storage \\ &quot;azureblob&quot;23 / Microsoft OneDrive \\ &quot;onedrive&quot;24 / OpenDrive \\ &quot;opendrive&quot;25 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH) \\ &quot;swift&quot;26 / Pcloud \\ &quot;pcloud&quot;27 / Put.io \\ &quot;putio&quot;28 / QingCloud Object Storage \\ &quot;qingstor&quot;29 / SSH/SFTP Connection \\ &quot;sftp&quot;30 / Sugarsync \\ &quot;sugarsync&quot;31 / Transparently chunk/split large files \\ &quot;chunker&quot;32 / Union merges the contents of several remotes \\ &quot;union&quot;33 / Webdav \\ &quot;webdav&quot;34 / Yandex Disk \\ &quot;yandex&quot;35 / http Connection \\ &quot;http&quot;36 / premiumize.me \\ &quot;premiumizeme&quot;Storage&gt; 13 # 选择 13 google drive** See help for drive backend at: https://rclone.org/drive/ **Google Application Client IdSetting your own is recommended.See https://rclone.org/drive/#making-your-own-client-id for how to create your own.If you leave this blank, it will use an internal key which is low performance.Enter a string value. Press Enter for the default (&quot;&quot;).client_id&gt; # 默认Google Application Client SecretSetting your own is recommended.Enter a string value. Press Enter for the default (&quot;&quot;).client_secret&gt; # 默认Scope that rclone should use when requesting access from drive.Enter a string value. Press Enter for the default (&quot;&quot;).Choose a number from below, or type in your own value 1 / Full access all files, excluding Application Data Folder. \\ &quot;drive&quot; 2 / Read-only access to file metadata and file contents. \\ &quot;drive.readonly&quot; / Access to files created by rclone only. 3 | These are visible in the drive website. | File authorization is revoked when the user deauthorizes the app. \\ &quot;drive.file&quot; / Allows read and write access to the Application Data folder. 4 | This is not visible in the drive website. \\ &quot;drive.appfolder&quot; / Allows read-only access to file metadata but 5 | does not allow any access to read or download file content. \\ &quot;drive.metadata.readonly&quot;scope&gt; 1 # 选1，所有权限ID of the root folderLeave blank normally.Fill in to access &quot;Computers&quot; folders (see docs), or for rclone to usea non root folder as its starting point.Note that if this is blank, the first time rclone runs it will fill itin with the ID of the root folder.Enter a string value. Press Enter for the default (&quot;&quot;).root_folder_id&gt; # 默认Service Account Credentials JSON file pathLeave blank normally.Needed only if you want use SA instead of interactive login.Enter a string value. Press Enter for the default (&quot;&quot;).service_account_file&gt; # 默认Edit advanced config? (y/n)y) Yesn) No (default)y/n&gt; # 默认Remote configUse auto config? * Say Y if not sure * Say N if you are working on a remote or headless machiney) Yes (default)n) Noy/n&gt; n # 如果在远程服务器上配置，记得选 n，否则可能无法正常授权If your browser doesn&#x27;t open automatically go to the following link: http://127.0.0.1:53682/authLog in and authorize rclone for accessWaiting for code...Got codeConfigure this as a team drive?y) Yesn) Noy/n&gt; n--------------------[remote]client_id =client_secret =scope = driveroot_folder_id =service_account_file =token = &#123;&quot;access_token&quot;:&quot;XXX&quot;,&quot;token_type&quot;:&quot;Bearer&quot;,&quot;refresh_token&quot;:&quot;XXX&quot;,&quot;expiry&quot;:&quot;2014-03-16T13:57:58.955387075Z&quot;&#125;--------------------y) Yes this is OKe) Edit this remoted) Delete this remotey/e/d&gt; yCurrent remotes:Name Type==== ====gdrive drivee) Edit existing remoten) New remoted) Delete remoter) Rename remotec) Copy remotes) Set configuration passwordq) Quit confige/n/d/r/c/s/q&gt; q 注意：如果在远程 linux 安装，有些配置(涉及 oauth2 的配置)需要使用浏览器授权，可以使用一下方法配置 参考：https://rclone.org/remote_setup/ Remote configUse auto config? * Say Y if not sure * Say N if you are working on a remote or headless machiney) Yesn) Noy/n&gt; n # 这里选择 n，授权链接会变成如下样式，而不再是 http://127.0.0.1Please go to the following link: https://accounts.google.com/o/oauth2/auth?access_type=offline&amp;client_id=202264815644.apps.googleusercontent.com&amp;redirect_uri=urn%3Aietf%3Awg%3Aoauth%3A2.0%3Aoob&amp;response_type=code&amp;scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fdrive&amp;state=J17j_xVz3tAQmV3sMO0xxwLog in and authorize rclone for accessEnter verification code&gt; # 打开链接登陆授权，将code粘贴到这里 挂载mkdir -p /home/gdrive#gdrive 为上面配置的 name#/home/gdrive 为挂载到本地的目录/usr/bin/rclone mount gdrive: /home/gdrive \\ --umask 0000 \\ --default-permissions \\ --allow-non-empty \\ --allow-other \\ --buffer-size 32M \\ --dir-cache-time 12h \\ --vfs-cache-mode \\ writes &amp; 报错Fatal error: failed to mount FUSE fs: fusermount: exec: “fusermount”: executable file not found in $PATH解决：安装 fuseapt-get install fuse -y # 卸载磁盘fusermount -qzu LocalFolder # LocalFolder 为本地挂载目录 查看挂载df -hFilesystem Size Used Avail Use% Mounted ongdrive: 1.0P 0 1.0P 0% /home/gdrive 自动挂载 cat &gt; /etc/systemd/system/rclone.service &lt;&lt;EOF[Unit]Description=RcloneAssertPathIsDirectory=LocalFolderAfter=network-online.target[Service]Type=simpleExecStart=/usr/bin/rclone mount emby: /home/gdrive \\ --umask 0000 \\ --default-permissions \\ --allow-non-empty \\ --allow-other \\ --buffer-size 32M \\ --dir-cache-time 12h \\ --vfs-read-chunk-size 64M \\ --vfs-read-chunk-size-limit 1GExecStop=/bin/fusermount -u LocalFolderRestart=on-abortUser=root[Install]WantedBy=default.targetEOF 启动 systemctl start rclone 开启启动 systemctl enable rclone","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Google Drive","slug":"Google-Drive","permalink":"https://wqdy.top/tags/Google-Drive/"},{"name":"rclone","slug":"rclone","permalink":"https://wqdy.top/tags/rclone/"}]},{"title":"群辉 NAS docker 中配置 v2ray 客户端","slug":"其他/nas/群辉-nas-docker-中配置-v2ray-客户端","date":"19/04/2020","updated":"19/04/2020","comments":true,"path":"1165.html","link":"","permalink":"https://wqdy.top/1165.html","excerpt":"","text":"安装docker插件 + v2ray 映像注意：X86 架构的 CPU 支持 docker，ARM 架构的 CPU 不支持 docker 在群辉套件中心搜索 docker 并安装 打开 docker，搜索 v2ray，双击下载 v2ray/official 即可 选择刚刚下载的映像，点击启动 输入容器名称，点击高级设置 在高级设置中勾选启用自动重新启动和创建桌面快捷方式 在卷中添加文件夹，装载路径为 /etc。需要提前在file station 中创建好 docker/v2ray 文件夹 在网络中勾选 使用与 Docker Host 相同的网络 其他默认，点击应用 点击下一步 将 向导完成后运行此容器 取消选中（因为还没有配置文件）。点击应用 v2ray 客户端配置文件可以用gui客户端中配置好服务器，直接导出客户端配置文件为 config.json，我使用的是 v2rayN 编辑 config.json， 修改 listen 为 0.0.0.0, protocol 为 http，port 随意，也可以不改 在 v2rayN 程序文件夹中 找到 geoip.dat geosite.dat 文件 在刚刚创建的 docker/v2ray文件夹中在创建一个 v2ray 文件夹，将 config.json geoip.dat geosite.dat 三个文件放进去 我的部分 config.json 配置 &#123; &quot;inbounds&quot;: [ &#123; &quot;tag&quot;: &quot;proxy&quot;, &quot;port&quot;: 10808, &quot;listen&quot;: &quot;0.0.0.0&quot;, &quot;protocol&quot;: &quot;http&quot;, &quot;sniffing&quot;: &#123; &quot;enabled&quot;: true, &quot;destOverride&quot;: [ &quot;http&quot;, &quot;tls&quot; ] &#125;, &quot;settings&quot;: &#123; &quot;auth&quot;: &quot;noauth&quot;, &quot;udp&quot;: true, &quot;ip&quot;: null, &quot;address&quot;: null, &quot;clients&quot;: null &#125;, &quot;streamSettings&quot;: null &#125; ]&#125; 最后启动刚刚创建好的 docker 即可 连接到这了只是在群辉中安装了 v2ray 客户端，并配置了服务器，还需要手动连接代理，在群辉中，你需要在 控制面板-网络-常规-代理服务器 中添加代理 如果你的其他设备想要连接也需要相同的方式手动配置代理 在 win10 设置中，如下图所示位置，代理方式只支持 http 代理（这就是为什么上步中要把protocol改为http）地址为你群规的ip，端口就是上步中设置的端口，配置完之后保存即可 手机中同理，在无线中配置代理 如果你想实现只需连接家里无线就可以直接实现科学上网，你需要在路由器中做一些配置，可以参考下文【待整理】","categories":[{"name":"NAS","slug":"NAS","permalink":"https://wqdy.top/c/NAS/"}],"tags":[]},{"title":"前端开发中常用的一些技巧","slug":"前端/前端开发中常用的一些技巧","date":"07/04/2020","updated":"07/04/2020","comments":true,"path":"1136.html","link":"","permalink":"https://wqdy.top/1136.html","excerpt":"","text":"css文字溢出省略号显示/* 强制一行内显示文本 */.single-line &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;/* 强制最多三行显示文本 */.multi-line &#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; /* 强制三行显示 */ overflow: hidden; text-overflow: ellipsis; /* 不是必须 */&#125; 让 div 宽度自适应文字内容.fit-width &#123; width: fit-content;&#125; opacity:0、display:none、visibility:hiddenopacity:0 和 display:none，若父节点元素应用了 opacity:0 和 display:none，无论其子孙元素如何挣扎都不会再出现在大众视野而若父节点元素应用 visibility:hidden，子孙元素应用 visibility:visible，那么其就会毫无意外的显现出来 max-width 优先级高于行内样式加 !important&lt;style&gt; div &#123; max-width: 50px; &#125;&lt;/style&gt;&lt;div style=&quot;width: 100px !important;&quot;&gt;&lt;/div&gt; div 的宽度为 50px 使用 CSS 网格定义 main 和 aside 元素CSS 网格可用于定义布局中的 main 部分和 aside 部分，这是 CSS 网格的绝佳用途。问题是，即使 aside 是空的，它的高度也会和 main 的高度相等。 要修复这个问题，可以让 aside 元素与其父元素的起点对齐，这样它的高度就不会扩展了。 .wrapper &#123; display: grid; grid-template-columns: repeat(12, minmax(0, 1fr)); grid-gap: 20px;&#125;/* align-self 将会让 aside 元素与其父元素的起点对齐。 */aside &#123; grid-column: 1 / 4; grid-row: 1; align-self: start;&#125;main &#123; grid-column: 4 / 13;&#125; 使用 display: inline-block 时奇怪的空隙给两个或两个以上的元素设置 display: inline-block 或者 display: inline ，将会导致它们之间产生一个微小的空隙。代码中的换行和缩进（连续空格）被渲染成了一个空格造成的 通过给父元素设置 font-size: 0 可以简单地解决这个问题。 交互式 HTML 元素的字体不生效给整个文档设置字体的时候，字体并不会应用于诸如 input， button select 和 textarea 这些元素上。默认情况下，它们并不会继承文档字体，因为浏览器给它们应用了系统字体。 要修复这个问题，直接给他们设置字体属性： input,button,select,textarea &#123; font-family: your-font-name;&#125; css 调试将代码添加到浏览器的控制台运行，页面上所有元素的轮廓都会显示出来。 https://gist.github.com/addyosmani/fd3999ea7fce242756b1 ;[].forEach.call($$(&#x27;*&#x27;), function (a) &#123; a.style.outline = &#x27;1px solid #&#x27; + (~~(Math.random() * (1 &lt;&lt; 24))).toString(16)&#125;) 压缩或拉伸图片用 CSS 调整一张图片的大小时，如果纵横比与图片的宽高不一致，则图片会被压缩或拉伸。 解决方法很简单：使用 CSS 的 object-fit。它的功能和给背景图片设置 background-size: cover 类似。 img &#123; width: 100%; height: 100%; object-fit: contain; /* object-fit: cover; */&#125; object-fit 语法参考https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit object-fit 属性由下列的值中的单独一个关键字来指定。 取值contain 保持长宽比，以长边填充cover 保持长宽比，以短边填充，多余的会被裁减掉fill 完全填充，会拉伸none 保持其原有的尺寸scale-down 内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。 滚动条样式::-webkit-scrollbar &#123; width: 8px; height: 8px;&#125;/* -webkit-scrollbar-thumb 滚动条手柄 */::-webkit-scrollbar-thumb &#123;&#125;::-webkit-scrollbar-thumb:hover &#123;&#125;/* -webkit-scrollbar-track 滚动条轨道 */::-webkit-scrollbar-track &#123;&#125;/*滚动条上半边或左半边*/::-webkit-scrollbar-track-piece:start &#123;&#125;/* -webkit-scrollbar-button 滚动条的轨道的两端按钮 *//*滚动条上边或左边按钮*/::-webkit-scrollbar-button:start &#123;&#125;/* -webkit-scrollbar-corne 垂直滚动条和水平滚动条相交的地方 */::-webkit-scrollbar-corner &#123;&#125; 卡券样式 .coupon &#123; width: 300px; height: 100px; position: relative; background: radial-gradient(circle at right bottom, transparent 10px, #ffffff 0) top right / 50% 50% no-repeat, radial-gradient(circle at left bottom, transparent 10px, #ffffff 0) top left / 50% 50% no-repeat, radial-gradient(circle at right top, transparent 10px, #ffffff 0) bottom right / 50% 50% no-repeat, radial-gradient(circle at left top, transparent 10px, #ffffff 0) bottom left / 50% 50% no-repeat; filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.2));&#125; 阴影效果 气泡阴影 .tip &#123; width: 100px; height: 30px; line-height: 30px; border: 1px solid rgb(245, 129, 127); border-radius: 4px; position: relative; background-color: #fff; filter: drop-shadow(0px 2px 4px rgba(245, 129, 127, 0.9));&#125;.tip::before &#123; content: &#x27;&#x27;; width: 0; height: 0; border-style: solid; border-width: 0 10px 10px 10px; border-color: transparent transparent #fff transparent; position: absolute; top: -10px; left: 0; right: 0; margin: auto; z-index: 2;&#125;.tip::after &#123; content: &#x27;&#x27;; width: 0; height: 0; border-style: solid; border-width: 0 10px 10px 10px; border-color: transparent transparent rgb(245, 129, 127) transparent; position: absolute; top: -11px; left: 0; right: 0; margin: auto; z-index: 1;&#125; 三角形阴影 .shadow-triangle &#123; width: 0; height: 0; border-style: solid; border-width: 0 50px 50px 50px; border-color: transparent transparent rgb(245, 129, 127) transparent; filter: drop-shadow(10px 0px 10px rgba(238, 125, 55, 0.5));&#125; 缺圆投影 .circle-square &#123; width: 100px; height: 50px; line-height: 50px; background: radial-gradient(circle at bottom right, transparent 20px, rgb(245, 129, 127) 15px); filter: drop-shadow(2px 2px 2px rgba(238, 132, 66, 0.9));&#125; 1px 边框/* 方式1 */.border:before &#123; content: &#x27; &#x27;; box-sizing: border-box; position: absolute; pointer-events: none; width: 200%; height: 200%; left: 0; top: 0; -webkit-transform: scale(0.5); transform: scale(0.5); transform-origin: 0 0; border: 1px solid #ccc;&#125;/* 方式2 */.border:before &#123; content: &#x27; &#x27;; box-sizing: border-box; position: absolute; pointer-events: none; top: -50%; right: -50%; bottom: -50%; left: -50%; -webkit-transform: scale(0.5); transform: scale(0.5); border: 1px solid #ccc;&#125; 记住密码之后，输入框变色问题谷歌浏览器使用如下方式解决 input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill &#123; -webkit-text-fill-color: #ededed !important; // 自动填充文字颜色 -webkit-box-shadow: 0 0 0px 1000px white inset !important; // 使用内阴影覆盖，这个内阴影一定要大，要不然盖不住&#125; 火狐浏览器无效","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"element-ui 实现向下滚动加载","slug":"前端/element-ui-实现向下滚动加载","date":"07/04/2020","updated":"07/04/2020","comments":true,"path":"1114.html","link":"","permalink":"https://wqdy.top/1114.html","excerpt":"","text":"自定义封装 vue 指令，实现 select 下拉框滚动加载封装 v-loadmore 指令 Vue.directive(&#x27;loadmore&#x27;, &#123; bind(el, binding) &#123; // 获取 element-ui 定义好的 scroll 盒子 const target = el.querySelector(&#x27;.el-select-dropdown .el-select-dropdown__wrap&#x27;) target.addEventListener(&#x27;scroll&#x27;, function() &#123; // scrollHeight 获取元素内容高度(只读) // scrollTop 获取或者设置元素的滚动高度 // clientHeight 读取元素的可见高度(只读) const flag = this.scrollHeight - this.scrollTop &lt;= this.clientHeight if (flag) &#123; binding.value() &#125; &#125;) &#125;&#125;) 使用 &lt;el-select v-loadmore=&quot;loadMore&quot;&gt; &lt;el-option&gt;&lt;/el-option&gt;&lt;/el-select&gt;&lt;script&gt;export default &#123; methods: &#123; loadMore () &#123; if (this.loadingMore == false) &#123; this.loadingMore = true return &#125; if (this.currentPage &gt; this.totlaPage) &#123; return &#125; // 获取数据 this.getData() &#125; &#125;&#125; 使用 vue-infinite-scrollgithub 地址：https://github.com/ElemeFE/vue-infinite-scroll 安装 npm i vue-infinite-scroll 使用 // # main.jsimport infiniteScroll from &#x27;vue-infinite-scroll&#x27;Vue.use(infiniteScroll) &lt;ul v-infinite-scroll=&quot;loadMore&quot; infinite-scroll-disabled=&quot;busy&quot; infinite-scroll-distance=&quot;10&quot;&gt; &lt;li v-for=&quot;(item, index) in moveRecord&quot; :key=&quot;index&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;export default &#123; methods: &#123; loadMore () &#123; this.busy = true; setTimeout(() =&gt; &#123; for (var i = 0, j = 10; i &lt; j; i++) &#123; this.data.push(&#123; name: count++ &#125;); &#125; this.busy = false; &#125;, 1000); &#125; &#125;&#125; element-ui el-scrollbar 组件https://github.com/ElemeFE/element/blob/dev/packages/scrollbar/src/main.js &lt;el-scrollbar style=&quot;height: 200px&quot;&gt; &lt;ul&gt; &lt;li&gt;zs&lt;/li&gt; ... &lt;/ul&gt;&lt;/el-scrollbar&gt; .el-scrollbar__wrap &#123; overflow-x: hidden;&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"微信小程序中相关 api 使用 promise","slug":"前端/微信小程序/微信小程序中相关api使用promise","date":"26/03/2020","updated":"26/03/2020","comments":true,"path":"1065.html","link":"","permalink":"https://wqdy.top/1065.html","excerpt":"","text":"微信小程序的 API 都是回调函数，一不小心就是回调地狱。我们可以用 Promise 封装下 const Promisify = f =&gt; &#123; return (arg = &#123;&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; arg.success = res =&gt; &#123; resolve(res) &#125; arg.fail = res =&gt; &#123; reject(res) &#125; f(arg) &#125;) &#125;&#125;// 使用const Request = Promisify(wx.request)const Login = Promisify(wx.login)Login().then(res =&gt; &#123; if (res.code) &#123; Request(&#123; url: &#x27;text.php&#x27; &#125;).then(res =&gt; &#123; console.log(res) &#125;) &#125;&#125;) 相关问题 wx.request 经 Promise 封装后，如何拿到requestTask","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"在微信小程序中使用 iconfont","slug":"前端/微信小程序/微信小程序中使用-iconfont","date":"25/03/2020","updated":"25/03/2020","comments":true,"path":"1060.html","link":"","permalink":"https://wqdy.top/1060.html","excerpt":"","text":"在 iconfont 选择好需要使用的图标，将代码下载，解压后找到 iconfont.css 修改名称为 iocnfont.wxss 放到项目中即可 使用: Font class 方式 &lt;icon class=&quot;iconfont icon-xxx&quot;&gt;&lt;/icon&gt; 将无效的字体引用删除，只保留 base64 引用 @font-face &#123; font-family: &#x27;iconfont&#x27;; src: url(&#x27;data:application/x-font-woff2;charset=utf-8;base64,...&#x27;) format(&#x27;woff2&#x27;);&#125; Font class 方式不支持使用彩色图标，且 symbol 方式也无法使用，因为 iconfont.js 中含有操作 dom 的代码，会报错 Cannot read property ‘getElementsByTagName’ of undefined 如果想引入彩色图标 https://github.com/iconfont-cli/mini-program-iconfont-cli","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"微信小程序中使用 npm 包","slug":"前端/微信小程序/微信小程序中使用npm包","date":"24/03/2020","updated":"24/03/2020","comments":true,"path":"1041.html","link":"","permalink":"https://wqdy.top/1041.html","excerpt":"","text":"官方文档：https://developers.weixin.qq.com/miniprogram/dev/devtools/npm.html # 初始化npm init# 安装包npm install [package] 打开开发者工具，在本地设置中，勾选使用 npm 模块，安装完之后 点击开发者工具中的菜单栏：工具 –&gt; 构建 npm 会额外生成一个miniprogram_npm 目录 是开发者工具构建 npm 时生成的，可以理解为小程序版的 npm 包。 在需要的地方引入，以 regenerator 为例 // 引入 regenerator-runtimeconst regeneratorRuntime = require(&#x27;regenerator-runtime&#x27;)","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"微信小程序中使用 async/await 语法","slug":"前端/微信小程序/微信小程序中使用async await语法","date":"24/03/2020","updated":"24/03/2020","comments":true,"path":"1018.html","link":"","permalink":"https://wqdy.top/1018.html","excerpt":"","text":"旧文章害死人 研究了半天，突然发现开发工具在 1.02.1904282 以及之后版本中，增加了增强编译已支持 Async&#x2F;Await 语法 2019-05-08更新日志第一条 已下内容已过期(文章刚发布一小时) 微信小程序中原生支持 async await 语法，前提是需要关闭 ES6 转 ES5 后 在开启 ES6 转 ES5 后 async 函数无法使用，可以使用 regenerator 包来解决。新版本的 regenerator 在小程序中无法使用，会报如下错误： 原因是 regenerator 包更新了 Function 函数，具体可参考：https://github.com/facebook/regenerator/pull/369https://github.com/facebook/regenerator/commit/063f14ef7f01bb29830e3f17e9ef151e7a5cb2f3 可以直接使用老版本来解决这个问题，或者修改源码，把 Function 改回去 直接使用老版本 npm install regenerator@0.13.1 如果使用了 npm 模块，之后在需要使用 async 语法的 js 中直接引入即可 const regeneratorRuntime = require(&#x27;regenerator-runtime&#x27;) 如果没有使用 npm 模块，不能直接 require 包名，需要将包提取出来，并引入完整路径 const regeneratorRuntime = require(&#x27;../../libs/regenerator-runtime&#x27;) 参考：微信小程序中使用 npm 包","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"WP-China-Yes 解决 wordpress 插件无法更新问题","slug":"其他/wordpress/wordpress-wp-china-yes-解决-wordpress-插件无法更新问题","date":"18/03/2020","updated":"18/03/2020","comments":true,"path":"957.html","link":"","permalink":"https://wqdy.top/957.html","excerpt":"","text":"去年开始国内无法正常访问 wordpress.org, 一直显示 429 Too Many Requests 错误，所以在我们使用 wordpress 程序的时候会发现无法在线安装主题或者插件，甚至无法更新 WP 版本。 WordPress 官网打不开原因可以参考：https://www.hostloc.com/thread-597678-5-1.html 情况大致是因为： wordpress.org 受到了中国大陆流量的攻击，导致 WordPress 的 CDN 提供商屏蔽了中国大陆的流量，大陆用户访问插件主题商城等服务时报 429 错误。 这里推荐一款插件：WP-China-Yes 此插件将全面替换 WordPress 访问官方服务的链接为高速稳定的中国大陆节点，以此加快站点更新版本、安装升级插件主题的速度，并彻底解决 429 报错问题。 插件是开源的 发布地址：https://www.ibadboy.net/archives/3204.html下载地址：https://github.com/wp-china-yes/wp-china-yes/releases 使用： 下载并安装插件后直接启用即可，无需设置，插件会自动接管所有 WP 访问境外服务器的流量。插件不会更改你的 WordPress 程序，若不想使用大陆加速节点，直接停用插件即可。 常见问题：插件&#x2F;主题更新缓慢甚至超时这种情况在大型包更新的情况下偶尔会出现，原因是第一次访问资源，云存储中还未有相应的镜像，再试一次就会好了。","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[]},{"title":"微信小程序 canvas touchmove 事件实现手写签名并保存到相册","slug":"前端/微信小程序/微信小程序-canvas touchmove事件实现手写签名并保存到相册","date":"18/03/2020","updated":"18/03/2020","comments":true,"path":"969.html","link":"","permalink":"https://wqdy.top/969.html","excerpt":"","text":"2020-03-19真机调试报错 r.Canvas is not a constructor原因：canvas 2d 和 webgl 暂不支持真机调试，请直接使用真机预览，真机预览模式下使用 vConsole 调试 基础代码(使用 Canvas 2D 接口) Component(&#123; data: &#123; ctx: &#x27;&#x27;, image: &#x27;&#x27; &#125;, methods: &#123; onLoad: function(options) &#123;&#125;, onReady: function() &#123; const query = wx.createSelectorQuery() query .select(&#x27;#sign&#x27;) .fields(&#123; node: true, size: true &#125;) .exec(res =&gt; &#123; console.log(res) const canvas = res[0].node const ctx = canvas.getContext(&#x27;2d&#x27;) console.log(ctx) const dpr = wx.getSystemInfoSync().pixelRatio canvas.width = res[0].width * dpr canvas.height = res[0].height * dpr ctx.scale(dpr, dpr) ctx.lineWidth = 4 //线条的宽度 ctx.strokeStyle = &#x27;#333&#x27; //线条的颜色 ctx.lineCap = &#x27;round&#x27; //定义线条开头和结尾处的形状 ctx.lineJoin = &#x27;bevel&#x27; // 线条与线条之间的连接方式，该属性有三个属性值：miter（默认值，尖角），bevel（衔接），round（圆角）。 this.setData(&#123; ctx: ctx &#125;) &#125;) &#125; &#125;&#125;) 实现手写效果 使用 catchtouchmove 绑定，默认会阻止页面跟着滑动 &lt;canvas type=&quot;2d&quot; id=&quot;sign&quot; bindtouchstart=&quot;bindtouchstartHandler&quot; catchtouchmove=&quot;catchtouchmoveHandler&quot;&gt;&lt;/canvas&gt; bindtouchstartHandler(e) &#123; if (e.type != &#x27;touchstart&#x27;) return false let ctx = this.data.ctx //开始本次绘画 ctx.beginPath() //画笔起始点 ctx.moveTo(e.touches[0].x, e.touches[0].y)&#125;,catchtouchmoveHandler(e) &#123; let left = e.currentTarget.offsetLeft let top = e.currentTarget.offsetTop let pageX = e.touches[0].pageX let pageY = e.touches[0].pageY let ctx = this.data.ctx //根据鼠标路径绘画 ctx.lineTo(pageX - left, pageY - top) //立即渲染 ctx.stroke()&#125; 使用 bindtouchmove，需要单独处理页面跟着滚动的问题 给 canvas 绑定 bindtouchmove&#x3D;”touchmoveHandler” 然后绑定空的 catchtouchmove 事件catchtouchmove=&quot;preventTouchmove&quot; 或者直接 catchtouchmove=&quot;ture&quot; &lt;canvas type=&quot;2d&quot; id=&quot;sign&quot; bindtouchstart=&quot;bindtouchstartHandler&quot; bindtouchmove=&quot;bindtouchmoveHandler&quot; catchtouchmove=&quot;preventTouchmove&quot;&gt;&lt;/canvas&gt; bindtouchstartHandler(e) &#123; if (e.type != &#x27;touchstart&#x27;) return false let ctx = this.data.ctx //开始本次绘画 ctx.beginPath() //画笔起始点 ctx.moveTo(e.touches[0].x, e.touches[0].y)&#125;,// bind绑定的事件bindtouchmoveHandler (e) &#123; let ctx = this.data.ctx //根据鼠标路径绘画 ctx.lineTo(e.touches[0].x, e.touches[0].y) //立即渲染 ctx.stroke()&#125;,preventTouchmove () &#123;&#125; 保存到相册 wx.canvasToTempFilePath(Object object, Object this)https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.canvasToTempFilePath.html // 把当前画布指定区域的内容导出生成指定大小的图片。 canvas2d不需要使用draw方法canvasToTempFilePath() &#123; return new Promise((resolve, reject) =&gt; &#123; const query = wx.createSelectorQuery() query .select(&#x27;#sign&#x27;) .fields(&#123; node: true, size: true &#125;) .exec(res =&gt; &#123; // console.log(res) const canvas = res[0].node wx.canvasToTempFilePath(&#123; x: 0, y: 0, fileType: &#x27;jpg&#x27;, canvas: canvas, success(res) &#123; console.log(res.tempFilePath) // 文件临时地址 可以保存到相册或上传 resolve(res.tempFilePath) &#125; &#125;) &#125;) &#125;)&#125;,// 保存本地saveToAlbum() &#123; this.canvasToTempFilePath().then(file =&gt; &#123; wx.getSetting(&#123; success(res) &#123; // 如果没有则获取授权 if (!res.authSetting[&#x27;scope.writePhotosAlbum&#x27;]) &#123; wx.authorize(&#123; scope: &#x27;scope.writePhotosAlbum&#x27;, success() &#123; wx.saveImageToPhotosAlbum(&#123; filePath: file, success() &#123; wx.showToast(&#123; title: &#x27;保存成功&#x27; &#125;) &#125;, fail() &#123; wx.showToast(&#123; title: &#x27;保存失败&#x27;, icon: &#x27;none&#x27; &#125;) &#125; &#125;) &#125;, fail() &#123;&#125; &#125;) &#125; else &#123; // 有授权直接保存 wx.saveImageToPhotosAlbum(&#123; filePath: file, success() &#123; wx.showToast(&#123; title: &#x27;保存成功&#x27; &#125;) &#125;, fail() &#123; wx.showToast(&#123; title: &#x27;保存失败&#x27;, icon: &#x27;none&#x27; &#125;) &#125; &#125;) &#125; &#125; &#125;) &#125;)&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"解决 WordPress 'Briefly unavailable for scheduled maintenance. Check back in a minute.'","slug":"其他/wordpress/wordpress-解决'Briefly unavailable for scheduled maintenance. Check back in a   minute.'","date":"14/03/2020","updated":"14/03/2020","comments":true,"path":"951.html","link":"","permalink":"https://wqdy.top/951.html","excerpt":"","text":"WordPress 在升级程序、主题、插件时，都会先切换到维护模式，也就是显示 ‘Briefly unavailable for scheduled maintenance. Check back in a minute’，如果升级顺利，也就几秒左右就恢复正常；但是如果由于网速不佳等原因导致升级中断，WordPress 就会一直停留在维护模式，不论前台还是后台。 如何解决这个问题呢？ 马上通过 FTP 登录你的网站，删除 WordPress 根目录下的 .maintenance ，刷新网页即可。","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[]},{"title":"github 下载加速--解决克隆 github 仓库时速度慢的问题","slug":"其他/github-下载加速-解决克隆-github-仓库时速度慢的问题","date":"09/03/2020","updated":"09/03/2020","comments":true,"path":"890.html","link":"","permalink":"https://wqdy.top/890.html","excerpt":"","text":"修改 host 方式访问 http://tool.chinaz.com/dns 或 https://www.ipaddress.com/ 查询以下三个链接的 DNS 解析地址 github.comassets-cdn.github.comgithub.global.ssl.fastly.net 找到 TTL 值最小的 IP，修改系统 Hosts 文件 之后刷新系统 DNS 缓存 Windows+X 打开系统命令行（管理员身份）或 powershell 运行 ipconfig &#x2F;flushdns 手动刷新系统 DNS 缓存。 利用国内代码管理平台中转利用码云(gitee) 新建仓库-导入已有仓库 将 github 仓库 clone 到 gitee 中 如果项目中有子模块，同理也需要 clone 到 gitee 中，同时修改主仓库中的 .gitmodules 文件，将子模块的地址修改为 gitee 地址 使用 GitHubDesktop 客户端使用代理仅仅开代理是不行的，需要单独配置 如果使用 HTTPS 协议克隆需要如下配置 # 设置代理git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080#取消代理git config --global --unset http.proxygit config --global --unset https.proxy 使用 SSH 协议克隆需要如下配置 修改.ssh&#x2F;config Host github.comHostname github.comProxyCommand connect -S 127.0.0.1:1080 %h %p 1080 端口换成你本地代理客户端的 socks 端口 github.com.cnpmjs.org 镜像站git clone https://github.com/vuejs/vue.git# 改为git clone https://github.com.cnpmjs.org/vuejs/vue.git https://github.com/521xueweihan/GitHub520SwitchHosts v4.0.2https://github.com/oldj/SwitchHosts/releases/tag/v4.0.2","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"github","slug":"github","permalink":"https://wqdy.top/tags/github/"}]},{"title":"ZeroTier 异地组网及私有 Moon 转发节点搭建","slug":"其他/ZeroTier异地组网及私有Moon转发节点搭建","date":"07/03/2020","updated":"07/03/2020","comments":true,"path":"819.html","link":"","permalink":"https://wqdy.top/819.html","excerpt":"","text":"支持 Windows、macOS、Linux、IOS、Android、Synology、QNAP、Western Digital MyCloud NAS等 使用官方根节点1、创建账号 https://my.zerotier.com 2、创建网络 进入 https://my.zerotier.com/network 点击 Create 创建网络，点击进入已创建的网络 此时可以看到 Network ID，后续添加设备都会需要这个 ID Access Control，默认是Certificate (Private Network)，选择此模式表示每次在添加新的主机时，需要手动勾选是否允许连接，如果选择None (Public Network)模式，表示加入网络后自动分配IP并允许连接，从安全性来说建议使用默认选项Certificate (Private Network)，方便性来看None (Public Network)更方便，不用每次加入网络后手动勾选。 好了，一个中转的ZeroTier就配置完成了，接下来只需要在其他设备安装所对应的客户端，然后加入到这个网络中就可以了。 搭建私有节点（moon） 搭建私有节点是为了解决根节点在国外,速度慢, 且不稳定 安装curl -s https://install.zerotier.com/ | sudo bash# 安装成功后# *** Success! You are ZeroTier address [ b32fxxxxxx ]. 配置 Mooncd /var/lib/zerotier-one# 生成 moon.json 配置文件zerotier-idtool initmoon identity.public &gt;&gt; moon.json# 编辑 moon.json 配置文件，修改 stableEndpointsvim moon.json&quot;stableEndpoints&quot;: [&quot;你服务器公网ip/9993&quot;]# 生成 .moon 文件 私有网络的 zerotier 标志性文件zerotier-idtool genmoon moon.json# 此命令会生成一个签名文件在当前目录下，文件名如 000000b32fxxxxxx.moon （b32fxxxxxx 为 ZeroTier address)# 移动文件# 将生成的 000000b32fxxxxxx.moon 移动到 moons.d 目录mkdir moons.dmv 000000b32fxxxxxx.moon moons.d# 重启 zerotier-one 服务systemctl restart zerotier-one# 加入虚拟网络# zerotier-cli join af415e486f26xxxx // af415e486f26xxxx 为在 zerotier 官网创建的网络 将内网机器连接上 moon 节点 执行命令 # windows 在 C:\\ProgramData\\ZeroTier\\One 目录下执行zerotier-cli orbit 000000b32fxxxxxx 000000b32fxxxxxx # moon 服务器的ID值 输入2遍 查看是否连接 # 在其他机子执行以下命令是否显示该 moon 节点# 或在 moon 服务器上执行命令否显示 LEAF 节点zerotier-cli listpeers200 listpeers &lt;ztaddr&gt; &lt;path&gt; &lt;latency&gt; &lt;version&gt; &lt;role&gt;200 listpeers xxxxxxxxxx xx.xx.xx.xx/4532;1037;853 183 1.6.4 LEAF200 listpeers xxxxxxxxxx xx.xx.xx.xx/9993;19869;4337 0 - PLANET200 listpeers xxxxxxxxxx xx.xx.xx.xx/9993;4337;4167 170 - PLANET200 listpeers xxxxxxxxxx xx.xx.xx.xx/9993;363;4274 63 - PLANET200 listpeers xxxxxxxxxx xx.xx.xx.xx/9993;19508;4192 145 - PLANET Dockerfilehttps://docs.docker.com/engine/reference/builder/ https://github.com/zerotier/ZeroTierOne/tree/master/ext/installfiles/linux/zerotier-containerized docker build . -t zerotier","categories":[],"tags":[{"name":"zerotier","slug":"zerotier","permalink":"https://wqdy.top/tags/zerotier/"}]},{"title":"关于 a 标签 target_blank 使用 rel=noopener","slug":"前端/关于-a-标签-target-blank-使用-relnoopener","date":"06/03/2020","updated":"06/03/2020","comments":true,"path":"798.html","link":"","permalink":"https://wqdy.top/798.html","excerpt":"","text":"为什么要使用rel&#x3D;’noopener’？ 举个例子: a.html 和 b.html 两个页面 a.html &lt;a href=&quot;b.html&quot; target=&quot;_blank&quot;&gt;da&lt;/a&gt; b.html &lt;script&gt;window.opener.location.href =&quot;http://wqdy.top&quot;&lt;/script&gt; 其中在 a.html 中有个超链接，点击后在新标签页打开 b.html页面，但是发现原 a.html 页面已经变成了其他页面。原因是使用 target=_blank 打开新的窗口时，赋予了新的窗口一些权限可以操作原窗口，其中 window.location 就是一个。 为了防止 window.opener 被滥用，提高网站的安全性，在使用 targrt=_blank 时需要加上 rel=noopener，同时为了兼容也可以加上 rel=noreferrer。","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"微信小程序学习笔记","slug":"前端/微信小程序/微信小程序学习笔记","date":"04/03/2020","updated":"04/03/2020","comments":true,"path":"873.html","link":"","permalink":"https://wqdy.top/873.html","excerpt":"","text":"微信公众平台 注册账号进入后台：设置 -&gt; 开发设置 -&gt; 拿到 AppID（创建小程序项目使用） 每个邮箱仅能申请一个小程序（未被微信公众平台注册，未被微信开放平台注册，未被个人微信号绑定的邮箱） 体验小程序 微信开发者工具 开发者工具 需要使用注册小程序的微信扫码登录 本地开发时：详情-项目配置，将 不校验合法域名勾上 小程序项目结构代码构成 pages/ ---------------- 页面（组件），所有页面都应该放到这个目录中 index/ ------------- index页面文件夹 index.js ---------- index页面的逻辑代码 index.wxml -------- index页面的HTML结构 index.wxss -------- index页面的CSS样式 index.json -------- 页面配置（可选）utils/ ---------------- 公共工具（函数）app.js ---------------- 入口文件app.json -------------- 全局配置（包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等）app.wxss -------------- 全局样式（CSS）project.config.json --- 开发工具配置（例如ES6转ES5、界面颜色、编译配置等） 配置 全局配置: app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等 页面配置 配置本页面的窗口表现 ， 同全局配置中的 window 项配置，如果页面中的配置与全局配置冲突，是以页面配置为准 页面路径列表-pages 配置项 所有需要展示的页面都要在 app.json 中进行配置，pages 数组的第一项表示进入小程序的默认页面 每一项开头不需要添加 /，否则报错 推荐：所有页面放到 pages 目录中，文件名称与文件夹名称相同 说明：在 app.json 中配置 pages，可以快速创建页面 标签栏 - tabBar 配置 当设置 position 为 top 时，将不会显示 icon tabBar 中的 list 是一个数组，只能配置最少 2 个、最多 5 个 tab，tab 按数组的顺序排序 list 中每一个菜单项的pagePath属性必须在 pages 中配置 文字颜色以及选中项文字颜色，只能统一设置不能单独设置 注意：没有出现在 tabBar.list 的 pagePath 页面不展示标签栏 WXMLhttps://developers.weixin.qq.com/miniprogram/dev/reference/wxml/ 数据绑定 WXML 中的动态数据均来自对应 Page 的 data 小程序中插值表达式的特点 插值表达式中可以直接使用 data 中提供的数据 可以在属性中使用 只能使用表达式，不能出现语句（if、for 等） 注意：小程序中的插值表达式不支持方法调用 ！！！需要通过特殊的机制来实现该功能 小程序中的数据绑定是单向的，不是双向的 Page(&#123; data: &#123; msg: &#x27;hello&#x27;, isCheck: true &#125;&#125;) &lt;text&gt;&#123;&#123; msg &#125;&#125;&lt;/text&gt;&lt;input type=&quot;text&quot; value=&quot;&#123;&#123; msg &#125;&#125;&quot; /&gt;&lt;checkbox checked=&quot;&#123;&#123;isCheck&#125;&#125;&quot;&gt;&lt;/checkbox&gt; 绑定数据的具体类型(Booleal) &lt;!-- 绑定的是字符串 false,转换成布尔值是 true， checkbox 是选中状态 --&gt;&lt;checkbox checked=&quot;false&quot;&gt;&lt;/checkbox&gt;&lt;!-- 绑定的是布尔值 false, checkbox 是未选中状态 --&gt;&lt;checkbox checked=&quot;&#123;&#123;false&#125;&#125;&quot;&gt;&lt;/checkbox&gt;&lt;!-- 绑定的是字符串 false, checkbox 是选中状态 --&gt;&lt;checkbox checked=&quot;&#123;&#123;&#x27;false&#x27;&#125;&#125;&quot;&gt;&lt;/checkbox&gt; 运算Page(&#123; data: &#123; flag: 0, a: 1, b: 2, c: 4, d: 8, length: 3, name: &#x27;zs&#x27; &#125;&#125;) &lt;!-- 三元运算 --&gt;&lt;!-- hidden --&gt;&lt;view hidden=&quot;&#123;&#123;flag === 0 ? true : false&#125;&#125;&quot;&gt;hidden&lt;/view&gt;&lt;!-- 算数运算 --&gt;&lt;!-- 13 + 4 + d --&gt;&lt;view&gt;&#123;&#123; 10 + a + b&#125;&#125; + &#123;&#123;c&#125;&#125; + d&lt;/view&gt;&lt;!-- checkbox是未选中状态 --&gt;&lt;checkbox checked=&quot;&#123;&#123;a &gt; b&#125;&#125;&quot;&gt;&lt;/checkbox&gt;&lt;!-- checkbox是选中状态 --&gt;&lt;!-- 花括号与引号间有空格，被解析成字符串 --&gt;&lt;checkbox checked=&quot; &#123;&#123;a &gt; b&#125;&#125;&quot;&gt;&lt;/checkbox&gt;&lt;!-- 逻辑判断 --&gt;&lt;view wx:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt;逻辑判断&lt;/view&gt;&lt;!-- 字符串运算 --&gt;&lt;view&gt;&#123;&#123; &#x27;name:&#x27; + name &#125;&#125;&lt;/view&gt;&lt;!-- name:zs --&gt; 注意： 花括号与引号间不要有空格，否则被解析成字符串 条件渲染https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html wx:if &lt;view wx:if=&quot;&#123;&#123; isLoading &#125;&#125;&quot;&gt; &lt;text&gt;数据加载中...&lt;/text&gt;&lt;/view&gt;&lt;view wx:else&gt; &lt;text&gt;搞定啦~&lt;/text&gt;&lt;/view&gt;&lt;!-- 隐藏多个元素，不改变 wxml的层级结构 --&gt;&lt;block wx:if=&quot;&#123;&#123; isLoading &#125;&#125;&quot;&gt; &lt;text&gt;小明&lt;/text&gt; &lt;text&gt;小红&lt;/text&gt;&lt;/block&gt; hidden &lt;view hidden=&quot;&#123;&#123; isLoading &#125;&#125;&quot;&gt; &lt;text&gt;搞定啦~&lt;/text&gt;&lt;/view&gt; 列表渲染https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html wx:for：遍历数组，在元素中通过 index 获取索引号，通过 item 获取当前项 wx:for-index=&quot;i&quot;：替换默认的 index wx:for-item=&quot;v&quot;：替换默认的 item 注意：遍历时，需要添加 wx:key 属性，来提高渲染性能 (wx:key 的值不需要添加 item.)，如 wx:key=&quot;id&quot;，如果 item 本身是一个唯一的字符串或者数字，可以使用保留关键字 *this(代表在 for 循环中的 item 本身) 作为 key 值 &lt;view wx:for=&quot;&#123;&#123; list &#125;&#125;&quot; wx:for-index=&quot;i&quot; wx:for-item=&quot;v&quot; wx:key=&quot;id&quot;&gt; &#123;&#123;i&#125;&#125;: &#123;&#123;v.message&#125;&#125;&lt;/view&gt; 注意：1. 也可以用来渲染一个对象，index 表示 key，item 表示 value。2. 可以用一个 block 标签包裹，将循环写在 block 标签上，且 block 标签并不会渲染到 dom 中 &lt;block wx:for=&quot;&#123;&#123;[1, 2, 3]&#125;&#125;&quot;&gt; &lt;view&gt;&#123;&#123;index&#125;&#125;:&lt;/view&gt; &lt;view&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;&lt;/block&gt; 模板https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/template.html 定义模板&lt;!-- name 属性作为模板的名字 --&gt;&lt;template name=&quot;msgItem&quot;&gt; &lt;view&gt; &lt;text&gt;&#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/template&gt; 可以将模板写在单独的一个 wxml 文件中，并通过 import 导入使用 使用模板使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入 注意：is 属性可以使用 Mustache 语法，来动态决定具体需要渲染哪个模板 &lt;template is=&quot;msgItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot; /&gt; Page(&#123; data: &#123; item: &#123; index: 0, msg: &#x27;this is a template&#x27; &#125; &#125; 模板的作用域模板拥有自己的作用域，只能使用 data 传入的数据以及模板定义文件中定义的 &lt;wxs /&gt; 模块 引用https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/import.html importimport可以在该文件中使用目标文件定义的template，如： 在 item.wxml 中定义了一个叫item的template： &lt;!-- item.wxml --&gt;&lt;template name=&quot;item&quot;&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;&lt;/template&gt; 在 index.wxml 中引用了 item.wxml，就可以使用item模板： &lt;import src=&quot;item.wxml&quot; /&gt;&lt;template is=&quot;item&quot; data=&quot;&#123;&#123;text: &#x27;forbar&#x27;&#125;&#125;&quot; /&gt; import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。 includeinclude 可以将目标文件除了 &lt;template/&gt; &lt;wxs/&gt; 外的整个代码引入，相当于是拷贝到 include 位置 WXSSWXSS(WeiXin Style Sheets)，用于描述 WXML 的组件样式 与 css 相比，WXSS 扩展的特性有： 尺寸单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx &#x3D; 375px &#x3D; 750 物理像素，1rpx &#x3D; 0.5px &#x3D; 1 物理像素。 样式导入 使用 @import 语句可以导入外联样式表，@import 后跟需要导入的外联样式表的相对路径，用;结束 WXSS 中的注释需要使用多行注释 /* */ 全局样式、局部样式： app.wxss page.wxss 动态样式：style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。 如果通过 wxss 使用背景图片，不能使用本地资源图片，可以使用网络图片，或者 base64；推荐使用&lt;image/&gt;标签来展示图片 &lt;view style=&quot;color:&#123;&#123;color&#125;&#125;;&quot; /&gt;&lt;view class=&quot;&#123;&#123;myclass&#125;&#125;&quot; /&gt; 选择器 目前支持的选择器有：.class #id element ::after ::before 基本组件https://developers.weixin.qq.com/miniprogram/dev/component/ view 组件（标签）类似于 HTML 中的 div，用来布局 hover-class 属性，指定按下去的样式类，其他属性使用见：https://developers.weixin.qq.com/miniprogram/dev/component/view.html text 组件类似于 HTML 中的 span，行内元素 属性 类型 默认值 必填 说明 selectable boolean false 否 文本是否可选（长按文本） space string 否 显示连续空格 decode boolean false 否 是否解码 详细使用文档： https://developers.weixin.qq.com/miniprogram/dev/component/text.html 注意：如果想要文本选中功能，必须使用 text 标签，并且添加 selectable 属性，除了文本节点以外的其他节点都无法长按选中 text 标签中只能嵌套 text 标签 decode 可以解析的有 &amp;nbsp; &amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;ensp; &amp;emsp; 可以使用 \\n 来换行，在编辑器中按回车键换行也会解析出换行 icon 组件https://developers.weixin.qq.com/miniprogram/dev/component/icon.html 使用 type 指定 icon 的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear button 组件https://developers.weixin.qq.com/miniprogram/dev/component/button.html 注意：如果设置了 type 属性，hover-class 属性会失效 input 组件输入框。该组件是原生组件 属性：placeholder-style: 指定 placeholder 的样式placeholder-class: 默认值 input-placeholder 指定 placeholder 的样式类maxlength: 默认 140，设置最大输入长度，设置为 -1 的时候不限制最大长度cursor-spacing: 默认 0，指定光标与键盘的距离，取 input 距离底部的距离和 cursor-spacing 指定的距离的最小值作为光标与键盘的距离confirm-type: 默认 done，设置键盘右下角按钮的文字，仅在 type&#x3D;’text’时生效adjust-position: 默认 true，键盘弹起时，是否自动上推页面 image 图片组件https://developers.weixin.qq.com/miniprogram/dev/component/image.html image 标签是 web 中 img 标签和背景图片的结合体 常用属性 src：图片资源地址 mode：图片裁剪、缩放的模式 lazy-load：图片懒加载，在即将进入一定范围（上下三屏）时才开始加载 show-menu-by-longpress: 开启长按图片显示识别小程序码菜单 binderror: 当错误发生时触发，用于图片加载失败时显示默认图片 注意：图片有默认宽高，默认宽高为：320 * 240 px；默认不会保持宽高比 swiper 轮播组件默认宽度 100%，高度 150px scroll-viewhttps://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html navigatorhttps://developers.weixin.qq.com/miniprogram/dev/component/navigator.htmlhttps://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html 属性 类型 默认值 必填 说明 target string self 否 在哪个目标上发生跳转，默认当前小程序 url string 否 当前小程序内的跳转链接 open-type string navigate 否 跳转方式 open-type 的合法值 值 说明 navigate 对应 wx.navigateTo redirect 对应 wx.redirectTo switchTab 对应 wx.switchTab reLaunch 对应 wx.reLaunch navigateBack 对应 wx.navigateBack exit 退出小程序，target=&quot;miniProgram&quot; 时生效 wx.navigateTo ，保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。wx.redirectTo 的功能，关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。wx.switchTab 的功能，跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面wx.reLaunch 的功能，关闭所有页面，打开到应用内的某个页面wx.navigateBack 的功能，关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。getCurrentPages url 可以使用绝对路径或相对路径，使用绝对路径时需要添加 / &lt;navigator url=&quot;/pages/index/index&quot; open-type=&quot;navigate&quot;&gt;sdfsf&lt;/navigator&gt;&lt;navigator url=&quot;./index/index&quot; open-type=&quot;navigate&quot;&gt;sdfsf&lt;/navigator&gt; 自定义组件https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html 普通页面也可以使用 Component 构造器来创建，提供 observers 支持数据监听，类似 vue 中的 watch 还可以扩展 conputed，类似 vue 计算属性 数据操作全局数据 app.js App(&#123; globalData: &#123; url: &#x27;hhh&#x27; &#125;&#125;) 在 app.js 文件中，直接使用 this.globalData.url // 获取this.globalData.url = &#x27;qqq&#x27; // 修改 在其他非 app.js 文件中使用 let App = getApp()let url = App.globalData.url // 获取App.globalData.url = &#x27;hhh&#x27; // 修改App.globalData.name = &#x27;zs&#x27; // 添加 页面内数据 获取数据 getMsg () &#123; console.log(this.data.msg) // 和 vue 中的不同&#125; 修改数据 setData setData()：更新数据 说明：将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步） 修改 data 中的数据 更新视图，也就是说：视图中使用该数据的地方会重新渲染 changeMsg () &#123; this.setData(&#123; name: &quot;jack&quot; &#125;, function () &#123; // 回调函数 &#125;)&#125; 注意：小程序中的数据不是双向绑定的，而是单向的！！！所以，无法直接修改 data 中的数据来将数据的变化显示在页面中，即通过 this.data.msg = &#39;修改后的数据&#39; 方式修改数据后，页面中不会显示该数据的变化 文本框操作： &lt;input value=&quot;&#123;&#123; input &#125;&#125;&quot; bindinput=&quot;inputChangeHandle&quot; /&gt; Page(&#123; inputChangeHandle: function(e) &#123; this.setData(&#123; input: e.detail.value &#125;) &#125;&#125;) 事件处理https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html 绑定事件：bindtap、catchtap 说明：bind 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡 事件对象可以携带额外信息，如 id, dataset, touches：通过标签的自定义属性data-*，实现给事件传递参数（不能使用函数调用的形式） 连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符：data-element-type ，最终会呈现为 event.currentTarget.dataset.elementType，data-elementType ，最终会呈现为 event.currentTarget.dataset.elementtype mark 也可以用于承载一些自定义数据（类似于 dataset ） &lt;button bindtap=&quot;sayHi&quot; data-msg=&quot;zs&quot;&gt;按钮&lt;/button&gt; Page(&#123; sayHi(event) &#123; console.log(event) console.log(&#x27;单击事件触发了&#x27;, event.currentTarget.dataset.msg) &#125;&#125;) WXS作用： 辅助构建页面结构的 不支持 es6 语法 &lt;!-- 语法结构 --&gt;&lt;wxs module=&quot;tools&quot;&gt; function fn (arg) &#123; return arg + 10 &#125; // 导出一个对象 module.exports = &#123; fn: fn &#125;&lt;/wxs&gt;&lt;!-- 使用 --&gt;&lt;view&gt;使用wxs：&#123;&#123; tools.fn(8) &#125;&#125;&lt;/view&gt; UI 库 weui-wsxx 生命周期两个生命周期：应用生命周期、页面生命周期 app 生命周期 页面 生命周期 小程序发送请求wx.request(Object object) 关于小程序中网络相关 API 的说明 在实际的项目中需要在 开发设置 中配置 服务器域名，然后小程序才能发送请求获取数据，但在开发期间，可以忽略这一步，在开发工具右上角的 详情 菜单中，勾选 不校验安全域名、TLS版本以及HTTPS证书 在小程序不用考虑跨域的问题，因为小程序是基于微信这个客户端 无法在小程序中使用 XHR 对象，发送请求 apiwx.previewImage(Object object) 全屏预览图片https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewImage.html &lt;image src=&quot;&#123;&#123;tools.replace(src)&#125;&#125;&quot; bindtap=&quot;previewImage&quot; data-current=&quot;&#123;&#123; src &#125;&#125;&quot; data-urls=&quot;&#123;&#123; item.images &#125;&#125;&quot;&gt;&lt;/image&gt; // 图片预览previewImage (e) &#123; // 获取需要预览的图片链接 let &#123;dataset: &#123; current, urls&#125;&#125; = e.currentTarget // 将图片替换为大图 current = current.replace(&#x27;w.h&#x27;, &#x27;1000.1000&#x27;) urls = urls.map(item =&gt; &#123; return item.replace(&#x27;w.h&#x27;, &#x27;1000.1000&#x27;) &#125;) // 调用预览图片 API wx.previewImage(&#123; current, // 当前显示图片的http链接 urls // 需要预览的图片http链接列表 &#125;)&#125; wx.saveImageToPhotosAlbum 保存图片到相册https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.saveImageToPhotosAlbum.html wx.pageScrollTo(Object object)将页面滚动到目标位置 选择节点 wx.createSelectorQuery()https://developers.weixin.qq.com/miniprogram/dev/api/wxml/wx.createSelectorQuery.html https://developers.weixin.qq.com/miniprogram/dev/framework/view/selector.html 返回一个 SelectorQuery 对象实例。在自定义组件或包含自定义组件的页面中，应使用 this.createSelectorQuery() 来代替 文件系统文件系统https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.saveFile.htmlhttps://developers.weixin.qq.com/miniprogram/dev/framework/ability/file-system.html 上传文件https://developers.weixin.qq.com/miniprogram/dev/api/network/upload/wx.uploadFile.html 文件管理器https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.getFileSystemManager.html 页面事件处理函数onPageScroll(Object)https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onPageScroll-Object-object 监听用户滑动页面事件。 Object 参数说明：scrollTop Number 页面在垂直方向已滚动的距离（单位 px） onPageScroll(scroll) &#123; console.log(scroll.scrollTop)&#125; 小程序中授权功能 打开小程序设置页（wx.openSetting）接口调整 openSetting 的问题 wepy 爬坑记 - openSetting wx.getSetting(&#123; success(res) &#123; console.log(&#x27;success: &#x27;, res) // 根据获取到的用户授权信息判断用户是否同意过授权 if (res.authSetting[&#x27;scope.address&#x27;] === true) &#123; // res.authSetting[&#x27;scope.address&#x27;] ===&gt; true // 已经授权，并且已经同意 // 直接打开 收获地址 页面 wx.chooseAddress(&#123; success(res) &#123; console.log(&#x27;是否确认同意授权：&#x27;, res) &#125; &#125;) &#125; else if (res.authSetting[&#x27;scope.address&#x27;] === false) &#123; // res.authSetting[&#x27;scope.address&#x27;] ===&gt; false // 已经授权，并切没有同意 // 弹出确认框，引导用户去授权 wx.showModal(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;您需要授权后，才能使用收获地址功能，是否打开授权界面&#x27;, success(res) &#123; if (res.confirm) &#123; // 点击确定按钮 wx.openSetting(&#123; success(res) &#123; // console.log(res) // 此处，可以通过 res.authSetting[&#x27;scope.address&#x27;] 来获取到用户 // 是否同意授权 if (res.authSetting[&#x27;scope.address&#x27;]) &#123; // 用户同意授权小程序使用通讯地址这个开发接口 wx.chooseAddress(&#123; success(res) &#123; console.log(&#x27;是否确认同意授权：&#x27;, res) &#125; &#125;) &#125; else &#123; console.log(&#x27;用户本次还是不同意小程序使用通讯地址&#x27;) &#125; &#125; &#125;) &#125; else &#123; // 点击取消按钮 console.log(&#x27;取消&#x27;) &#125; &#125; &#125;) &#125; else &#123; // res.authSetting[&#x27;scope.address&#x27;] ===&gt; undefined // 没有授权 // 第一次点击按钮 wx.chooseAddress(&#123; success(res) &#123; console.log(&#x27;是否确认同意授权：&#x27;, res) &#125; &#125;) &#125; &#125;&#125;) 分包加载https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html 与 vue 的区别 小程序中 插值表达式可以用在属性中 小程序中的插值表达式默认不支持方法调用，需要通过特殊机制来实现 &lt;!-- 以下不会再视图中输出内容，也不会报错 --&gt;&lt;view&gt;&#123;&#123;[1, 2].join(&#x27;-&#x27;)&#125;&#125;&lt;/view&gt; 小程序中的数据操作 获取数据 this.data.msg 更新数据 this.setData(&#123; msg: &#39;something&#39; &#125;) 绑定布尔值 &lt;!-- vue 中 --&gt;&lt;xx :xx=&quot;true&quot;&gt;&lt;/xx&gt;&lt;!-- 小程序中 --&gt;&lt;xx xx=&quot;&#123;&#123;true&#125;&#125;&quot;&gt;&lt;/xx&gt; 小程序中绑定事件时，不能直接调用事件处理程序，所以传参需要通过自定义属性 遍历数据 小程序中 wx:for = &quot;lists&quot;, 而 Vue 是 v-for = &quot;item in lists&quot; todomvc 案例 每个框架或库都应该写一个 todomvc，来了解这个框架的使用模式是怎样的 功能 1 欢迎界面（没有任务就展示欢迎界面，有任务就展示任务列表） 注意：欢迎界面 和 任务列表 只能二选一 2 展示任务列表 3 添加任务 剩余任务数量会改变 4 任务状态切换（完成和未完成） 剩余任务数量会改变 当所有的任务都完成，隐藏剩余任务数量展示 5 删除任务 剩余任务数量会改变（删除未完成任务） 6 切换所有任务的选中状态 只要有一项是选中的，那么，就应该让其他项也选中 7 展示清除已完成任务按钮 1 当有已完成的任务，就展示 2 单击清除已完成任务按钮，会清除所有已完成的任务 任务中需要频繁处理的操作：1 清除已完成任务按钮 的展示和隐藏2 剩余任务（未完成任务）的展示和隐藏 other微信小程序 —— button 按钮去除 border 边框：使用 button::after&#123; border: none; &#125; 来去除边框 button navogator 组件默认有点击态，可以添加 hover-class=&quot;none&quot; 去除 getCurrentPages() 方法https://developers.weixin.qq.com/miniprogram/dev/reference/api/getCurrentPages.html 获取当前页面栈。数组中第一个元素为首页，最后一个元素为当前页面。 页面间数据传递 let page = getCurrentPages()console.log(page)let prevPage = page[page.length - 2]// 修改上个页面的数据prevPage.setData(&#123; msg: &#x27;hehehe&#x27; &#125;, () =&gt; &#123; wx.navigateBack()&#125;)","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"常用软件及破解资源合集","slug":"其他/软件/常用软件及破解资源","date":"02/03/2020","updated":"02/03/2020","comments":true,"path":"691.html","link":"","permalink":"https://wqdy.top/691.html","excerpt":"","text":"部分破解软件可在TG频道里下载 名称 平台 版本 说明 Internet Download Manager Win 6.38.16 下载工具 Eagle Win&#x2F;Mac 1.8.2 图片管理工具 WinScp Win 5.17.10 Windows 环境下开源图形化 SFTP 客户端 Dism++ Win 10.1.1001.10(2020-01-18) 系统优化备份工具 ADSafe Win 5.1.921.1800 广告屏蔽工具 synergy 官网 Win 1.5.0-r2278 多台计算机之间共享你的鼠标和键盘 Parallels Desktop Mac 16.1.1 虚拟机 VMware Workstation Pro Win 16.1.0 Build 17198959 虚拟机 Snipaste Win&#x2F;Mac v2.5.6 截图工具 百度网盘资源下载工具 Win 百度网盘资源下载工具合集 Adobe Zii Mac – Universal Adobe CC Patcher Mac 6.0.6 苹果Mac端Adobe软件通用破解工具 Billfish Win v1.4.6.12 支持多种格式素材的管理工具 fiddler Win 5.0 抓包工具 ScreenToGif Win 2.3.2 开源屏幕，摄像头和画板录像 potplayer Win 音视频播放器 待整理 嬴政天下 Adobe 全家桶视频剪辑图片录屏fluent terminalMem Reduct RaiDrivetyporaallavsoft 视频下载Mobile Debug MorphVOX Pro 变声器","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://wqdy.top/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"破解","slug":"破解","permalink":"https://wqdy.top/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"使用代码方式显示 WordPress 文章最后修改时间","slug":"其他/wordpress/wordpress-使用代码方式显示文章最后修改时间","date":"01/03/2020","updated":"01/03/2020","comments":true,"path":"690.html","link":"","permalink":"https://wqdy.top/690.html","excerpt":"","text":"对于偏技术性的文章，用户更在意文章的更新时间而非发表时间 将如下代码添加到主题函数 function.php 文件中，如果你不会的话，推荐使用这个插件：Code Snippets function wp_last_updated_date( $content ) &#123; $time = get_the_time(&#x27;U&#x27;); $modified_time = get_the_modified_time(&#x27;U&#x27;); $custom_content = &#x27;&#x27;; if ($modified_time &gt;= $time + 86400) &#123; $updated_time = get_the_modified_time(&#x27;Y-m-d H:i:s&#x27;); $custom_content .= &#x27;&lt;p class=&quot;last-updated&quot; style=&quot;color: #999;font-size: 12px;&quot;&gt;文章最后更新于&#x27;. $updated_time .&#x27;，如果失效请留言&lt;/p&gt;&#x27;; &#125; $custom_content .= $content; return $custom_content;&#125;add_filter( &#x27;the_content&#x27;, &#x27;wp_last_updated_date&#x27; );","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[]},{"title":"wordpress 插件 Code Snippets - 无需修改 functions.php 文件向站点添加自定义代码","slug":"其他/wordpress/wordpress-插件-code-snippets无需修改functions.php文件向站点添加自定义代","date":"01/03/2020","updated":"01/03/2020","comments":true,"path":"671.html","link":"","permalink":"https://wqdy.top/671.html","excerpt":"","text":"插件介绍Code Snippets 是一款可以简单、干净、安全添加 php 代码到你网站的插件，就跟直接写入 functions.php 文件里面的效果一样。 使用 Code Snippets 添加代码还有一个优点就是添加的代码不会因为你主题文件升级而丢失，而直接写入 functions.php 文件里面升级会被覆盖，还需要手动备份一次。 直接在后台搜索该插件安装即可 使用示例添加 php 代码直接新建一个 snippets 将 php 代码站填进去即可 添加 css 代码add_action( &#x27;wp_head&#x27;, function () &#123; ?&gt;&lt;style&gt; /* write your CSS code here */&lt;/style&gt;&lt;?php &#125; ); 添加 js 代码默认示例添加 js 代码使用的是 wp_head 函数，这里推荐使用 wp_footer，你可以根据 js 作用自行选择 // 在底部添加js代码，add_action( &#x27;wp_footer&#x27;, function () &#123; ?&gt;&lt;script&gt; /* write your JavaScript code here */&lt;/script&gt;&lt;?php &#125; );","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[]},{"title":"浏览器中图片另存为时默认保存为jfif格式问题","slug":"其他/浏览器中图片另存为时默认保存为jfif格式问题","date":"29/02/2020","updated":"29/02/2020","comments":true,"path":"660.html","link":"","permalink":"https://wqdy.top/660.html","excerpt":"","text":"jfif（JPEG File Interchange Format，JPEG 档案交换格式）格式是一种图片存储格式之一，由 JPEG 格式衍生而来 win10 中，在浏览器中通过图片另存为时发现默认保存为该格式时，说明系统把 JPEG 格式默认为了该格式，可以通过修改注册表还原，具体操作步骤如下： WIN + R 打开运行窗口，输入 regedit 回车 找到路径 HKEY_CLASSES_ROOT\\MIME\\Database\\Content Type\\image/jpeg，把 extension 的值改成 .jpg，关闭注册表即可","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"RoughJS -- JavaScript手绘风格的图形库","slug":"前端/前端库/roughjs-javascript手绘风格的图形库","date":"29/02/2020","updated":"29/02/2020","comments":true,"path":"650.html","link":"","permalink":"https://wqdy.top/650.html","excerpt":"","text":"RoughJS是一个轻量级的JavaScript图形库（压缩后约9KB），可以让你在网页上绘制素描风格、手绘样式般的图形。RoughJS定义了绘制直线，曲线，圆弧，多边形，圆和椭圆的图元，同时它还支持绘制SVG路径。 Rough.js可同时用于Canvas和SVG。 网站地址：https://roughjs.com/ 使用手册：https://www.tutorialdocs.com/tutorial/roughjs/get-started.html","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"前端工具库","slug":"前端工具库","permalink":"https://wqdy.top/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%BA%93/"}]},{"title":"如何为 WordPress 文章中的链接自动添加 nofollow","slug":"其他/wordpress/wordpress-为文章中的链接自动添加nofollow","date":"18/02/2020","updated":"18/02/2020","comments":true,"path":"554.html","link":"","permalink":"https://wqdy.top/554.html","excerpt":"","text":"在 SEO 的角度，我们不宜在网站中设置过多的外链，防止搜索引擎蜘蛛在爬虫你的网站时跳出到其他网站。因此，了解并为外链加上 nofollow 链接是非常有必要的（除非这些外链与你的网站有利益关系，比如是你的其他网站又或者是合作伙伴的网站）。 什么是 nofollow 链接Nofollow 链接是带有 rel &#x3D;”nofollow” HTML 标记的链接。 nofollow 标签可帮助搜索引擎了解要忽略目标链接，并且不会将网页（放置 nofollow 链接）的 PageRank 传递给此类链接。 以下链接类型应该设置为 nofollow 链接：返利链接，赞助商链接，广告链接，社交媒体链接，不可信&#x2F;不可靠网站内容链接 如何建立 Nofollow 链接将下面的代码添加到主题的 functions.php 文件即可： 如果不想直接修改 functions.php 文件，可以使用 Code Snippets 插件 // 文章外部链接加上nofollowadd_filter( &#x27;the_content&#x27;, &#x27;nf_url_parse&#x27;);function nf_url_parse( $content ) &#123; $regexp = &quot;&lt;a\\s[^&gt;]*href=(\\&quot;??)([^\\&quot; &gt;]*?)\\\\1[^&gt;]*&gt;&quot;; if(preg_match_all(&quot;/$regexp/siU&quot;, $content, $matches, PREG_SET_ORDER)) &#123; if( !empty($matches) ) &#123; $srcUrl = get_option(&#x27;siteurl&#x27;); for ($i=0; $i &lt; count($matches); $i++) &#123; $tag = $matches[$i][0]; $tag2 = $matches[$i][0]; $url = $matches[$i][0]; $noFollow = &#x27;&#x27;; // $pattern = &#x27;/target\\s*=\\s*&quot;\\s*_blank\\s*&quot;/&#x27;; // preg_match($pattern, $tag2, $match, PREG_OFFSET_CAPTURE); // if( count($match) &lt; 1 ) // $noFollow .= &#x27; target=&quot;_blank&quot; &#x27;; $pattern = &#x27;/rel\\s*=\\s*&quot;\\s*[n|d]ofollow\\s*&quot;/&#x27;; preg_match($pattern, $tag2, $match, PREG_OFFSET_CAPTURE); if( count($match) &lt; 1 ) $noFollow .= &#x27; rel=&quot;nofollow&quot; &#x27;; $pos = strpos($url,$srcUrl); if ($pos === false) &#123; $tag = rtrim ($tag,&#x27;&gt;&#x27;); $tag .= $noFollow.&#x27;&gt;&#x27;; $content = str_replace($tag2,$tag,$content); &#125; &#125; &#125; &#125; $content = str_replace(&#x27;]]&gt;&#x27;, &#x27;]]&gt;&#x27;, $content); return $content;&#125; 检查 nofollow 链接是否生效使用浏览器的 检查 功能查看 nofollow 链接 使用浏览器打开页面，移动鼠标光标至你想要检查的链接上方。 右击鼠标按钮，选择 检查 选项 （以 Chrome 为例，不同浏览器选项叫法不太一样） 代码查看窗口将在浏览器的底部&#x2F;右侧打开。你可以通过查看 HTML 代码查看链接是否添加了 rel&#x3D;”nofollow”。 使用 Chrome 扩展组件（插件）检查页面 nofollow 链接 下载名为NoFollow的 Chrome 扩展组件，安装该插件后重新加载页面，该网页上的所有 nofollow 链接都将会高亮突出显示。","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[]},{"title":"dux主题修改记录","slug":"其他/wordpress/wordpress-dux主题修改记录","date":"12/02/2020","updated":"12/02/2020","comments":true,"path":"504.html","link":"","permalink":"https://wqdy.top/504.html","excerpt":"","text":"给网站添加语言打开 theme/dux/header.php 文件，修改如下内容 &lt;!DOCTYPE HTML&gt;-&lt;html&gt;+&lt;html lang=&quot;zh&quot;&gt; 修改面包屑导航位置打开 theme/dux/single.php 文件，修改如下内容 &lt;?php get_header(); ?&gt;-&lt;?php if( _hui(&#x27;breadcrumbs_single_s&#x27;) )&#123; ?&gt;- &lt;div class=&quot;breadcrumbs&quot;&gt;- &lt;div class=&quot;container&quot;&gt;&lt;?php echo hui_breadcrumbs() ?&gt;&lt;/div&gt;- &lt;/div&gt;-&lt;?php &#125; ?&gt;&lt;section class=&quot;container&quot;&gt;+ &lt;?php if( _hui(&#x27;breadcrumbs_single_s&#x27;) )&#123; ?&gt;+ &lt;div class=&quot;breadcrumbs&quot;&gt;+ &lt;div class=&quot;container&quot;&gt;&lt;?php echo hui_breadcrumbs() ?&gt;&lt;/div&gt;+ &lt;/div&gt;+ &lt;?php &#125; ?&gt; &lt;div class=&quot;content-wrap&quot;&gt; &lt;div class=&quot;content&quot;&gt; 添加自定义样式 /* 面包屑导航 */.breadcrumbs &#123; box-shadow: none; background: none; margin-bottom: 0;&#125;","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/tags/wordpress/"}]},{"title":"手机端无限制视频播放软件","slug":"其他/手机端无限制视频播放软件","date":"07/02/2020","updated":"07/02/2020","comments":true,"path":"487.html","link":"","permalink":"https://wqdy.top/487.html","excerpt":"","text":"星雨视频(有广告) 卧龙影视(无广告) 玉米电影(无广告) 为伪装app，即软件图标和名称很奇怪。打开软件如果没有显示播放器相关功能，在后台关闭软件后重新打开","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[]},{"title":"斐讯K2P、K2路由器刷机","slug":"其他/斐讯k2p、k2路由器固件","date":"07/02/2020","updated":"07/02/2020","comments":true,"path":"478.html","link":"","permalink":"https://wqdy.top/478.html","excerpt":"","text":"PADAVAN（老毛子）固件H大固件地址：http://opt.cn2qq.com/padavan/ k2路由器下载 RT-AC54U-GPIO-1-PSG1218-64M**.trx 文件 K2P各固件的区别，供大家参考：K2P_V5_3.4.3.9-099.trx 这是K2P的MTK平台原版未改版最新v5.0无线驱动固件K2P_DRV_V5_3.4.3.9-099.trx 这是K2P的MTK平台硬改USB最新v5.0无线驱动固件K2P_DRV_512M_3.4.3.9-099.trx 这是K2P的MTK平台硬改512MB内存(RAM)和USB稳定v4.0无线驱动固件K2P_DRV_256M_3.4.3.9-099.trx 这是K2P的MTK平台硬改256MB内存(RAM)和USB稳定v4.0无线驱动固件K2P_DRV_3.4.3.9-099.trx 这是K2P的MTK平台硬改USB稳定v4.0无线驱动固件K2P_3.4.3.9-099.trx 这是K2P的MTK平台原版未改版稳定v4.0无线驱动固件 管理地址：192.168.123.1管理账号：admin管理密码：admin HANWCKF固件地址 https://pan.baidu.com/s/1kU8YqrH 提取码: hmdn k2p 源码 https://github.com/hanwckf/rt-n56u 灯大固件：http://rom.nanodm.net/ waynezwd的固件地址：https://pan.baidu.com/s/1KvlWl4Hr1DwY2N0NxgzeBA 提取码: w5e8 高恪免费路由固件http://www.gocloud.cn/bbs/forum-51-1.html ledeOpenWrt 固件 https://github.com/coolsnowwolf/lede 魔改固件下载 http://lean.ys168.com/ 论坛https://www.right.com.cn/forum/forum.php http://www.gocloud.cn/bbs/forum.php","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"斐讯","slug":"斐讯","permalink":"https://wqdy.top/tags/%E6%96%90%E8%AE%AF/"}]},{"title":"网站配置SSL后无法访问解决办法","slug":"运维/网站配置ssl后无法访问解决办法","date":"04/02/2020","updated":"04/02/2020","comments":true,"path":"450.html","link":"","permalink":"https://wqdy.top/450.html","excerpt":"","text":"开放 443 端口 域名证书有效且配置正确 ssl配置问题 正确启用HTTP&#x2F;2支持，正确配置ssl_protocols和ssl_ciphers 启用HTTP2并非只在 listen 443 ssl 配置中加入http2就行了，它主要需要两个地方的设置支持：ssl_protocols 和 ssl_ciphers 。 修改如下配置以向后兼容 listen 443 ssl http2;- ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;+ ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; 在线 http2 检测 https://www.rosehosting.com/network-tools/http2-support.html https://myssl.com/http2_check.html https://www.ssllabs.com/ssltest/analyze.html","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[{"name":"ssl","slug":"ssl","permalink":"https://wqdy.top/tags/ssl/"},{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/tags/wordpress/"}]},{"title":"vue-awesome-swiper 设置 loop：true不会自动滚动的问题","slug":"前端/vue/vue-vue awesome swiper插件设置loop：true不会自动滚动的问题","date":"20/01/2020","updated":"20/01/2020","comments":true,"path":"1002.html","link":"","permalink":"https://wqdy.top/1002.html","excerpt":"","text":"vue-awesome-swiper: 基于 Swiper4、适用于 Vue 的轮播组件，支持服务端渲染和单页应用 github地址：https://github.com/surmon-china/vue-awesome-swiper 官网：https://github.surmon.me/vue-awesome-swiper/ 问题： 设置loop：true， autoplay：2000 不会自动滚动 解决在 swiper 上添加 v-if=&quot;swiperSlides.length&gt;0&quot; &lt;swiper v-if=&quot;swiperSlides.length&gt;0&quot; :options=&quot;swiperOption&quot; ref=&quot;mySwiper&quot;&gt;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"echarts 柱状图基本配置","slug":"前端/前端库/echarts-柱状图基本配置","date":"20/01/2020","updated":"20/01/2020","comments":true,"path":"1145.html","link":"","permalink":"https://wqdy.top/1145.html","excerpt":"","text":"monthOptions: &#123; color: [&#x27;#FFD058&#x27;], // 设置柱的颜色 会被 series itemStyle color 覆盖 xAxis: [ &#123; data: [&#x27;报备组数&#x27;, &#x27;来访组数&#x27;, &#x27;大定套数&#x27;, &#x27;草签套数&#x27;, &#x27;正签套数&#x27;], // x轴 axisLabel: &#123; inside: false, // 在外部显示 textStyle: &#123; // 设置样式 color: &#x27;rgba(255,255,255,0.5)&#x27;, fontSize: 15, fontFamily: &#x27;PingFang-SC-Regular,PingFang-SC&#x27; &#125; &#125;, axisTick: &#123; show: false &#125;, // x轴线上的分割点 axisLine: &#123; show: false &#125;// x轴线 &#125; ], yAxis: &#123; axisLine: &#123; show: false &#125;, axisTick: &#123; show: false &#125;, axisLabel: &#123; formatter: function () &#123; return &#x27;&#x27; &#125; // 去掉y轴显示数字 &#125;, splitLine: &#123; show: false &#125; // 水平线 &#125;, grid: &#123; // 间距 left: &#x27;10%&#x27;, right: &#x27;10%&#x27;, bottom: &#x27;15%&#x27;, top: &#x27;15%&#x27;, containLabel: true &#125;, series: [ &#123; // 用于显示阴影 type: &#x27;bar&#x27;, itemStyle: &#123; color: &#x27;rgba(255,255,255,0.08)&#x27; &#125;, barGap: &#x27;-100%&#x27;, // barCategoryGap: &#x27;25%&#x27;, barWidth: &#x27;15%&#x27;, data: [1, 1, 1, 1, 1] // animation: false &#125;, &#123; // 正常数据 name: &#x27;&#x27;, type: &#x27;bar&#x27;, barWidth: &#x27;15%&#x27;, data: [], itemStyle: &#123; // 上方显示数值 normal: &#123; label: &#123; formatter: function (val) &#123; return formate(val.value) &#125;, show: true, // 开启显示 position: &#x27;top&#x27;, // 在上方显示 textStyle: &#123; // 数值样式 color: &#x27;#FFD058&#x27;, fontSize: 15, fontFamily: &#x27;PingFang-SC-Regular,PingFang-SC&#x27; &#125; &#125; &#125; &#125; &#125; ], animationDuration: 2000&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"https://wqdy.top/tags/echarts/"}]},{"title":"nodejs 版本管理工具","slug":"前端/nodejs-版本管理工具","date":"19/01/2020","updated":"04/09/2021","comments":true,"path":"439.html","link":"","permalink":"https://wqdy.top/439.html","excerpt":"","text":"ngithub地址 支持 macOS, Linux 安装 npm install -g n 使用 n --latest # Output the latest node version availablen --lts # Output the latest LTS node version availablen ls # Output downloaded versionsn ls-remote [version] # Output matching versions available for downloadn uninstall # Remove the installed node and npm# 安装最新版n latest# 安装长期支持版本n lts# 安装指定版本n 12.4.1# 切换nodejs版本n# 上下键选择已安装的版本，回车切换ο node/13.6.0 node/10.4.1# 查看当前版本 node -vnode -v nvmgithub地址 支持 macOS, Linux NodeSourcegithub地址 支持 Linux nvm-windows支持 Windows github地址 安装 注意：1. 需要卸载已经安装的 nodejs 版本，并删除残留的 nodejs 程序目录（例如：”C:\\Program Files\\nodejs”） 删除 npm 全局安装的包（”C:\\Users&lt;user&gt;\\AppData\\Roaming\\npm” 安装 nvm-windows 下载 重新安装全局包 安装完成后，必须为每个安装版本的node重新安装全局工具 使用 nvm-windows runs in an Admin shell. You’ll need to start powershell or Command Prompt as Administrator to use nvm-windows NVM for Windows is a command line tool. Simply type nvm in the console for help. The basic commands are: nvm arch [32|64]: Show if node is running in 32 or 64 bit mode. Specify 32 or 64 to override the default architecture. nvm install &lt;version&gt; [arch]: The version can be a node.js version or “latest” for the latest stable version. Optionally specify whether to install the 32 or 64 bit version (defaults to system arch). Set [arch] to “all” to install 32 AND 64 bit versions. nvm list [available]: List the node.js installations. Type available at the end to show a list of versions available for download. nvm on: Enable node.js version management. nvm off: Disable node.js version management (does not uninstall anything). nvm proxy [url]: Set a proxy to use for downloads. Leave [url] blank to see the current proxy. Set [url] to “none” to remove the proxy. nvm uninstall &lt;version&gt;: Uninstall a specific version. nvm use &lt;version&gt; [arch]: Switch to use the specified version. Optionally specify 32&#x2F;64bit architecture. nvm use will continue using the selected version, but switch to 32&#x2F;64 bit mode based on the value supplied to . For information about using use in a specific directory (or using .nvmrc), please refer to issue #16. nvm root &lt;path&gt;: Set the directory where nvm should store different versions of node.js. If is not set, the current root will be displayed. nvm version: Displays the current running version of NVM for Windows. nvm node_mirror &lt;node_mirror_url&gt;: Set the node mirror.People in China can use https://npm.taobao.org/mirrors/node/ nvm npm_mirror &lt;npm_mirror_url&gt;: Set the npm mirror.People in China can use https://npm.taobao.org/mirrors/npm/","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://wqdy.top/tags/nodejs/"}]},{"title":"使用 Fiddler 向指定页面中注入 js 或修改页面内容, 本地文件/目录响应请求","slug":"前端/调试/使用fiddler向指定页面中注入js或修改页面内容, 线上请求映射到本地开发环境","date":"13/01/2020","updated":"13/01/2020","comments":true,"path":"433.html","link":"","permalink":"https://wqdy.top/433.html","excerpt":"","text":"修改线上页面内容有时候调试网页，需要在第三方页面中注入点 js 或修改一些代码，来进行自己的测试，可以使用 FiddlerScript 修改页面内容 使用方法如下 打开 fiddler 选择右边的 FiddlerScript 选项卡, 或者从菜单 - Rules(规则) - Customize Rules(自定义规则) 打开 点击 Go to(转到) - 选择 OnBeforeResponse 添加如下代码 static function OnBeforeResponse(oSession: Session) &#123; // ... // 判断如果是百度或是请求url中包含 baidu.com 的响应就在head前面添加一个 js 弹窗 if (oSession.HostnameIs(&#x27;www.baidu.com&#x27;) || oSession.uriContains(&#x27;baidu.com&#x27;) &amp;&amp; oSession.oResponse.headers.ExistsAndContains(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;)) &#123; // 解码响应内容 oSession.utilDecodeResponse() // 替换内容 oSession.utilReplaceInResponse(&#x27;&lt;/head&gt;&#x27;, &#x27;&lt;script&gt;alert(&quot;哈哈&quot;);&lt;/script&gt;&lt;/head&gt;&#x27;) &#125;&#125; 如果要替换的内容比较多或比较复杂，可以使用正则替换，替换方式如下 // 解码响应内容oSession.utilDecodeResponse()var oBody = System.Text.Encoding.UTF8.GetString(oSession.responseBodyBytes)// 使用正则进行替换var oRegEx = /&lt;\\/head&gt;/gioBody = oBody.replace(oRegEx, &#x27;&lt;script&gt;alert(1);&lt;/script&gt;&lt;/head&gt;&#x27;)//设置新的响应内容oSession.utilSetResponseBody(oBody) 最后点击左上角的 Save Script(保存) 即可 线上请求映射到本地开发环境 本地文件响应 编辑 FiddlerScript 添加如下代码 static function OnBeforeResponse(oSession: Session) &#123; // 如果请求 url 中包含 nav.js 就用 D:/nav.js 来响应 if (oSession.uriContains(&#x27;nav.js&#x27;)) &#123; oSession[&#x27;x-replywithfile&#x27;] = &#x27;D:/nav.js&#x27; &#125;&#125; 除了编辑 FiddlerScript，也可以选择在右侧打开 AutoResponder(自动回复器) 选项卡（参考第三点） ，添加规则并启用规则，效果相同 本地目录响应 原理同响应单个文件，只是封装了方法批量替换 static function OnBeforeResponse(oSession: Session) &#123; if (m_Hide304s &amp;&amp; oSession.responseCode == 304) &#123; oSession[&#x27;ui-hide&#x27;] = &#x27;true&#x27; &#125; var domain: String = &#x27;http://online.com/static/&#x27; // 本地目录 注意使用 &#x27;/&#x27; 代替 &#x27;\\&#x27; var folder: String = &#x27;D:/static/&#x27; AutoResponseFolder(oSession, domain, folder)&#125;static function AutoResponseFolder (oSession: Session, domain: String, folder: String) &#123; // 获取当前对话的完整URL var fullUrl: String = oSession.fullUrl if (fullUrl.StartsWith(domain)) &#123; var localPath: String = fullUrl.replace(domain, folder) // 设置延迟 // oSession[&#x27;response-trickle-delay&#x27;] = 1000 oSession[&#x27;x-replywithfile&#x27;] = localPath // FiddlerObject.log(localPath) &#125;&#125; 替换整个线上环境为本地开发环境 例如将所有 http://online.com 上的请求替换成本地 localhost，可以做如下： 在 AutoResponder(自动回复器) 选项卡中，添加如下规则：regex:(?insx)http://online.com\\/(?&lt;name&gt;.+)$ &#x3D;&gt; http://localhost/$&#123;name&#125; 使用 Stave 插件批量映射 下载地址：https://code.google.com/archive/p/stave/downloads","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"fiddler","slug":"fiddler","permalink":"https://wqdy.top/tags/fiddler/"},{"name":"调试","slug":"调试","permalink":"https://wqdy.top/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"SEO工具之Xenu-网站死链接检测","slug":"其他/软件/SEO工具之Xenu-网站死链接检测","date":"10/01/2020","updated":"10/01/2020","comments":true,"path":"411.html","link":"","permalink":"https://wqdy.top/411.html","excerpt":"","text":"网站建立的时间久了，有时候删除过期的文章，会造成链接无法正常访问，或者网站使用了图床，图片不能正常访问等。如果一个网站存在大量死链接，会严重影响用户的正常浏览，也影响搜索引擎爬取网站，对网站优化排名不利 Xenu是一款出色的网站死链接检测工具，检测网页中的链接、图片、js、css等是否存在损坏的链接 xenu 下载 http://home.snafu.de/tilman/xenulink.html","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[{"name":"seo","slug":"seo","permalink":"https://wqdy.top/tags/seo/"}]},{"title":"wordpress 站点更换域名","slug":"其他/wordpress/wordpress-站点更换域名","date":"02/01/2020","updated":"02/01/2020","comments":true,"path":"386.html","link":"","permalink":"https://wqdy.top/386.html","excerpt":"","text":"假设旧域名是a.com，新域名为b.com，修改数据库 sql 如下 UPDATE wp_options SET option_value = REPLACE(option_value, &#x27;http://a.com&#x27;, &#x27;http://b.com&#x27;) WHERE option_name = &#x27;home&#x27; OR option_name = &#x27;siteurl&#x27;;UPDATE wp_posts SET post_content = REPLACE (post_content, &#x27;http://a.com&#x27;, &#x27;http://b.com&#x27;);UPDATE wp_postmeta SET meta_value = REPLACE (meta_value, &#x27;http://a.com&#x27;,&#x27;http://b.com&#x27;);UPDATE wp_comments SET comment_content = REPLACE (comment_content, &#x27;http://a.com&#x27;, &#x27;http://b.com&#x27;);UPDATE wp_comments SET comment_author_url = REPLACE (comment_author_url, &#x27;http://a.com&#x27;, &#x27;http://b.com&#x27;);UPDATE wp_posts SET guid = REPLACE (guid, &#x27;http://a.com&#x27;, &#x27;http://b.com&#x27;) WHERE post_type = &#x27;attachment&#x27;;","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/tags/wordpress/"}]},{"title":"vue 项目中使用 axios.all 处理并发请求报 \"TypeError: this.$axios.all is not a function\" 异常解决方法","slug":"前端/vue/vue-项目中使用axios.all处理并发请求报typeerror this.$axios.all is not a function异常解决方法","date":"27/12/2019","updated":"27/12/2019","comments":true,"path":"384.html","link":"","permalink":"https://wqdy.top/384.html","excerpt":"","text":"axios&#x2F;index.js 部分配置如下 // axios/index.jsimport axios from &#x27;axios&#x27;const Axios = axios.create(&#123; // ...&#125;) 原因： axios 实例没有 all 这个方法，all 是 axios 的静态方法 所以解决方式就是将该方法手动挂载到 Axios 实例上即可 在 axios/index.js 添加如下配置 // axios/index.jsimport axios from &#x27;axios&#x27;const Axios = axios.create(&#123; // ...&#125;)+ Axios.all = axios.all+ Axios.spread = axios.spread 附 axios 并发多个请求方式： function request1 () &#123; return axios.get(&#x27;/user/12345&#x27;)&#125;function request2 () &#123; return axios.get(&#x27;/user/12345/permissions&#x27;)&#125;axios.all([request1(), request2()]) .then(axios.spread((res1, res2) =&gt; &#123; // 两个请求现在都执行完成 // acct、perms 分别为两个请求的结果 &#125;))","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wqdy.top/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://wqdy.top/tags/axios/"}]},{"title":"下载神器 Internet Download Manager 中文破解版","slug":"其他/软件/下载神器-internet-download-manager-中文破解版","date":"22/12/2019","updated":"22/12/2019","comments":true,"path":"366.html","link":"","permalink":"https://wqdy.top/366.html","excerpt":"","text":"Internet Download Manager (简称IDM) 是 Windows 平台老牌而功能强大的多线程下载工具，支持多媒体下载、自动捕获链接、自动识别文件名、静默下载、批量下载、计划下载任务、站点抓取、队列，支持IE, Opera, Firefox, Chrome等所有流行的浏览器，如果启用高级集成，则可以捕获和接管从任何程序的下载。 破解版下载地址 Internet Download Manager 6.38.16Internet Download Manager 6.35.18链接：https://pan.baidu.com/s/1NQmnqEGAfCu416zCwX-ATA提取码：wqdy 安装说明 下载完成后解压，运行安装程序，安装完就是注册版 配合插件使用 谷歌浏览器插件安装方法：找到你的 IMD 安装目录 注意是安装好后 找到 IDMGCExt.crx IDMGCExt59.crx2 个文件,选择 IDMGCExt.crx 拖动到谷歌浏览器,如果装不上选择 IDMGCExt59.crx 能装上! 提醒：某些网盘无法使用 IDM 下载的解决办法：下载时，按住 Alt 键，再点击下载按钮就不会调用 IDM 了！ 有能力的建议支持正版","categories":[{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"}],"tags":[{"name":"下载","slug":"下载","permalink":"https://wqdy.top/tags/%E4%B8%8B%E8%BD%BD/"},{"name":"idm","slug":"idm","permalink":"https://wqdy.top/tags/idm/"}]},{"title":"将 html 内容转换成图片总结 html2canvas与dom-to-image","slug":"前端/前端库/html-dom-转换成图片总结","date":"17/12/2019","updated":"17/12/2019","comments":true,"path":"355.html","link":"","permalink":"https://wqdy.top/355.html","excerpt":"","text":"html2canvashtml2canvas 基本使用 npm install html2canvas import html2canvas from &#x27;html2canvas&#x27; // 语法// html2canvas(element, options)html2canvas(document.body).then(function(canvas) &#123; // document.body.appendChild(canvas) let dataURL = canvas.toDataURL(&#x27;image/png&#x27;) // dataURL 为 base64 图片 // var img = new Image() // img.src = dataURL // document.body.appendChild(img)&#125;) 常用配置使用示例 var options = &#123; dpi: 192, scale: 2, // 放大 // logging: true, //日志开关，便于查看html2canvas的内部执行流程 useCORS: true // 开启跨域配置, (跨域图片，转换的时候会将跨域图片识别为空白,因此需要开启此选项)&#125;html2canvas(document.querySelector(&#x27;#app&#x27;), options).then(canvas =&gt; &#123; document.body.appendChild(canvas)&#125;) html2canvas 生成图片模糊问题 html2canvas 第二个参数配置 scale 和 dpi, 参考 如果要生成的 dom 中有背景图片，将背景图片换成 div 包裹 img 标签形式，不要通过css设置成background dom-to-imagedom-to-image 基本使用 npm install dom-to-image /* in ES 6 */import domtoimage from &#x27;dom-to-image&#x27;/* in ES 5 */var domtoimage = require(&#x27;dom-to-image&#x27;) var node = document.getElementById(&#x27;my-node&#x27;)domtoimage .toPng(node) .then(function(dataUrl) &#123; var img = new Image() img.src = dataUrl document.body.appendChild(img) &#125;) .catch(function(error) &#123; console.error(&#x27;oops, something went wrong!&#x27;, error) &#125;) 将 base64 转换成 file 对象用于上传到服务器 b64ToFile(dataurl) &#123; let arr = dataurl.split(&#x27;,&#x27;) let mime = arr[0].match(/:(.*?);/)[1] let bstr = atob(arr[1]) let n = bstr.length let u8arr = new Uint8Array(n) while (n--) &#123; u8arr[n] = bstr.charCodeAt(n) &#125; let file = new File([u8arr], &#x27;filename.png&#x27;, &#123;type:mime&#125;)&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wqdy.top/tags/html/"},{"name":"canvas","slug":"canvas","permalink":"https://wqdy.top/tags/canvas/"}]},{"title":"dux 主题自定义代码高亮-使用 highlight.js","slug":"其他/wordpress/dux-主题自定义代码高亮-使用-highlight-js","date":"14/12/2019","updated":"14/12/2019","comments":true,"path":"338.html","link":"","permalink":"https://wqdy.top/338.html","excerpt":"","text":"dux 主题默认使用 Google Code Prettify 实现代码高亮 下载在 highlight 官网下载 js 和 css 文件 可以使用官网提供的 CDN 链接，也可以根据需要定制自己需要的语言 选择自己喜欢的主题，在这里进行下载 将 highlight.main.js 文件放到主题的 /js/libs/ 文件夹中 编辑主题文件编辑 /js/loader.js 文件，将 highlight.min.js 引入 tbquire.config(&#123; baseUrl: jsui.uri + &#x27;/js&#x27;, urlArgs: &#x27;ver=&#x27; + jsui.ver, paths: &#123; &#x27;swiper&#x27; : &#x27;libs/swiper.min&#x27;, &#x27;jquery.cookie&#x27; : &#x27;libs/jquery.cookie.min&#x27;, &#x27;jsrender&#x27; : &#x27;libs/jsrender.min&#x27;, &#x27;router&#x27; : &#x27;libs/router.min&#x27;, &#x27;lazyload&#x27; : &#x27;libs/lazyload.min&#x27;, &#x27;prettyprint&#x27; : &#x27;libs/prettyprint&#x27;,+ &#x27;highlight&#x27; : &#x27;libs/highlight.min&#x27;, &#x27;ias&#x27; : &#x27;libs/ias.min&#x27;, &#x27;main&#x27; : &#x27;main&#x27;, &#x27;comment&#x27; : &#x27;comment&#x27;, &#x27;user&#x27; : &#x27;user&#x27; &#125;&#125;) 编辑 /js/main.js 注释掉 prettyprint 部分 /* * prettyprint * ====================================================*/-$(&#x27;pre&#x27;).each(function()&#123;- if( !$(this).attr(&#x27;style&#x27;) ) $(this).addClass(&#x27;prettyprint&#x27;)-&#125;)-if( $(&#x27;.prettyprint&#x27;).length )&#123;- tbquire([&#x27;prettyprint&#x27;], function(prettyprint) &#123;- prettyPrint()- &#125;)-&#125;+/*+ * highlight+ * ====================================================+*/++$(&#x27;pre code&#x27;).forEach((block) =&gt; &#123;+ tbquire([&#x27;highlight&#x27;], function() &#123;+ hljs.highlightBlock(block)+&#125;) 此时 highlight 脚本已经生效，接下来就是应用 highlight 样式 应用 highlight 样式你可以选择将下载好的 css 文件打开，将样式拷贝到 &#x2F;libs&#x2F;css&#x2F;main.css 文件中 也可以在 wordpress后台-外观-自定义-添加额外css 中为主题定义样式","categories":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/tags/wordpress/"}]},{"title":"js 不写行尾分号注意事项","slug":"前端/js/js-不写行尾分号注意事项","date":"01/11/2019","updated":"01/11/2019","comments":true,"path":"1656.html","link":"","permalink":"https://wqdy.top/1656.html","excerpt":"","text":"若行首为 (、[、/、+、-，会与上一行代码相接，此时需要在行首添加分号++、--在上下两行都不加分号的情况下，与下一行代码相接return 语句在执行时会在末尾加分号","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"+0 -0 Number.NaN NaN undefined null ''  相等性判断","slug":"前端/js/js-0-0-number-nan-nan-undefined-null-相等性判断","date":"28/10/2019","updated":"28/10/2019","comments":true,"path":"397.html","link":"","permalink":"https://wqdy.top/397.html","excerpt":"","text":"主要区分 +0 和 -0、NaN 和 NaN 在不同情况下的相等性区别== === console.log(+0 === -0) // trueconsole.log(NaN == NaN) // false NaN 不与任何值相等，包括自身console.log(undefined == null) // trueconsole.log(undefined === null) // falseconsole.log(NaN === NaN) // falseconsole.log(Number.NaN === NaN) // false Object.is() 方法判断两个值是否是相同的值。比较时不会做类型转换，这与 == === 运算符的判定方式都不一样 Object.is(+0, -0) // falseObject.is(0, -0) // falseObject.is(0, +0) // trueObject.is(-0, -0) // trueObject.is(undefined, undefined) // trueObject.is(null, null) // trueObject.is(Number.NaN, Number.NaN) // trueObject.is(Number.NaN, NaN) // trueObject.is(NaN, NaN) // trueObject.is(NaN, 0 / 0) // true 在 Set， Map 内部，两个 NaN 是相等, +0 和 -0 也是相等的 let a = [NaN, NaN, undefined, undefined, +0, -0, &#123;&#125;, &#123;&#125;]let b = new Set(a) // &#123;NaN, undefined, 0, &#123;&#125;, &#123;&#125;&#125; 总结： 比较运算符中 +0 和 -0 是相等的、NaN 和 NaN是不等的 Object.is() 方法中 +0 和 -0 是不相等的、NaN 和 NaN是相等的 在 Set， Map 内部， +0 和 -0 是相等的、NaN 和 NaN 也是相等的","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"window.setTimeout 第三个参数","slug":"前端/js/js-window-settimeout-第三个参数","date":"28/10/2019","updated":"28/10/2019","comments":true,"path":"1659.html","link":"","permalink":"https://wqdy.top/1659.html","excerpt":"","text":"MDN上关于 setTimeout 介绍 语法 var timeoutID = scope.setTimeout(function[, delay, param1, param2, ...])// delay 可选 默认 0// param1, ..., paramN 可选 ，附加参数，一旦定时器到期，他会作为参数传递给 function// 返回值timeoutID是一个正整数，表示定时器的编号 应用 for (var i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer(j) &#123; console.log(j) &#125;, i * 1000, i )&#125;// 会立即返回一个 timeid// 1// 2// 3// 4// 5","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"speedtest 测速脚本","slug":"运维/speedtest-测速脚本","date":"25/10/2019","updated":"25/10/2019","comments":true,"path":"230.html","link":"","permalink":"https://wqdy.top/230.html","excerpt":"","text":"wget https://raw.github.com/sivel/speedtest-cli/master/speedtest.py# 添加权限chmod a+rx speedtest.py# 简单的使用方法python speedtest.py# 生成一张图片，并分享给其他人python speedtest.py --share# 在默认情况下，SpeedTest是选择离测试机最近的一个节点进行测试的，如果你想要自定义测试到某个地区的上传/下载速率，那首先列出目前可用的SpeedTest服务器：python speedtest.py --list# 此时会列出所有的服务器（按照距离远近进行排列）# 如果想一点一点的列出服务器，请输入：python speedtest.py --list|more# 如果你想列出指定地区的测试节点，可以使用python speedtest.py --list | grep Chinapython speedtest.py --server 22991# 如果是要生成分享的图片，那就加上 sharepython speedtest.py --server 11599 --share","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wqdy.top/tags/linux/"}]},{"title":"预解析, async, defer 以及 preload","slug":"前端/html/html-预解析-async-defer-以及-preload","date":"24/10/2019","updated":"24/10/2019","comments":true,"path":"391.html","link":"","permalink":"https://wqdy.top/391.html","excerpt":"","text":"预解析https://developer.mozilla.org/zh-CN/docs/Web/HTML/Optimizing_your_pages_for_speculative_parsing link 标签 ref 属性值 prefetch preload 用于预加载&lt;link ref=&quot;preload&quot; href=&quot;*.js&quot; as=&quot;script&quot; /&gt;&lt;!-- preload需要写上正确的as属性,如果不写或错误，等同于XHR请求，优先级非常低 --&gt;&lt;link rel=&quot;preload&quot; href=&quot;font.woff&quot; as=&quot;font&quot; crossorigin /&gt;&lt;!-- 预加载字体你还必须设置crossorigin 属性 --&gt; preload 是用于预加载当前页的资源，浏览器会优先加载它们(加载后并不执行，在需要执行的时候再执行) 将加载和执行分离开，可不阻塞渲染和 document 的 onload 事件提前加载指定资源，不再出现依赖的 font 字体隔了一段时间才刷出 prefetch 是用于预加载后续页面使用的资源，浏览器也会加载它们，但优先级不高 避免混用 preload 和 prefetch，混用的话，并不会复用资源，而是会重复加载 插入的脚本（无论在什么位置）在网络优先级中是很低级 script 标签的 defer 和 async 异步加载这两个属性都告诉浏览器，它可以 “在后台” 加载脚本的同时继续解析 HTML，并在脚本加载完之后再执行。这样，脚本下载就不会阻塞 DOM 构建和页面渲染了 defer 和 async 之间的不同是他们开始执行脚本的时机的不同 async(H5) 一旦脚本可用，则会异步执行（仅适用于外部脚本） 脚本在它们完成下载完成后的第一时间执行，如果一个指定 async 的脚本很快就完成了下载，那么它的执行会阻塞 DOM 构建以及所有在之后才完成下载的同步脚本。 defer 规定当页面已完成解析后，执行脚本（仅适用于外部脚本） 脚本会按照它在 HTML 中出现的顺序执行，并且不会阻塞解析。","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"Github 开源项目收集","slug":"前端/github-开源项目收集","date":"21/10/2019","updated":"21/10/2019","comments":true,"path":"356.html","link":"","permalink":"https://wqdy.top/356.html","excerpt":"","text":"知识库前端面试题及答案汇总 CS-Notes 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++ TypeScript 入门教程 js 函数式编程(英文) 中文翻译 TypeScript Deep Dive(英文) 深入理解 TypeScript(中文翻译) TypeScript 手册(官方手册中文翻译版) 前端进阶之道前端进阶之道-在线阅读 Vue.js 技术揭秘 工具库DOM to Image 使用 HTML5 canvas 从 DOM 节点生成图像 v-tooltip vue-analytics Vue plugin for Google Analytics Dexie.js A Minimalistic Wrapper for IndexedDB 2md A Converter for Copy&#x2F;Paste content to Markdown marked A markdown parser and compiler. Built for speed single-spa A javascript framework for front-end microservices path-to-regexp Turn a path string such as /user/:name into a regular expression Draft.js Rich Text Editor Framework for React Node.js Best Practices https://github.com/goldbergyoni/nodebestpractices html5-boilerplate 前端模板 https://github.com/h5bp/html5-boilerplate Airbnb 提供的非常精确和专业的风格指南https://github.com/airbnb/javascript","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"github","slug":"github","permalink":"https://wqdy.top/tags/github/"}]},{"title":"使用 axios 导致 cookie 丢失问题","slug":"前端/前端库/axios-cookie-丢失问题","date":"11/10/2019","updated":"11/10/2019","comments":true,"path":"402.html","link":"","permalink":"https://wqdy.top/402.html","excerpt":"","text":"问题：使用 axios 发送请求会拦截响应头中的 set-cookie，导致 cookie 丢失 https://github.com/axios/axios/issues/953 在控制台中也找不到 cookie console.log(res.headers[&#x27;set-cookie&#x27;]) // undefinedconsole.log(document.cookie) // &#x27;&#x27; 解决方式：修改 axios 配置 axios.defaults.withCredentials = true // 默认是 false// Axios.interceptors.request.use(// config =&gt; &#123;// config.withCredentials = true // 添加// return config// &#125;)axios.create(&#123; withCredentials: true // 表示跨域请求时是否需要使用凭证 默认 false&#125;) 设置 withCredentials = true 会造成跨域，需要使用代理解决跨域问题","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"},{"name":"axios","slug":"axios","permalink":"https://wqdy.top/tags/axios/"}]},{"title":"google 浏览器插件离线安装方法","slug":"其他/chrome-插件离线安装方法","date":"09/10/2019","updated":"09/10/2019","comments":true,"path":"372.html","link":"","permalink":"https://wqdy.top/372.html","excerpt":"","text":"谷歌浏览器扩展程序管理页面 chrome:&#x2F;&#x2F;extensions&#x2F; 方式一 .crx打开扩展程序管理页面，将 .crx 格式插件拖入浏览器即可 若安装时出现“程序包无效 CRX-HEADER-INVALID”的报错信息，或出现 该扩展程序未列在 Chrome 网上应用店中，并可能是在您不知情的情况下添加的，且插件无法启用，可使用方式二安装 方式二 .zip将 .crx 插件后缀改成 .zip，或下载 .zip 格式插件 扩展程序管理页面，开启开发者模式，再按 F5 刷新一下，将 .zip 格式插件拖入浏览器，或者将 .zip 格式插件解压，点击加载已解压的扩展程序 其他禁用 Chrome 的“请停用以开发者模式运行的扩展程序”提示的方法","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://wqdy.top/tags/chrome/"}]},{"title":"v2ray 搭建配置教程","slug":"其他/学习强国/v2ray-搭建教程及配置","date":"08/10/2019","updated":"05/09/2021","comments":true,"path":"226.html","link":"","permalink":"https://wqdy.top/226.html","excerpt":"","text":"相关链接v2ray 用户手册 githubV2Ray 白话文指南 github在线配置生成v2ray web面板 v2-uiSSPanel-Uim 节点管理面板&#x2F;用户管理系统使用宝塔部署 SSPanel 魔改版 安装一键脚本安装bash &lt;(curl -s -L https://git.io/v2ray.sh) 安装完成后，输入 v2ray 即可管理 V2Ray 管理命令 v2ray info # 查看 V2Ray 配置信息v2ray config # 修改 V2Ray 配置v2ray link # 生成 V2Ray 配置文件链接v2ray infolink # 生成 V2Ray 配置信息链接v2ray qr # 生成 V2Ray 配置二维码链接v2ray ss # 修改 Shadowsocks 配置v2ray ssinfo # 查看 Shadowsocks 配置信息v2ray ssqr # 生成 Shadowsocks 配置二维码链接v2ray status # 查看 V2Ray 运行状态v2ray start # 启动 V2Rayv2ray stop # 停止 V2Rayv2ray restart # 重启 V2Rayv2ray log # 查看 V2Ray 运行日志v2ray update # 更新 V2Rayv2ray update.sh # 更新 V2Ray 管理脚本v2ray uninstall # 卸载 V2Ray 官方脚本官方脚本 # 安装bash &lt;(curl -L -s https://install.direct/go.sh)# 安装完成后记住 PORT UUID，忘记也没关系可以使用下面命令查看# 启动systemctl start v2ray# 查看端口 Portcat /etc/v2ray/config.json | grep port# 查看 id (UUID)cat /etc/v2ray/config.json | grep id 卸载如果脚本不支持卸载，可使用以下方法手动卸载 其中 systemd 和 sysv 二选一，取决于你的系统 #停用并卸载服务(systemd)systemctl stop v2raysystemctl disable v2ray#停用并卸载服务(sysv)service v2ray stopupdate-rc.d -f v2ray remove# 删除文件# 配置文件rm -rf /etc/v2ray/*# 程序rm -rf /usr/bin/v2ray/*# 日志rm -rf /var/log/v2ray/*# systemd 启动项rm -rf /lib/systemd/system/v2ray.service# sysv 启动项rm -rf /etc/init.d/v2ray Nginx + WebSocket + TLS参考：https://guide.v2fly.org/advanced/wss_and_web.html V2Ray 脚本可直接使用 Caddy 配置 WebSocket + TLS 传输协议，但是如果想在 vps 上同时使用 nginx 跑一个小博客，那么会导致 caddy 和 nginx 监听端口时发生冲突，这显然不是我们想要的 所以就要将 TLS 部分放到 nginx 程序里面去实现 首先使用官方脚本安装好服务端程序申请 SSL 证书 如果使用宝塔面板，可以通过面板一键生成 ssl 证书，快速配置 nginx+ssl 申请免费 SSL 证书参考这里 nginx 配置 如果使用宝塔面板，可以通过面板一键生成 ssl 证书，快速配置 nginx+ssl server &#123; listen 443 ssl; listen [::]:443 ssl; server_name aaa.com; # 域名 # 配置ssl ssl_certificate /etc/letsencrypt/aaa.com.crt; # 证书 ssl_certificate_key /etc/letsencrypt/aaa.com.key; # 密钥 ssl_session_timeout 1d; ssl_session_cache shared:MozSSL:10m; ssl_session_tickets off; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384; ssl_prefer_server_ciphers off; # location /ray &#123; # 与 V2Ray 服务端配置中的 path 保持一致 if ($http_upgrade != &quot;websocket&quot;) &#123; # WebSocket协商失败时返回404 return 404; &#125; proxy_redirect off; proxy_pass http://127.0.0.1:2333; # 假设 WebSocket 监听在环回地址的 2333 端口上 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $host; # Show real IP in v2ray access.log proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; v2ray 服务端配置&#x2F;etc&#x2F;v2ray&#x2F;config.json &#123; &quot;inbounds&quot;: [ &#123; &quot;port&quot;: 2333, // WebSocket 监听端口 &quot;listen&quot;: &quot;127.0.0.1&quot;, // 只监听 127.0.0.1，避免除本机外的机器探测到开放了 22445 端口 &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: &#123; &quot;clients&quot;: [ &#123; &quot;id&quot;: &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxx&quot;, &quot;alterId&quot;: 32 &#125; ] &#125;, &quot;streamSettings&quot;: &#123; &quot;network&quot;: &quot;ws&quot;, &quot;wsSettings&quot;: &#123; &quot;path&quot;: &quot;/ray&quot; &#125; &#125; &#125; ], &quot;outbounds&quot;: [ &#123; &quot;protocol&quot;: &quot;freedom&quot;, &quot;settings&quot;: &#123;&#125; &#125; ]&#125; 客户端配置&#123; &quot;inbounds&quot;: [ &#123; &quot;port&quot;: 1080, &quot;listen&quot;: &quot;127.0.0.1&quot;, &quot;protocol&quot;: &quot;socks&quot;, &quot;sniffing&quot;: &#123; &quot;enabled&quot;: true, &quot;destOverride&quot;: [&quot;http&quot;, &quot;tls&quot;] &#125;, &quot;settings&quot;: &#123; &quot;auth&quot;: &quot;noauth&quot;, &quot;udp&quot;: false &#125; &#125; ], &quot;outbounds&quot;: [ &#123; &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: &#123; &quot;vnext&quot;: [ &#123; &quot;address&quot;: &quot;aaa.com&quot;, // nginx server_name &quot;port&quot;: 443, &quot;users&quot;: [ &#123; &quot;id&quot;: &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxx&quot;, // 同服务端配合 &quot;alterId&quot;: 32 // 同服务端配合 &#125; ] &#125; ] &#125;, &quot;streamSettings&quot;: &#123; &quot;network&quot;: &quot;ws&quot;, &quot;security&quot;: &quot;tls&quot;, &quot;wsSettings&quot;: &#123; &quot;path&quot;: &quot;/ray&quot; // 与 V2Ray 服务端配置中的 path 保持一致 &#125; &#125; &#125; ]&#125; Nginx+vmess+ws+tls&#x2F; http2 over tls 一键安装脚本https://github.com/wulabing/V2Ray_ws-tls_bash_onekey 证书签发错误的原因是签发服务器已经不认默认的邮箱名:@example.com, - curl https://get.acme.sh | sh+ curl https://get.acme.sh | sh -s email=admin@youremail.com 添加-s 参数, 把你的邮箱放进去 另外如果脚本全部正常跑完, 还是不能用的,请用这个网站 https://www.matools.com/port 检查下你的端口是不是已经被封了 v2ray 配置好后无法连接解决办法# 检查端口占用情况yum install net-toolsnetstat -apn | grep v2ray# 发现v2ray并没有监听我们的公网IP，只监听了一个IPV6：# tcp6 0 0 :::40682 :::* LISTEN 19553/v2ray# unix 3 [ ] STREAM CONNECTED 80938 19553/v2ray# 修改配置文件添加 listen 字段# v2ray默认配置文件在/etc/v2ray/conf.json&quot;inbound&quot;: &#123; &quot;listen&quot;:&quot;12.34.56.78&quot;,&#125;# v2ray 测试配置文件是否正确/usr/bin/v2ray/v2ray --test --config /etc/v2ray/config.json 客户端客户端可以参考这里","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"input file 控件","slug":"前端/html/html-input-file-控件","date":"27/09/2019","updated":"27/09/2019","comments":true,"path":"406.html","link":"","permalink":"https://wqdy.top/406.html","excerpt":"","text":"限制上传文件类型&lt;input id=&quot;File1&quot; type=&quot;file&quot; accept=&quot;.xls,.doc,.txt,.pdf&quot; /&gt; 文件类型 .3gpp audio/3gpp， video/3gpp 3GPP Audio/Video .ac3 audio/ac3 AC3 Audio .asf allpication/vnd.ms-asf Advanced Streaming Format .au audio/basic AU Audio .css text/css Cascading Style Sheets .csv text/csv Comma Separated Values .doc application/msword MS Word Document .dot application/msword MS Word Template .dtd application/xml-dtd Document Type Definition .dwg image/vnd.dwg AutoCAD Drawing Database .dxf image/vnd.dxf AutoCAD Drawing Interchange Format .gif image/gif Graphic Interchange Format .htm text/html HyperText Markup Language .html text/html HyperText Markup Language .jp2 image/jp2 JPEG-2000 .jpe image/jpeg JPEG .jpeg image/jpeg JPEG .jpg image/jpeg JPEG .js text/javascript， application/javascript JavaScript .json application/json JavaScript Object Notation .mp2 audio/mpeg， video/mpeg MPEG Audio/Video Stream， Layer II .mp3 audio/mpeg MPEG Audio Stream， Layer III .mp4 audio/mp4， video/mp4 MPEG-4 Audio/Video .mpeg video/mpeg MPEG Video Stream， Layer II .mpg video/mpeg MPEG Video Stream， Layer II .mpp application/vnd.ms-project MS Project Project .ogg application/ogg， audio/ogg Ogg Vorbis .pdf application/pdf Portable Document Format .png image/png Portable Network Graphics .pot application/vnd.ms-powerpoint MS PowerPoint Template .pps application/vnd.ms-powerpoint MS PowerPoint Slideshow .ppt application/vnd.ms-powerpoint MS PowerPoint Presentation .rtf application/rtf， text/rtf Rich Text Format .svf image/vnd.svf Simple Vector Format .tif image/tiff Tagged Image Format File .tiff image/tiff Tagged Image Format File .txt text/plain Plain Text .wdb application/vnd.ms-works MS Works Database .wps application/vnd.ms-works Works Text Document .xhtml application/xhtml+xml Extensible HyperText Markup Language .xlc application/vnd.ms-excel MS Excel Chart .xlm application/vnd.ms-excel MS Excel Macro .xls application/vnd.ms-excel MS Excel Spreadsheet .xlt application/vnd.ms-excel MS Excel Template .xlw application/vnd.ms-excel MS Excel Workspace .xml text/xml， application/xml Extensible Markup Language .zip aplication/zip Compressed Archive 清空 value使用 input file 进行文件上传时，重复选择相同文件时，change 事件不再触发解决方式：手动将 file 的 value 值设置为空 &lt;input type=&quot;file&quot; id=&quot;file&quot; accept=&quot;image/gif,image/jpeg&quot; @change=&quot;uploadFile($event)&quot; /&gt; $event.target.value = &#x27;&#x27;// 或var file = document.getElementById(&#x27;file&#x27;)file.value = &#x27;&#x27;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"Chrome Developer Tools 使用技巧","slug":"前端/调试/chrome-developer-tools-使用技巧","date":"25/08/2019","updated":"25/08/2019","comments":true,"path":"419.html","link":"","permalink":"https://wqdy.top/419.html","excerpt":"","text":"console.log()占位符 %o 它接受对象，%s 接受字符串，%d 表示小数或整数，%c CSS 值的占位符,对应的后面的参数必须是 CSS 语句 如： console.log(&#x27;%s 的价格是 %d 磅 %d 便士&#x27;, &#x27;衬衫&#x27;, 9, 15) 输出：衬衫的价格是 9 磅 15 便士 如： console.log(&#x27;I am a %cbutton&#x27;, &#x27;color: white; background-color: orange; padding: 2px 5px; border-radius: 2px&#x27;) 输出：I am a button console.dir()console.warn()输出警告信息，字的颜色是黄色的，用于区分或过滤掉无用的输出 console.table()将数据以表格的形式输出，对于数据列表的输出更容易观察其数据结构，并且点击输出的表头可以对数据排序 第二个可选参数是需要输出的字段。默认输出所有字段 console.table(data) // 输出全部console.table(data, [&#x27;id&#x27;, &#x27;price&#x27;]) // 输出 data 中的 id price 字段 console.count()计数器，可以用来统计代码被执行的次数 for (let i = 0; i &lt; 5; i++) &#123; if (i % 2) &#123; console.count(&#x27;odds&#x27;) &#125;&#125; 输出结果为： odds: 1odds: 2 console.countReset() // 可以使用它重置计数器。 console.time()是一个用于跟踪操作时间的专用函数，可以用来跟踪 js 的执行时间 const a = () =&gt; &#123; console.time(&#x27;a&#x27;) // do something console.timeEnd(&#x27;a&#x27;)&#125;console.time()for (i = 0; i &lt; 10; ++i) &#123; a()&#125;console.timeEnd() 选择 DOM 元素 在谷歌开发控制台中, 可以使用 $(&#39;选择器&#39;) 类似于 jquery 的方式选择 DOM 元素 $(&#39;&#39;) 等效于 document.querySelector(&#39;&#39;)，这将返回 DOM 中与选择器匹配的第一个元素，可以使用 $$(tagName) 或 $$(.class)，选择 DOM 的所有元素并返回一个数组。可以通过下标获取指定的元素，例如，$$(&#39;.box&#39;) 获取具有类 box 的所有元素，$$(&#39;.box&#39;)[0]和 $$(&#39;.box&#39;)[1]分别获取第一个和第二个元素 inspect($(&#39;selector&#39;)) 将检查与选择器匹配的元素，并转到 Elements 选项卡 $0，$1，$2 等可以获取最近检查过的元素，即通过 $0 即可直接获取当前高亮的元素，$1 可以获取上一个高亮的元素 将页面转换为可编辑状态在 Console 中输入: document.body.contentEditable = true 之后页面中的内容即为可编辑状态，可以编辑 DOM 中的任何内容 查找与 DOM 中的元素关联的事件getEventListeners($(&#39;selector&#39;)) 返回一个对象数组，其中包含绑定到该元素的所有事件。你可以展开对象来查看事件 要找到特定事件的侦听器，可以这样做: getEventListeners($(&#x27;selector&#x27;)).eventName[0].listener// 将显示与 id 为 btn 的元素的单击事件关联的侦听器getEventListeners($(&#x27;btn&#x27;)).click[0].listener 或 控制台 &#x3D;&gt; Element &#x3D;&gt; EventListeners https://segmentfault.com/q/1010000002892890 监控事件监视绑定到 DOM 中特定元素的事件，然后在它们被触发后立即将它们记录在控制台中 // 监控绑定到 &#x27;#box&#x27; 元素的所有事件monitorEvents($(&#x27;#box&#x27;))// 监控绑定到 &#x27;selector&#x27; 元素的 click 事件monitorEvents($(&#x27;#box&#x27;), &#x27;click&#x27;)// 监控绑定到 &#x27;selector&#x27; 元素的 click 和 focus 事件monitorEvents($(&#x27;#box&#x27;), [&#x27;click&#x27;, &#x27;focus&#x27;])// 停止监视unmonitorEvents($(&#x27;#box&#x27;)) 检索最后一个结果的值$_ 表示控制台中最近一次返回的值 1 + 1&gt; 2$_&gt; 2 断点调试 跳到下个断点, 如果后面没有断点了,那么代码直接执行完 单步调试 : 下一步 没有断点的话,函数就直接跳过 单步调试 : 进入函数 单步调试 : 跳出函数 单步调试 : 下一步 不管有没有断点,都会一步一步的走,纯碎的下一步 让所有的断点失效 自动根据错误断点","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://wqdy.top/tags/chrome/"}]},{"title":"临时邮箱手机号","slug":"其他/临时邮箱手机号","date":"18/08/2019","updated":"18/08/2019","comments":true,"path":"232.html","link":"","permalink":"https://wqdy.top/232.html","excerpt":"","text":"用于注册临时账号，保护隐私 临时邮箱 https://bccto.me/https://10minutemail.net/http://24mail.chacuo.net/http://www.yopmail.com/zh/https://shorttimemail.com/zh-Hans/https://temp-mail.org/zh/https://t.odmail.cn/https://9em.org/https://maildrop.cc https://eskiimo.com 匿名发送邮件 短信验证码平台 国内平台https://www.pdflibr.comhttps://www.visitorsms.com/cnhttps://www.becmd.comhttp://www.114sim.comhttps://yunduanxin.nethttp://www.smszk.comhttp://z-sms.comhttp://www.shejiinn.comhttps://sms.cngrok.com 国外平台 https://ch.freephonenum.comhttps://smsreceivefree.comhttps://zh.mytrashmobile.comhttps://www.receive-sms-online.infohttps://receiveasms.comhttps://sms-online.co/receive-free-smshttps://receive-sms.com","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"谷歌账号无法注册解决方式","slug":"其他/谷歌账号无法注册解决方式","date":"06/08/2019","updated":"06/08/2019","comments":true,"path":"206.html","link":"","permalink":"https://wqdy.top/206.html","excerpt":"","text":"无法注册原因 此电话号码无法用于进行验证 解决思路 通过其他页面或方式进入谷歌注册入口，如通过 Google Voice 或 Google Analysis 等进入 用安卓手机自带的电子邮件客户端申请 在选择邮箱时，切换 “改用我目前的邮件地址” 为 “注册新的 Gmail 邮箱” 选择适当的语言以及模式（页面左下角语言设置） Chrome 语言设置为 English-United States 成功案例 2019&#x2F;08&#x2F;06 小米手机-使用自带的电子邮件客户端-用国内手机号-QQ 邮箱-注册成功 2020&#x2F;01&#x2F;05 小米手机-使用自带的电子邮件客户端-用国内手机号-注册新的 Gmail 邮箱-注册成功 2020&#x2F;01&#x2F;19 苹果手机-使用自带的邮件客户端-国内手机号-注册新的 Gmail 邮箱-注册成功 2020&#x2F;12&#x2F;29 苹果手机-使用自带的邮件客户端-国内手机号(已被使用过)-注册新的 Gmail 邮箱-注册成功 2021&#x2F;04&#x2F;06 w10-谷歌浏览器 + WebRTC Leak Prevent插件（在无痕模式下启用 + IP handling policy:Disabled non-proxied UDp(froce proxy) ）-国内手机号(已被使用过)-注册新的 Gmail 邮箱-注册成功","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"google","slug":"google","permalink":"https://wqdy.top/tags/google/"}]},{"title":"icon 图标在 vue 项目中的使用","slug":"前端/vue/vue-icon图标的使用","date":"01/08/2019","updated":"13/10/2019","comments":true,"path":"2011.html","link":"","permalink":"https://wqdy.top/2011.html","excerpt":"","text":"参考链接：https://juejin.im/post/59bb864b5188257e7a427c09 使用 iconfont阿里开源图库 https://www.iconfont.cn/ 使用方法 https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d8d11a391&amp;helptype=code 下载代码到本地（也可以使用在线链接）打开 demo_index.html 使用说明，有三种使用方式 unicode font-class symbolunicode 方式： &amp;#x33; 这样，不直观，语意不明确，不支持多色图标font-class 方式： 使用 class 定义，有语意，需要注意命名空间的问题，也是不支持多色图标symbol 方式：使用 svg 不用再去请求 woff|eot|ttf| 这些字体库，且缩放不会失真，支持更加复杂的图标 symbol 方式使用步骤： 第一步：引入项目下面生成的 symbol 代码： &lt;script src=&quot;./iconfont.js&quot;&gt;&lt;/script&gt; 或通过 import 导入 import &#x27;./iconfont.js&#x27; 第二步：加入通用 CSS 代码： .icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125; 第三步：挑选相应图标并获取类名，应用于页面： &lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt; symbol 其实使用了 SVG Sprite 技术， 所有的 svg-sprite 都是通过 iconfont 的 iconfont.js 生成的，所以： 所有图标 icon 都很不直观，完全不知道哪个图标名对应什么图标，每次增删改图标，或者添加一些自定义的 svg 图标，只能将其也上传到 iconfont 和原有的图标放在一个项目库中，之后再重新下载，将整体 js 文件一起替换，而且也做不到按需加载 导出的 svg 包含大量的无用信息，例如编辑器源信息、注释等。通常包含其它一些不会影响渲染结果或可以移除的内容 vue cli3 项目使用 svg-sprite-loader 打包 svgvue cli3 默认使用 file-loader 处理 svg： /* config.module.rule(&#x27;svg&#x27;) */&#123; test: /\\.(svg)(\\?.*)?$/, use: [ /* config.module.rule(&#x27;svg&#x27;).use(&#x27;file-loader&#x27;) */ &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;static/img/[name].[hash:8].[ext]&#x27; &#125; &#125; ]&#125; 并路径指定为在 img 文件夹下，但我们的 svg 并不在 img 文件夹，而且 svg-sprite-loader 已经自带了 file-loader 的功能，所以，我们可以在我们自定义的 vue.config.js 文件下将 rule(svg) 清除： module.exports = &#123; chainWebpack: config =&gt; &#123; config.module.rule(&#x27;svg&#x27;).uses.clear() &#125;&#125; 或者添加忽略，然后加上自定义的 svg rule，最后的配置如下： /* 使用 svg-sprite-loader 处理 svg */// 默认规则忽略 src/icons 文件夹config.module .rule(&#x27;svg&#x27;) .exclude.add(path.resolve(__dirname, &#x27;src/icons&#x27;)) .end()// src/icons 文件夹下的 svg 使用 svg-sprite-loaderconfig.module .rule(&#x27;svg-sprite-loader&#x27;) .include.add(path.resolve(__dirname, &#x27;src/icons&#x27;)) .end() .test(/\\.svg$/) .use(&#x27;svg-sprite&#x27;) .loader(&#x27;svg-sprite-loader&#x27;) .options(&#123; symbolId: &#x27;icon-[name]&#x27; &#125;) .end() 之后可以通过如下方式使用 import &#x27;@/icons/qq.svg&#x27; &lt;!-- xlink:href=&quot;#icon-图标文件名 --&gt;&lt;svg&gt;&lt;use xlink:href=&quot;#icon-qq&quot; /&gt;&lt;/svg&gt; 使用缺点：需要手动导入图标 自动导入使用 webpack 的 require.context api require.context 语法 require.context(directory, (useSubdirectories = false), (regExp = /^\\.\\//))// directory：说明需要检索的目录// useSubdirectories：是否检索子目录// regExp: 匹配文件的正则表达式// Examples:require.context(&#x27;./test&#x27;, false, /\\.test\\.js$/)// 表示在 test 文件夹（不包含子目录）下面的找所有文件名以 .test.js 结尾的能被 require 的文件 自动引入 @&#x2F;icons 下面所有的图标 // 基础组件的自动化全局注册const requireComponent = require.context(&#x27;../../components&#x27;, false)// console.log(requireComponent.keys())requireComponent.keys().forEach(filename =&gt; &#123; const componentConfig = requireComponent(filename) // console.log(componentConfig) const componentName = filename .split(&#x27;/&#x27;) .pop() .replace(/\\.\\w+$/, &#x27;&#x27;) // console.log(componentName) Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig )&#125;) const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context(&#x27;@/icons&#x27;, false)requireAll(req) 之后直接将图标放入 @/icons 文件夹下就可以直接使用了，删改图标同理 优化 svg删除无用信息 svgo阿里云导出的 svg 是带有默认的 fill 的，导致图标不能继承父级元素的颜色,可以通过删除默认 fill 解决 安装 npm i svgo svgo-loader -D config.module .rule(&#x27;svg-sprite-loader&#x27;) .include.add(path.resolve(__dirname, &#x27;src/icons&#x27;)) .use(&#x27;svgo-loader&#x27;) .loader(&#x27;svgo-loader&#x27;) .tap(options =&gt; &#123; options = &#123; plugins: [ &#123; removeXMLNS: true &#125;, // 删除xmlns属性（对于内联svg，默认情况下禁用） &#123; convertStyleToAttrs: true &#125; // 将css样式转换为svg元素属性 ] &#125; return options &#125;) 也可以在图标管理中 我的项目 批量操作 批量去色 将默认颜色去除， 之后可以通过 css 自定义颜色 svg &#123; fill: red;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://wqdy.top/c/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wqdy.top/tags/vue/"}]},{"title":"addEventListener 以及 vue 中的 .passive 修饰符","slug":"前端/js/js-addeventlistener-以及-vue-中的-passive-修饰符","date":"31/07/2019","updated":"31/07/2019","comments":true,"path":"403.html","link":"","permalink":"https://wqdy.top/403.html","excerpt":"","text":"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener 添加事件 // 语法target.addEventListener(type, listener[, useCapture])// type: 事件的类型: click mouseover 字符串类型，不带 on// listener: 函数，每次点击，执行这个函数// useCapture: 可选，true: 事件在捕获阶段执行，false: 事件在冒泡阶段执行(默认)target.addEventListener(type, listener[, options]) options 可选，可用的选项如下：capture: Boolean，默认 false，等价于以前的 useCapture 参数once: Boolean，默认 false，如果是 true，表示 listener 在添加之后最多只调用一次。 listener 也会在其被调用之后自动移除passive: Boolean，默认 false，设置为 true 时，表示 listener 永远不会调用 preventDefault() 如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。 浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿 .passive 修饰符尤其能够提升移动端的性能vue .passive 事件修饰符 移除事件 removeEventListener 在第三个参数是布尔值的时候，addEventListener(“foo”, listener, true) 添加的监听器，必须用 removeEventListener(“foo”, listener, true) 才能删除掉, 因为这个监听器也有可能还注册在了冒泡阶段, 如果第三个参数为 false 则直接通过 removeEventListener(“foo”, listener) 就可以删除 通过 addEventListener(“foo”, listener, {capture: true}) 添加的监听器删除时也同样需要添加 {capture: true} 来删除，当然 {capture: true} 换成 true 也可以 通过 addEventListener(“foo”, listener, {passive: true}) 添加的监听器直接通过 removeEventListener(“foo”, listener) 就可以删除了因为一个监听器同时是 passive 和非 passive（以及同时是 once 和非 once）是说不通的，如果你添加了多个，那么后添加的会忽略 removeEventListener(“foo”, listener, {capture: true}) &#x2F;&#x2F; {capture: true} 必须加，当然 {capture: true} 换成 true 也可以","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"axios 取消请求","slug":"前端/前端库/axios-取消请求","date":"27/07/2019","updated":"27/07/2019","comments":true,"path":"430.html","link":"","permalink":"https://wqdy.top/430.html","excerpt":"","text":"原生 js abort() 方法 let A = $.ajax(&#123;&#125;)A.abort() Axios 提供了一个 CancelToken 的函数，这是一个构造函数，该函数的作用就是用来取消接口请求的 methods: &#123; getMsg () &#123; let CancelToken = axios.CancelToken let that = this axios.get(&#x27;&#x27;, &#123; cancelToken: new CancelToken(function executor(c) &#123; that.cancel = c console.log(c) // 这个参数 c 就是 CancelToken 构造函数里面自带的取消请求的函数，这里把该函数当参数用 &#125;) params: &#123;&#125; &#125;).then(res =&gt; &#123; this.items = res.data &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125;, cancelGetMsg () &#123; this.cancel() &#125;&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"},{"name":"axios","slug":"axios","permalink":"https://wqdy.top/tags/axios/"}]},{"title":"移动端兼容性问题总结","slug":"前端/移动端/移动端兼容性问题总结","date":"23/07/2019","updated":"23/07/2019","comments":true,"path":"387.html","link":"","permalink":"https://wqdy.top/387.html","excerpt":"","text":"1. ios 移动端页面对点击事件有 300ms 延时使用 fastclick 库 https://github.com/ftlabs/fastclick 使用 FastClick 的时候，在需要使用的层上，实例化它。我们使用 document.body 是因为希望所有的按钮和链接都获得快速点击 import FastClick from &#x27;fastclick&#x27;FastClick.attach(document.body) 2. ios 滚动卡顿div &#123; -webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */ /* -webkit-overflow-scrolling: auto; */ /* 当手指从触摸屏上移开，滚动会立即停止 */&#125; 3. ios 1px border 变宽以 dpr &#x3D; 2 为例：你拿到一张标准的基于 iphone6 的设计稿(750px)你看到它设计的一个 border 宽度是 1px你兴致勃勃地写下了 border: 1px solid #000;然而 iphone6 实际渲染像素是 375px，那么设计需要 border 的其实是 border: 0.5px solid #000;然后你的是 1px不是 1px 变粗了，只是实际只是需要 0.5px 而已 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 意思是将物理设备的宽度设置给当前浏览器 在使用 table 标签设置 border: 1px 并使用 border-collapse: collapse; 合并边框后，发现 td 之间的边框宽度并不是 1px，而是比 1px 宽，大概为 1.5px 4. webapp 软键盘弹起时问题其他参考链接 https://segmentfault.com/a/1190000010693229https://github.com/ioing/IOING 页面放大: &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot; /&gt; 输入框被遮挡，看不见输入的内容: document.activeElement.scrollIntoView() 页面自动上移，但收回软键盘时页面没有恢复原样少了一截 fixed 定位效果失效: ios 弹出软键盘的时候, webview 的高度没有变化导致超出屏幕范围，并且不会触发 resize 事件 scrollIntoView 与 scrollIntoViewIfNeeded Element.scrollIntoView(option) 方法让当前的元素滚动到浏览器窗口的可视区域内option 如果为 true，元素的顶端将和其所在滚动区的可视区域的顶端对齐， 默认option 如果为 false，元素的底端将和其所在滚动区的可视区域的底端对齐 element.scrollIntoViewIfNeeded() 用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动 var scrollHeight = document.documentElement.scrollTop || document.body.scrollTop || 0var clientHeight = document.documentElement.clientHeight || document.body.clientHeightvar innerHeight = window.innerHeight// 键盘弹起时 scrollHeight innerHeight 发生变化 &lt;input @focus=&quot;input(1)&quot; @blur=&quot;input(2)&quot; /&gt; input (num) &#123; var u = navigator.userAgent if (u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Linux&#x27;) &gt; -1) &#123; // 安卓手机通过 resize 事件监听键盘事件，因为部分手机手动关闭键盘时并不会失焦 &#125; else if (u.indexOf(&#x27;iPhone&#x27;) &gt; -1) &#123; // 苹果手机 if (num === 1) &#123; // 键盘弹起 document.activeElement.scrollIntoView() &#125; else &#123; // 键盘隐藏 var scrollHeight = document.documentElement.scrollTop || document.body.scrollTop || 0 // window.scrollTo(0, Math.max(scrollHeight - 1, 0)) window.scrollTo(0, 0) &#125; &#125;&#125; 附：安卓手机监听 resize data () &#123; return &#123; originalHeight: document.documentElement.clientHeight || document.body.clientHeight, resizeHeight: document.documentElement.clientHeight || document.body.clientHeight &#125;&#125;,watch: &#123; resizeHeight (val) &#123; var u = navigator.userAgent if (u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Linux&#x27;) &gt; -1) &#123; // var detail = document.querySelector(&#x27;.detail&#x27;) if (this.resizeHeight - 0 &lt; this.originalHeight - 0) &#123; // detail.style.paddingBottom = &#x27;260px&#x27; document.activeElement.scrollIntoView(&#123; behavior: &#x27;auto&#x27;, block: &#x27;start&#x27; &#125;) &#125; else &#123; // detail.style.paddingBottom = &#x27;0&#x27; &#125; &#125; &#125;&#125;,mounted () &#123; const that = this window.onresize = () =&gt; &#123; return (() =&gt; &#123; window.resizeHeight = document.documentElement.clientHeight || document.body.clientHeight that.resizeHeight = window.resizeHeight &#125;)() &#125;&#125; 5. 手机端页面文件上传兼容性问题6. 移动端和 PC 端中的 hover 处理 移动端点击时会有 pc 端 hover 效果百度一下给出的方式是注册 touchstart 事件 document.body.addEventListener(&#x27;touchstart&#x27;, function() &#123;&#125;) 但经过测试并没有解决该问题 7. 移动端 touch 时，会触发 pc 端的 mouseenter mouseleave 事件在事件中通过判断屏幕宽度解决 8. ios a 链接 input type&#x3D;”file” 等在点击时会出现灰色（touch 高亮）-webkit-tap-highlight-color: transparent; 9. 禁用浏览器自动调整字体大小移动端浏览器切换橫向模式时会调整字体大小（字体变大），解决方式: html &#123; -webkit-text-size-adjust: none; /* 或 100% */&#125; 谷歌浏览器已不支持这个属性了，不能通过该方式实现小于 12px 的字体，可使用缩放（transform:scale(0.8)）来实现小于 12px 的字体 10. appearance 属性normal|icon|window|button|menu|field所有主流浏览器都不支持 appearance 属性 -webkit-appearance: none; 去除默认样式，使 ios 端和安卓端显示效果一样，但有一个问题，input 的 checkbox 和 radio 类型在安卓端可能无法正常显示 11. 禁止长按在 iOS 上，当你触摸并按住触摸的目标，比如长按一个链接，浏览器将显示链接有关的系统默认菜单，长按图像弹出选项存储或者拷贝图像，长按文字弹出选择文字菜单 可通过如下方式禁止这些行为 禁止长按图片保存 img &#123; -webkit-touch-callout: none; pointer-events: none; // 像微信浏览器还是无法禁止，加上这行样式即可&#125; 禁用长按复制 user-select: none; 禁止长按呼出菜单 div &#123; -webkit-touch-callout: none;&#125; 12. 点击穿透假如页面上有两个元素 A 和 B。B 元素在 A 元素之上。我们在 B 元素的 touchstart 事件上注册了一个回调函数，该回调函数的作用是隐藏 B 元素。我们发现，当我们点击 B 元素，B 元素被隐藏了，随后，A 元素触发了 click 事件。这是因为在移动端浏览器，事件执行的顺序是 touchstart &gt; touchend &gt; click。而 click 事件有 300ms 的延迟，当 touchstart 事件把 B 元素隐藏之后，隔了 300ms，浏览器触发了 click 事件，但是此时 B 元素不见了，所以该事件被派发到了 A 元素身上。如果 A 元素是一个链接，那此时页面就会意外地跳转。跨页面点击穿透问题 点击页内按钮跳转至新页，然后发现新页面中对应位置元素的 click 事件被触发了 13. 移动端 video 播放时不弹出页面层&lt;video x5-playsinline=&quot;&quot; playsinline=&quot;&quot; webkit-playsinline=&quot;&quot;&gt;&lt;/video&gt; 14. vue 移动端监听 scrollmounted () &#123; document.querySelector(&#x27;.list&#x27;).addEventListener(&#x27;scroll&#x27;, () =&gt; &#123; this.scroll = document.querySelector(&#x27;.list&#x27;).scrollTop &#125;)&#125; 15. vue 移动端列表保存滚动位置beforeRouteEnter (to, from, next) &#123; next((vm) =&gt; &#123; // console.log(vm.$route.meta.scrollTop) if (vm.$route.meta.scrollTop) &#123; document.querySelector(&#x27;.list&#x27;).scrollTop = vm.$route.meta.scrollTop &#125; &#125;)&#125;,beforeRouteLeave (to, from, next) &#123; if (to.name === &#x27;invite&#x27;) &#123; this.$store.commit(&#x27;removeIncludeComponent&#x27;, &#x27;staff&#x27;) // next() &#125; if (to.name === &#x27;staffDetail&#x27;) &#123; let top = document.querySelector(&#x27;.list&#x27;).scrollTop console.log(top) this.$route.meta.scrollTop = top &#125; next()&#125; 16. 移动端去除 type 为 number 的箭头input::-webkit-outer-spin-button,input::-webkit-inner-spin-button &#123; -webkit-appearance: none !important; margin: 0;&#125; 17. 设置状态栏的背景颜色（IOS）设置状态栏的背景颜色，只有在”apple-mobile-web-app-capable” content&#x3D;”yes”时生效 &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt; content 参数： default ：状态栏背景是白色。black ：状态栏背景是黑色。black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。 18. 弹出数字键盘&lt;!-- 有&quot;#&quot; &quot;*&quot;符号输入 --&gt;&lt;input type=&quot;tel&quot; /&gt;&lt;!-- 纯数字 --&gt;&lt;input pattern=&quot;\\d*&quot; /&gt; 打开原生应用某些浏览器会禁用此协议，比如微信内部浏览器（除非开了白名单） &lt;a href=&quot;weixin://&quot;&gt;打开微信&lt;/a&gt;&lt;a href=&quot;alipays://&quot;&gt;打开支付宝&lt;/a&gt;&lt;a href=&quot;alipays://platformapi/startapp?saId=10000007&quot;&gt;打开支付宝的扫一扫功能&lt;/a&gt;&lt;a href=&quot;alipays://platformapi/startapp?appId=60000002&quot;&gt;打开支付宝的蚂蚁森林&lt;/a&gt; 解决 IOS下 active 伪类失效给 body 注册一个空事件即可 &lt;body ontouchstart&gt;&lt;/body&gt; 最简单的 rem 实现 @media (min-width: 640px) &#123; html &#123; font-size: calc(640px / 3.75); &#125;&#125;@media (min-width: 320px) and (max-width: 640px) &#123; html &#123; font-size: calc(100vw / 3.75); &#125;&#125; better-scroll 解决移动端滚动问题https://github.com/ustbhuangyi/better-scroll/ iphone X 适配 - 安全区域(safe area)参考：https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/adaptivity-and-layout/ 在 iOS 11 中采用了 viewport-fit 的 meta 标签作为适配方案 viewport-fit 取值 auto 默认：页面内容显示在 safe area 内cover 页面内容充满屏幕，可以通过添加边距保证网页主要内容处于 safe area 中不被裁剪 iOS 11 的 webview 引入了 constant、env 来处理 viewport-fit=cover 属性，以及一组四个预定义的常量：safe-area-inset-left, safe-area-inset-right, safe-area-inset-top 和 safe-area-inset-bottom，分别表示 safe area 和可视窗口 viewport 顶部，右边，左边，底部的间距，可以用于设置 margin 和 padding 或者绝对定位时 left 和 top，这四个常量只有在 viewport-fit=cover 时有效 建议使用 viewport-fit=cover 因为会使用 auto 会造成屏幕四周出现白边 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot; /&gt; /* top 为 0 的 fixed 定位的 heade */header &#123; position: fixed; top: 0; /* ... */ /* Status bar height on iOS 10 */ padding-top: 20px; /* Status bar height on iOS 11.0 */ padding-top: constant(safe-area-inset-top); /* Status bar height on iOS 11+ */ padding-top: env(safe-area-inset-top);&#125; body &#123; padding-top: constant(safe-area-inset-top); // 为导航栏+状态栏的高度 88px padding-left: constant(safe-area-inset-left); // 如果未竖屏时为0 padding-right: constant(safe-area-inset-right); // 如果未竖屏时为0 padding-bottom: constant(safe-area-inset-bottom); // 为底下圆弧的高度 34px&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"前端常用js代码段汇总","slug":"前端/js/js-常用-js-代码段汇总","date":"22/07/2019","updated":"22/07/2019","comments":true,"path":"382.html","link":"","permalink":"https://wqdy.top/382.html","excerpt":"","text":"类型识别获取数据类型，返回结果为 Number、String、Object、Array 等// 返回数据类型function getRawType(value) &#123; return Object.prototype.toString.call(value).slice(8, -1)&#125;// 正则 =&gt; RegExp// 时间对象 =&gt; Date// 字符串 =&gt; String// 对象 =&gt; Object// 数组 =&gt; Array 判断变量是不是字符串类型Object.prototype.toString.call(&#x27;str&#x27;) // &#x27;[object String]&#x27;typeof &#x27;str&#x27; // &#x27;string&#x27; 判断变量是不是引用类型例如： arrays, functions, objects, regexes, new Number(0),以及 new String(‘’) function isObject(value) &#123; let type = typeof value return value != null &amp;&amp; (type == &#x27;object&#x27; || type == &#x27;function&#x27;)&#125; 判断变量是不是 Object 类型的数据function isPlainObject(value) &#123; return Object.prototype.toString.call(value) === &#x27;[object Object]&#x27;&#125; 判断变量是不是数组类型function isArray(arr) &#123; return Object.prototype.toString.call(arr) === &#x27;[object Array]&#x27;&#125;function isArray(arr) &#123; return Array.isArray(arr)&#125; 将 isArray 挂载到 Array 上Array.isArray = Array.isArray || isArray 格式转换数字格式化：小于 10 的数值前面加上 0/** * @param &#123;number&#125; num 要格式化的数值 * @return &#123;string&#125; 把小于10的数值前面加上0 */function prefix_zero(num) &#123; return num &gt;= 10 ? num : &#x27;0&#x27; + num&#125; 价格格式化 (1234567 &#x3D;&gt; 1,234,567.00)/** * @param &#123;number&#125; price 价格 * @returns &#123;string&#125; 1234567 =&gt; 1,234,567.00 */function formatPrice(price) &#123; if (typeof price !== &#x27;number&#x27;) return price return String(Number(price).toFixed(2)).replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g, &#x27;,&#x27;)&#125;// \\b 匹配单词边界// \\B 匹配非单词边界 其他方式 let a = 123456789 // a 为number类型a.toLocaleString(&#x27;en-US&#x27;) // &#x27;123,456,789&#x27;let b = 123456789 // b 可为number类型或string类型Intl.NumberFormat().format(b) //&#x27;123,456,789&#x27; 手机号格式化：隐藏中间四位数字/** * @param &#123;string&#125; mobile 手机号 * @returns &#123;string&#125; */function formatMobile(mobile) &#123; mobile = String(mobile) if (!/\\d&#123;11&#125;/.test(mobile)) &#123; return mobile &#125; return mobile.replace(/(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)/, &#x27;$1****$2&#x27;)&#125; 进制转换parseInt(str, radix) // 任意进制转换为 10 进制整数值Number.toString(radix) //返回表示该数字的指定进制形式的字符串 检测平台（设备）类型isWechat = /micromessenger/i.test(navigator.userAgent)isWeibo = /weibo/i.test(navigator.userAgent)isQQ = /qq/i.test(navigator.userAgent)isIOS = /(iphone|ipod|ipad|ios)/i.test(navigator.userAgent)isAndroid = /android/i.test(navigator.userAgent) 数组去重function distinct(arr) &#123; return arr.filter((v, i, array) =&gt; array.indexOf(v) === i)&#125;// 对象数组去重// arr: 目标数组// id: 唯一属性function distinct(arr, id) &#123; let object = &#123;&#125; let objres = arr.reduce((item, next) =&gt; &#123; object[next[id]] ? &#x27;&#x27; : (object[next[id]] = true &amp;&amp; item.push(next)) return item &#125;, []) return objres&#125; 数组顺序上移下移// 对象数组顺序上移下移// arr: 目标数组// 上移arr[index] = arr.splice(index - 1, 1, arr[index])[0]// 下移arr[index] = arr.splice(index + 1, 1, arr[index])[0] 快速创建 a 标签let a = &#x27;超链接&#x27;.link(&#x27;https://wqdy.top&#x27;)console.log(a) // &lt;a href=&quot;https://wqdy.top&quot;&gt;超链接&lt;/a&gt; 正则进阶：捕获括号： 匹配 &#x27;wqdy&#x27; 并且记住匹配项/(wqdy)/ 非捕获括号： 匹配 &#x27;wqdy&#x27; 但是不记住匹配项/(?:wqdy)/ 先行断言： 匹配&#x27;wqdy&#x27;仅仅当&#x27;wqdy&#x27;后面跟着&#x27;top&#x27;/wqdy(?=top)/ 后行断言： 匹配&#x27;top&#x27;仅仅当&#x27;top&#x27;前面是&#x27;wqdy&#x27;/(?&lt;=wqdy)top/ 正向否定查找： 匹配&#x27;wqdy&#x27;仅仅当&#x27;wqdy&#x27;后面不跟着&#x27;gkd&#x27;/wqdy(?!gkd)/ 判断是否有滚动条function isScroll() &#123; return window.innerWidth - $(document).width() !== 0&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"less 使用 - mixin 混合","slug":"前端/less-使用-mixin-混合","date":"21/07/2019","updated":"21/07/2019","comments":true,"path":"424.html","link":"","permalink":"https://wqdy.top/424.html","excerpt":"","text":"mixin 混合可以在 mixin 中使用类选择器和 id 选择器 .bgc 定义了一个属性集，在任何需要使用 .bgc 属性集的选择器中，只需像下面这样调用：(小括号是可选的) .bgc &#123; background-color: #ccc;&#125;div &#123; color: #f00; .bgc();&#125; 编译后的 CSS 代码为： .bgc &#123; background-color: #ccc;&#125;div &#123; color: #f00; background-color: #ccc;&#125; 总结：mixin 其实就是一种嵌套，简单的讲，mixin 就是规则级别的复用 mixin 的定义也会被原封不动的输出到编译生成的 CSS 代码中 如果希望编译生成的 CSS 代码中不包含 mixin 的定义，在定义 mixin 时，只需在 class、id 的后面添加一对小括号即可。如： .bgc() &#123; background-color: #ccc;&#125;div &#123; .bgc;&#125; 编译后的 CSS 代码为： div &#123; background-color: #ccc;&#125; mixin 可以包含选择器 .hover() &#123; &amp;:hover &#123; background-color: #ccc; &#125;&#125;div &#123; .hover;&#125; 编译后的 CSS 代码为： div:hover &#123; background-color: #ccc;&#125; 命令空间 Namespaces如果想要在一个更复杂的选择器中混合属性，可以堆叠多个 id 或类 可以将 mixin 置于 id 选择器之下，这样可以确保它不会和另一个库冲突 #bgc &#123; .inner() &#123; color: red; &#125;&#125;div &#123; #bgc.inner;&#125; !important 关键字在 mixin 后使用 !important 关键字，将会标记调用所有继承的属性为!important .bgc &#123; background-color: #ccc;&#125;div &#123; .bgc !important;&#125;// 编译后 css 为div &#123; background-color: #ccc !important;&#125; 带参数的 Mixin mixin 还可以接受参数，这些参数在混合时传递给选择器块 从上面的代码可以看出：mixin 其实就是一种嵌套，简单的讲，mixin 就是规则级别的复用。除了类选择器外，你也可以使用 id 选择器来定义 mixin。","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"less","slug":"less","permalink":"https://wqdy.top/tags/less/"}]},{"title":"高阶函数与柯里化","slug":"前端/js/js-高阶函数与柯里化","date":"17/07/2019","updated":"17/07/2019","comments":true,"path":"399.html","link":"","permalink":"https://wqdy.top/399.html","excerpt":"","text":"高阶函数高阶函数定义：将函数作为参数或者返回值是函数的函数常见的 sort、reduce 等函数就是高阶函数 function add(a) &#123; return function(b) &#123; return a + b &#125;&#125;var sum = add(1)(2) // 3// es6写法let add = (a) =&gt; (b) =&gt; a + b// 等价于let add = (a, b) =&gt; a + b 柯里化wiki 的柯里化定义: 把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术 柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要 n 个参数的函数变成只需要剩下的（n - 1 个）参数就可以调用 // 形如;(a) =&gt; (b) =&gt; (c) =&gt; &#123;&#125;let add = (a) =&gt; (b) =&gt; a + blet add1 = add(1) // a = 1; b =&gt; a + badd1(2) // 1 + 2 = 3 add1 函数等价于有了 a 这个闭包变量的 b &#x3D; a + b add 函数按照 wiki 的定义可以理解成只柯里化了一次，n 个连续箭头组成的函数实际上就是柯里化了 n - 1 次前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值 所以多个连续箭头函数就是多次柯里化的 es6 写法 应用： 函数懒执行函数式编程 柯里化函数使用场景： 减少重复传递不变的参数 function discount(price, discount) &#123; return price * discount&#125;// 每次都要重复传入 discount 参数，可以将这个函数柯里化function discount(price, discount) &#123; return (price) =&gt; &#123; return price * discount &#125;&#125;const tenPercentDiscount = discount(0.9) // 9折const twentyPercentDiscount = discount(0.8) // 8折// 现在每次计算价格只需要：tenPercentDiscount(500) // 500 * 0.9twentyPercentDiscount(1000) // 1000 * 0.8 柯里化实现function curry(func) &#123; return function curried(...args) &#123; if (args.length &gt;= func.length) &#123; return func.apply(this, args) &#125; else &#123; return function(...args2) &#123; return curried.apply(this, args.concat(args2)) &#125; &#125; &#125;&#125;function sum(a, b, c) &#123; return a + b + c&#125;let curriedSum = curry(sum)console.log(curriedSum(1, 2, 3)) // 6console.log(curriedSum(1)(2, 3)) // 6 偏函数","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"常用命令","slug":"前端/常用命令","date":"12/07/2019","updated":"12/07/2019","comments":true,"path":"417.html","link":"","permalink":"https://wqdy.top/417.html","excerpt":"","text":"快速删除 node_modules 文件夹系统命令 # cmd# /q 直接删除，不需要二次确认# /s 允许删除非空目录rd /q/s node_modules# powershellrmdir -r -Force node_modules# 或rm -r -Force node_modules 使用 npm 包 npm i rimraf -grimraf node_modulesnpm i -g dlfdlf node_modules 一次执行多条命令# cmd 使用 &amp;&amp; 连接多个命令cd vue &amp;&amp; npm i# powershell 使用 | 连接多条命令cd vue | npm i 删除一个文件夹内字节小于 10kb 的文件# 输出所有大小小于10k的文件# find ./ -size -10k &gt; NoNeedSite.txtfind ./ -size -10k -exec rm &#123;&#125; \\","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"Window.history 对象","slug":"前端/js/js-window-history-对象","date":"12/07/2019","updated":"12/07/2019","comments":true,"path":"383.html","link":"","permalink":"https://wqdy.top/383.html","excerpt":"","text":"Window.history 是一个只读属性，提供了操作浏览器会话历史（浏览器地址栏中访问的页面，以及当前页面中通过框架加载的页面）的接口。HTML5 引入了 history.pushState() 和 history.replaceState() 方法，它们分别可以添加和修改历史记录条目。这些方法通常与 window.onpopstate 配合使用。 参考 https://developer.mozilla.org/zh-CN/docs/Web/API/History_API https://developer.mozilla.org/zh-CN/docs/Web/API/Window/history 在 history 中跳转 window.history.back() // 向后跳转 相当于点击浏览器回退按钮window.history.forward() // 向前跳转 相当于点击了前进按钮window.history.go(-1) // 跳转 历史中的某一特定页面(go(-1) 等同于调用 back()) 可以通过查看长度属性的值来确定的历史堆栈中页面的数量 window.history.length history.pushState(stateObject, title, url) 状态对象（stateObject）–stateObject 是一个 JavaScript 对象，通过 pushState 方法可以将 stateObject 内容传递到新页面中。 标题（title）–几乎没有浏览器支持该参数，但是传一个空字符串会比较安全。 地址（url）–新的历史记录条目的地址（可选，不指定的话则为文档当前 URL）；浏览器在调用 pushState()方法后不会加载该地址；传入的 URL 与当前 URL 应该是同源的，否则，pushState()会抛出异常。 history.pushState()主要是在不刷新浏览器的情况下，创建新的浏览记录并插入浏览记录队列中 假设在 http://mozilla.org/foo.html 中执行了以下 JavaScript 代码: let stateObj = &#123; foo: &#x27;bar&#x27;&#125;history.pushState(stateObj, &#x27;page 2&#x27;, &#x27;bar.html&#x27;) 这将使浏览器地址栏显示为 http://mozilla.org/bar.html，但并不会导致浏览器加载 bar.html ，甚至不会检查 bar.html 是否存在 history.replaceState() 的使用与 history.pushState() 非常相似，区别在于 replaceState() 是修改了当前的历史记录项而不是新建一个","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"配置 web 服务器","slug":"运维/配置-web-服务器","date":"09/07/2019","updated":"09/07/2019","comments":true,"path":"415.html","link":"","permalink":"https://wqdy.top/415.html","excerpt":"","text":"Apache 安装centos# yum install httpd （centos之下，Apache的名字叫httpd，和Apache的主程序 httpd.exe 同名） 打开并测试 Apache 先确保，云服务器的 80 端口，是允许外网访问的。 开启 Apache 服务 service httpd start# 查看状态service httpd status 测试 Apache 是否正常运行 浏览器输入： 外网 IP:80，如果能正常显示 Apache 的内置主页，则说明 Apache 服务已正常开启。 修改 Apache 的配置文件主配置文件 /etc/httpd/conf/httpd.conf 修改如下键值兼容 php 键：DirectoryIndex值：index.html index.php 默认站点主目录：&#x2F;var&#x2F;www&#x2F;html&#x2F; https://www.cnblogs.com/smbin/p/6946210.html 安装证书 安装 ssl 模块 # yum install mod_ssl -y Ps：安装完成后，会在&#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;下生成一个 ssl.conf 配置文件。 建一个目录用来放 ssl 证书文件 # mkdir /etc/httpd/ssl/ 编辑 ssl 配置文件 # vim /etc/httpd/conf.d/ssl.conf 修改以下几行，去掉前面的“#”注释； &lt;VirtualHost&gt;#网页文件路径DocumentRoot &quot;/var/www/html&quot;#改为自己的域名ServerName cuilongjin.top:80#启用SSL功能SSLEngine on#填写证书文件路径SSLCertificateFile /etc/httpd/ssl/cert-1541656252121_cuilongjin.top.key#填写私钥文件路径SSLCertificateKeyFile /etc/httpd/ssl/cert-1541656252121_cuilongjin.top.key#填写证书链文件路径SSLCertificateChainFile /etc/httpd/ssl/cert-1541656252121_cuilongjin.top_chain.crt&lt;/VirtualHost&gt; 重启服务器 # service httpd restart Nginx 的安装与配置CentOS 下安装：通过安装包安装 # 安装所需环境yum install gcc-c++yum install -y pcre pcre-develyum install -y zlib zlib-develyum install -y openssl openssl-devel# 官网下载 nginx https://nginx.org/yum install wgetwget -c https://nginx.org/download/nginx-1.17.4.tar.gz# 解压tar -zxvf nginx-1.17.4.tar.gzcd nginx-1.17.1# 配置./configure# 编译安装makemake install# 查找安装路径：whereis nginx# 启动、停止 重启 nginxcd /usr/local/nginx/sbin/./nginx # 启动./nginx -s stop # 此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程./nginx -s quit # 此方式停止步骤是待nginx进程处理任务完毕进行停止./nginx -s quit &amp;&amp; ./nginx # 重启 nginx# 重新加载配置文件# 配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用 -s reload 不用先停止 nginx 再启动即可将配置信息在 nginx 中生效，如下：./nginx -s reload# 查询 nginx 进程ps aux|grep nginx# 开机自启动在 rc.local 增加启动代码vi /etc/rc.local# 增加一行 /usr/local/nginx/sbin/nginx# 设置执行权限chmod 755 rc.local# 添加 nginx 为系统服务 centos 下，yum 源不提供 nginx 的安装，可以通过切换 yum 源的方法获取安装 yum -y install nginx 主站点目录&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 配置 Nginx： Nginx 的配置文件默认位置为：/etc/nginx/nginx.conf server &#123; listen 80; #监听80端口，接收http请求 server_name localhost; #就是网站地址 root /usr/share/nginx/html; # 准备存放代码工程的路径 #路由到网站根目录www.example.com时候的处理 location / &#123; index index.php index.html index.htm; &#125; #当请求网站下php文件的时候，反向代理到php-fpm location ~ \\.php$ &#123; include fastcgi.conf; #加载nginx的fastcgi模块 fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; #nginx fastcgi进程监听的IP地址和端口 &#125;&#125; 自定义 Nginx 站点配置文件存放目录 /etc/nginx/conf.d/ 默认站点目录&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 安装 php yum install php php-fpm 配置 php.ini &#x2F;etc&#x2F;php.ini cgi.fix_pathinfo=1 配置 php-fpm &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf user &#x3D; nginx group &#x3D; nginx chkconfig php-fpm on #设置 php-fpm 自启动 service nginx restart #重新启动 nginx service php-fpm start #启动 php-fpm sudo iptables -I INPUT -p tcp -m tcp –dport 80 -j ACCEPT sudo iptables -I INPUT -p tcp -m tcp –dport 443 -j ACCEPT iptables -L -n &#x2F;usr&#x2F;sbin&#x2F;nginx 查询 nginx 进程 ps -ef | grep nginx nginx 配置 ## HTTPS server configuration#server &#123; listen 443 ssl http2 default_server; listen [::]:443 ssl; server_name _; root /usr/share/nginx/html; ssl_certificate ssl/cuilongjin.top.pem; ssl_certificate_key ssl/cuilongjin.top.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; location ~ \\.php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; ## The default server#server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; location ~ \\.php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; ubuntu 下安装安装 nginx sudo apt-get install nginx Ubuntu 安装之后的文件结构大致为： 所有的配置文件都在&#x2F;etc&#x2F;nginx 下，并且每个虚拟主机已经安排在了&#x2F;etc&#x2F;nginx&#x2F;sites-available 下 程序文件在&#x2F;usr&#x2F;sbin&#x2F;nginx 日志文件在&#x2F;var&#x2F;log&#x2F;nginx 并已经在&#x2F;etc&#x2F;init.d&#x2F;下创建了启动脚本 nginx 服务器配置文件在&#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F; 默认主站点目录 &#x2F;var&#x2F;www&#x2F;html，（有的可能在&#x2F;var&#x2F;www）, 请参考&#x2F;etc&#x2F;nginx&#x2F;sites-available 里的配置 安装 php apt-get install php 配置 php.ini &#x2F;etc&#x2F;php&#x2F;7.2&#x2F;cli&#x2F; cgi.fix_pathinfo=1 配置 php-fpm 启动 nginx /etc/init.d/nginx restart/etc/init.d/nginx stop/etc/init.d/nginx start 删除 nginx sudo apt-get --purge remove nginx# –-purge 包括配置文件 arch 下安装 nginxpacman -S nginx 启动 Nginx 服务,运行以下命令: # systemctl start nginx 要 Nginx 服务开机时启动,运行以下命令:# systemctl enable nginx 默认页面是: /usr/share/nginx/html/index.html 配置你可以修改在 &#x2F;etc&#x2F;nginx&#x2F; 目录中的文件来更改配置 .&#x2F;etc&#x2F;nginx&#x2F;nginx.conf 是主配置文件","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wqdy.top/tags/linux/"}]},{"title":"移动端(Safari)浏览网页时对数字禁用电话功能","slug":"前端/移动端-safari浏览网页时对数字禁用电话功能","date":"09/07/2019","updated":"09/07/2019","comments":true,"path":"388.html","link":"","permalink":"https://wqdy.top/388.html","excerpt":"","text":"移动端(Safari)浏览网页时对数字禁用电话功能 标准的电话号码格式是： &lt;a href=&quot;tel:+86-123-456-7890&quot;&gt;1234567890&lt;/a&gt; 有时候不是电话号码的数字会被浏览器自动解析为如上电话号码格式，导致样式和布局改变 忽略页面中的数字识别为电话号码, 只要把这个默认行为关闭就行 &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; 这个关闭不会影响真正电话号码的识别 说明：Meta 标签中的 format-detection 属性及含义format-detection 中文的意思是 “格式检测”，它是用来检测 html 里的一些格式的 &lt;!-- 禁止了把数字转化为拨号链接 默认为 yes --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;&lt;!-- 禁止作为邮箱地址 默认为 yes --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt;&lt;!-- 禁止跳转至地图 默认为 yes --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;adress=no&quot; /&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no,adress=no&quot; /&gt;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"解决VPS通过SS访问谷歌学术受限","slug":"其他/解决vps通过ss访问谷歌学术受限","date":"09/07/2019","updated":"09/07/2019","comments":true,"path":"222.html","link":"","permalink":"https://wqdy.top/222.html","excerpt":"","text":"在网上搜索后发现有可能有以下原因： 1.你的 VPS 被人用来做爬虫爬 Google，IP 被封 2.你的 IPv4 网段有人做爬虫，网段被封 3.你的 IPv6 网段有人做爬虫，网段被封 IPv6 网段被封 强制你的 VPS 用 IPv4 来访问，具体方法在 /etc/sysctl.conf 后追加 # disable ipv6net.ipv6.conf.all.disable_ipv6=1net.ipv6.conf.default.disable_ipv6=1net.ipv6.conf.lo.disable_ipv6=1 IPv4 网段被封 强制 VPS 使用 IPv6 访问，确认打开 VPS 上的 IPv6 功能，更改 VPS 的 hosts 中指定 Google Schoolar 的 IPv6 地址，编辑/etc/hosts后追加： ## Scholar## type &#x27;host google.com&#x27; to get the correct ipv6 address or## visit https://github.com/lennylxx/ipv6-hosts2404:6800:4004:81a::200e scholar.google.cn2404:6800:4004:81a::200e scholar.google.com.hk2404:6800:4004:81a::200e scholar.google.com2404:6800:4004:81a::200e scholar.l.google.com 更改配置后，重启 SS","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"ss","slug":"ss","permalink":"https://wqdy.top/tags/ss/"}]},{"title":"搭建ss服务器","slug":"其他/学习强国/vultr-搭建ss服务器","date":"09/07/2019","updated":"09/07/2019","comments":true,"path":"224.html","link":"","permalink":"https://wqdy.top/224.html","excerpt":"","text":"购买 VPS 服务器vultr 注册地址：https://www.vultr.com/ 利用 ipip 这个网站的 实用工具里的 ping 来全国性的 ping 我们的主机，检测连通性 部署 VPS 服务器ssh 工具Win：使用软件 PuTTY打开软件Host Name (or IP address) 写你服务器的 IP 地址Port 默认 22Connection type 选择 SSHOpen Mac：默认有 SSH 命令ssh root@IP输入用户名和密码,用户名为 rootlogin as: rootroot@IP’s password: 安装服务CentOS&#x2F;Debian&#x2F;Ubuntu ShadowsocksR 单&#x2F;多端口 一键管理脚本https://doub.io/ss-jc42/ yum -y install wgetwget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 备用脚本： yum -y install wgetwget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 复制上面的代码到 VPS 服务器里，按回车键，脚本会自动安装，以后只需要运行 bash ssr.sh 这个快捷命令就可以出现下图的界面进行设置。 安装 SSR 服务端 设置端口和密码 设置的加密方式: aes-256-cfb 选择协议插件: auth_sha1_v4 选择混淆插件 plain ShadowsocksR MudbJSON 模式多用户一键脚本 支持流量限制https://doub.io/ss-jc60/ wget -N --no-check-certificate https://softs.fun/Bash/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 备用下载地址 wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh bash ssrmu.sh 测速脚本官方地址wget https://raw.githubusercontent.com/oooldking/script/master/superbench.shchmod +x superbench.sh./superbench.sh 加速锐速&#x2F;BBR&#x2F;魔改 BBR&#x2F;KCPTUN 加速效果对比测试 【原版 BBR】 wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh# 重启服务器# 验证是否安装成功sysctl net.ipv4.tcp_congestion_control# 得到如下结果表示安装成功net.ipv4.tcp_congestion_control = bbr 【魔改 BBR】 只有 centos 和 debain 版 # centos 版wget --no-check-certificate https://raw.githubusercontent.com/tcp-nanqinlang/general/master/General/CentOS/bash/tcp_nanqinlang-1.3.2.shbash tcp_nanqinlang-1.3.2.sh# debain 版wget --no-check-certificate https://github.com/tcp-nanqinlang/general/releases/download/3.4.2.1/tcp_nanqinlang-fool-1.3.0.shbash tcp_nanqinlang-fool-1.3.0.sh# 选择 1 安装内核，重启# 运行 选择 2 安装并开启算法bash tcp_nanqinlang-1.3.2.sh# 选择 2 安装并开启算法 【BBRPlus（BBR v2.0）】 Github 项目地址：https://github.com/cx9208/bbrplus 一键脚本（仅CentOS） yum -y install wget &amp;&amp; wget &quot;https://github.com/cx9208/bbrplus/raw/master/ok_bbrplus_centos.sh&quot; &amp;&amp; chmod +x ok_bbrplus_centos.sh &amp;&amp; ./ok_bbrplus_centos.sh 等待安装完成，重启，重启之后，按照以下步骤检查是否成功： 执行 uname -r，显示 4.14.129-bbrplus 则切换内核成功 执行 lsmod | grep bbr，显示有 bbrplus 则开启成功","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"ss","slug":"ss","permalink":"https://wqdy.top/tags/ss/"}]},{"title":"npm 包管理工具的使用","slug":"前端/npm-使用","date":"03/07/2019","updated":"03/07/2019","comments":true,"path":"427.html","link":"","permalink":"https://wqdy.top/427.html","excerpt":"","text":"解决某些 npm 包无法下载的问题如 electron sass 修改 ~/.npmrc，或当前项目下的.npmrc 文件（如果没有可以新建）增加如下内容 registry=https://registry.npm.taobao.orgsass_binary_site=https://npm.taobao.org/mirrors/node-sass/phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjselectron_mirror=http://npm.taobao.org/mirrors/electron/chromedriver_cdnurl=http://npm.taobao.org/mirrors/chromedriver 淘宝 npm 镜像 https://npm.taobao.org/ npm 官网npm 文档npm 中文文档 npm 基本命令# 更新 npmnpm -v|--versionnpm install npm@latest -g# nvm : npm Version Manager# 搜索包npm search &lt;pkg&gt;# 安装包npm install [&lt;@scope&gt;/]&lt;pkg&gt; # [&lt;@scope&gt;/] 安装限定范围的包npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;tag&gt;npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version&gt;npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version range&gt;npm install &lt;folder&gt;npm install &lt;tarball file&gt; # .tar, .tar.gz, or .tgznpm install &lt;tarball url&gt;# 公有仓库npm install user/project # 默认 githubnpm install bitbucket:user/projectnpm install gitlab:user/project#semver:^5.0 # semver 版本npm install git+https://git@github.com/user/project.gitnpm install git+ssh://git@github.com/user/project.gitnpm install git://github.com/user/project.gitnpm install &lt;pkg&gt; -S|--save # 安装到 dependenciesnpm install &lt;pkg&gt; -D|--save-dev # 安装到 devDependencies# --verbose 参数 显示安装的详细信息npm i --verbose# --production 参数 只会安装 dependencies 依赖，而忽略 devDependencies 依赖，用于生产环境npm i --production# 安装全局包npm install -g &lt;pkg&gt;# 更新包npm outdated # 检查可以更新的模块npm update # 更新全部本地包# 更新全局安装的包npm update -g # 更新全部npm update -g| --global &lt;pkg&gt; # 更新指定包# 更新方式 1# 手动修改 package.json 中依赖包版本，之后执行npm install --force# 更新方式 2 使用第三方插件：npm install -g npm-check-updatesncu # 查看可更新包ncu -u # 更新 package.jsonnpm install # 升级到最新版本# 删除本地包npm uninstall &lt;pkg&gt;npm uninstall --save &lt;pkg&gt; # 从 `package.json` 文件中删除依赖# 卸载全局安装的包npm uninstall -g &lt;pkg&gt;# 打开官网npm docs|home [&lt;pkg&gt;]# 打开源码仓库页面npm repo [&lt;pkg&gt;]# 初始化一个项目，创建一个 package.json 文件，项目名不能为中文npm init# 创建默认 package.json 文件 快速的初始化一个项目，会使用文件夹名称作为项目名npm init --yes or -y 简写 npm install 可简写成 npm inpm uninstall 可简写成 npm uni npm 修改源修改全局配置 进入~&#x2F;.npmrc 增加 registry=https://registry.npm.taobao.org 通过命令 npm config set registry https://registry.npm.taobao.org 修改当前项目的 npm 源 在 package.json 同级目录下创建 .npmrc 文件，增加 registry=https://registry.npm.taobao.org 临时使用指定源下载 npm install jquery --registry=https://registry.npm.taobao.org 使用 nrm 管理源 npm 配置文件# .npmrc 配置文件位置（~/.npmrc）npm config list# npm 缓存目录，默认 C:\\Users\\&lt;username&gt;\\AppData\\Roaming\\npm-cachenpm config get cache# 删除 npm 缓存：注意：如果网速慢的话，会导致下载失败。 再重新下载之前，建议使用该命令，清除刚才下载的缓存，否则有可能一直无法下载成功npm cache clean --force | -f# npm 全局 node 包位置： 默认在 C:\\Users\\用户名\\AppData\\Roaming\\npm目录下npm config get prefix# 或者npm root -g# 修改 npm 全局文件位置及缓存文件位置npm config set prefix &quot;&lt;new_path&gt;&quot;npm config set cache &quot;&lt;new_path&gt;&quot; 版本号使用 NPM 下载和发布代码时都会接触到版本号。NPM 使用语义版本号来管理代码 语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。 如果只是修复 bug，需要更新 Z 位 如果是新增了功能，但是向下兼容，需要更新 Y 位 如果有大变动，向下不兼容，需要更新 X 位 nrm 使用nrm：npm registry manager（npm 仓库地址管理工具） # 查看配置列表，带 `*` 号即为当前使用的配置nrm ls# 切换源nrm use 源的别名# 添加源nrm add 别名 地址# 测速nrm test 别名# 删除源nrm del 别名 查看项目安装了那些包npm list --depth=0 [--dev | --production]npm list --depth=0 –depth 表示深度，我们使用的模块会有依赖，深度为零的时候，不会显示依赖模块 查看全局安装的包npm list --depth=0 --global package.json 文件package.json 文件，包（项目）描述文件，用来管理组织一个包（项目），它是一个纯 JSON 格式的 作用：描述当前项目（包）的信息，描述当前包（项目）的依赖项 如何生成：npm init或者npm init -y 作用 作为一个标准的包，必须要有package.json文件进行描述 一个项目的 node_modules 目录通常都会很大，不用拷贝 node_modules 目录，可以通过 package.json 文件配合npm install 直接安装项目所有的依赖项 描述内容 &#123; &quot;name&quot;: &quot;myproject&quot;, // 描述了包的名字，不能有中文 &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, // 包的描述信息 &quot;main&quot;: &quot;index.js&quot;, // 入口文件 &quot;scripts&quot;: &#123; // 配置一些脚本 &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], // 关键字（方便搜索） &quot;author&quot;: &quot;&quot;, // 作者信息 &quot;license&quot;: &quot;ISC&quot;, // 许可证，开源协议 &quot;dependencies&quot;: &#123; // 项目依赖 &quot;bootstrap&quot;: &quot;^3.3.7&quot;, &quot;jquery&quot;: &quot;^3.3.1&quot; &#125;&#125; 注意：一个合法的 package.json，必须要有 name 和 version 两个属性","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://wqdy.top/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://wqdy.top/tags/npm/"}]},{"title":"telegram ss ip 名单","slug":"其他/学习强国/telegram-ss-ip-名单","date":"30/06/2019","updated":"30/06/2019","comments":true,"path":"236.html","link":"","permalink":"https://wqdy.top/236.html","excerpt":"","text":"91.108.56.0/2291.108.4.0/22109.239.140.0/24149.154.160.0/20","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"telegram","slug":"telegram","permalink":"https://wqdy.top/tags/telegram/"}]},{"title":"如何注册美区 PayPal 并绑定美区 Apple ID，以及风控的解决方案","slug":"其他/如何注册美区-paypal-并绑定美区-apple-id，以及风控的解决方","date":"30/06/2019","updated":"30/06/2019","comments":true,"path":"234.html","link":"","permalink":"https://wqdy.top/234.html","excerpt":"","text":"原文","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"神级代码注释","slug":"其他/神级代码注释","date":"30/06/2019","updated":"30/06/2019","comments":true,"path":"2008.html","link":"","permalink":"https://wqdy.top/2008.html","excerpt":"","text":"http://www.asciiworld.com/https://github.com/Blankj/awesome-comment -------------------------&lt; Just have fun with gist &gt; ------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || //When I wrote this, only God and I understood what I was doing//Now, God only knows","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"【学习强国】","slug":"其他/学习强国/【学习强国】","date":"30/06/2019","updated":"05/09/2021","comments":true,"path":"228.html","link":"","permalink":"https://wqdy.top/228.html","excerpt":"","text":"shadowsocksv2ray githubtrojanclash 搭建v2ray 搭建配置教程 客户端 仅仅拥有客户端并不能 FQ，还需要在客户端中添加可用的节点，客户端并不提供节点 iOS Shadowrocket(小火箭) 在线安装 在线安装 共享账号 支持 ss、ssr、vmess 协议 macOS clashXV2rayUShadowsocksX-NGClash.for.Windows Windows Shadowsocksshadowsockes v2ray插件ShadowsocksRv2rayNClash.for.Windows Android V2RayNGShadowsocksshadowsockes v2ray插件KitsunebiClashForAndroid 免费节点订阅ssrsub&#x2F;ssr 参考链接 https://congcong0806.github.io/2018/04/20/SS/ 订阅转换边缘@订阅转换APIsubconverter 规则Hackl0us&#x2F;SS-Rule-Snippet 搜集、整理、维护 Surge &#x2F; Quantumult (X) &#x2F; Shadowrocket &#x2F; Surfboard &#x2F; clash (Premium) 实用规则。gfwlist&#x2F;gfwlistlhie1&#x2F;RulesACL4SSR&#x2F;ACL4SSR SSR 去广告ACL规则&#x2F;SS完整GFWList规则&#x2F;Clash规则碎片 TGChinaG（几鸡）","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"Docker 的安装和使用","slug":"运维/docker","date":"18/06/2019","updated":"18/06/2019","comments":true,"path":"420.html","link":"","permalink":"https://wqdy.top/420.html","excerpt":"","text":"安装 dcokerubuntu 16.04 (LTS) 安装 docker参考官网安装方法 https://docs.docker.com/engine/install/ubuntu/ 卸载旧版本 $ sudo apt-get remove docker docker-engine docker.io containerd runc 镜像仓库方式安装设置镜像仓库# 更新 apt 软件包索引：$ sudo apt-get update# 安装软件包，以允许 apt 通过 HTTPS 使用镜像仓库：$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common# 添加 Docker 的官方 GPG 密钥：$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 验证密钥指纹是否为 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。$ sudo apt-key fingerprint 0EBFCD88# 设置 stable 镜像仓库# amd64:$ sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; 使用国内源 # 更换国内软件源，推荐中国科技大学的源$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak$ sudo sed -i &#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list$ sudo apt update# 安装需要的包$ sudo apt install apt-transport-https ca-certificates software-properties-common curl# 添加 GPG 密钥，并添加 Docker-ce 软件源，这里还是以中国科技大学的 Docker-ce 源为例$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -$ sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\$(lsb_release -cs) stable&quot;# 添加成功后更新软件包缓存$ sudo apt update# 安装 Docker-ce$ sudo apt install docker-ce 安装 DOCKER CE$ sudo apt-get update$ sudo apt-get install docker-ce docker-ce-cli containerd.io # 安装指定版本$ apt-cache madison docker-ce docker-ce | 5:18.09.1~3-0~ubuntu-bionic | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages docker-ce | 5:18.09.0~3-0~ubuntu-bionic | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages docker-ce | 18.06.0~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages docker-ce | 18.03.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages ...$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io 启动 docker daemon否则会报错：docker: Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?.See ‘docker run –help’. $ sudo service docker start# sudo systemctl enable docker# sudo systemctl start docker 验证是否正确安装 $ sudo docker run hello-world 此命令将下载一个测试镜像并在容器中运行它。容器运行时，它将输出一条参考消息并退出 升级 docker ce如需升级 Docker CE，首先运行 sudo apt-get update，然后按照顺序执行操作，并选择您要安装的新版本 卸载 docker ce$ sudo apt-get purge docker-ce docker-ce-cli containerd.io 主机上的镜像、容器、存储卷、或定制配置文件不会自动删除。如需删除所有镜像、容器和存储卷，请运行下列命令： $ sudo rm -rf /var/lib/docker 将 docker 配置为在启动时启动使用脚本安装curl -sSL https://get.docker.com/ | sh# 将用户添加到docker组，可以用非root用户使用docker$ sudo usermod -aG docker &lt;your-user&gt; 国内的服务器可以使用如下脚本加速安装， # 阿里云的安装脚本curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -# DaoCloud 的安装脚本curl -sSL https://get.daocloud.io/docker | sh centos 安装 docker参考官网安装方法 https://docs.docker.com/engine/install/centos/ 卸载旧版本(如果安装过旧版本的话) $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装需要的软件包， yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的 $ sudo yum install -y yum-utils 设置 yum 源 $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装 $ sudo yum install docker-ce# 可以查看所有仓库中所有 docker 版本，并选择特定版本安装$ yum list docker-ce --showduplicates | sort -r$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io# 启动 Docker,设置开机启动,停止 Docker$ sudo systemctl start docker$ sudo systemctl enable docker$ sudo systemctl stop docker 卸载 $ sudo yum remove docker-ce docker-ce-cli containerd.io$ sudo rm -rf /var/lib/docker 常见问题 # 报错：Requires: container-selinux &gt;= 2:2.74You could try using --skip-broken to work around the problem$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo$ yum install epel-release # 阿里云上的 epel 源$ yum makecache$ yum install container-selinux # Job for docker.service failed because the control process exited with error code. See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details.卸载 docker 重新安装 使用 docker配置镜像加速修改 docker 源修改配置文件 /etc/docker/daemon.json（Linux） 或者 %programdata%\\docker\\config\\daemon.json（Window) 如果没有新建一个 &#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125; 重启 docker 安装镜像安装 Ubuntu 镜像 docker search ubuntu # 查找 Ubuntu 镜像docker pull ubuntu # 安装 Ubuntu 镜像docker images #查看 docker 镜像# 创建并运行 docker 容器docker run -it -d --name ubuntu_test -p 8088:80 ubuntu# --name 自定义容器名，-p 指定端口映射，前者为虚拟机端口，后者为容器端口,成功后返回 id# 多个 -p 指定多个端口映射# 运行 docker 容器 启动一个 bash 交互终端docker run -it 容器名:容器tag /bin/bashdocker start container_id# 查看所有启动的容器(查看所有容器加 -a)docker ps# 根据 id 查看容器信息docker inspect id# 进入docker(或者把容器id改为容器名，也可以进入)docker exec -it 容器id或容器名 /bin/bash# OCI runtime exec failed: exec failed: container_linux.go:349: starting container process caused &quot;exec: \\&quot;/bin/bash\\&quot;: stat /bin/bash: no such file or directory&quot;: unknown# 解决# docker exec -it 容器id或容器名 /bin/sh# docker exec -it 容器id或容器名 bash# docker exec -it 容器id或容器名 sh# 退出容器exit# 停止容器docker stop id# 删除容器docker rm 容器id# 删除镜像docker rmi 删除镜像 备份镜像 # 制作 docker 镜像 1.0 为版本号docker commit 98 my-ubuntu:1.0# 查看镜像是否创建docker images# 保存镜像到 docker 账号中# 登录进 Docker 注册中心docker login# 推送镜像docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]docker tag my-ubuntu:1.0 cuilongjin/my-ubuntu:1.0docker push cuilongjin/my-ubuntu:1.0# 打包镜像并查看docker save -o my-ubuntu.tar my-ubuntu:1.0 恢复容器 # 从docker账号中拉取docker pull cuilongjin/my-ubuntu:1.0# 从本地docker load -i ~/my-ubuntu.tar# docker images# 用加载的镜像去运行Docker容器docker run -d -p 80:80 my-ubuntu docker 给已存在的容器添加或修改端口映射 方式 1： 提交一个运行中的容器为镜像 $ docker commit containerid foo/live 运行镜像并添加端口 $ docker run -d -p 8000:80 foo/live /bin/bash 方式 2：iptable 转发端口 将容器的 8000 端口映射到 docker 主机的 8001 端口 $ iptables -t nat -A DOCKER -p tcp --dport 5001 -j DNAT --to-destination 45.77.150.20:8000 docker 容器使用问题Centos7 docker 容器报 docker Failed to get D-Bus connection 错误$ systemctl start nginxFailed to get D-Bus connection: Operation not permitted。 原因是 dbus-daemon 没能启动 解决方法 docker run -it -d --name ubuntu_test -p 8088:80 ubuntu$ docker run --privileged -ti --name test1 centos /usr/sbin/init ssh 链接 docker 容器进入容器 安装依赖 yum install passwd openssl openssh-server openssh-clients -y 安装 service 命令： yum install initscripts -y 修改密码： passwd 修改配置： vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config PubkeyAuthentication yes #启用公钥私钥配对认证方式AuthorizedKeysFile .ssh&#x2F;authorized_keys #公钥文件路径 PermitRootLogin yes #root 能使用 ssh 登录 重启 ssh 服务，并设置开机启动： service sshd restartchkconfig sshd on 如果无法执行，可试着执行： systemctl start sshd.service systemctl enable sshd.serviceservice sshd restart 运行 docker exec -it 容器 &#x2F;bin&#x2F;bash 出现如下错误OCI runtime exec failed: exec failed: container_linux.go:346: starting container process caused &quot;exec: \\&quot;/bin/bash\\&quot;: stat /bin/bash: no such file or directory&quot;: unknown 解决方式：尝试使用如下命令 sudo docker exec -it 容器 /bin/shsudo docker exec -it 容器 bash docker-compose如果你想要通过 docker-compose 统一管理你的 Docker container，这里也可以安装一下 官方文档：https://docs.docker.com/compose/install/ sudo curl -L https://github.com/docker/compose/releases/download/1.26.2/run.sh &gt; /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose 使用 pip 安装 pip install docker-compose 运行一下 docker-compose version 来检测一下是否成功 创建配置文件创建一个名为 docker-compose.yml 的配置文件 version: &#x27;3&#x27;services: v2ray1: image: v2fly/v2fly-core # 镜像名称 container_name: v2ray # 容器名称 restart: always command: v2ray -config=/etc/v2ray/config.json # 覆盖容器启动后默认执行的命令 ports: # HOST:CONTAINER - &#x27;44222:44222&#x27; # 端口 #- &quot;127.0.0.1:8889:8889&quot; volumes: # HOST:CONTAINER - ./config:/etc/v2ray # 目录 #- /etc/v2ray/v2ray.crt:/etc/v2ray/v2ray.crt #- /etc/v2ray/v2ray.key:/etc/v2ray/v2ray.key v2ray2: build: context: ./dir # context 选项可以是 Dockerfile 的文件路径，也可以是到链接到 git 仓库的 url dockerfile: path/of/Dockerfile # 使用此 dockerfile 文件来构建，必须指定构建路径 命令以下命令需要在 docker-compose.yml 所在目录下执行 docker-compose up -d # 部署 v2raydocker-compose start v2ray # 启动 v2raydocker-compose stop v2ray # 停止 v2raydocker-compose restart v2ray # 重启 v2raydocker stop v2ray &amp;&amp; docker rm v2ray # 删除 v2raydocker-compose pull &amp;&amp; docker-compose up -d # 更新 v2ray","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://wqdy.top/tags/docker/"}]},{"title":"移动端调试","slug":"前端/调试/移动端-调试","date":"18/06/2019","updated":"18/06/2019","comments":true,"path":"418.html","link":"","permalink":"https://wqdy.top/418.html","excerpt":"","text":"一些调试工具 直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法 100% 还原手机的真实情况 chrome 远程调试功能 chrome://inspect/#devices 需要连接数据线，其次是设置比较繁琐，而且还限制了 android 手机。对于 IOS 的调试则可能要使用 Safari 的另一套工具 weinre：远程调试，在 PC 上生成一个像 chrome 开发工具一样的调试器，需要手动引入 js Eruda、vConsole：在移动端页面上生成一个调试器，调试信息会挡住操作元素，查看复杂数据结构的 log 不方便，需要手动引入 js 安装各种虚拟机 sdk，在电脑上进行手机调试。能比较真实模拟手机，但是安装繁琐，操作不方便，无法模拟真实的手势操作 Erudahttps://github.com/liriliri/eruda Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获 XHR 请求、显示本地存储和 Cookie 信息等等。 按钮拖拽，面板透明度大小设置。 Console 面板：捕获 Console 日志，支持 log、error、info、warn、dir、time&#x2F;timeEnd、clear、count、assert、table；支持占位符，包括%c 自定义样式输出；支持按日志类型及正则表达式过滤；支持快捷命令加载 underscore、jQuery 库；支持 JavaScript 脚本执行。 Elements 面板：查看标签内容及属性；查看应用在 Dom 上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看 Dom 上绑定的各类事件。 Network 面板：捕获请求，查看发送数据、返回头、返回内容等信息。 Resources 面板：查看并清除 localStorage、sessionStorage 及 cookie；查看页面加载脚本及样式文件；查看页面加载图片。 Sources 面板：查看页面源码；格式化 html，css，js 代码及 json 数据。 Info 面板：输出 URL 及 User Agent；支持自定义输出内容。 Snippets 面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。 使用 通过 CDN 使用： &lt;script src=&quot;//cdn.bootcss.com/eruda/1.5.2/eruda.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; eruda.init()&lt;/script&gt; 通过 npm 安装： npm install eruda --save 在页面中加载脚本： &lt;script src=&quot;node_modules/eruda/eruda.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; eruda.init()&lt;/script&gt; Js 文件对于移动端来说略重（gzip 后大概 100kb）。建议通过 url 参数来控制是否加载调试器，比如： ;(function() &#123; var src = &#x27;node_modules/eruda/eruda.min.js&#x27; if (!/eruda=true/.test(window.location) &amp;&amp; localStorage.getItem(&#x27;active-eruda&#x27;) != &#x27;true&#x27;) return document.write(&#x27;&lt;scr&#x27; + &#x27;ipt src=&quot;&#x27; + src + &#x27;&quot;&gt;&lt;/scr&#x27; + &#x27;ipt&gt;&#x27;) document.write(&#x27;&lt;scr&#x27; + &#x27;ipt&gt;eruda.init();&lt;/scr&#x27; + &#x27;ipt&gt;&#x27;)&#125;)() 初始化时可以传入配置： container：用于插件初始化的 Dom 元素，如果不设置，默认创建 div 作为容器直接置于 html 根结点下面 tool：指定要初始化哪些面板，默认加载所有 let el = document.createElement(&#x27;div&#x27;)document.body.appendChild(el)eruda.init(&#123; container: el, tool: [&#x27;console&#x27;, &#x27;elements&#x27;], useShadowDom: true&#125;) vConsolehttps://github.com/Tencent/vConsole 一个轻量、可拓展、针对手机网页的前端开发者调试面板 特性 查看 console 日志 查看网络请求 查看页面 element 结构 查看 Cookies、localStorage 和 SessionStorage 手动执行 JS 命令行 自定义插件 使用说明 下载 vConsole 的最新版本（不要直接下载 dev 分支下的 dist/vconsole.min.js），复制 dist/vconsole.min.js 到项目中： 在 HTML 中引入 vConsole 模块 &lt;script src=&quot;dist/vconsole.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 初始化 var vConsole = new VConsole() console.log(&#x27;Hello world&#x27;)&lt;/script&gt; 在 vue 项目中：使用 npm 安装 npm install vconsole 在 main.js 中引入 import VConsole from &#x27;vconsole&#x27;const isDebug = true// 本地开发调试注入 vConsoleif (isDebug) &#123; new VConsole()&#125; weinrehttp://people.apache.org/~pmuellr/weinre/docs/latest/Home.html Element： 查看&#x2F;修改 dom，查看&#x2F;修改 dom CSS Resources：查看&#x2F;修改 localStorage, sessionStorage Network：查看网络请求 Timeline： Console：查看控制台输出 不能做 JS 调试 使用 # 安装npm install -g weinre# 启动 weinre 服务weinre --boundHost 192.168.3.44 --httpPort 8888启动调试客户端在浏览器中打开 &#x27;http://192.168.3.44:8888&#x27; 即可启动调试客户端在需要调试的页面中添加如下&lt;script src=&quot;http://192.168.3.44:8888/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt; spy-debuggerhttps://github.com/wuchangming/spy-debugger 微信调试，各种 WebView 样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP&#x2F;HTTPS，无需 USB 连接设备 spy-debugger 集成了weinre，简化了weinre需要给每个调试的页面添加 js 代码。原理是拦截所有 html 页面请求注入weinre所需要的 js 代码。让页面调试更加方便 1、页面调试＋抓包2、操作简单，无需 USB 连接设备3、支持 HTTPS4、spy-debugger内部集成了weinre、node-mitmproxy、AnyProxy。5、自动忽略原生 App 发起的 https 请求，只拦截 webview 发起的 https 请求。对使用了 SSL pinning 技术的原生 App 不造成任何影响。6、可以配合其它代理工具一起使用(默认使用 AnyProxy) (设置外部代理) 基本使用 # 安装npm install spy-debugger -g# 启动spy-debugger#设置手机的HTTP代理代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)# 手机安装证书手机浏览器访问 http://s.xxx设置-&gt;通用-&gt;描述文件与设备管理-&gt;找到node-mitmproxy CA（安装）设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到node-mitmproxy CA（打开） 自定义选项 # 自定义端口spy-debugger -p 8888# 设置页面内容为可编辑模式spy-debugger -w true# 是否只拦截浏览器发起的https请求(默认： true)spy-debugger -b false# 是否允许weinre监控iframe加载的页面(默认： false)spy-debugger -i true# 是否允许 HTTP 缓存(默认： false)spy-debugger -c true m-consolehttps://github.com/fwon/m-console 手机远程调试工具，手机通过代理连接上 PC 后，可以在 PC 版浏览器打印 log 和错误日志 需要手动给每个调试的页面添加 js 代码 DebugGap-VIDEhttps://www.debuggap.com/debug_webview.html Mobile Debughttps://www.mobiledebug.com/ whistlehttps://segmentfault.com/a/1190000016058875?utm_source=tag-newesthttp://wproxy.org/whistle/ chiihttps://github.com/liriliri/chii 抓包工具AnyProxyhttps://github.com/alibaba/anyproxyZan Proxyhttps://youzan.github.io/zan-proxy/","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://wqdy.top/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"【es6】Promise","slug":"前端/js/js-es6-promise","date":"08/01/2019","updated":"08/01/2019","comments":true,"path":"410.html","link":"","permalink":"https://wqdy.top/410.html","excerpt":"","text":"promise 的三个状态 pending : 等待 (等待成功或者失败去调用) fulfilled : 成功调用(resolve) rejected : 失败调用(reject) then、catch 和 finally 说明：获取异步操作的结果 then() ：用于获取异步操作成功时的结果 -&gt; resolve catch()：用于获取异步操作失败时的结果 -&gt; reject finally()：不管 Promise 最后状态如何，都会执行的操作，finally方法的回调函数不接受任何参数 then()方法可以有多个，按照先后顺序执行，通过回调函数返回值传递数据给下一个 then p .then((value) =&gt; &#123; &#125;) // onfullfilled 执行 .catch((err) =&gt; &#123;&#125;) // onrejected 执行// ----------- 或者 -----------// then 中传两个参数：第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数p.then( // onfullfilled 执行 (value) =&gt; &#123; &#125;, // onrejected 执行 (err) =&gt; &#123; &#125;) all 和 raceMDN-Promise.all()MDN-Promise.race() let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;成功1&#x27;) &#125;,500)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;成功2&#x27;) &#125;,1500)&#125;)let p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;失败&#x27;) &#125;, 1000)&#125;)// 等待 p1，p2 请求完成Promise.all([p1, p2]).then(res =&gt; &#123; console.log(res) // [&#x27;成功1&#x27;, &#x27;成功2&#x27;]&#125;)// 等待所有请求完成，只要有一个请求被 reject，就会进入 catch 回调Promise.all([p1, p2, p3]).then(res =&gt; &#123; console.log(res)&#125;).catch(error =&gt; &#123; console.log(error) // &#x27;失败&#x27;&#125;)// 始终返回最快的那一个异步，不管resolve还是rejectPromise.race([p1, p2]).then((res) =&gt; &#123; console.log(res) // &#x27;成功1&#x27;&#125;, (error) =&gt; &#123; console.log(error)&#125;)Promise.race([p1, p3]).then((res) =&gt; &#123; console.log(res) // &#x27;成功1&#x27;&#125;, (error) =&gt; &#123; console.log(error)&#125;)Promise.race([p2, p3]).then((result) =&gt; &#123; console.log(res)&#125;, (error) =&gt; &#123; console.log(error) // &#x27;失败&#x27;&#125;) async 和 await 异步编程终极方案 async &#x2F; await 用同步编写代码的方式 处理异步操作的一个方案 async：修饰 (修饰一个内部有异步操作的函数) 格式 : async + 函数 (里面有异步操作的函数) await : 等待 (等上一个异步操作完成啊 , 修饰 一个结果是 promise 的)异步操作 格式 : await + 异步操作(结果 promise 对象) async 和 await 是成对出现的，await 只能在 async 函数中使用 // 第一步封装function readFile(path) &#123; // 1. 实例化 promise const p = new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, (err, data) =&gt; &#123; if (err) &#123; // 操作错误 调用 =&gt; reject =&gt; catch return reject(err) &#125; // 操作成功 调用 =&gt; resolve =&gt; then resolve(data.toString()) &#125;) &#125;) // 2. 返回 promise 对象 return p&#125;// 第二步：使用 (async/await)// async + 函数 (里面有异步操作的函数)async function fn() &#123; // await + 异步操作(结果promise对象) // 读取a文件 try &#123; const res1 = await readFile(&#x27;./data/a1.txt&#x27;) console.log(res1) &#125; catch (error) &#123; console.log(error) &#125; // 读取 b 文件 const res2 = await readFile(&#x27;./data/b.txt&#x27;) console.log(res2) // 读取 c 文件 const res3 = await readFile(&#x27;./data/c.txt&#x27;) console.log(res3)&#125;fn() // 延时函数function sleep(a, b) &#123; const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(b) &#125;, a) &#125;) return p&#125;async function fn() &#123; const res1 = await sleep(1000, &#x27;a&#x27;) console.log(res1) const res2 = await sleep(5000, &#x27;b&#x27;) console.log(res2) const res3 = await sleep(3000, &#x27;c&#x27;) console.log(res3)&#125;// fn()sleep(1000, &#x27;a&#x27;) .then((res) =&gt; &#123; console.log(res) return sleep(5000, &#x27;b&#x27;) &#125;) .then((res) =&gt; &#123; console.log(res) return sleep(3000, &#x27;c&#x27;) &#125;) .then((res) =&gt; &#123; console.log(res) &#125;)const p1 = Promise.all([sleep(1000, &#x27;a&#x27;), sleep(5000, &#x27;b&#x27;)])p1.then((res) =&gt; &#123; console.log(res)&#125;)const p2 = Promise.race([sleep(1000, &#x27;a&#x27;), sleep(5000, &#x27;b&#x27;)])p2.then((res) =&gt; &#123; console.log(res)&#125;) Promise.try()实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。 Promise.resolve().then(f) 上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。 const f = () =&gt; console.log(&#x27;now&#x27;)Promise.resolve().then(f)console.log(&#x27;next&#x27;)// next// now 用async函数 (async () =&gt; f())().then(...).catch(...) Promise.try方法 const f = () =&gt; console.log(&#x27;now&#x27;)Promise.try(f)console.log(&#x27;next&#x27;)// now// next new Promise 和 Promise.resolve()","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://wqdy.top/tags/es6/"},{"name":"promise","slug":"promise","permalink":"https://wqdy.top/tags/promise/"}]},{"title":"Vue","slug":"前端/vue/vue","date":"08/01/2019","updated":"22/03/2019","comments":true,"path":"2010.html","link":"","permalink":"https://wqdy.top/2010.html","excerpt":"","text":"Vue插槽 vue 中文网 github 下载地址 Vue.js (读音 &#x2F;vju:&#x2F; view) 渐进式 JavaScript 框架 渐进式：小型项目使用 vue 就够了，随着页面的复杂程度提高，就要学习 vue-rouer 来管理更多的页面，再随着项目的数据越来越多，管理数据也变得麻烦起来了，就开始使用 vuex 来管理数据 框架 : 一整套的解决方案 框架和库的区别库(Library) ，代表 : jquery 库就是一系列函数的集合，我们开发人员在使用库的时候，想要完成什么样的功能，就调用库中提供的某个方法 比如：想要添加样式，就调用 jquery 中的 .css() &#x2F; .addClass() 库起到了一个辅助的作用，在使用库的是时候，是由开发人员说了算，也是由开发人员起主导作用 框架 (Framework)，代表 : vue 在使用框架的时候，是由框架说了算，由框架起到了主导作用 框架是一套完整的解决方案，框架中制定了一套规则，使用框架的时候，只需要按照规则把代码放到合适的地方，然后框架会在合适的时机，主动调用开发人员的代码 比如 : 想用 vue 组件里遍历就得使用 v-for，使用 for 不行 主要区别：控制反转 也就是 : 谁起到了主导作用 使用库的时候：开发人员起主导作用 使用框架的时候：框架起到了主导作用 从体量上看，框架一般比库大 会发现使用框架的时候，会受到很多限制 我们所说的前端框架与库的区别？ MVC + MVVMMVC MVC 是一种软件架构模式，也有人叫做设计模式 M : Model 数据模型 (专门用来操作数据，数据的 CRUD) V : View 视图 (对于前端来说就是页面) C : Controller 控制器 (是视图和数据模型沟通的桥梁，用于处理业务逻辑) MVVM Vue 使用的是 MVVM 模式 MVVM &#x3D;&#x3D;&#x3D;&gt; M &#x2F; V &#x2F; VM M : model 数据层 V : view 视图层 VM : ViewModel 视图模型 核心 : M &lt;&#x3D;&#x3D;&#x3D;&gt; VM &lt;&#x3D;&#x3D;&#x3D;&gt; V MVVM 优势 MVC 模式将应用程序划为三个部分，实现职责分离 但是，在前端中，经常要通过 js 代码来进行一些逻辑操作，最终还要把这些逻辑操作展示页面中，也需要频繁的操作DOM 比如 : ajax 请求、添加、修改、设置样式、动画 MVVM 的思想通过 数据双向绑定 让数据自动的双向同步 V (修改视图) –&gt; M M (修改数据) –&gt; V 采用的是 : 数据驱动视图的思想，数据是核心。不要再想着怎么操作 DOM，而是想着如何操作数据 Vue 中的 MVVM 注意 : 不推荐直接手动操作 DOM 每个人操作 DOM 的方法不一样，会造成性能不一样官网 : 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例 Vue 基本使用 安装 : npm i vue 导入 : &lt;script src=&#39;./vue.js&#39;&gt;&lt;/script&gt; 实例化 vue const vm = new Vue(&#123; // 指定 vue 管理的边界，不能是 body 或 html 节点 el: &#x27;#app&#x27;, // 提供视图中需要的数据 // 视图可以直接使用 data 中的数据 data: &#123; msg: &#x27;xxx&#x27; &#125;&#125;) 使用注意点使用 vm 表示 vue 实例 Vue 构造函数首字母大写 参数是一个对象 id&#x3D;’#app’，其他也可以 边界外无法使用 msg 插值表达式1. &#123;&#123;&#125;&#125; : mustache 语法，小胡子语法，插值表达式2. 作用 : 使用`&#123;&#123;&#125;&#125;` 从`data`中获取数据，并展示在模板中3. 说明 : `&#123;&#123;&#125;&#125;` 中只能出现 js 表达式4. `&#123;&#123;&#125;&#125;` 语法不能作用在 HTML 元素的属性上 表达式 (有返回值的)： 基本的数据类型 1 &#39;abc&#39; false [] &#123;&#125; 数据类型 和 运算符结合在一起1+2 arr.join(&#39;-&#39;) true ? 123 : 321 语句： if 语句 for 语句 双向数据绑定input + v-modelv-model 指令：数据双向绑定的指令 作用：把 data 中的 num 值 和 input 上的值绑定到一起，一方的值发生了改变，另 一方也会跟着改变 注意：v-model 只能用在表单控件上（input checkbox 等） 数据双向绑定的原理&lt;div id=&quot;app&quot;&gt; &lt;input id=&quot;input&quot; type=&quot;text&quot; /&gt;&lt;/div&gt; let obj = &#123;&#125;let tempObject.defineProperty(obj, &#x27;name&#x27;, &#123; set: function (newVal) &#123; // 设置属性时会触发该函数 console.log(&#x27;设置&#x27;, newVal) temp = newVal input.value = newVal &#125;, get: function () &#123; // 获取属性时会触发该函数 console.log(&#x27;获取&#x27;) return temp &#125;&#125;)input.oninput = function () &#123; // console.log(this.value) obj.name = this.value console.log(obj.name)&#125; 深入响应式原理检测变化注意：受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 Vue 不允许在已经创建的实例上动态添加新的根级响应式属性，可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上，或者创建一个包含原对象属性和新属性的对象替换掉原对象 列表渲染数组更新检测数组的方法可以触发视图更新：方法如下： push()、pop()、shift()、unshift()、splice()、sort()、reverse() 替换数组 用一个含有相同元素的数组去替换原来的数组并不会导致 Vue 丢弃现有 DOM 并重新渲染整个列表 注意：由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 解决第一类问题： // Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 解决第二类问题： vm.items.splice(newLength) 指令学习指令 指令：就是一个特殊的标记，起一个辅助作用，使 html 具备原来没有的功能 vue 中所有的指令都是以 v- 开头的，比如 : v-model v-bind v-if v-for 等等 v-model (常用) 说明：用在表单元素中，用来实现数据双向绑定 (input checkbox 等等)作用：将 数据 和 文本框的值 绑定到一起，任何一方发生改变，都会引起对方的改变注意：v-model 在不同类型的表单元素中作用不同v-model 会忽略所有表单元素的 value、checked、selected 的初始值而总是将 Vue 实例的数据作为数据来源 &lt;div id=&quot;app&quot;&gt; &lt;!-- 文本输入框 绑定的是值 --&gt; &lt;input type=&quot;text&quot; v-model=&quot;num&quot; /&gt; &lt;!-- 多选框 绑定的选中状态 --&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;isChecked&quot; /&gt;&lt;/div&gt; const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; num: 0, isChecked: true &#125;&#125;) v-text 和 v-html 说明 : 设置文本内容 v-text : 相当于之前的 innerText v-html : 相当于之前的 innerHTML，会解析 html 标签，（已经废弃三大括号的插值） &lt;div id=&quot;app&quot;&gt; &lt;h1 v-text=&quot;msg1&quot;&gt;&lt;/h1&gt; &lt;h1 v-html=&quot;msg2&quot;&gt;&lt;/h1&gt;&lt;/div&gt; const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg1: &#x27;&lt;a href=&quot;#&quot;&gt;haha&lt;/a&gt;&#x27;, msg2: &#x27;&lt;a href=&quot;#&quot;&gt;haha&lt;/a&gt;&#x27; &#125;&#125;) v-bind (常用) 说明：动态绑定数据 (单向)出现原因：在 HTML 属性中，无法使用插值表达式 &lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;href&quot;&gt;hahaha&lt;/a&gt; &lt;!-- v-bind 可以直接省略 --&gt; &lt;a :href=&quot;href&quot;&gt;hahaha&lt;/a&gt;&lt;/div&gt; // v-bind：// 说明：动态数据绑定 (单向)，因为html的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据, 需要使用 v-bindconst vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; href: &#x27;https://www.baidu.com&#x27; &#125;&#125;) v-bind 和 v-model 的区别&lt;!-- v-model 数据双向绑定 --&gt;&lt;!--场景：表单元素中 --&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;isChecked1&quot; /&gt;&lt;!-- v-bind 数据动态绑定 (单向) --&gt;&lt;!--场景：主要用在属性中 --&gt;&lt;input type=&quot;checkbox&quot; :checked=&quot;isChecked2&quot; /&gt; 操作样式&lt;div id=&quot;app&quot;&gt; &lt;!-- 操作样式 --&gt; &lt;!-- 1. 动态添加类，但不符合 vue 数据是核心的思想 --&gt; &lt;h1 :class=&quot;cls&quot;&gt;hahaha&lt;/h1&gt; &lt;!-- 2. class 值是一个对象 --&gt; &lt;!-- 属性名为类名 --&gt; &lt;!-- 属性值为布尔值 --&gt; &lt;h1 :class=&quot;&#123;red: isRed, fz: isFz&#125;&quot;&gt;hahaha&lt;/h1&gt; &lt;!-- 3. style --&gt; &lt;h1 :style=&quot;&#123;backgroundColor: &#x27;red&#x27;, fontSize: fz + &#x27;px&#x27;&#125;&quot;&gt;hahaha&lt;/h1&gt;&lt;/div&gt; // v-bind :// 说明 : 动态数据绑定 (单向)，因为 html 的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据 , 需要使用 v-bindconst vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; href: &#x27;https://www.baidu.com&#x27; &#125;&#125;) 其他操作 &lt;div id=&quot;app&quot;&gt; &lt;div :class=&quot;[&#x27;red&#x27;, &#x27;fz&#x27;]&quot;&gt;heheheh&lt;/div&gt; &lt;!-- ===&gt; &lt;div class=&quot;red fz&quot;&gt;&lt;/div&gt; --&gt; &lt;!-- 多个样式对象写成数组的形式，如果有相同样式后面会覆盖前面 --&gt; &lt;div :class=&quot;[&#123;red: true&#125;, &#x27;fz&#x27;]&quot;&gt;hehehe&lt;/div&gt; &lt;!-- ===&gt; &lt;div class=&quot;red fz&quot;&gt;&lt;/div&gt; --&gt;&lt;/div&gt; v-on 注册事件&#x2F;绑定事件 v-on:click 绑定了一个 click 事件 缩写 : @click&#x3D;’fn’ 函数写在 methods 里面 &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;fn&quot;&gt;按钮&lt;/button&gt; &lt;!-- 简写 @ --&gt; &lt;button @click=&quot;fn1&quot;&gt;按钮&lt;/button&gt; &lt;!-- 传参 --&gt; &lt;button @click=&quot;fn2(123)&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; // v-on 注册事件// v-on:click =&gt; 绑定点击事件const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, // 事件函数写在 methods 中 methods: &#123; fn () &#123; console.log(&#x27;haha&#x27;) &#125;, fn1 () &#123; console.log(&#x27;haha&#x27;) &#125;, fn2 (ref) &#123; console.log(ref) &#125; &#125;&#125;) 函数里面的 this 指的就是 vm 实例 this === vm // truethis.msg // 获取数据this.msg = &#x27;XXX&#x27; // 修改数据 事件对象 $event &lt;!-- 绑定事件对象的时候, 没有添加小括号，此时，直接在方法中，通过参数 e 就可以获取到事件对象 --&gt;&lt;button @click=&quot;fn&quot;&gt;按钮&lt;/button&gt;&lt;!-- 如果绑定事件的地方,事件函数有() @click=&#x27;fn()&#x27; 则需要通过 $event 获取 --&gt;&lt;button @click=&quot;fn1($event, 123)&quot;&gt;按钮&lt;/button&gt; const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123; fn (e) &#123; console.log(e) &#125;, fn1 (e, ref) &#123; console.log(e) console.log(ref) &#125; &#125;&#125;) v-for遍历数据，为数据中的每一项生成一个指令所在的标签 &lt;!-- 1: 最常用 遍历数组 --&gt;&lt;li v-for=&quot;(item, index) in list1&quot;&gt;&#123;&#123; item &#125;&#125; - &#123;&#123; index &#125;&#125;&lt;/li&gt;&lt;!-- 2: 遍历元素是对象的数组 --&gt;&lt;li v-for=&quot;item in list2&quot;&gt;&#123;&#123; item.name &#125;&#125; - id:&#123;&#123; item.id &#125;&#125;&lt;/li&gt;&lt;!-- 3: 遍历对象 --&gt;&lt;!-- item 是 属性值，key 是属性名 --&gt;&lt;li v-for=&quot;(item, key) in obj&quot;&gt;&#123;&#123; item &#125;&#125;-&#123;&#123;key&#125;&#125;&lt;/li&gt;&lt;!-- 4: 生成10个h1 （item是1-10）--&gt;&lt;h1 v-for=&quot;item in 10&quot;&gt;我是h1 &#123;&#123; item &#125;&#125;&lt;/h1&gt; v-if 和 v-show&lt;h1 v-if=&quot;isShow&quot;&gt;我是h1 v-if&lt;/h1&gt;&lt;h1 v-show=&quot;isShow&quot;&gt;我是h1 v-show&lt;/h1&gt; v-if 和 v-show 都可以切换元素的显示与隐藏，不同的是 v-if 通过创建删除节点来控制元素的显示与隐藏， v-show 的元素始终会被渲染并保留在 DOM 中，只是简单地切换元素的 CSS 属性 display，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else 使用场景 : v-if 因为要不断的创建和删除来切换显示与隐藏，所以性能不高 v-if：切换次数不频繁的时候 v-show：切换次数频繁的时候 v-else-if 和 v-elsev-else：两种情况的 &lt;h1 v-if=&quot;num &gt; 40&quot;&gt;第一个&lt;/h1&gt;&lt;h1 v-else&gt;第三个&lt;/h1&gt; v-else-if：三种以上情况 &lt;h1 v-if=&quot;num &gt;= 40&quot;&gt;第一个&lt;/h1&gt;&lt;h1 v-else-if=&quot;num &gt;= 30 &amp;&amp; num &lt; 40&quot;&gt;第二个&lt;/h1&gt;&lt;h1 v-else&gt;第三个&lt;/h1&gt; v-once作用：告诉 vue 这个标签中的内容只需要解析一次，即便是数据再发送改变，这个标签中的内容也不会被更新 &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt;&lt;p v-once&gt;带 onece 的 &#123;&#123; num &#125;&#125;&lt;/p&gt; v-pre作用：告诉 vue 这段节点中没有指令或表达式，不需要解析，从而，提升性能 &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt;&lt;p v-pre&gt;带 v-pre &#123;&#123; num &#125;&#125;&lt;/p&gt; v-cloak使用遮盖 给要遮盖的元素添加一个 v-cloak 指令： &lt;h1 v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; 使用属性选择器，添加样式：[v-cloak] &#123; display: none &#125; vue 会在解析模板后将 v-cloak 指令从页面中移除，移除指令的时候，差值表达式已经变为对应的数据 按键修饰符在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符 Vue 为最常用的按键提供了别名： &lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13=&quot;submit&quot; /&gt;&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot; /&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=&quot;submit&quot; /&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive &lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器 .ctrl .alt .shift .meta &lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=&quot;clear&quot; /&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt; 鼠标按钮修饰符 .left .right .middle 这些修饰符会限制处理函数仅响应特定的鼠标按钮 计算属性computed: &#123; message () &#123;&#125;,&#125; 特点：计算属性是基于它们的响应式依赖进行缓存的，只有跟计算属性相关的数据发生了改变，计算属性才会重新计算 注意点: 计算属性必须返回一个值 计算属性只能当属性用，不能当方法用 不能和 data 中的属性名重名 key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值 建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升 就地复用 &lt;!-- 显示组件 --&gt;&lt;p v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt; &#123;&#123; item.name &#125;&#125; &lt;input type=&quot;text&quot; /&gt;&lt;/p&gt;&lt;!-- 数据 --&gt;data: &#123;list: [&#123;id: 1, name: &#x27;zs&#x27;&#125;, &#123;id: 2, name: &#x27;ls&#x27;&#125;, &#123;id: 3, name: &#x27;ww&#x27;&#125;]&lt;!-- 演示 --&gt;vm.list.unshift(&#123;id:4, name:&#x27;zl&#x27;&#125;) 使用 key 如果数组的元素是一个对象，使用对象里固定属性，一般情况下，对象里都有 id 如果数组的元素是一个简单类型，不是一个对象，就可以取索引作为 key 异步 DOM 更新 Vue 中采用了 异步DOM更新 的机制 数据发生改变后，vue 没有立即将数据的改变更新到视图中，而是等到数据不再变化的时候 一次性的将数据的改变更新到视图中 为什么是异步 DOM 更新? 性能的考虑 因为对于前端来说，修改数据进行 DOM 操作是常有的事情，如果频繁操作 DOM，会严重影响页面的加载性能 DOM 操作这是前端的性能的瓶颈 比如 : for (let i &#x3D; 1; i &lt; 10000; i++&gt;) 如果同步 就要重新渲染 1000 次 验证异步 DOM 更新： // 通过dom来获取count的值// this.$el ==&gt; vue 边界元素console.log(this.$el.children[0].innerText) // 0this.count = 100console.log(this.$el.children[0].innerText) // 0 需求：在数据更新后，立即获取到更新后的内容 this.$nextTick(() =&gt; &#123; // DOM 更新后，会执行 this.$nextTick() 的回调函数，所以能拿到值 console.log(this.$el.children[0].innerText) // 100&#125;) 监听 watchvue 中可以通过 watch 配置项来监听 vue 实例中数据的变化 基本使用 data: &#123; num: 0&#125;,// 监听watch: &#123; // 监听 num 属性的数据变化 // 作用: 只要 num 的值发生变化，这个方法就会被调用 // 第一个参数: 新值 // 第二个参数: 旧值 num (newVal, oldVal) &#123; console.log(&#x27;新:&#x27;, newVal) console.log(&#x27;旧:&#x27;, oldVal) &#125;&#125; 监听对象 data: &#123; msg: &#x27;&#x27;, obj: &#123; age: 18 &#125;&#125;watch: &#123; // 监听对象 obj (newVal) &#123; // 虽然 obj 中的属性值发生改变了，但 obj 引用的地址没有发生改变，所以不会触发事件 console.log(newVal) &#125;, // 监听对象的属性 // 从对象的角度来监听的 obj: &#123; // 深度监听 监听对象里面的属性 deep: true, // 页面刚进入立即触发监听，以表达式的当前值触发回调 immediate: true, // 对象里的属性值发生变化，调用 handler 方法 handler (newVal) &#123; this.msg = `obj.age 值变化了，新值：$&#123;newVal.age&#125;` &#125; &#125;, // 从属性的角度来监听 &#x27;obj.age&#x27; (newVal) &#123; this.msg = `obj.age 值变化了，新值：$&#123;newVal&#125;` &#125;&#125; 使用案例：需求 : 监听文本框字符个数，并显示格式验证码 &lt;input type=&quot;text&quot; v-model=&quot;val&quot; /&gt;&lt;span v-show=&quot;isTrue&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt; data: &#123; val: &#x27;&#x27;, msg: &#x27;请输入 6-12 位&#x27;, isTrue: false&#125;,watch: &#123; val (newVal) &#123; if (/^[0-9a-zA-z]&#123;6,12&#125;$/.test(newVal)) &#123; this.isTrue = false &#125; else &#123; this.isTrue = true &#125; &#125;&#125; 生命周期函数 所有的 vue 组件，都是 vue 实例，一个组件对应一个实例，并且接收相同的选项对象（一些根实例特有的选项除外） 实例生命周期也叫做：组件生命周期 声明周期图：01 生命周期介绍vue 生命周期钩子函数 简单说：一个组件（实例）从开始到最后消化所经历的各种状态，就是一个组件的生命周期 生命周期钩子函数的定义：从组件被创建，到组件挂在到页面上运行，再到页面关闭组件被销毁，这三个阶段总是伴随着组件的各种事件，这些事件，统称为组件的生命周期函数（简称 : 钩子函数） 开发人员可以通过 vue 提供的钩子函数，让我们写的代码参与到 vue 的生命周期里面来，让我们的代码在合适的阶段起到相应的作用 注意： vue 在执行过程中会 自动调用 生命周期钩子函数，我们只需要提供这些钩子函数即可 钩子函数的名称都是 vue 中规定好的 vue 实例生命周期 参考 1 vue 实例生命周期 参考 2 钩子函数 - beforeCreate 在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用 此时组件的选项还未挂载，因此无法访问 methods，data，computed 上的方法或数据 使用场景 : 几乎不用 钩子函数 - created (掌握) 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch&#x2F;event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见 可以调用 methods 中的方法、改变 data 中的数据，并且修改可以通过 vue 的响应式绑定体现在页面上、获取 computed 中的计算属性等 使用场景：发送 ajax、本地存储获取数据 钩子函数 - beforeMounted() 在挂载开始之前被调用（挂载：DOM 渲染） 钩子函数 - mounted() (掌握) el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 这个周期可以获取 DOM 指令的生效在 mounted 周期之前 在这个周期内，对 data 的改变可以生效。但是要进下一轮的 DOM 更新，DOM 上的数据才会更新 使用场景：发送 ajax、操作 DOM 钩子函数 - beforeUpdate() 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程 此处获取的数据是更新后的数据，但是获取页面中的 DOM 元素是更新之前的 小提示 : 打印 this.$el ，打开小三角是之后的，是因为打印是有监听的功能，展示的是后面更改之后的 钩子函数 - updated() 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子 组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作 应该避免在此期间更改状态。如果要相应状态改变，通常最好使用 计算属性 或 watcher 取而代之 钩子函数 - beforeDestroy() 实例销毁之前调用。在这一步，实例仍然完全可用。 使用场景：实例销毁之前，执行清理任务，比如：清除定时器等 created () &#123; this.timerId = setInterval(() =&gt; &#123; console.log(1111) &#125;, 500)&#125;, // 如果当组件销毁了,还不清除定时器会出现性能问题 // 在浏览器中可以尝试销毁 vm.$destroy() // 最后销毁beforeDestroy () &#123; clearInterval(this.timerId)&#125; 钩子函数 - destroyed() Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 使用接口的形式发送数据json-server 提供假数据接口 作用：根据指定的 JSON 文件，提供假数据接口 地址：json-server 使用步骤 1. 全局安装 json-server: `npm i -g json-server`2. 准备一个json数据3. 执行：`json-server data.json`data.json&#123; &quot;todos&quot;: [ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20 &#125; ]&#125; REST API 格式 1. 查询：GET2. 添加：POST3. 删除：DELETE4. 更新： PUT：需要将对象里的所有属性提交 PATCH(打补丁)：只需要提交需要修改的属性 具体接口 查询全部数据 http://localhost:3000/todos查询指定数据 http://localhost:3000/todos/2 添加一个对象 http://localhost:3000/todosPOSTid 会自动帮我们添加 更新数据 http://localhost:3000/todos/3PUT 或者 PATCHPUT 需要提供该对象的所有数据PATCH 只需要提供要修改的数据即可 删除数据http://localhost:3000/todos/3DELETE 可以借助 postman 测试接口 axios 发送请求 作用 : 一个专门用来发送 ajax 请求的库, 可以在浏览器或者 node.js 中使用 使用步骤 本地安装 axios : npm i -g axios 导入 axios axios 使用说明 GTE 方式发送请求 // 方式1axios.get(&#x27;http://localhost:3000/todoList/1&#x27;).then(res =&gt; &#123; console.log(&#x27;获取到数据了：&#x27;, res.data)&#125;)// 方式2axios .get(&#x27;http://localhost:3000/todoList&#x27;, &#123; params: &#123; id: 1 &#125; &#125;) .then(res =&gt; &#123; console.log(&#x27;获取到数据了：&#x27;, res.data) &#125;) POST 方式发送请求 // post 请求axios // 第一个参数：表示接口地址 // 第二个参数：表示接口需要的参数 .post(&#x27;http://localhost:3000/todoList&#x27;, &#123; name: &#x27;haha&#x27;, done: true &#125;) .then(res =&gt; &#123;&#125;) 过滤器概念 : vue 中的过滤器(filter)：数据格式化，让数据按照我们规定的格式输出 比如 : 对于日期来说，将日期格式化转化为 年-月-日 小时:分:秒 &lt;!-- 直接显示 --&gt;&lt;h1&gt;&#123;&#123; date &#125;&#125;&lt;/h1&gt;显示：2019-01-11T10:11:19.566Z 不是我们想要的 我们想要的：2019-01-11 18-11-53 全局过滤器 和 局部过滤器 全局方式创建的过滤器，在任何一个 Vue 实例中都可以使用 (一般情况下，为了项目方便管理，都是一个 vue 实例) 局部创建的过滤器只能在当前 vue 实例中使用 全局过滤器应在 Vue 实例创建之前创建 注册全局过滤器 // 第一个参数：过滤器的名字// 第二个参数：是一个回调函数，只要使用过滤器的时候，这个回调函数就会执行，res =&gt; 原始数据// 必须要有返回值：通过回调函数的返回值得到格式化后的数据Vue.filter(&#x27;date&#x27;, res =&gt; &#123; return res&#125;) 注册局部过滤器 在 vm 的配置项里写一个 filters，对应的是一个对象 filters: &#123; date (res) &#123; return res &#125;&#125; moment 插件 moment 使用：npm i moment 日期 &#x3D;&gt; 指定格式moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;) 时间戳 &#x3D;&gt; 指定格式moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;) &#96;&#96;&#96;jsVue.filter(‘dataFilter’, res &#x3D;&gt; { return moment(res).format(‘YYYY-MM-DD HH-mm-ss’)}) **使用过滤器**```html&lt;!-- data: 原始数据 dataFilter: 过滤器名称 |：管道--&gt;&lt;h1&gt;&#123;&#123; date | dataFilter &#125;&#125;&lt;/h1&gt; // 全局Vue.filter(&#x27;dataFilter&#x27;, res =&gt; &#123; return moment(res).format(&#x27;YYYY-MM-DD HH-mm-ss&#x27;)&#125;)// 局部filters: &#123; date (res, format = &#x27;YYYY-MM-DD&#x27;, arg) &#123; return moment(res).format(format) &#125;&#125; 参数问题 &lt;h1&gt;&#123;&#123; date | dateFilter(&#x27;YYYY-MM-DD HH-mm-ss&#x27;, 888) &#125;&#125;&lt;/h1&gt; Vue.filter(&#x27;dateFilter&#x27;, (res, format = &#x27;YYYY-MM-DD&#x27;, arg) =&gt; &#123; // res: 原始数据 // format：dateFilter 中的第一个参数，等号后面为默认值 // arg: dateFilter 中的第二个参数 console.log(arg) // 888 return moment(res).format(format)&#125;) 组件 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常 可复用 的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树 注册组件的两种方式：全局组件、局部组件 Vue 实例中的配置项（如：methods、filters、watch、computed、directives、生命周期钩子函数）都可以在组件中使用 全局组件 说明：全局组件在所有的 vue 实例中都可以使用 注意： 注册全局组件应放在 vm 实例之前 模板只允许有一个根节点 组件中的 data 必须是函数，并且要返回一个对象 组件复用时如果 data 为对象，所有复用的组件的 data 指向同一片内存空间，一个组件被修改了会影响其他组件，这不是我们想要的 // 注册全局组件Vue.component(&#x27;hello&#x27;, &#123; template: &#x27;&lt;p&gt;A custom component!&lt;/p&gt;&#x27;, data () &#123; return &#123; msg: &#x27;注意：组件的data必须是一个函数！！！&#x27; &#125; &#125;&#125;)// 给组件指定返回值// 组件名称为 Oneconst One = Vue.component(&#x27;hello&#x27;, &#123; template: &#x27;&lt;p&gt;A custom component!&lt;/p&gt;&#x27;&#125;)// 可以简写为 ==&gt;const One = &#123; template: &#x27;&lt;p&gt;A custom component!&lt;/p&gt;&#x27;&#125; &lt;!-- 使用：以自定义元素的方式 --&gt;&lt;div id=&quot;example&quot;&gt; &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt;&lt;!-- 渲染结果 --&gt;&lt;div id=&quot;example&quot;&gt; &lt;p&gt;A custom component!&lt;/p&gt;&lt;/div&gt; 局部组件 局部组件是在某一个具体的 vue 实例（组件）中定义的，只能在当前 vue 实例（组件）中使用 const vm = new Vue(&#123; el: &#x27;#app&#x27;, // 局部组件 components: &#123; // 子组件 com-a &#x27;com-a&#x27;: &#123; template: `&lt;h1&gt;局部组件：&#123;&#123; num &#125;&#125;&lt;/h1&gt;`, data () &#123; return &#123; num: 10 &#125; &#125; &#125; &#125;&#125;) 组件通讯 组件是一个独立、封闭的个体 也就是说：组件中的数据默认情况下，只能在组件内部使用，无法直接在组件外部使用 可以将 vue 实例看做一个组件 对于组件之间需要相互使用彼此的情况，应该使用 组件通讯机制 来解决 组件通讯的三种情况 : 父组件将数据传递给子组件(父 -&gt; 子) 子组件将数据传递给父组件 (子 &#x3D;&gt; 父) 非父子组件(兄弟组件) 父组件到子组件 将要传递的数据，通过属性传递给子组件 &lt;child :msg=&quot;pmsg&quot;&gt;&lt;/child&gt; 子组件通过 props 配置项来指定要接收的数据，props 是一个数组 在使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名代替 如果使用字符串模板，那么这个限制就不存在了 props: [&#x27;msg&#x27;] 传递过来的 props 属性的用法与 data 属性的用法相同 子组件不能直接修改父组件传过来的数据，可以将父组件传过来的值保存在一个临时变量中 如果 props 传过来的数据为引用类型，只要不是重新赋值，修改数据不会报错，但不推荐这样做 &lt;!-- 第一步：将你要传递的数据,作为属性传递给子组件 --&gt;&lt;hello :num=&quot;pnum&quot;&gt;&lt;/hello&gt; Vue.component(&#x27;hello&#x27;, &#123; template: `&lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;`, // 第二部：子组件通过 props 配置项来指定要接收的数据 props: [&#x27;num&#x27;]&#125;) 子组件到父组件 方式：父组件给子组件传递一个函数，由子组件调用这个函数 说明：借助 vue 中的自定义事件(v-on:cunstomFn&#x3D;”fn”) $emit()：触发事件 第一步：父组件了里准备一个方法 const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; pnum: 1 &#125;, methods: &#123; pfn (num) &#123; this.pnum += num &#125; &#125;&#125;) 第二步：把这个方法作为事件传递给子组件 &lt;hello @fn=&quot;pfn&quot;&gt;&lt;/hello&gt;&lt;!-- 或&lt;hello @fn=&quot;num += $event&quot;&gt;&lt;/hello&gt;$event 为传过来的参数--&gt; 第三步：子组件调用父组件传过来的方法 Vue.component(&#x27;hello&#x27;, &#123; template: `&lt;button @click=&#x27;click&#x27;&gt;按钮&lt;/button&gt;`, data () &#123; return &#123; num: 5 &#125; &#125;, methods: &#123; click () &#123; // 第一个参数：表示要触发的自定义事件名称，也就是 @fn // 第二个参数：表示要传递给父组件的数据 this.$emit(&#x27;fn&#x27;, this.num) &#125; &#125;&#125;) 非父子组件通讯 是通过 事件总线 (event bus 公交车) 机制 来实现的 事件总线：实际上就是一个 空 Vue 实例 可以实现任意两个组件之间的通讯而不管两个组件到底有什么样的层级关系 $emit()：发送数据 $on()：接收数据 // 第一步：实例化事件总线 busconst bus = new Vue()// 触发组件 A 中的事件bus.$emit(&#x27;id&#x27;, 1)// 在组件 B 创建的钩子中监听事件bus.$on(&#x27;id&#x27;, id =&gt; &#123; // ...&#125;) 示例：组件 A —&gt; 组件 B &lt;div id=&quot;app&quot;&gt; &lt;com-a&gt;&lt;/com-a&gt; &lt;com-b&gt;&lt;/com-b&gt;&lt;/div&gt; // 第一步：实例化事件总线 busconst bus = new Vue()// 组件 AVue.component(&#x27;com-a&#x27;, &#123; template: `&lt;h1 @click=&quot;click&quot;&gt;组件A&lt;/h1&gt;`, methods: &#123; click () &#123; // 第二部：发送数据 bus.$emit(&#x27;hello&#x27;, &#x27;你好&#x27;) &#125; &#125;&#125;)// 组件 BVue.component(&#x27;com-b&#x27;, &#123; template: `&lt;h1&gt;组件B&lt;/h1&gt;`, created () &#123; // 第三步：接收数据 bus.$on(&#x27;hello&#x27;, res =&gt; &#123; console.log(&#x27;接收到数据&#x27;, res) &#125;) &#125;&#125;)const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;&#125;) [开关灯案例] 单向数据流(组件与组件之间)所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 当 todo-head 中的 todoName 设置数据后回车添加到 todoList，todoList 的长度就会发生变化，然后就会根据(组件与组件之间的)单向数据流，把数据单向下流到子组件中而且必须是通过 props 往下传递的才可以 refsvm.$refs 一个对象，持有已注册过 ref 的所有子组件 ( HTML 元素) 使用 : &lt;!-- 在 HTML元素 中，添加ref属性 --&gt;&lt;div ref=&quot;div&quot;&gt;哈哈&lt;/div&gt;&lt;child ref=&quot;child&quot;&gt;&lt;/child&gt; // 在JS中通过 $refs.属性 来获取// 在 mounted 函数中使用Vue.component(&#x27;child&#x27;, &#123; template: `&lt;h1&gt;组件A&lt;/h1&gt;`, data () &#123; return &#123; num: 100 &#125; &#125;, methods: &#123; fn () &#123;&#125; &#125;&#125;)const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, mounted () &#123; console.log(this.$refs) console.log(this.$refs.div) // div 标签 console.log(this.$refs.child) // child 组件 &#125;&#125;) 如果获取的是一个子组件，那么通过 ref 就能获取到子组件中的 data 和 methods console.log(this.$refs.child.num) // 100console.log(this.$refs.child.fn) // fn 一般在第三方的组件中， 可能会用到这个功能 单页面应用程序SPA : Single Page Application 单页面应用程序 MPA : Multiple Page Application 多页面应用程序 单页 web 应用，就是只有一个 web 页面的应用，是加载单个 HTML 页面，并在用户与应用程序交互时动态更新该页面的 web 应用程序 区别 对于传统的多页面应用程序来说，每次请求服务器返回的都是一个完整的页面 对于单页应用程序来说，只有第一次会加载页面，以后的每次请求，仅仅是获取必要的数据，然后由页面中 js 解析获取的数据展示在页面中 优势 : 减少了请求体积，加快页面响应速度，降低了对服务器的压力 更好的用户体验，让用户在 web app 感受 native app 的流畅 路由 路由 : 是浏览器 URL 中的哈希值( # hash) 与 展示视图内容 之间的对应规则 在 web App 中，通过一个页面来展示和管理整个应用的功能。SPA 往往是功能复杂的应用，为了有效管理所有视图内容，前端路由应运而生。简单来说，路由就是一套映射规则(一对一的对应规则)，由开发人员制定规则。当 URL 中的哈希值( # hash) 发生改变后，路由会根据制定好的规则，展示对应的视图内容。 vue 中的路由；是 hash 和 component 的对应关系，一个哈希值对应一个组件 基本使用安装路由 : npm i vue-router 引入路由 &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./node_modules/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; 详细使用步骤 实例路由对象并挂载到 vue 实例 上 // 路由实例 与 Vue 实例 关联到一起const router = new VueRouter()const vm = new Vue(&#123; el: &#x27;#app&#x27;, router&#125;) 入口 (#哈希值) &lt;!--方式1 : url地址为入口 输入url地址改变哈希值router.html#/one方式2 : router-link+toto 属性：实际上就是哈希值，将来要参与路由规则中进行与组件匹配router-link 标签最终会转化为 a 标签，to 属性转化为 a 标签的 href 属性--&gt;&lt;router-link to=&quot;/one&quot;&gt;One&lt;/router-link&gt;&lt;router-link to=&quot;/two&quot;&gt;Tow&lt;/router-link&gt; 注册组件并设置返回值 const One = &#123; template: `&lt;div&gt;组件 One&lt;/div&gt;`&#125;const Two = &#123; template: `&lt;div&gt;组件 Two&lt;/div&gt;`&#125; 设置规则 // path : 路由路径// component : 将来要展示的路由组件const router = new VueRouter(&#123; routes: [&#123; path: &#x27;/one&#x27;, component: One &#125;, &#123; path: &#x27;/two&#x27;, component: Two &#125;]&#125;) 出口 &lt;!-- 出口：组件要展示的地方--&gt;&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 示例 ： &lt;div id=&quot;app&quot;&gt; &lt;!-- 入口 --&gt; &lt;!-- 可以直接通过url地址访问路由 --&gt; &lt;!-- to 属性：路由匹配路径router-link 最终会转化为 a 标签--&gt; &lt;router-link to=&quot;/one&quot;&gt;One&lt;/router-link&gt; &lt;router-link to=&quot;/two&quot;&gt;Tow&lt;/router-link&gt; &lt;!-- 5. 出口 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; // 3. 注册组件并设置返回值const One = &#123; template: `&lt;div&gt;组件 One&lt;/div&gt;`&#125;const Two = &#123; template: `&lt;div&gt;组件 Two&lt;/div&gt;`&#125;// 1. 实例化路由对象const router = new VueRouter(&#123; routes: [ // 4. 配置路由规则，路由和实例一一对应 &#123; path: &#x27;/one&#x27;, component: One &#125;, &#123; path: &#x27;/two&#x27;, component: Two &#125; ]&#125;)const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, // 2. 将路由挂载到 vue 实例上，让 vue 和路由关联在一起 router&#125;) 多出口情况 &lt;div id=&quot;app&quot;&gt; &lt;!-- 多个出口的形式 --&gt; &lt;router-view name=&quot;one&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;two&quot;&gt;&lt;/router-view&gt;&lt;/div&gt; const One = &#123; template: `&lt;div&gt;组件 One&lt;/div&gt;`&#125;const Two = &#123; template: `&lt;div&gt;组件 Two&lt;/div&gt;`&#125;const router = new VueRouter(&#123; routes: [ // 配置路由规则，一个路由对应多个实例 &#123; path: &#x27;/&#x27;, // conponents 为一个对象 components: &#123; // key 为出口的 name 属性值 // value 为组件实例 one: One, two: Two &#125; &#125; ]&#125;) 入口菜单高亮处理点击导航会给链接添加两个类名： &lt;a href=&quot;#/one&quot; class=&quot;router-link-exact-active router-link-active&quot;&gt;One&lt;/a&gt;&lt;a href=&quot;#/two&quot; class=&quot;&quot;&gt;Two&lt;/a&gt; 修改方式 1：直接修改类的内容 .router-link-exact-active,.router-link-active &#123; color: red; font-size: 50px;&#125; 修饰方式 2：给默认高亮类名设置别名，别名为已经定义好样式的类名 (推荐) const router = new VueRouter(&#123; routes: [], // 修改默认高亮的a标签的类名 linkActiveClass: &#x27;red&#x27;&#125;) 精确匹配和模糊匹配 精确匹配：router-link-exact-active 类名 : 只有当浏览器地址栏中的哈希值 与 router-link 的 to 属性值完全匹配才会添加该类 模糊匹配：router-link-active 类名 : 只要浏览器地址栏中的哈希值包含 router-link 的 to 属性值就会添加该类名 解决办法：加个 exact &lt;router-link to=&quot;/&quot; exact&gt; One&lt;/router-link&gt; 注意：精确匹配和模糊匹配，只对添加类名这个机制有效，与路由的匹配规则无关 路由参数入口 &lt;!-- 1. 入口 --&gt;&lt;router-link to=&quot;/detail/1&quot;&gt;手机1&lt;/router-link&gt;&lt;router-link to=&quot;/detail/2&quot;&gt;手机2&lt;/router-link&gt;&lt;router-link to=&quot;/detail/3&quot;&gt;手机3&lt;/router-link&gt; 传参 动态路由匹配 const Detail = Vue.component(&#x27;detail&#x27;, &#123; template: `&lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;`&#125;)routes: [ // 方式1：手动一个一个配置 &#123; path: &#x27;/detail/1&#x27;, component: Detail &#125;, &#123; path: &#x27;/detail/2&#x27;, component: Detail &#125;, &#123; path: &#x27;/detail/3&#x27;, component: Detail &#125;， // 正确的方式：把传过去的 1/2/3 当成参数 &#123; path: &#x27;/detail/:id?&#x27;, component: Detail &#125;] ? 代表参数可传可不传，即可识别的路径包括：detail、detail/1、detail2、detail3 获取参数的三种正确方式 // $route =&gt; 路由配置对象const Detail = Vue.component(&#x27;detail&#x27;, &#123; // 方式1：组件中直接读取 // $route.path 为路由路径 // $route.params.id 为路由参数 template: ` &lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt; `, created() &#123; // 方式2：js直接读取 // 打印只会打印一次，因为组件是复用的，每次进来钩子函数只会执行一次 // #/detail/2?name=zs console.log(this.$route) // 路由配置对象 console.log(this.$route.path) // #/detail/2 console.log(this.$route.params) // &#123;id: &quot;2&quot;&#125; console.log(this.$route.query) // &#123;name: &#x27;zs&#x27;&#125; console.log(this.$route.params.id) // 2 &#125;, // 方式3：监听路由的参数变化(因为不是 data 中的数据，不需要深度监听) watch: &#123; // to：新值 // from：旧值 $route(to, from) &#123; console.log(to.params.id) &#125; &#125;&#125;) 编程式导航 const userId = &#x27;123&#x27;// 字符串router.push(&#x27;/user&#x27;) // -&gt; /user// 对象, path为路由的path属性值router.push(&#123; path: &#x27;/user&#x27; &#125;) // -&gt; /userrouter.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 命名的路由，name 为路由的 name 属性值router.push(&#123; name: &#x27;user&#x27;, params: &#123; userId &#125;&#125;) // -&gt; /user/123// 如果提供了 path，params 会被忽略// 这里的 params 不生效router.push(&#123; path: &#x27;/user&#x27;, params: &#123; userId &#125;&#125;) // -&gt; /user// 带查询参数router.push(&#123; path: &#x27;register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125;&#125;) // -&gt; /register?plan=privateroutes: [&#123; path: &#x27;/user/:id?&#x27;, name=&#x27;user&#x27;, component: User &#125;] 重定向redirect // 将 / 重定向到 /home&#123; path: &#x27;/&#x27;, redirect: &#x27;/home&#x27; &#125; 单文件组件vue 是单文件组件后缀为 .vue 的文件 单文件组件，无法直接在浏览器中使用，必须经过 webpack 这种打包工具处理后，才能在浏览器中使用 单文件组件的三个组成部分 template (模板结构) script 组件的代码逻辑 style 样式 脚手架介绍vue-cli 是 vue 的脚手架工具 因为 webpack 配置繁琐，阻止一批想用 vue 但是不会 webpack 的开发人员 vue-cli 提供了一条命令，我们直接通过这条命令就可以快速的生成一个 vue 项目 (vue init XX)，项目的基本结构、以及 webpack 配置项 全部配置 好了 Vue Loader 手动配置置 webpack Vue CLI3 Vue webpack 配置 使用安装：npm i -g vue-cli 初始化 vue 项目：vue init webpack 项目名称 进入到项目根目录运行项目：npm run dev 项目安装过程： ? Project name demo? Project description A Vue.js project? Author? Vue build standalone =&gt; 运行时+编译? Install vue-router? Yes? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Set up unit tests No? Setup e2e tests with Nightwatch? No 项目目录介绍https://vuejs-templates.github.io/webpack/structure.html .├── build/ # webpack config files├── config/index.js # main project config├── src/│ ├── main.js # app entry file│ ├── App.vue # main app component│ ├── components/ # ui components│ └── assets/ # module assets (processed by webpack)├── static/ # pure static assets (directly copied)├── test/│ └── unit/ # unit tests│ └── e2e/ # e2e tests├── .babelrc # babel config├── .editorconfig # settings for your editor├── .eslintrc.js # eslint config├── .eslintignore # eslint ignore rules├── .gitignore # sensible defaults for gitignore├── .postcssrc.js # postcss config├── index.html # index.html template├── package.json # build scripts and dependencies└── README.md # Default README file build 和 config 不要动，都是一些配置好的，还有一些他们之间的约定 .gitkeep：static 为预留的文件夹，空文件夹默认不会上传到 github，添加这个文件让 static 文件夹被 git 上传 .editorconfig 编译器配置，需要安装 vscode 插件：Editorconfig charset = utf-8 utf-8 格式编码indent_style = space 空格和tab都可以缩进indent_size = 2 缩进为2个end_of_line = lf 回车换行insert_final_newline = true 结束最后一行+一个空白trim_trailing_whitespace = true 开头去除空白 eslint 校验 忽略文件中有这个 &#x3D;&gt; &#x2F;*.js &#x3D;&gt; 意思是根目录下的.js 文件不校验,,但是发现根目录就没有.js 文件 /* eslint-disable no-new */ eslint 忽略 no-new 规则 /* eslint-disable */ 也可以 如果去掉,就会提示你 不要以 new 开头 可以前面给个变量 var vm &#x3D; new Vue() 但是又提示没有用,还要打印一下,其实这个赋值是没有意义的 不要去掉.这是 eslint 的不校验下一行代码 standard 代码规范 postcssrc 处理 less css 等 src assets 静态资源 components 组件 router 路由 App.vue 根组件 &#x3D;&gt; 指定路由出口 脚手架之后，所有的组件都将渲染到 app.vue 中 vm 中的 #app 还是 index.html 中的 #app， app.vue 中的会覆盖前者可以通过分别添加 title 属性验证一下 &lt;router-view/&gt; 路由出口要写在 app.vue 组件模板中 main.js 入口 js 文件 作用：创建 vue 实例，导入其他组件并挂在到 vue 实例上 Vue.config.productionTip = false 不要打印提示 route&#x2F;index.js：路由 @：build&#x2F; webpack.base.config.js &#x3D;&gt; &#39;@&#39;: resolve(&#39;src&#39;) 如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能 https://router.vuejs.org/zh/installation.html 两种编译模式完整版和运行时版 参考官网 编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码 运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切 使用 完整版 (包含编译器) new Vue(&#123; el: &#x27;#app&#x27;, router, components: &#123; App &#125;, template: &#x27;&lt;App/&gt;&#x27;&#125;) 只使用运行时 new Vue(&#123; el: &#x27;#app&#x27;, router, render: h =&gt; h(App)&#125;) 查看编译模式：build &#x3D;&gt; webpack.base.config.js &#x3D;&gt; &#39;vue\\$&#39;: &#39;vue/dist/vue.esm.js&#39;, 手动配置路由安装路由 npm i vue-router 准备工作：创建一个文件夹 router&#x2F;router.js 具体配置： /* router.js */// 引入路由import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;// 导入组件import Home from &#x27;@/components/home/Home&#x27; (template + script + style)import Login from &#x27;@/components/login/Login&#x27;// 把路由当成插件安装Vue.use(VueRouter)// 创建路由，配置路由const router = new VueRouter(&#123; // 路由规则routes: [ &#123; path : &#x27;/home&#x27;, component : Home &#125;, &#123; path : &#x27;/login&#x27;, component : Login &#125;]&#125;)// 导出路由export default router// 在 main.js 中绑定路由router在跟组件 App.vue 下配置出口&lt;router-view&gt;&lt;/router-view&gt; /* main.js */new Vue(&#123; // 绑定路由 router&#125;) &lt;!-- App.vue --&gt;&lt;!-- 配置出口 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 编辑器配置插件 vetur：vue 单文件组件的高亮 eslint 关闭 eslint：打开 config&#x2F;index.js，将 26 行 : dev.useEslint设置为 false，重启项目 ( npm run dev) Prettier：格式化插件 TODOMVC 案例准备工作 Vue-TodoMVC 下载模板地址 git clone https://github.com/tastejs/todomvc-app-template.git 安装依赖包 : npm i 安装 vue : npm i vue 开始 https://github.com/cuilongjin/todomvc-app-template/tree/master 列表渲染 渲染任务列表：&lt;label&gt;&#123;&#123; item.name &#125;&#125;&lt;/label&gt; 任务完成 : :class=&quot;&#123; completed : item.done &#125;&quot; 多选框选中状态 : v-model=&#39;item.done&#39; 添加任务 获取文本输入框的内容 (关键点) 把 input 通过 v-model 双向数据绑定 &#x3D;&#x3D; todoName @keyup.enter 触发事件 addTodo &#x3D;&gt; 拿到 todoName 的值 判断文本框不能为空 按回车添加任务 对象{done: false, id: , name : todoName} 获取数组里最后一个元素的 id+1 如果数组之前一个元素都没有 , id &#x3D; 1 将对象添加进数组 添加完，清除文本框内容 删除任务 传索引this.todoList.splice(index, 1) 传 id // 根据 id 找到对应的元素索引const index = this.todoList.findIndex(item =&gt; item.id === id)// 根据索引删除this.todoList.splice(index, 1) 传 id 过滤 // 传过来一个 id, 过滤出来不等于这个 id 的元素，重新赋值给 todoListthis.todoList = this.todoList.filter(item =&gt; item.id !== id) 编辑任务 显示编辑框 ( editing : true) (难点) 在 data 中添加一个 editId : -1 在 :classediting: item.id &#x3D;&#x3D;&#x3D; editId 双击 : 接收过来双击元素的 idthis.editId &#x3D; id 关键点 :vue 中 data 中的数据一旦发生改变，当前页面的指令和表达式都会重新计算 读取内容&lt;input class=&quot;edit&quot; v-model=&quot;item.name&quot;&gt; 回车隐藏编辑框 底部的显示与隐藏 v-if&#x2F;v-show // 组件部分&lt;footer class=&quot;footer&quot; v-show=&quot;isFooter()&quot;&gt;// js isFooter() &#123; return this.todoList.length &gt; 0 &#125; 因为 vue 中 data 的数据发送了改变，当前页面中的指令和表达式都会重新计算，所以只要文本框里的内容发生改变，todoName 也会发送改变，isFooter 会一直被调用，性能不好。我们需要的是数组列表的个数改变才会影响底部的变化，所以需要用到计算属性 计算属性 &lt;footer class=&quot;footer&quot; v-show=&quot;isFooter&quot;&gt;&lt;/footer&gt; computed: &#123; // 计算属性 判断底部是否显示 // 1. 计算属性只会跟着相关属性的值发生变化而变化 // 2. 一定要有返回值 // 3. 一定要写在 computed 里面 // 4. 写起来像一个方法，用起来像一个属性 isFooter () &#123; return this.todoList.length &gt; 0 &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://wqdy.top/c/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wqdy.top/tags/vue/"}]},{"title":"Webpack","slug":"前端/工程化/webpack","date":"05/01/2019","updated":"05/01/2019","comments":true,"path":"429.html","link":"","permalink":"https://wqdy.top/429.html","excerpt":"","text":"webpack 官网 webpack 中文网 webpack 配置文件 概述webpack 是一个现代 JavaScript 应用程序的模块打包器（module bundler） webpack 是一个模块化方案（预编译） webpack 获取具有依赖关系的模块，并生成表示这些模块的静态资源 webpack 的两个特点：模块化、打包 四个核心概念：入口(entry)、输出(output)、加载器(loader)、插件(plugins) 模块化方案：webpack 和 requirejs（通过编写代码的方式将前端的功能，划分成独立的模块）browserify 是与 webpack 相似的模块化打包工具 webpack 起源 webpack 解决了现存模块打包器的两个痛点： Code Spliting - 代码分离 静态资源的模块化处理方案 webpack 与模块 前端模块系统的演进 在 webpack 看来：所有的静态资源都是模块 webpack 模块能够识别以下等形式的模块之间的依赖： ES2015 import export CommonJS require() module.exports AMD define 和 require css&#x2F;sass&#x2F;less 文件中的 @import 图片连接，比如：样式 url(...) 或 HTML &lt;img src=...&gt; 字体等 在 webpack 提供的模块化环境中 想要加载一个 JS 文件，只需要 require(‘a.js’) 想要加载一个 CSS 文件，只需要 require(‘css&#x2F;index.css’) 想要加载一个图片文件，只需要 require(‘images&#x2F;a.png’) 入门 Webpack，看这篇就够了 webpack 打包原理：​ 入口文件： main.js ​ webpack 从入口出发，递归分析项目中所有的依赖项（模块），使用 loader 来处理对应的模块最终，打包生成一个 bundle.js 文件。 ​ 如果配置了 webpack 中的 代码分离（Code Spliting），webpack 会根据 分离点 将这个模块生成一个独立的 JS 文件 ​ 还可以通过配置，将 CSS 、 图片、 字体 等文件，从 bundle.js 中抽离为独立的文件 webpack 的基本使用安装：npm i -D webpack webpack-cli webpack：是 webpack 工具的核心包 webpack-cli：提供了一些在终端中使用的命令 -D(–save-dev)：表示项目开发期间的依赖 webpack 的两种使用方式：命令行、配置文件（webpack.config.js） 命令行使用说明 package.json中的scripts中可以存放一些 bash 命令，这些 bash 命令可以通过 npm run 命令名称 来执行 注意：npm 在执行 scripts 中的命令的时候，是在电脑系统后台默认开启一个 bash，将当前目录下的./node_modules/.bin这个文件夹临时加入了系统环境变量 使用方式：npm run build 设置开发状态： mode 如果没有设置 mode 配置项，webpack 会默认提供开发环境(production) 在入口文件中可以使用 import 引入 js css less 等文件 &quot;scripts&quot;: &#123; // webpack 是 webpack-cli 提供的命令 // src/js/main.js 为入口文件 // --output dist/bundle.js 为出口文件 // --mode development 生产环境 &quot;build&quot;: &quot;webpack&quot; &quot;build1&quot;: &quot;webpack src/js/main.js --output dist/bundle.js --mode development&quot;&#125; 配置文件方式（推荐）项目根目录下创建一个 webpack.config.js文件，运行 webpack 命令时的默认配置文件 指定其他文件：--config webpack.XX.js 配置 package.json 中的 scripts , 脚本命令为： &quot;build&quot;: &quot;webpack&quot; 执行命令 : npm run build 示例代码 // webpack 是基于 node的 , 所以配置文件符合 node 方式书写配置// 注意 : 不要再这个文件中使用ES6的的模块化 import语法const path = require(&#x27;path&#x27;)module.exports = &#123; // 入口 entry: path.join(__dirname, &#x27;./src/js/main.js&#x27;), // 出口 output: &#123; // 出口目录 path: path.join(__dirname, &#x27;dist&#x27;), filename: &#x27;js/bundle.js&#x27; &#125;, // 开发模式 mode: &#x27;development&#x27;&#125; webpack-dev-server安装：npm i -D webpack-dev-server 作用：配合 webpack，创建开发环境（启动服务器、监视文件变化、自动编译、刷新浏览器等），提高开发效率 注意：无法直接在终端中执行 webpack-dev-server，需要在 package.json 配置 scripts 后使用 使用说明 webpack-dev-server将打包好的文件存储在内存中，提高编译和加载速度，效率更高（不会生成 dist 目录） 在内存中出口目录为项目根目录（命令行中的提示：webpack output is served from /） 在index.html页面中引入文件不需要加dist CLI 配置 --contentBase ：告诉服务器在哪个目录中提供服务（可以理解为：打开哪个目录中的 index.html） --contentBase ./src：当前目录下的 src 文件夹 --open true ：自动打开浏览器 --port 3000 ：指定端口号 --hot ：热更新，只加载修改的文件(按需加载修改的内容)，而非全部加载 --progress：显示进度条 &#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --contentBase src --open --port 8888 --hot&quot; &#125;&#125; 配置文件配置配置 package.json 中的 scripts , 脚本命令为： &quot;dev&quot;: &quot;webpack-dev-server --hot&quot; 执行命令 : npm run dev // --hot 热更新写在命令行里，不然的话还要配其他插件麻烦module.exports = &#123; devServer: &#123; contentBase: path.join(__dirname, &#x27;src&#x27;), // 自动打开浏览器 open: true, // 端口号 port: 3000, // hot: true, proxy: &#123; &#x27;/api&#x27;: &#123; // api 表示当前项目请求的 key target: &#x27;http://www.baidu.com&#x27;, // 代理服务器路径 pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;/api&#x27; &#125;, // 重写路径 changeOrigin: true &#125; &#125; // 请求 localhost:8080/api/.. 会被代理到 http://www.baidu.com/api/.. &#125; // plugins: [ // new webpack.HotModuleReplacementPlugin() // ]&#125; html-webpack-plugin 插件 安装：npm i -D html-webpack-plugin 作用：根据模板，在内存中自动生成 html 页面，并自动引入bundle.js、css等文件 配置文件配置： // 引入 html-webpack-plugin 插件const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; // 配置插件 plugins: [ // html-webpack-plugin 配置 new HtmlWebpackPlugin(&#123; // 模板页面路径 template: path.join(__dirname, &#x27;src/index.html&#x27;) &#125;) ]&#125; 打包非 js 文件webpack 默认只能处理 js 文件，非 js(css、less、图片、字体等)处理不了，借助 loader 加载器 处理 css 文件在 main.js中引入 css 文件 import &#39;../css/main.css&#39; 安装 : npm i -D style-loader css-loader 在 webpack.config.js 中，添加个新的配置项 module 在 module 中添加 loader 来处理 css module.exports = &#123; module: &#123; rules: [ // 处理 css // 注意点 use 执行loader 顺序 从右往左 // css-loader: 读取css文件内容，将其转化为一个模块 // style-loader: 拿到模块, 创建一个style标签，插入页面中 &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125; ] &#125;&#125; 处理 less 文件在 main.js中引入 less 文件 import &#39;../css/main.less&#39; 安装 : npm i -D less-loader less style-loader css-loader 在 webpack.config.js 中配置项 module-&gt;rules中添加 loader 来处理 less module.exports = &#123; module: &#123; rules: [ //处理 css &#123; test: /\\.less$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;] &#125; ] &#125;&#125; 处理图片文件安装 : npm i -D url-loader file-loader 在 webpack.config.js 中配置项 module-&gt;rules中添加 loader 来处理图片 module.exports = &#123; module: &#123; rules: [ // 处理图片 &#123; test: /\\.(jpg|png)$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; // 图片大小 &lt;= 10000 =&gt; 转化为base64 // 图片大小 &gt;= 10000 =&gt; 不会转base64 内部调用 file-loader 加载图片 limit: 10000 &#125; &#125; ] &#125; ] &#125;&#125; url-loader 默认会将图片转化为 base64 编码格式，目的：提高性能 file-loader 在处理图片时，会对文件进行重命名 base64 编码格式的图片说明： 精灵图：将一些小图片合并为一张图片，减少请求次数，提高性能 字体图标：直接将一些小的图片,合并到字体文件中，并且不会失真 base64：是一种编码格式,能够将图片、文字等常见的文件，转化为 base64 格式，这种字符串格式浏览器能够识别并且读取显示到页面中 base64 是一个字符串，也可以直接被内嵌到页面中，或者 css 中 注意：大图片不适合用 base64 处理，只有小的图标才适合 base64 处理 处理字体文件在 main.js 中引入 css 文件 import &#39;../css/iconfont/iconfont.css&#39; 在 webpack.config.js 中配置 module.exports = &#123; module: &#123; rules: [ // 处理字体图标 &#123; test: /\\.(svg|woff|woff2|ttf|eot)$/, use: &#x27;url-loader&#x27; &#125; ] &#125;&#125; 处理 ES6 语法 现在的项目都是使用 ES6 开发的，但是这些新的 ES6 语法，并不是所有的浏览器都支持，所以就需要有一个工具，帮我们转成 es5 语法，这个就是：babel babel Babel is a JavaScript compiler. &#x3D;&#x3D;&gt; babel 是一个 JavaScript 编译器 webpack 只能处理 import &#x2F; export 这个 es6 模块化语法，而其他的 js 新语法，应该使用 babel 来处理 babel 的使用 : 安装： npm i -D babel-core babel-loader@7 babel-core 是 babel 的核心包 babel-loader 加载 js 文件，并将 js 代码内容交给 babel-core 解析为 es5 低版本的 js 安装：npm i -D babel-preset-env babel-preset-stage-2 babel-preset-env：表示能够解析 es2015、es2016、es2017、es2018 这些标准的语法 babel-preset-stage-2：用来解析还没有被采纳为标准的语法 babel-polyfill与babel-plugin-transform-runtime 也是做兼容处理的,以前都是用这个，兼容更早的 配置 : 在 webpack.config.js 中添加一个 loader module.exports = &#123; module: &#123; rules: [ // 处理 ES6 语法 &#123; test: /\\.js$/, use: &#x27;babel-loader&#x27;, // 设置忽略 node-modules 文件夹 exclude: /node-modules/ &#125; ] &#125;&#125; 在项目根目录中创建 babel 的配置文件，叫：.babelrc &#123; &quot;presets&quot;: [ &quot;env&quot;, &quot;stage-2&quot; ], ----------- // 暂时不用 // 如果未来某一天真的用到了polify &quot;plugins&quot;: [ &quot;transform-runtime&quot;, &#123; &quot;helpers&quot;: false, &quot;polyfill&quot;: true, &quot;regenerator&quot;: true, &quot;moduleName&quot;: &quot;babel-runtime&quot; &#125; ]&#125; 项目打包上线执行 : npm run build 对项目进行打包，生成 dist 文件 模拟本地服务器 : 安装 : npm i -g http-server 把 dist 文件里的内容放到服务器里即可，直接运行http-server webpack 和 gulp 区别 Gulp 侧重于前端开发的整个过程的控制管理（像是流水线），我们可以通过给 gulp 配置不通的 task（通过 Gulp 中的 gulp.task() 方法配置，比如启动 server、sass&#x2F;less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程 Webpack 也称之为模块打包机 ，由此也可以看出 Webpack 更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js 文件、css 文件等）都可以看成模块，最初 Webpack 本身就是为前端 JS 代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack 是通过 loader（加载器）和 plugins（插件）对资源进行处理的 gulp 是构建工具，Webpack 是 js 模块化的解决方案","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://wqdy.top/tags/webpack/"}]},{"title":"nodejs 基本使用","slug":"前端/nodejs","date":"29/12/2018","updated":"29/12/2018","comments":true,"path":"409.html","link":"","permalink":"https://wqdy.top/409.html","excerpt":"","text":"nodejs 基本介绍为什么要学习 nodejs 降低编程语言切换的成本(nodejs 实质上用的还是 javascript) NodeJS 是前端项目的基础设施，前端项目中用到的大量工具 (大前端) nodejs 在处理高并发上有得天独厚的优势(利用 nodejs 做中间层) 对于前端工程师，面试时对于 nodejs 有一定的要求 node.js 是什么？node.js，也叫作 node，或者 nodejs，指的都是一个平台 node.js 官方网站 node.js 中文网 node.js 中文社区 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，nodejs 允许 javascript 代码运行在服务端 1. nodejs不是一门新的编程语言，nodejs是在服务端运行javascript的运行环境2. 运行环境：写得程序想要运行必须要有对应的运行环境 php代码必须要有apache服务器 在web端，浏览器就是javascript的运行环境 在node端，nodejs就是javascript的运行环境2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎 nodejs 的本质：不是一门新的编程语言，nodejs 是 javascript 运行在服务端的运行环境，编程语言还是 javascript nodejs 与浏览器的区别相同点：nodejs 与浏览器都是 js 的运行环境，都能够解析 js 程序。对于 ECMAScript 语法来说，在 nodejs 和浏览器中都能运行 不同点：nodejs 无法使用 DOM 和 BOM 的操作，浏览器无法执行 nodejs 中的文件操作等功能 nodejs 可以干什么？ 开发服务端程序 开发命令行工具（CLI），比如 npm，webpack，gulp，less，sass 等 开发桌面应用程序（借助 node-webkit、electron 等框架实现） 安装 nodejsnodejs 版本下载地址 当前版本 历史版本 官网术语解释 LTS 版本：Long-term Support 版本，长期支持版，即稳定版。 Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入 查看 node 版本 node -v 运行 nodejs 程序方式一：使用 node 执行 js 文件 创建 js 文件 helloworld.js 写 nodejs 的内容：console.log(&#39;hello nodejs&#39;) 打开命令窗口 cmd shift 加右键打开命令窗口，执行 node 文件名.js即可 执行命令：node helloworld.js 注意：在 nodejs 中是无法使用 DOM 和 BOM 的内容的，因此document， window等内容是无法使用的 方式二：REPL 介绍 REPL 全称: Read-Eval-Print-Loop（交互式解释器） R 读取 - 读取用户输入，解析输入了 Javascript 数据结构并存储在内存中 E 执行 - 执行输入的数据结构 P 打印 - 输出结果 L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出 在 REPL 中编写程序 （类似于浏览器开发人员工具中的控制台功能） 直接在控制台输入 node 命令进入 REPL 环境 按两次 Control + C 退出 REPL 界面 或者 输入 .exit 退出 REPL 界面 按住 control 键不要放开, 然后按两下 c 键 环境变量当要求系统运行一个程序 而没有告诉它程序所在的完整路径时 首先在当前目录中查找和该字符串匹配的可执行文件 进入用户 path 环境变量查找 进入系统 path 环境变量查找 配置环境变量： 找到环境变量：计算机 --右键--&gt; 属性 --&gt; 高级系统设置 --&gt; 高级 --&gt; 环境变量 global 模块-全局变量JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。 在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。 在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。 常用的 global 属性 console: 用于打印日志setTimeout/clearTimeout: 设置清除延时器setInterval/clearInterval: 设置清除定时器__dirname: 当前文件的路径，不包括文件名__filename：当前文件的路径，包括文件名// 与模块化相关的，模块化的时候会用到requireexportsmodule fs 模块 fs 模块是 nodejs 中最常用的一个模块，因此掌握 fs 模块非常的有必要，fs 模块的方法非常多，用到了哪个查哪个即可。 文档地址：http://nodejs.cn/api/fs.html 在 nodejs 中，提供了 fs 模块，这是 node 的核心模块 注意： 除了 global 模块中的内容可以直接使用，其他模块都是需要加载的。 fs 模块不是全局的，不能直接使用。因此需要导入才能使用。 const fs = require(&#x27;fs&#x27;) 读取文件 语法：fs.readFile(file[, options], callback) 方式一：不传编码参数 // 参数1：文件路径// 参数2：读取文件的回调函数// 回调函数参数1：错误对象，如果读取失败，err 会包含错误信息，如果读取成功，err 是 null// 回调函数参数2：读取成功后的数据（是一个Buffer对象）fs.readFile(&#x27;data.txt&#x27;, function(err, data) &#123; console.log(err) console.log(data) console.log(data.toString()) // 将Buffer对象转换成字符串&#125;) 方式二：传编码参数 // 参数1：文件的路径// 参数2：编码，如果设置了，返回一个字符串，如果没有设置，会返回一个buffer对象// 参数3：回调函数fs.readFile(&#x27;data.txt&#x27;, &#x27;utf8&#x27;, function(err, data) &#123; console.log(err) console.log(data)&#125;) 关于 Buffer 对象 1. Buffer对象是Nodejs用于处理二进制数据的2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象4. Buffer对象可以调用toString()方法转换成字符串 写文件 语法：fs.writeFile(file, data[, options], callback) // 参数1：文件路径(如果文件不存在，会自动创建)// 参数2：写入的文件内容（注意：写入的内容会覆盖以前的内容）// 参数3：写文件后的回调函数fs.writeFile(&#x27;2.txt&#x27;, &#x27;hello world&#x27;, function(err) &#123; if (err) return console.log(&#x27;写入文件失败&#x27;, err) console.log(&#x27;写入文件成功&#x27;)&#125;) 注意： 写文件的时候，会把原来的内容给覆盖掉 语法：fs.appendFile(path, data[, options], callback) // 参数1：追加的文件名(如果文件不存在，会自动创建)// 参数2：追加的文件内容// 参数3：追加文件后的回调函数fs.appendFile(&#x27;2.txt&#x27;, &#x27;我是追加的内容&#x27;, function(err) &#123; if (err) return console.log(&#x27;追加文件内容失败&#x27;) console.log(&#x27;追加文件内容成功&#x27;)&#125;) 思考：如果没有 appendFile，通过 readFile 与 writeFile 应该怎么实现？ 文件同步与异步的说明 fs 中所有的文件操作，都提供了异步和同步两种方式 异步方式：不会阻塞代码的执行 // 异步方式const fs = require(&#x27;fs&#x27;)console.log(111)fs.readFile(&#x27;2.txt&#x27;, &#x27;utf8&#x27;, function(err, data) &#123; if (err) &#123; return console.log(&#x27;读取文件失败&#x27;, err) &#125; console.log(data)&#125;)console.log(&#x27;222&#x27;) 同步方式：会阻塞代码的执行 //同步方式console.log(111)const result = fs.readFileSync(&#x27;2.txt&#x27;, &#x27;utf-8&#x27;)console.log(result)console.log(222) 总结：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。 其他 api（了解）方法有很多，但是用起来都非常的简单，学会查文档 文档：http://nodejs.cn/api/fs.html 方法名 描述 fs.readFile(path, callback) 读取文件内容（异步） fs.readFileSync(path) 读取文件内容（同步） fs.writeFile(path, data, callback) 写入文件内容（异步） fs.writeFileSync(path, data) 写入文件内容（同步） fs.appendFile(path, data, callback) 追加文件内容（异步） fs.appendFileSync(path, data) 追加文件内容（同步） fs.rename(oldPath, newPath, callback) 重命名文件（异步） fs.renameSync(oldPath, newPath) 重命名文件（同步） fs.unlink(path, callback) 删除文件（异步） fs.unlinkSync(path) 删除文件（同步） fs.mkdir(path, mode, callback) 创建文件夹（异步） fs.mkdirSync(path, mode) 创建文件夹（同步） fs.rmdir(path, callback) 删除文件夹（异步） fs.rmdirSync(path) 删除文件夹（同步） fs.readdir(path, option, callback) 读取文件夹内容（异步） fs.readdirSync(path, option) 读取文件夹内容（同步） fs.stat(path, callback) 查看文件状态（异步） fs.statSync(path) 查看文件状态（同步） path 模块路径操作的问题在读写文件的时候，文件路径可以写相对路径或者绝对路径 data.txt 是相对路径，读取当前目录下的 data.txt，相对路径相对的是指向 node 命令的路径 // 如果node命令不是在当前目录下执行就会报错，在当前执行node命令的目录下查找data.txt，找不到fs.readFile(&#x27;data.txt&#x27;, &#x27;utf8&#x27;, function(err, data) &#123; if (err) &#123; return console.log(&#x27;读取文件失败&#x27;, err) &#125; console.log(data)&#125;) 相对路径：相对于执行 node 命令的路径 推荐使用绝对路径：__dirname: 当前文件的目录，__filename: 当前文件的目录，包含文件名 path 模块的常用方法 关于路径，在 linux 系统中，路径分隔符使用的是/，但是在 windows 系统中，路径使用的\\ 在我们拼写路径的时候会带来很多的麻烦，经常会出现 windows 下写的代码，在 linux 操作系统下执行不了，path 模块就是为了解决这个问题而存在的。 常用方法： path.join() // 拼接路径，返回拼接后的结果// windows系统下path.join(&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;gg&#x27;, &#x27;index.html&#x27;)&#x27;abc\\def\\gg\\a.html&#x27;// linux系统下path.join(&#x27;abc&#x27;,&#x27;def&#x27;,&#x27;gg&#x27;, &#x27;index.html&#x27;)&#x27;abc/def/gg/index.html&#x27;【优化读写文件的代码】其他方法:path.basename(path[, ext]) 返回文件的最后一部分path.dirname(path) 返回路径的目录名path.extname(path) 获取路径的扩展名(后缀名)var path = require(&#x27;path&#x27;)var temp = &#x27;abc\\\\def\\\\gg\\\\a.html&#x27;console.log(path.basename(temp)) //a.htmlconsole.log(path.dirname(temp)) //abc\\def\\ggconsole.log(path.extname(temp)) //.html path 模块其他 api（了解） 方法名 描述 path.basename(path[, ext]) 返回文件的最后一部分 path.dirname(path) 返回路径的目录名 path.extname(path) 获取路径的扩展名 path.isAbsolute(path) 判断目录是否是绝对路径 path.join([...paths]) 将所有的 path 片段拼接成一个规范的路径 path.normalize(path) 规范化路径 path.parse(path) 将一个路径解析成一个 path 对象 path.format(pathObj) 讲一个 path 对象解析成一个规范的路径 http 模块创建服务器基本步骤// 1. 导入http模块，http模块是node的核心模块，作用是用来创建 http 服务器的const http = require(&#x27;http&#x27;)// 2. 创建服务器let server = http.createServer()// 3. 服务器处理请求server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; console.log(&#x27;我接收到请求了&#x27;)&#125;)// 4. 启动服务器，监听某个端口server.listen(9999, (err) =&gt; &#123; console.log(&#x27;服务器启动成功了, 请访问： http://localhost:9999&#x27;)&#125;) 详细说明 给服务器注册 request 事件，只要服务器接收到了客户端的请求，就会触发 request 事件 request 事件有两个参数，req 表示请求对象，可以获取所有与请求相关的信息，res 是响应对象，可以获取所有与响应相关的信息 服务器监听的端口范围为：1-65535 之间，推荐使用 3000 以上的端口，因为 3000 以下的端口一般留给系统使用 request 对象详解文档地址：http://nodejs.cn/api/http.html#http_message_headers 常见属性： headers: 所有的请求头信息method：请求的方式rawHeaders：所有的请求头信息（数组的方式）url：请求的地址（url地址的路径部分） 请求 http://127.0.0.1:3000/index 获取到的是：/index 请求 http://127.0.0.1:3000 获取到的是：/ 注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个favicon.ico的请求 小结：request 对象中，常用的就是 method 和 url 两个参数 response 对象详解文档地址：http://nodejs.cn/api/http.html#http_class_http_serverresponse 常见的属性和方法： res.write(data): 给浏览器发送响应体，可以调用多次，从而提供连续的响应体res.end()：通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成res.end(data)：结束请求，并且响应一段内容，相当于res.write(data) + res.end()res.statusCode: 响应的的状态码 200 404 500res.statusMessage: 响应的状态信息（不能有中文）， 如果不设置会根据statusCode自动设置res.setHeader(name, value)：设置响应头信息，比如&#x27;content-type&#x27;，&#x27;text/html;charset=utf-8&#x27;res.writeHead(statusCode, statusMessage, options)：设置响应头，同时可以设置状态码和状态信息 options 是对象，写响应头的键值对 注意：必须先设置响应头，才能设置响应主体。 注意：浏览器中输入的 URL 地址，仅仅是一个标识，可以不与服务器中的文件路径一致。也就是说：返回什么内容是由服务端的逻辑决定 路由 : url 标示和对应文件&#x2F;数据的一一对应关系 模拟 Apache 服务器 根据 req.url 读取不同的页面内容，返回给浏览器 // 需求: 简单模仿apache服务器，浏览器发送127.0.0.1:8888/index.html// 对应的返回www文件夹下面的index.html的内容const fs = require(&#x27;fs&#x27;)const http = require(&#x27;http&#x27;)const path = require(&#x27;path&#x27;)// 创建服务器let server = http.createServer()// 监听请求server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; // 根据不同请求输出不同响应数据 if (req.url === &#x27;/&#x27; || req.url === &#x27;/i&#x27;) &#123; // 读取www下面的index.html let filename = path.join(__dirname, &#x27;www&#x27;, &#x27;index.html&#x27;) fs.readFile(filename, &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) console.log(&#x27;文件读取失败&#x27;) // 服务器响应文件 res.statusCode = 200 res.statusMessage = &#x27;ok&#x27; res.setHeader(&#x27;content-type&#x27;, &#x27;text/html;charset=utf-8&#x27;) res.end(data) &#125;) &#125; else if (req.url === &#x27;/l&#x27;) &#123; // 读取list.html let filename = path.join(__dirname, &#x27;www&#x27;, &#x27;list.html&#x27;) fs.readFile(filename, &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) return console.log(&#x27;文件读取失败&#x27;) // 服务器响应文件 res.writeHead(200, &#x27;OOOOOOK&#x27;, &#123; &#x27;content-type&#x27;: &#x27;text/html;charset=utf-8&#x27; &#125;) res.end(data) &#125;) &#125; else &#123; // 返回浏览器, 未找到资源 res.writeHead(404, &#x27;NOT FOUND&#x27;, &#123; &#x27;content-type&#x27;: &#x27;text/html;charset=utf-8&#x27; &#125;) res.end(&#x27;404 ,资源未找到&#x27;) &#125;&#125;)// 开启服务器server.listen(8888, () =&gt; &#123; console.log(&#x27;服务器开启了&#x27;)&#125;) MIME 类型 MIME(Multipurpose Internet Mail Extensions)多用途 Internet 邮件扩展类型 是一种表示文档性质和格式的标准化方式 浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的 MIME 类型附加到响应对象的头部是非常重要的 MIME 类型 mime 模块 作用：获取文件的 MIME 类型 安装：npm i mime let mime = require(&#x27;mime&#x27;)// 获取路径对应的 MIME 类型mime.getType(&#x27;txt&#x27;) // &#x27;text/plain&#x27;// 根据 MIME 获取到文件后缀名mime.getExtension(&#x27;text/plain&#x27;) // &#x27;txt&#x27; nodemon 自动重启 作用：监听到 js 文件修改后，自动重启 node 程序 安装：npm i -g nodemon 使用：nodemon app.js 运行 node 程序 hacknews 案例 Hacker News 示例 路由（route）：就是一套映射规则，根据 url 地址分配到对应的处理程序 功能划分 1 新闻列表页 - &#x2F;index get 2 新闻详情页 - &#x2F;details get 3 新闻添加页 - &#x2F;submit get 4 新闻添加请求 - &#x2F;add post art-template 模板引擎 文档 安装 npm install art-template 核心方法 // 基于模板路径渲染模板// 参数1：文件的路径// 参数2：数据// 返回值：返回渲染后的内容// template(filename, data)let html = template(path.join(__dirname, &#x27;pages&#x27;, &#x27;index.html&#x27;), &#123; name: &#x27;大吉大利，今晚吃鸡&#x27; &#125;) 注意点：文件的路径必须是绝对路径；会将整个 html 当做模板返回 url 模块 说明：用于 URL 处理与解析 注意：通过 url 拿到的查询参数都是字符串格式 // 导入url模块var url = require(&#x27;url&#x27;)// 解析 URL 字符串并返回一个 URL 对象// 第一个参数：表示要解析的URL字符串// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象var ret = url.parse(&#x27;http://localhost:3000/details?id=1&amp;name=jack&#x27;, true)console.log(ret.query) // &#123;id: &#x27;1&#x27;, name: &#x27;jack&#x27;&#125; querystring 模块 用于解析与格式化 URL 查询字符串 注意：只在专门处理查询字符串时使用 // foo=bar&amp;abc=xyz&amp;abc=123var querystring = require(&#x27;querystring&#x27;)// 将查询参数转化为对象// 第一个参数: 要解析的 URL 查询字符串querystring.parse(&#x27;foo=bar&amp;abc=xyz&#x27;) // &#123;foo: &#x27;bar&#x27;, abc: &#x27;xyz&#x27;&#125; 服务端重定向 HTTP 状态码说明 301 和 302 说明：服务端可以通过 HTTP 状态码让浏览器中的页面重定向 res.writeHead(302, &#123; Location: &#x27;/&#x27;&#125;)res.end() POST 请求参数的处理 说明：POST 请求可以发送大量数据，没有大小限制 // 接受POST参数var postData = []// data事件：用来接受客户端发送过来的POST请求数据var result = &#x27;&#x27;req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; result += chunk&#125;)// end事件：当POST数据接收完毕时，触发req.on(&#x27;end&#x27;, () =&gt; &#123; cosnole.log(result)&#125;) 模块化改造 hackerNews","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://wqdy.top/tags/nodejs/"},{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"常用js —— es6","slug":"前端/js/常用js —— es6","date":"29/12/2018","updated":"22/02/2022","comments":true,"path":"405.html","link":"","permalink":"https://wqdy.top/405.html","excerpt":"","text":"let 与 const[知乎]我用了两个月的时间才理解 let [MDN]变量提升 let 的使用 let 声明的变量只有在当前作用域(块作用域)有效 &#123; var a = 1 let b = 2&#125;console.log(a) // 1console.log(b) // ReferenceError: b is not defined 不允许重复声明 var a = 1let a = 2 // SyntaxError: Identifier &#x27;a&#x27; has already been declaredlet b = 3const b = 4 // SyntaxError: Identifier &#x27;b&#x27; has already been declared 使用 let 声明的全局变量，不会成为 window 的属性 let c = 1console.log(window.c) // undefinedconsole.log(c) // 1 存在变量提升 let a = 1&#123; a = 2 let a&#125;// 如果 let 不会提升，那么 a = 2 就会将外面的 a 由 1 变成 2// 但运行发现 a = 2 报错：Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization a = 1; let a // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization 总结： let&#x2F;const 声明的「创建」过程被提升了，但是「初始化」没有提升，var 声明的「创建」和「初始化」都被提升了，但「赋值」没被提升，function 声明的「创建」、「初始化」和「赋值」都被提升了 let 声明会提升到块顶部，从块顶部到该变量的初始化语句，这块区域叫做 TDZ（暂时死区），所谓暂时死区，就是不能在初始化之前，使用变量 如果你在 TDZ 内使用该变量，JS 就会报错 如果 let x 的初始化过程失败了，那么 x 变量就将永远处于 created 状态 你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了） 由于 x 无法被初始化，所以 x 永远处在暂时死区 const 的使用const 声明一个常量。常量：代码执行的过程中，不可以修改常量里面的值 const 声明的量不可以改变 const PI = 3.1415PI = 3 // TypeError: Assignment to constant variable const 声明的变量必须赋值 const num// SyntaxError: Missing initializer in const declaration 如果 const 声明了一个对象，仅仅保证地址不变，可以修改对象的属性 const obj = &#123; name: &#x27;zs&#x27; &#125;obj.age = 18 // 正确obj = &#123;&#125; // TypeError: Assignment to constant variable 其他用法和 let 一样 模板字符串// 定义一个字符串let str = `hello world`// 内部允许换行let str = ` hello world`// 内部可以使用表达式let str = `你好，我是$&#123;name&#125;` 箭头函数特点 不存在 prototype 这个属性 let a = () =&gt; &#123;&#125;console.log(a.prototype) // undefined 没有自己的 this，arguments 箭头函数的 this、arguments 都是在定义函数时绑定外层的 this 和 arguments，而不是在执行过程中绑定的，所以不会因为调用者不同而发生变化。可以使用剩余参数(Rest 参数)表示法获得的自身入参列表 因为箭头函数没有 this，因此箭头函数不能作为构造函数 不能用 call()、apply()、bind() 这些方法改变 this 的指向 fn = function()&#123; let arrow = (...args) =&gt; &#123; console.log(arguments) // 外层的入参列表 -&gt; Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ] console.log(args) // 使用剩余参数表示法获得的自身入参列表 -&gt; (3) [4, 5, 6] &#125; arrow(4, 5, 6) console.log(arrow.length) // 0&#125;fn(1, 2, 3) 如果函数体只有一行语句，并且需要返回这个值，那么可以省略 {} 和 return let fn = (n1, n2) =&gt; n1 + n2 Rest 参数和 arguments 对象的区别： rest 参数只包括那些没有给出名称的参数，arguments 包含所有参数 rest 参数之后不能再有其他参数，否则会报错 函数的 length 属性，不包括 rest 参数 arguments 对象不是真正的数组，而 rest 参数是数组实例，可以直接使用数组的方法 对象简化语法// 当属性的 key 和变量的名相同时可以简写let person = &#123; name: name &#125; ==&gt; let person = &#123; name &#125;// 声明函数let cal = &#123; add: function () &#123; return 1 &#125;, // 可以省略 `:function` add()&#123; return 1 &#125;&#125; 属性名表达式 ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。 let propKey = &#x27;foo&#x27;let methodKey = &#x27;bar&#x27;let obj = &#123; [propKey]: true, // foo: true [&#x27;a&#x27; + &#x27;bc&#x27;]: 123, // abc: 123 [methodKey]() &#123; return &#x27;hi&#x27; &#125;&#125; class 关键字ES5 中通过 构造函数 + 原型 的方式来实现面向对象 // 构造函数function Person() &#123; this.name = &#x27;jack&#x27; this.age = 18&#125;// 在原型中添加实例方法Person.prototype.say = function() &#123; console.log(this.name, this.age)&#125;// 创建实例const p = new Person()p.say() ES6 中出现了 class 关键字，用来实现面向对象 class 声明不允许再次声明已经存在的类，否则将会抛出一个类型错误class 声明不可以提升class 仅仅是一个语法结构（语法糖），本质还是函数，实现继承本质上还是通过构造函数 + 原型的方式 class Person &#123;&#125;Person instanceof Function // true 类声明 // 创建 Person 类class Person &#123; // 类的构造函数 constructor 固定名称 constructor(name, age) &#123; this.name = name this.age = age &#125; // 添加实例方法 say() &#123; console.log(this.name, this.age) &#125;&#125;// 创建实例const p = new Person(&#x27;tom&#x27;, 18)console.log(p) // Person &#123;name: &#x27;tom&#x27;, age: 18&#125;p.say() // tom 18 类表达式 赋予一个命名类表达式的名称是类的主体的本地名称 // 匿名类let Person = class &#123;&#125;new Person() // Person &#123;&#125;// 命名类let Person = class A &#123;&#125;new Person() // A &#123;&#125;new A() // Uncaught ReferenceError: A is not definedconsole.log(Person) // class A &#123;&#125;console.log(A) // Uncaught ReferenceError: A is not defined 类表达式也不存在提升 static 关键字用来定义一个类的静态方法。调用静态方法不需要实例化该类，但不能通过一个类实例调用静态方法 class Point &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; static distance(a, b) &#123; const dx = a.x - b.x const dy = a.y - b.y return Math.hypot(dx, dy) &#125;&#125;const p1 = new Point(5, 5)const p2 = new Point(10, 10)console.log(Point.distance(p1, p2)) 继承：要实现至少需要两个 class（子类 和 父类），子类继承自父类，继承后，子类就可以使用父类中的属性或方法 // 继承// 父类class Person &#123; constructor(name, age) &#123; this.name = name &#125; say() &#123; console.log(&#x27;父类中的 say 方法&#x27;, this.name) &#125;&#125;// 子类class Chinese extends Person &#123; constructor(name, age) &#123; // 子类中使用 constructor 必须手动调用 super // super 表示父类的构造函数 // 先调用 super() 在使用 this super() this.name = name this.age = age &#125;&#125;// 创建实例const c = new Chinese(&#x27;zs&#x27;, 18)console.log(c)c.say() // 父类中的方法 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring） // 1. 对象解构var &#123; a, b &#125; = &#123; a: 10, b: 20 &#125;// 同;(&#123; a, b &#125; = &#123; a: 10, b: 20 &#125;) // 使用没有声明的赋值，数组解构类似console.log(a, b) // 10 20// 提取变量并赋值var &#123; a: p, b: q &#125; = &#123; a: 10, b: 20 &#125;console.log(p, q) // 10 20// 将剩余属性赋值给一个变量var &#123; a, b, ...rest &#125; = &#123; a: 10, b: 20, c: 30, d: 40 &#125;console.log(a, b, rest) // 10 20 &#123;c: 30, d: 40&#125;// 提供默认值var &#123; a = 1, b = 1 &#125; = &#123; a: 10 &#125;console.log(a, b) // 10 1// 赋值并提供默认值var &#123; a: aa = 10, b: bb = 1 &#125; = &#123; a: 10 &#125;console.log(aa, bb) // 10 1// 2. 数组解构var [a, b] = [1, 2]console.log(a, b) // 1 2// 将剩余数组赋值给一个变量var [a, b, ...rest] = [1, 2, 3, 4]console.log(a, b, rest) // 1 2 [3, 4]// ==&gt; var a = arr[0]; var b = arr[1]// 提供默认值var [c = 2, d = 2] = [10]console.log(c, d) // 10 2// 忽略某些值var [a = 2, , b = 2] = [10, 20, 30]console.log(a, b) // 10 30// 3. 函数参数的解构赋值function foo(&#123; x &#125;) &#123; console.log(x) // 1&#125;foo(&#123; x: 1, y: 2 &#125;)// 函数参数默认值function foo(&#123; x = 10 &#125;) &#123; console.log(x) // 10&#125;foo()// 4. 解构的特殊应用// 交换变量var a = 1var b = 3;[a, b] = [b, a]console.log(a) // 3console.log(b) // 1// 字符串解构var str = &#x27;love&#x27;var [a, b, c, d] = strconsole.log(a, b, c, d) // l o v e 扩展运算符扩展运算符（spread）是三个点（…）。作用：将一个数组转为用逗号分隔的参数序列 var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]console.log(...arr) // a b c 应用 // 数组深拷贝var arr = [1, 2, 3]var arr1 = [...arr]console.log(arr === arr1) // false, 说明arr1和arr指向不同数组// 把一个数组插入另一个数组字面量var arr2 = [...arr, 4, 5, 6]console.log(arr2) // [1, 2, 3, 4, 5, 6]// 字符串转数组var str = &#x27;love&#x27;var arr3 = [...str]console.log(arr3) // [ &#x27;l&#x27;, &#x27;o&#x27;, &#x27;v&#x27;, &#x27;e&#x27; ] 对象展开 let defaults = &#123; name: &#x27;zs&#x27;, age: 18 &#125;let search = &#123; ...defaults, age: 12 &#125; // &#123; name: &#x27;zs&#x27;, age: 12 &#125; 后面的属性会覆盖前面的属性 对象展开仅包含对象自身的可枚举属性 class C &#123; p = 12 m() &#123;&#125;&#125;let c = new C()let clone = &#123; ...c &#125;clone.p // okclone.m() // error! ES6 模块化","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://wqdy.top/tags/es6/"}]},{"title":"防抖和节流","slug":"前端/js/js-防抖和节流","date":"12/12/2018","updated":"12/12/2018","comments":true,"path":"398.html","link":"","permalink":"https://wqdy.top/398.html","excerpt":"","text":"防抖和节流都是为了解决短时间内大量触发某函数而导致的性能问题，比如触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象 防抖（debounce）在事件被触发 n 秒后再执行回调函数，如果在这 n 秒内又被触发，则重新计时（只会触发最后一次） 应用场景 用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询 ajax 请求，这样可以有效减少请求次数，节约请求资源 window 的 resize、scroll 事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次 节流（throttle）规定一个单位时间 n，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内事件被触发多次，只有一次能生效（每 n 秒触发一次） 应用场景 鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次 在页面的无限加载场景下，需要用户在滚动页面时，每隔一段时间发一次 ajax 请求，而不是在用户停下滚动页面操作时才去请求数据 监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断 区别防抖的作用是将多个连续的debounced调用合并为一次callback调用。防抖是基于最近次 debounced 调用来重置 waitTime，如果debounced事件触发间隔小于 waitTime，callback就不会执行； 节流的作用是限制callback调用的频率（每waitTime调用一次）。是基于上次 callback 调用来计算 waitTime 的，不管callback 事件触发有多频繁，只要距离上次 callback 调用超过了 waitTime，就一定会进行下次 callback 调用。 – 原理： 防抖是 debounced 维护了一个计时器，规定在 waitTime 时间后触发 callback，但是在 waitTime 时间内再次触发 debounced 的话，会清除当前的 timer 然后重新计时，这样一来，只有最后一次debounced 操作才能触发 callback； 节流是通过判断是否到达一定时间 (waitTime) 来再次触发 callback ， func 在 waitTime 时间内不能被再次触发。 实现 throttle-debounce 插件 https://www.npmjs.com/package/throttle-debounce &lt;input id=&quot;input&quot; type=&quot;text&quot; /&gt; input.oninput = throttle(1000, function() &#123; console.log(this.value)&#125;)function b() &#123; console.log(this.name)&#125;const a = debounce(1000, b)a.call(&#123; name: &#x27;zs&#x27; &#125;)// 节流function throttle(delay, callback) &#123; let timer = null let lastExec = 0 return function() &#123; const self = this const elapsed = Number(new Date()) - lastExec const args = arguments function exec() &#123; callback.apply(self, args) lastExec = Number(new Date()) &#125; clearTimeout(timer) if (elapsed &gt; delay) &#123; exec() &#125; else &#123; timer = setTimeout(function() &#123; exec() &#125;, delay - elapsed) &#125; &#125;&#125;// 防抖function debounce(delay, callback) &#123; let timer = null return function() &#123; const self = this const args = arguments function exec() &#123; callback.apply(self, args) lastExec = Number(new Date()) &#125; clearTimeout(timer) timer = setTimeout(function() &#123; exec() &#125;, delay) &#125;&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"LESS 基本使用","slug":"前端/less-基本使用","date":"11/12/2018","updated":"11/12/2018","comments":true,"path":"425.html","link":"","permalink":"https://wqdy.top/425.html","excerpt":"","text":"Less 简介 Less 是一门 CSS 预处理语言（预先处理）,它扩展了 CSS 语言，增加了变量、Mixin、函数等特性 浏览器不直接识别 less 文件，浏览器只识别 css 文件，所以我们写了 less 文件之后，我们需要预先把 less 文件转换成 css 文件。 本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。 less 仅仅是写 css 的另一种方式，写出来的 less 文件浏览器也不识别，所以啊，我们写完了 less 文件，还需要通过 less 解析器解析成 css，最终浏览器引入的还是 css 文件。 学习网站： 官网 http://lesscss.org/中文网 http://lesscss.cn/ less 的编译 如何把 less 文件变成 css 文件 使用打包工具gulp webpack 使用考拉 koala 是一个前端预处理器语言（less&#x2F;sass）图形编译工具，支持 Less、Sass、Compass、CoffeeScript，帮助 web 开发者更高效地使用它们进行开发。跨平台运行，完美兼容 windows、linux、mac。 考拉官网 使用步骤： 把less文件夹拖进去 会在当前目录生成一个css目录 优点：不用 node 环境，不用 less 环境，koala 内置了 使用插件easy less Less 语法变量注释 /* 这是CSS中的注释，因此会编译到css中 */// 这是less的注释，css不能识别这个注释， 最后不会编译到css文件 变量 // @变量名: 变量值;@color: #ccc;p &#123; color: @color;&#125; mixin 函数混入函数 // 定义一个函数：不带参数.btn() &#123; background-color: #ccc;&#125;// 调用函数.my_btn &#123; .btn();&#125;// 定义一个函数：带参数.btn_border(@width) &#123; border: @width solid #000;&#125;.my_btn &#123; // 如果函数定义了参数，调用的时候必须传入参数，否则会报错 .btn_border(10px);&#125;// 定义一个函数：带参数默认值.btn_border(@width: 1px) &#123; border: @width solid #000;&#125;.my_btn &#123; // 因为有默认值，所以不会报错 .btn_border(); .btn_border(10px);&#125; 应用：定义兼容多浏览器的圆角 .border_radius(@value: 5px) &#123; -webkit-border-radius: @value; -moz-border-radius: @value; -ms-border-radius: @value; border-radius: @value;&#125;div &#123; .border_radius(10px);&#125; 嵌套 我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。 使用伪类的时候 可以使用&amp; 表示自己 .father &#123; width: 100px; // 子代 .son1 &#123; &#125; // 后代 &gt; .son2 &#123; &#125; // 交集： &amp; 表示本身 &amp;.now &#123; &#125; &amp;::before &#123; &#125; &amp;:hover &#123; &#125;&#125; 导入// 可以省略后缀名@import &#x27;variable&#x27;;@import &#x27;maxin&#x27;; 模块化的思想，分模块进行管理这些 less 文件，最终只需要使用 import 将 less 引入到一起即可 函数（运算） 在我们的 CSS 中充斥着大量的数值型的 value，less 可以直接支持运算，也提供了一系列的函数提供给我们使用。 li &#123; float: left; width: round(100%/6, 2); height: 100px + 100px;&#125; http://www.1024i.com/demo/less/reference.html","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"less","slug":"less","permalink":"https://wqdy.top/tags/less/"}]},{"title":"移动 web","slug":"前端/移动-web","date":"11/12/2018","updated":"11/12/2018","comments":true,"path":"389.html","link":"","permalink":"https://wqdy.top/389.html","excerpt":"","text":"移动 web 基础移动端开发现状 移动 web 开发指的是需要适配移动设备的网页开发 移动 web 开发与 pc 端 web 开发没有本质的区别，使用的还是 HTML&#x2F;CSS&#x2F;JavaScript 的技术 移动 web 开发与 pc 端 web 开发的区别是什么？ 移动端的浏览器与 pc 端不同 谷歌浏览器 苹果浏览器、 UC浏览器 QQ浏览器 欧朋浏览器 百度手机浏览器 360安全浏览器 搜狗浏览器 猎豹浏览器等国内的手机浏览器都是根据webkit内核修改过来的，国内没有自主研发的内核，国内的操作系统也是基于Android系统修改的。因此在移动端，css3 属性只需要加 webkit 前缀即可 移动端设备尺寸不一样(尺寸非常多，碎片化很严重) Android： 320*480 480*800 540*960 720*1280 1080*1920 2k屏 4k屏iphpne： 640*960 640*1136 750*1334 1242*2208 移动端开发分类 原生 app（native app） 混合 app（Hybrid app） web 应用（webApp） 原生 app（native app） 原生 app 是基于操作系统的开发，比如安卓，ios，windows phone,他们只能在各自的操作系统上运行。 优点： 可以访问操作系统，获取更多的资源（gps，摄像头，传感器，麦克风等） 速度快，性能高，用户体验好 可以离线使用 缺点： 开发成本高 需要安装和更新，更新与发布需要审核。 Web App Web 应用使用 H5C3 开发页面，为浏览器设计的基于 web 的应用，可以在各种智能设备的手机浏览器上运行。不需要安装即可运行。 优点： 支持设备广泛 开发成本低（使用） 可以随时上线与更新，无需审核 缺点： 用户体验极度依赖网速 要求联网 无法获取手机的资源（gps，摄像头） 混合 app（Hybrid App） Hybrid App 是指介于 web-app、native-app 这两者之间的 app,它虽然看上去是一个 Native App，但只有一个 UI WebView，里面访问的是一个 Web App。（淘宝、京东、手机百度） Hybird App 说白了就是使用了 Native app 的壳，里面其实还是 HTML5 页面 优点： 开发成本和难度更低，兼容多个平台 也可以访问手机的操作系统资源。 更新维护更方便 缺点： 用户体验相比原生 app 稍差 性能依赖于网速 总结： 三种开发各有优缺点，具体用什么需要根据实际情况而定，比如预算，app 注重功能还是内容等 屏幕与分辨率理解设备像素、设备独立像素和 css 像素 移动设备与 PC 设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面 屏幕尺寸 通常我们所指的屏幕尺寸，实际上指的是屏幕对角线的长度（一般用英寸来度量） 1英寸 = 2.54厘米 屏幕分辨率 分辨率则一般用像素来度量，表示屏幕水平和垂直方向的像素数，例如 1920*1080 指的是屏幕垂直方向和水平方向分别有 1920 和 1080 个像素点而构成 像素：指计算机显示设备中的最小单位，即一个像素点的大小。每一个像素点可以理解为就是屏幕上的一个发光点 像素密度 ppi PPI (Pixels Per Inch)表示屏幕每英寸的像素数 PPI 值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙 设备像素 设备像素 (device pixels）也叫物理像素 设备像素指的是显示器上的真实像素，每个像素的大小是屏幕固有的属性，屏幕出厂以后就不会改变了 设备分辨率描述的就是这个显示器的宽和高分别是多少个设备像素 设备像素和设备分辨率交给操作系统来管理，浏览器不知道、也不需要知道设备分辨率的大小，浏览器只需要知道逻辑分辨率就可以了 设备独立像素 设备独立像素（Device Independent Pixels）也叫逻辑像素、设备无关像素。在 IOS 设备上叫PT，Android 设备上叫DP，在 css 中，叫PX 为了能够保证 图像内容在不同的 PPI 设备看上去大小应该差不多 ，操作系统定义了一个单位：设备独立像素，用设备独立像素定义的尺寸，不管屏幕的参数如何，都能以合适的大小显示（这也是设备独立像素名字的由来） 对于那些像素密度高的屏幕，操作系统将多个设备像素划分为一个逻辑像素。屏幕的像素密度越高，就需要更多的设备像素来显示一个设备独立像素。至于将多少设备像素划分为一个逻辑像素，这由操作系统决定 获取设备的像素比 window.devicePixelRatio // 物理像素 与 css 像素的比值 DPR 通过 screen.width/height得到的屏幕宽度和高度就是逻辑分辨率（单位：设备独立像素） css 像素与缩放在缩放比例为 100% 的情况下，一个 css 像素大小等于一个设备独立像素 缩放页面的时候，元素的 css 像素数量不会改变，改变的只是每个 css 像素的大小 缩放比例 &#x3D; css 像素边长 &#x2F; 设备独立像素边长 如果原本元素宽度为 128 个设备独立像素，那么缩放 200% 以后元素宽度为 256 个设备独立像素（css 像素宽度始终是 128） 桌面浏览器上缩放机制是 page zoom，缩放会导致 CSS 像素边长的改变，从而导致 window.devicePixelRatio 的改变 在移动端缩放机制是 pinch zoom，计算 window.devicePixelRatio 时，不考虑 pinch zoom 对 CSS 像素尺寸的影响，因此 window.devicePixelRatio 不会随缩放而改变 2 倍图与 3 倍图 以后同学在工作的过程中，从 UI 那拿到的设计图通常都是 640 的设计图或者是 750 的设计图 把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度 设备像素比 devicePixelRatio：即像素的压缩比例 结论 ：在移动端为了在高清屏手机上显示得更加细腻，通常会使用更大的图片，比如 2 倍图或者 3 倍图 视口 viewport问题：一个电脑上的网站，在手机端访问，效果是什么样的？iPhone5 的设备宽度只有 320px，一张宽度为 640px 的图片在手机端访问，显示的效果是什么？1. 在手机端，html的 大小都是 980px，为什么？这主要是历史原因导致的，因为在移动设备刚流行的时候，网站大多都是pc端的，pc端的页面宽度一般都比较大，移动设备的宽度比较小，如果pc端页面直接在移动端显示的话，页面就会错乱。为了解决这个问题，移动端html的大小直接就定死成了980px（因为早起的pc端网站版心就是980px居多）2. 视口在 pc 端，html 的大小默认是继承了浏览器的宽度，即浏览器多宽，html 的大小就是多宽，但是在移动端，多出来了一个视口的概念（乔布斯）,视口说白了就是介于浏览器与 html 之间的一个东西，视口的宽度默认定死了 980px，因此 html 的宽度默认就是 980px，视口的特点是能够根据设备的宽度进行缩放3. 视口设置对于现在的移动端页面来说，视口默认为 980px 肯定不合适，因为设备宽度不够的话，视口会进行缩放，导致页面展示效果不好看 视口参数设置 // width 设置视口的宽度// width=device-width 设置视口宽度为设备的宽度（常用）// initial-scale 设置初始缩放比例// initial-scale=1.0 表示不缩放// user-scalable 设置是否允许用户缩放// user-scalable=no 不允许用户缩放// maximum-scale 设置允许的最大缩放比例// maximum-scale=1.0 可以不设置，因为都禁止用户缩放了// minimum-scale 设置允许最小缩放比// minimum-scale=1.0 不设置，因为都禁用用户缩放了// 标准写法：// 快捷键： meta:vp + tab键&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;&gt; 移动端调试问题 模拟器调试 真机调试：使用手机进行访问。 手机设备五花八门，屏幕尺寸都大不一样，尤其是安卓端，给我们的页面预览带来了一些麻烦。在实际工作中，作为开发者不可能有足够的设备让我们去测试（除了测试部门 ），即便有，效率也特别的低，因此开发者一般都是通过浏览器的手机模拟器来模拟不同的设备。 流式布局移动端的特点 手机端的兼容性问题比 PC 端小很多，因为手机端的浏览器版本比较新 手机端屏幕比较小，能够放的内容比较少。 问题：布局的时候怎么解决屏幕大小不一致的问题？ PC 端，固定版心，让所有分辨率的电脑的版心都是一样的，比如京东 移动端：移动端无法设置版心，因为移动端的设备屏幕本身就小，设置版心不合适。因此移动端大多会采用流式布局（百分比布局） 流式布局，也叫百分比布局，是移动端开发中经常使用的布局方式之一。 流式布局的特征： 宽度自适应，高度写死，并不是百分百还原设计图 图标都是固定死大小的，包括字体等也是固定死的。并不是所有的东西都是自适应的。 一些大的图片，设置宽度为百分比自适应即可，随着屏幕大小进行变化 流式布局无法做到所有设备都非常逼真的还原设计图，有些设备显示效果不是特别的好看。但是流式布局是移动端非常常用的一种布局方式，比较简单，需要掌握（携程、京东) 最后一天会学习 rem 布局，配合 less 非常的方便，并且能够实现完全的自适应，包括字体以及图标等 经典的流式布局 1. 左侧固定，右侧自适应2. 右侧固定，左侧自适应3. 两侧固定，中间自适应（圣杯布局，双飞翼布局）4. 等分布局 touch 事件移动端新增了 4 个与手指触摸相关的事件 touchstart: 手指放到屏幕上时触发 touchmove: 手指在屏幕上滑动式触发（会触发多次） touchend: 手指离开屏幕时触发 touchcancel: 系统取消 touch 事件的时候触发，比如电话 每个触摸事件被触发后，会生成一个 event 对象，event 对象中changedTouches会记录手指滑动的信息 e.touches // 当前屏幕上的手指e.targetTouches // 当前dom元素上的手指。e.changedTouches // 触摸时发生改变的手指(重点)(如手指离开屏幕) 这些列表里的每次触摸由 touch 对象组成，touch 对象里包含着触摸信息，主要属性如下 // e.changedTouches[0].clientXclientX / clientY // 触摸点相对浏览器窗口的位置pageX / pageY // 触摸点相对于页面的位置 !&gt; 使用 jquery 注册 touch 类事件时，获取手指使用 e.originalEvent.touchs[0] ，因为 jq 对事件对象进行了封装 【案例：jdm-滑动轮播图】 【案例：jdm-区域滚动】 iscroll 插件使用https://github.com/cubiq/iscroll iscroll 参考文档 注意：使用 iscroll 需要满足的条件 父盒子嵌套了子盒子（一个） 如果有多个子盒子，所以我们需要使用一个盒子把所有的子盒子包裹起来 如果有图片，我们需要保证图片加载完成，如果有浮动，需要清除浮动，为了保证子盒子的高度获取的是正确的 子盒子大小一定要超过父盒子的大小 // 使用：box为父盒子var box = document.querySelector(&#x27;.box&#x27;)new IScroll(box, &#123; scrollX: false, // 横向滚动 scrollY: true // 纵向滚动&#125;) zepto 框架 Zepto是一个轻量级的针对现代高级浏览器的 JavaScript 库， 它与 jquery有着类似的 api。 如果你会用 jquery，那么你也会用 zepto github 地址 中文文档 zepto 与 jquery 的区别 jquery 针对 pc 端，主要用于解决浏览器兼容性问题，zepto 主要针对移动端 zepto 比 jquery 轻量，文件体积更小 zepto 封装了一些移动端的手势事件 zepto 的基本使用zepto 的使用与 jquery 基本一致，zepto 是分模块的，需要某个功能，就需要引入某个 zepto 的文件 &lt;script src=&quot;zepto/zepto.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;zepto/event.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;zepto/fx.js&quot;&gt;&lt;/script&gt; $(function() &#123; $(&#x27;.box&#x27;).addClass(&#x27;demo&#x27;) $(&#x27;button&#x27;).on(&#x27;click&#x27;, function() &#123; $(&#x27;.box&#x27;).animate(&#123; width: 500 &#125;, 1000) &#125;)&#125;) zepto 的定制安装 Nodejs 环境 1、下载 zepto.js 2、解压缩 3、cmd 命令行进入解压缩后的目录 4、执行npm install命令 5、编辑 make 文件的41行，添加自定义模块并保存 7、然后执行命令 npm run-script dist 8、查看目录 dist 即构建好的 zepto.js zepto 手势事件zepto 中根据touchstart touchmove touchend封装了一些常用的手势事件，这些事件都是基于 touchstart touchmove touchend 封装 tap // 轻触事件,用于替代移动端的click事件，因为click事件在老版本中会有300ms的延迟swipe //手指滑动时触发swipeLeft //左滑swipeRight //右滑swipeUp //上滑swipeDown //下滑 响应式什么是响应式布局 响应式布局（respond layout）是 Ethan Marcotte 在 2010 年 5 月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端（手机、平板、pc 电脑、手表） ——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的 为什么要有响应式布局？ 在移动互联日益成熟的时候，在 PC 端开发的网页已经无法满足移动设备的要求 通常的做法是针对移动端单独做一套特定的版本 如果终端越来越多，那么需要开发的版本就会越来越多（大屏设备的普及） 响应式布局 ：一个网站能够兼容多个终端（节约开发成本） 优点： 面对不同分辨率设备灵活性强 能够快捷解决多设备显示适应问题 **缺点： ** 兼容各种设备工作量大，效率低下 代码累赘，会出现隐藏无用的元素，加载时间加长 其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况 响应式开发现状： 如果已经存在 PC 的网站了，那么一般不会使用响应式开发，而是针对移动端再开发一套系统（比如京东、淘宝） 在新建站点 上采用响应式开发的越来越多 在国内，响应式开发还不是特别的流行。但响应式开发是大势所趋，会越来越流行 响应式开发与移动 web 开发的比较 开发方式 移动 web 开发+pc 开发 响应式开发 引用场景 一般已经有了 PC 端网站，只需要端独开发移动端网站即可 针对一些新建网站，并且要求适配移动端 开发 针对性强，开发效率高 兼容各种终端，效率低 适配 只能适配移动端或者 PC 端，pad 上体验比较差 可以适配各种终端 效率 代码简介，加载快 代码相对复杂，加载慢 媒体查询 媒体查询（Media Query）是 CSS3 提出来的一个新的属性，通过媒体查询可以查询到 screen 的宽度，从而指定某个宽度区间的网页布局 设备分类 分类 宽度范围 大屏设备 &gt;1200px 中屏设备 992px~1200px 小屏设备 768px~992px 超小屏设备 &lt; 768px 媒体查询的使用需求： &lt;!-- 大屏设备(&gt;1200px) 版心：1170px 背景色：红色 中屏设备(992-1200) 版心：970px 背景色：蓝色 小屏设备(768-992) 版心：750px 背景色：黄色 超小屏设备(&lt;768px) 版心：100% 背景色：绿色--&gt; 响应式开发的原理：使用媒体查询实现不同终端的布局和样式的切换 媒体查询语法： /* 查询屏幕 *//* screen 和第一个 and 可以省略 */@media screen and 条件 &#123;&#125;/* 条件的写法 *//* min-width: 只要屏幕宽度超过这个值的设备样式就能生效 *//* max-width: 只要屏幕宽度小于这个值的设备样式就能生效 */@media screen and (min-width: 1200px) &#123; .container &#123; width: 1170px; background-color: red; &#125;&#125;@media screen and (min-width: 992px) and (max-width: 1200px) &#123; .container &#123; width: 970px; background-color: blue; &#125;&#125;@media screen and (min-width: 768px) and (max-width: 992px) &#123; .container &#123; width: 750px; background-color: yellow; &#125;&#125;@media screen and (max-width: 768px) &#123; .container &#123; width: 100%; background-color: green; &#125;&#125; bootstrap 框架【项目：微金所】 REMrem 是什么？rem（font size of the root element）是指相对于根元素的字体大小的单位。它就是一个相对单位。 em（font size of the element）是指相对于 当前元素的字体大小 的单位。它也是一个相对单位。 它们之间其实很相似，只不过计算的规则一个是依赖根元素，一个是当前元素计算。 html &#123; font-size: 16px;&#125;body &#123; font-size: 20px;&#125;div.em &#123; /* em 的计算方式参照的当前元素的 font-size，如果不设置，默认继承自父盒子 */ width: 2em; height: 2em; background-color: red;&#125;/* rem 的计算方式参照的是 html 的 font-size */div.rem &#123; width: 2rem; height: 2rem; background-color: blue;&#125; 为什么要用 rem？ rem 的主要目的就是解决用于不同屏幕的适配问题。rem 能够等比例的适配所有的屏幕。 由于市面上手机种类繁多，导致移动端的屏幕种类非常的混乱，比如有常见的320px 360px 375px 384px 480px 640px等。在开发中，美工一般只会提供 750px 或者是 640px 的设计稿，这就要求我们通过一张设计稿能够适配所有的屏幕。通常解决方案如下： 流式布局：虽然可以让各种屏幕都适配，但是显示效果不是非常的友好，因为只有几个尺寸的手机能够完美的显示出来视觉设计师和交互最想要的效果。但是目前使用流式布局的公司非常多，比如 亚马逊 、京东 、携程 响应式布局：响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难 。所以一般都是中小型的门户或者博客类站点会采用响应式的方法从 PC 端页面到移动端页面以及 web app 直接一步到位，因为这样反而可以节约成本。 rem 布局：rem 能够适配所有的屏幕，与 less 配合使用效果会更好。目前使用 rem 布局的有：淘宝 、 苏宁 rem 布局因为 rem 的基准点是根元素 html 的字体大小，因此我们只需要设置不同屏幕的 html 的 font-size 大小不一样就可以达到不同屏幕的适配了。 rem 配合媒体查询使用 rem 配合媒体查询可以适配多个终端 @media(min-width: 320px) &#123; html &#123; /* 基准值 / 设计图的大小 = 某个屏幕的font-size / 屏幕的宽度 */ /* 100/750 = x/370 */ font-size: 50px; &#125;&#125;... 优点：使用媒体查询适配，速度快。 缺点：适配多个终端时，需要添加响应的代码。 rem 配合 javascript通过 javascript 获取可视区的宽度，计算 font-size 的值，也可以适配多个终端 // 根据屏幕的大小动态设置 html的 font-sizefunction responsive () &#123; var uiWidth = 750 // 设计图宽度 var base = 100 // 设计图中1rem的大小 // 当前屏幕的大小 var pageWidth = window.innerWidth if(pageWidth &gt;= 750) &#123; pageWidth = 750 &#125; if(pageWidth &lt;= 320) &#123; pageWidth = 320 &#125; // 说白了就是把一个屏幕分成了 7.5 rem document.documentElement.style.fontSize = (base / uiWidth * pageWidth).toFixed(2) + ’px‘&#125; 优点：直接适配所有的终端 缺点：必须在页面加载之前设置 html 的 font-size 值，不然会出现文字大小调动的情况。 rem 配合 flexible 插件 flexible 插件基准值（base）是设计图的 1&#x2F;10 使用 flexible 在 header 中引入 flexible.js 这个文件 根据设计图能够确定基准值， 配合 px2rem 插件 ，需要设置一个 rootFontSize 【案例：苏宁易购】 swiper 插件 Swiper 是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端 swiper 中文网 othera &#123; /* 取消链接高亮, 移动端特有的样式 */ -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"浏览器的工作原理","slug":"前端/浏览器的工作原理","date":"30/11/2018","updated":"30/11/2018","comments":true,"path":"400.html","link":"","permalink":"https://wqdy.top/400.html","excerpt":"","text":"浏览器的组成 用户界面－ 包括地址栏、后退&#x2F;前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分 浏览器引擎－ 用来查询及操作渲染引擎的接口 渲染引擎（浏览器内核）－ 用来显示请求的内容，例如，如果请求内容为 html，它负责解析 html 及 css，并将解析后的结果显示出来 网络－ 用来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作 UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口 JS 解释器－ 用来解释执行 JS 代码 数据存储－ 属于持久层，浏览器需要在硬盘中保存类似 cookie 的各种数据，HTML5 定义了 Storage 技术，这是一种轻量级完整的客户端存储技术 主流的渲染引擎 浏览器的渲染引擎也叫排版引擎，或者是浏览器内核 主流的 渲染引擎 有 Chrome 浏览器: Blink 引擎（WebKit 的一个分支）。 Safari 浏览器: WebKit 引擎，windows 版本 2008 年 3 月 18 日推出正式版，但苹果已于 2012 年 7 月 25 日停止开发 Windows 版的 Safari。 FireFox 浏览器: Gecko 引擎。 Opera 浏览器: Blink 引擎(早期版使用 Presto 引擎）。 Internet Explorer 浏览器: Trident 引擎。 Microsoft Edge 浏览器: EdgeHTML 引擎（Trident 的一个分支）。 渲染引擎工作原理渲染引擎解析的基本流程： 解析 HTML 构建 Dom树，同时解析所有的 css 样式，构建 css 规则。DOM 是 W3C 组织推荐的处理可扩展置标语言的标准编程接口。 根据 DOM 树和 css 规则合并构建 渲染树 DOM 树上的节点没有样式的，渲染树的节点有样式的 渲染树上的节点都是需要渲染的，所以渲染树上没有像head标签 或 display: none这样的元素，但是它们在 Dom 树中 对渲染树进行布局，定位坐标和大小、确定是否换行、确定 position、overflow、z-index 等等，这个过程叫layout 或 reflow。 绘制渲染树，调用操作系统底层 API(UI Backend)进行绘图操作。 webkit 内核工作流程 gecko 内核工作流程 结论：浏览器能够解析 HTML 文件，并且显示到页面中。所以我们写的文件能够使用浏览器打开并且能够看到效果。 重绘与回流重绘与回流回流(reflow): 又叫重排，当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。 重绘(repaint)：当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。 每个页面至少需要一次回流+重绘 回流必将引起重绘 回流什么时候发生？ 1、添加或者删除可见的 DOM 元素 2、元素位置改变 3、元素尺寸改变——边距、填充、边框、宽度和高度 4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变 5、页面渲染初始化 6、浏览器窗口尺寸改变——resize 事件发生时 var s = document.body.styles.padding = &#x27;2px&#x27; // 回流+重绘s.border = &#x27;1px solid red&#x27; // 再一次 回流+重绘s.color = &#x27;blue&#x27; // 再一次重绘s.backgroundColor = &#x27;#ccc&#x27; // 再一次 重绘s.fontSize = &#x27;14px&#x27; // 再一次 回流+重绘// 添加node，再一次 回流+重绘document.body.appendChild(document.createTextNode(&#x27;abc!&#x27;)) 聪明的浏览器 从上个实例代码中可以看到几行简单的 JS 代码就引起了 6 次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句 JS 操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前 flush 队列，这样浏览器的优化可能就起不到作用了。当你向浏览器请求一些 style 信息的时候，就会让浏览器 flush 队列，比如： offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop&#x2F;Left&#x2F;Width&#x2F;Height clientTop&#x2F;Left&#x2F;Width&#x2F;Height width,height 请求了 getComputedStyle(), 或者 IE 的 currentStyle 如何性能优化 减少回流与重绘的次数，就需要简单对渲染树的操作 直接使用 className 修改样式，少用 style 设置样式 让要操作的元素进行”离线处理”，处理完后一起更新 使用 DocumentFragment 进行缓存操作，引发一次回流和重绘 使用 display:none 技术，只引发两次回流和重绘 将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow 完成功能是前提，在完成功能的情况下想着优化代码","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://wqdy.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"HTML5","slug":"前端/html/html5","date":"23/11/2018","updated":"23/11/2018","comments":true,"path":"395.html","link":"","permalink":"https://wqdy.top/395.html","excerpt":"","text":"什么是 HTML5 HTML5 并不仅仅是作为 HTML 标记语言的一个最新版本， 更重要的是它制定了 web 应用开发的一系列标准，成为第一个将 web 作为应用开发平台的 HTML 语言。 HTML5 定义了一系列新元素，如 新语义标签、多媒体标 签等，可以帮助开发者开发更加丰富的应用，同时有令人眼花缭乱的 css3，还提供了一些 Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用，制作 webApp，甚至结合 Canvas 我们可开发网页游戏 我们日常讨论的 H5 其实指的是一个泛称，它是由HTML5+CSS3+javascript 等技术组合而成的一个应用开发平台 HTML5 的历史1. WHATWG: Web Hypertext Application Technology Working。 WHATWG成立的原因是W3C意图放弃HTML，而力图发展XML技术2. HTML5 的第一份正式草案已于2008年1月22日公布3. 2014年10月29日，万维网联盟宣布，经过接近8年的艰苦努力，该标准规范终于制定完成 思考：问什么 HTML5 在 2008 年就发布草案了，到 2014 年才火起来？ 因为移动端的推动，HTML 在老的浏览器上兼容性很严重，并且 HTML5 很多新特性其实就是为移动端而出现的，可以说HTML5 是为移动端而生的 HTML5 语义化标签常用语义化标签 在 HTML5 之前，我们布局大多使用 div，但是 div 并没有语义化，HTML5 推出了一系列的语义化标签，可以用来表示 header、footer 等。 HTML5 新的语义化标签 header 头部、nav 导航、footer 底部、aside 侧边栏、article 文章、section 区块、main 主体区域 本质上新语义标签与&lt;div&gt;、&lt;span&gt;没有区别，只是其具有语义性，使用时除了在 HTML 结构上需要注意外，其它和普通标签的使用无任何差别，&lt;nav&gt;完全可以理解成&lt;div class=&quot;nav&quot;&gt;。不要好奇，它只是一个标签！就是增加了语义性，更加利于 SEO 的优化。 html5 还推出了一些其他的标签：http://www.w3school.com.cn/tags/index.asp 兼容性处理IE678 不识别这个标签 document.createElement(&#x27;header&#x27;) // 创建这个标签即可让IE678识别// 创建的标签默认是行内样式。// 还需给标签加一个 display:block 的属性。 借助 html5shiv.js 我们每次都要去创建标签，并且还需要设置 display：block 属性，非常麻烦，因此我们可以引入一个第三方 js 文件，这个 js 文件的功能就是创建元素和设置 display 属性。 &lt;!-- [if lte IE 8] &gt; // lte ==&gt; 小于等于&lt;script src=&quot;js/html5shiv.min.js&quot;&gt;&lt;/script&gt;&lt;! [endif] --&gt;&lt;!-- 当 ie 浏览器的版本小于等于8的时候，才会引入 html5shiv.js --&gt;&lt;!-- css hack --&gt;&lt;!-- 条件注释 IE独有的注释 --&gt; 类名操作(重点) js 在 H5 中给所有的 DOM 对象新增了一个属性 classList classList 是一个集合，会存储某个元素上所有的类名，使用 classList 来替代 className 操作 class 类 // 添加类div.classList.add(&#x27;classname&#x27;)// 移除类div.classList.remove(&#x27;classname&#x27;)// 切换类div.classList.toggle(&#x27;classname&#x27;)// 判断类div.classList.contains(&#x27;classname&#x27;) 【tab 栏案例】 自定义属性操作（重点） H5 规定，以后但凡给标签增加自定义属性，都应该用 data- 开头 (规范) H5 给所有的 DOM 对象增加了一个 dataset 的属性，这个属性中会包含所有 data- 开头的属性 html 5 中操作自定义属性 dataset 属性 &lt;div id=&quot;box&quot; data-name=&quot;zs&quot; data-age=&quot;10&quot; data-user-name=&quot;ls&quot;&gt;&lt;/div&gt;&lt;script&gt; var box = document.querySelector(&#x27;#box&#x27;) console.log(box.dataset) // DOMStringMap &#123;name: &#x27;zs&#x27;, age: &#x27;10&#x27;, userName: &#x27;ls&#x27;&#125; console.log(box.dataset.name) // zs console.log(box.dataset[&#x27;age&#x27;]) // 10 console.log(box.dataset.userName) // ls box.dataset.aaBb = &#x27;cc&#x27; // 在html结构中或添加 data-aa-bb=&quot;cc&quot; 的自定义属性&lt;/script&gt; 注意：html 中属性是忽略大小写的，相当于是小写字母，如果需要大写，应使用中划线 - 进行分隔，在 js 中会转换成驼峰的形式，如data-user-name ==&gt; userName jquery 中操作自定义属性 jquery 并没有把 data- 当成自定义属性来用，jq 中封装了 data() 方法 &lt;div data-id=&quot;1&quot; data-name=&quot;zs&quot; id=&quot;box&quot; data-a=&#x27;&#123;&quot;b&quot;:&quot;c&quot;&#125;&#x27;&gt;&lt;/div&gt;&lt;script&gt; console.log($(&#x27;#box&#x27;).data()) // &#123;id: 1, name: &quot;zs&quot;&#125; // console.log($(&#x27;#box&#x27;).attr()) // error console.log(box.dataset) // DOMStringMap&#123;id: &quot;1&quot;, name: &quot;zs&quot;&#125; console.log($(&#x27;#box&#x27;).data(&#x27;id&#x27;)) // 1 =&gt; 获取到自定义属性 $(&#x27;#box&#x27;).data(&#x27;id&#x27;, 2) // 并不会修改原标签中的自定义属性 console.log($(&#x27;#box&#x27;).data(&#x27;id&#x27;)) // 2 =&gt; html中data-id依然是1 console.log($(&#x27;#box&#x27;).attr(&#x27;data-id&#x27;)) // 1 console.log(box.dataset[&#x27;id&#x27;]) // 1 =&gt; 获取到的还是原来的 data-id $(&#x27;#box&#x27;).attr(&#x27;data-id&#x27;, 3) console.log($(&#x27;#box&#x27;).data(&#x27;id&#x27;)) // 3 console.log(box.dataset[&#x27;id&#x27;]) // 3 // 属性里使用json语法，但通过data()设置的不能解析成对象 $(&#x27;#box&#x27;).data(&#x27;d&#x27;, &#x27;&#123;&quot;e&quot;:&quot;f&quot;&#125;&#x27;) console.log($(&#x27;#box&#x27;).data(&#x27;a&#x27;)) // &#123;b: &quot;c&quot;&#125; =&gt; 对象 console.log($(&#x27;#box&#x27;).data(&#x27;d&#x27;)) // &#x27;&#123;&quot;e&quot;:&quot;f&quot;&#125;&#x27; $(&#x27;#box&#x27;).removeData() // 删除之前通过 data() 方法设置的数据&lt;/script&gt; !&gt; jq 的 data() 方法内部使用了缓存来实现，该方法设置的属性只能通过该方法获取，在 html 页面中看不到属性值，通过原生 dataset 属性也获取不到值 网络状态 在移动端，我们经常需要检测设置是在线还是离线，HTML5 为此定义了一个 navigator.onLine 属性，这个属性用于检测设备是否联网。navigator.onLine 在不同浏览器中有细微的差别。 网络状态navigator.onLine 返回用户当前的网络状况，是一个布尔值1. 如果浏览器连不上网(包括局域网)，就是离线状态，也就是脱机状态，会返回 false2. 否则就是在线状态，返回 true 注意：返回 true 不一定就是说一定能访问互联网，因为有可能连接的是局域网。但是返回 false 则表示一定连不上网。 监听网络变化 为了更好的确定网络是否连接，HTML5 还定义了两个事件，用于监听网络状态的变化。 // 网络连接时会被调用window.addEventListener(&#x27;online&#x27;, function() &#123; alert(&#x27;online&#x27;)&#125;)// 当网络断开时会被调用window.addEventListener(&#x27;offline&#x27;, function() &#123; alert(&#x27;offline&#x27;)&#125;) 地理位置 在 HTML 规范中，增加了获取用户地理信息的 API，这样使得我们可以基于用户位置开发互联网应用，即基于位置服务 LBS(Location Base Service) 隐私HTML5 规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。在获取地理位置之前，会询问用户，只有在获得许可之后，才能获取到用户的位置信息。 H5 提供的获取地理位置信息并不是特别的精确，会一定的误差，如果需要非常精确的定位，还是需要使用安卓或者 ios，访问基于操作系统的方法。 （小程序） 相关的方法// successCallback:获取成功后会调用,并返回一个position对象，里面包含了地理位置信息// 获取失败了会调用，并返回error对象，里面包含了错误信息。// 获取当前的地理位置信息navigator.geolocation.getCurrentPosition(successCallback, errorCallback)// 重复的获取当前的地理位置信息navigator.geolocation.watchPosition(successCallback, errorCallback) 实例： navigator.geolocation.getCurrentPosition( function(position) &#123; // 定位成功会调用该方 // 法谷歌浏览器进行了限制，看不到，可以再IE浏览器下查看 // position.coords.latitude 纬度 // position.coords.longitude 经度 // position.coords.accuracy 精度 // position.coords.altitude 海拔高度 &#125;, function(error) &#123; // 定位失败会调用该方法 // error 是错误信息 &#125;) 苹果浏览器对 webkit 定位权限进行了修改，所有定位请求的页面必须是 https 协议的。 百度地图、高德地图、腾讯地图 仅仅获取到经纬度对于用户来说意义并不大，因为用户也不知道经度和纬度表示的是地球上的哪一个地方，因为我们可以结合百度地图，准确的将用户的位置显示出来。 百度地图官网：http://lbsyun.baidu.com/ 1. 在开发中，找到 javascript API2. 直接查看示例 demo3. 复制相应的代码，替换掉秘钥就行，秘钥只需创建一个新的应用就可以了 web 存储 在代码执行的时候，数据都是存储在内存中的，当页面关闭或者浏览器关闭的时候，内存就被释放掉了。数据只有存储在硬盘上，才不会被释放。 cookie特点： 在浏览器端的存储数据的容器 大小 4k 生命周期，默认会话级别，但是可以设置过期时间 cookie 中的数据可以在同一个网站的页面共享 cookie 中的数据，在请求时会进行自动携带 不同浏览器的 cookie 不能共享 cookie 是以字符串形式存在的，这个字符串有固定的格式：key&#x3D;value;key1&#x3D;value1；在获取 cookie 内容时，一般需要通过正则或者字符串的方法进行处理，转换成对象，最终得到数据 一般用于存储 sessionId，可以实现登录状态保持 (会话保持) document.cookie = &#x27;name=zhangsan&#x27;document.cookie = &#x27;age=18&#x27;document.cookie = &#x27;sex=23&#x27;// 设置过期时间document.cookie = &#x27;sex=12;max-age=3600&#x27;// 读取cookievar result = document.cookieconsole.log(result) WebStorage HTML5 规范提出使用 sessionStorage 和 localStorage 存储数据。设置、读取、删除操作很方便 sessionStorage 和 localStorage 特点 都保存在客户端 大小为 5M 左右 使用方法相同 以键值对的方式，存储字符串格式的数据 sessionStorage 和 localStorage 区别 sessionStorage 生命周期默认为一个会话周期，且不能设置周期，一旦关闭浏览器，就销毁了，不能在多个窗口下共享数据 localStorage 永久生效，除非手动删除，可以多个窗口共享 使用方法 setItem(key, value) // 设置存储内容getItem(key) // 读取存储内容removeItem(key) // 删除键值为key的存储内容clear() // 清空所有存储内容（谨慎使用） 存取复杂数据类型：先将复杂数据转换成 JSON 字符串 JSON.stringify(obj/arr) 在进行存储；使用时将 JSON 字符串转换成复杂数据类型 JSON.parse( jsonStr ) 【案例-换肤效果】 Cookie 和 WebStorage 比较cookie 大小受限 用户可以操作（禁用）cookie，使功能受限 安全性较低 有些状态不可能保存在客户端。 每次访问都要传送 cookie 给服务器，浪费带宽 WebStorage 存储空间更大：cookie 为 4KB，而 WebStorage 是 5MB WebStorage 不会传送到服务器，存储在本地的数据可以直接获取，速度更快，并且减少了客户端和服务器端的交互，节省了网络流量 对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage 会非常方便 安全性：WebStorage 不会随着 HTTP header 发送到服务器端，所以安全性相对于 cookie 来说比较高一些，不会担心截获，但是仍然存在伪造问题 WebStorage 提供了一些方法，数据操作比 cookie 方便 自定义播放器全屏切换 API： // requestFullScreen 这个方法还没有标准化，需要添加私有前缀video.requestFullScreen()video.webkitRequestFullScreen()video.mozRequestFullScreen() video&#x2F;audio 属性： currentTime: 设置或返回音频&#x2F;视频中的当前播放位置（以秒计） duration: 返回当前音频&#x2F;视频的长度（以秒计） autoplay: 默认 false 设置或返回是否在加载完成后随即播放音频&#x2F;视频 volume: 设置或返回音频&#x2F;视频的音量 paused: 设置或返回音频&#x2F;视频是否暂停， true 指示音频&#x2F;视频已暂停 方法： load(): 重新加载音频&#x2F;视频元素 play(): 开始播放音频&#x2F;视频 pause(): 暂停当前播放的音频&#x2F;视频 事件： timeupdate: 播放进度更改时触发 参考文档http://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp 推荐：https://www.awesomes.cn/repo/videojs/video-js 文件读取 通过 FileReader 对象我们可以读取本地存储的文件（用户通过 input:file 上传的文件），可以使用 File 对象来指定所要读取的文件或数据。其中 File 对象可以是来自用户在一个&lt;input&gt;元素上选择文件后返回的 FileList 对象，也可以来自由拖放操作生成的 DataTransfer files对于 file 类型的 input 框，在这个 DOM 对象中，存在一个 files 属性，这个属性是 FileList 对象，是一个伪数组，里面存储着上传的所有文件，当 input 框指定了 multiple 属性之后，就可以上传多个文件了。 也就是说，通过 files 这个属性，我们就可以获取到所有上传的文件。 file 对象File 对象中包含了文件的最后修改时间、文件名、文件类型等信息。 FileReader 对象FileReader 是一个 HTML5 新增的对象，用于读取文件（必须通过 input:file 上传） var file = input.files[0]// 创建一个fileReader对象var fr = new FileReader// 读取文件的两个方法fr.readAsText(file) 以文本的方式读取文件 ,文本文件fr.readAsDataURL(file) 以DataURL形式读取文件，图片，视频// 文件读取完成事件：fr.onload = function()&#123; // 当文件读取完成，可以通过result属性获取结果 console.log(fr.result)&#125; 案例：图片预览 // 1. FileReader 是异步的var file = document.getElementById(&#x27;file&#x27;)var box = document.getElementById(&#x27;box&#x27;)file.addEventListener(&#x27;change&#x27;, function() &#123; console.dir(this) // file 中files 属性里面存储了所有上传的文件 // 这个data就是我们上传的那个文件 var data = file.files[0] // 1. 创建一个文件读取器 var fr = new FileReader() // 2. 让文件读取器读取整个文件 fr.readAsDataURL(data) // 3. 等待文件读取完 // onload：文件读取完成后，就会触发 fr.onload = function() &#123; // 通过 fr.result 就可以获取到最终的结果 var img = document.createElement(&#x27;img&#x27;) img.src = fr.result box.innerHTML = &#x27;&#x27; box.appendChild(img) &#125;&#125;) // 2. URL.createObjectURL(file) 缺点： 1. 试验中 2. 同步（阻塞）var file = document.getElementById(&#x27;file&#x27;)file.addEventListener(&#x27;change&#x27;, function() &#123; var data = this.files[0] var result = URL.createObjectURL(data) img.src = result&#125;)","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wqdy.top/tags/html/"}]},{"title":"CSS3 基础","slug":"前端/css/css3-基础","date":"23/11/2018","updated":"23/11/2018","comments":true,"path":"1632.html","link":"","permalink":"https://wqdy.top/1632.html","excerpt":"","text":"如同人类的的进化一样，CSS3 是 CSS2 的“进化”版本，在 CSS2 基础上，增强 或 新增 了许多特性， 弥补了 CSS2 的众多不足之处，使得 Web 开发变得更为高效和便捷。 现状 PC 端浏览器支持程度差，需要添加私有前缀 移动端支持优于 PC 端 不断改进中 应用相对广泛 关于私有前缀： 在标准还未确定时，部分浏览器已经根据最初草案实现了部分功能，为了与之后确定下来的标准进行兼容，所以每种浏览器使用了自己的私有前缀与标准进行区分，当标准确立后，各大浏览器将逐步支持不带前缀的 css3 新属性 目前已有很多私有前缀可以不写了，但为了兼容老版本的浏览器，可以仍沿用私有前缀和标准方法，逐渐过渡 一般来说，CSS3 主要是为移动端而生的，因此我们在移动端没必要写太多的前缀，因为移动端的 ios 和 Android 的浏览器都是 webkit 内核 谷歌、苹果浏览器：-webkit-火狐浏览器：-moz-IE 浏览器：-ms-欧朋浏览器：-o- 一般工作中不用去加，会通过打包工具 webpack 自动添加 选择器阴影 text-shadow: 文字阴影 语法：text-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]* &lt;shadow&gt; =&gt; &lt;length&gt;&#123;2,3&#125; &amp;&amp; &lt;color&gt;?text-shadow：水平偏移 垂直偏移 羽化大小 颜色水平偏移 垂直偏移 可以为负值，羽化大小可选且不可为负可以设置多组阴影值，用逗号隔开 box-shadow: 边框阴影 语法：box-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]* &lt;shadow&gt; =&gt; inset? &amp;&amp; &lt;length&gt;&#123;2,4&#125; &amp;&amp; &lt;color&gt;?box-shadow：水平偏移 垂直偏移 羽化大小 阴影外延 颜色水平偏移、垂直偏移、阴影外延可以为负值，羽化大小、阴影外延可选，羽化大小不允许负值可以设置多组阴影值，用逗号隔开inset：设置对象的阴影类型为内阴影。该值为空时，则对象的阴影类型为外阴影 背景background-size bakground-clip background-origin 渐变线性渐变 linear-gradient() 指沿着某条直线朝一个方向产生的渐变效果 渐变实际上相当与一张图片，因为需要加给 background-image 才会生效 /* 最简单的渐变 颜色至少两个 方向默认从上到下 */background-image: linear-gradient(red, green);/* 设定渐变的方向 */background-image: linear-gradient(to right, red, green);/* 也可以设定渐变的角度 */background-image: linear-gradient(45deg, red, green);/* 设定渐变的范围 */background-image: linear-gradient(to right, red 20%, green 80%)/* 每一个区间表示渐变颜色的范围 */background-image: linear-gradient(to right, red 20%, green 20%) 径向渐变 radial-gradient 指从一个中心点开始沿着四周产生渐变效果 /* 最简单的渐变 */background-image: radial-gradient(red, green);/* 指定圆的半径和圆心 */background-image: radial-gradient(200px at center, red, green);/* 指定椭圆 */background-image: radial-gradient(200px 80px at center, red, green);/* 指定范围 */background-image: radial-gradient(200px at center, green 50%, red 50%); 盒子模型 CSS3 中可以通过 box-sizing 来指定盒模型，即可指定为 content-box、border-box，这样我们计算盒子大小的方式就发生了改变 可以分成两种情况： box-sizing: border-box 计算方式为 content &#x3D; width – border - padding box-sizing: content-box 计算方式为 content &#x3D; width calc() 函数用于动态计算长度值 注意：运算符前后都需要保留一个空格，例如：width: calc(100% - 10px) 任何长度值都可以使用 calc() 函数进行计算 calc() 函数支持 + 、-、 * 、/ 运算 calc() 函数使用标准的数学运算优先级规则 过渡 过渡的属性 如果两个状态发生改变，没有过渡，效果是瞬间变化的，如果加上了过渡，那么这个过程就会有动画的效果，整个状态变化的过程是由浏览器来完成的，我们只需要关注开始状态与结束状态即可 /* transition-property：设置过渡属性 默认值为 all 表示全部*//* 多个用逗号分隔 */transition-property: all;/* transition-duration:设置过渡时间 */transition-duration: 1s;/* transition-delay：设置过渡延时 */transition-delay: 2s;/* transition-timing-function:设置过渡的速度 *//* linear(匀速)，ease(平滑)，ease-in，ease-out，ease-in-out， steps(10)(分步动画) */transition-timing-function: linear; 注意： 过渡必须要有两个状态的变化 过渡除了可以加到初始的状态，可以加到 hover 状态，但效果不一样，如果加到 hover 状态，回来就没有过渡了 属性合写 /* 属性 时间 延时 速度 *//* 多个过渡用逗号隔开 */transition: width 1s 3s linear, border-radius 3s; 2D 转换 transform: 转换，是 CSS3 最具颠覆性的几个特性之一，既可以用于 2D 转换，也可以用于 3D 转换 transform: 2D 转换，元素在平面上实现移动、旋转、缩放、斜切等操作 scale 缩放transform: scaleX(0.5); /* 让宽度变化 */transform: scaleY(0.5); /* 让高度变化，注意不能写多个transform，不然会覆盖 */transform: scale(0.5); /* 让宽度和高度同时变化 */ 注意： scale 接收的值是倍数，因此没有单位 scale 是一个值时，宽度高度会等比例同事缩放 scale 缩放时内部内容也会缩放 可以通过 transition-origin 设定缩放原点 （可以是数值或方位词 top、left…) translate 平移transform: translateX(100px);transform: translateY(100px);transform: translate(100px, 100px);transform: translate(50%, 50%); 注意： translate 的值可以是 px，也可以是百分比，如果是百分比，那么参照的是自身的宽高 translate 移动的元素并不会影响其他盒子，类似于相对定位 rotate 旋转transform: rotate(360deg); /* 旋转360度 */transform: rotate(-360deg); /* 逆时针旋转360度 */ 注意： 单位是 deg，角度，不是 px 正值顺时针转，负值逆时针转 可以通过 transition-origin 设定旋转原点 rotate 旋转会让坐标轴也跟着旋转 skew 斜切(变形)skew 在实际开发中，是用的最少的一个属性。一般来说，x 和 y 只会倾斜其中的一个 /* 在水平方向倾斜30deg */transform: skewX(30deg);/* 在垂直方向倾斜30deg */transform: skewY(30deg); 【案例：扫光效果.html】 transform-origin 转换原点 通过 transform-origin 可以设置转换的中心原点 transform-origin: center center;transform-origin: 40px 40px; 转换合写问题 transform 属性只能写一个，如果写了多个会覆盖，属性的值可以写多个， 用空格隔开即可 transform: translateX(800px) scale(1.5) rotate(360deg); transform 属性可以连写，但是顺序对效果影响的，因为它会在第一个效果的基础上执行第二个效果，然后执行第三个效果（通常会把 rotate 放后面） 如果对 transform 进行过度效果的时候，初始状态和结束状态要一一对应 【案例：盾牌打散与合并效果.html】 3D 转换思考：2D 与 3D 的区别？ 坐标轴 用 X、Y、Z 分别表示空间的 3 个维度，三条轴互相垂直。注意+Y 是向下的 perspective 透视 电脑显示屏是一个 2D 的平面，因为我们看不出来旋转的方向，通过 perspective 属性，可以定义 3D 元素距视图的距离，单位是 px。 说白了，设置了 perspective 属性后，就有了进大远小的效果了，在视觉上，让我们能看出来 3d 的效果。 注意：当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。 perspective：500px; 对于我们眼睛来说，离我们越近的房子，我们会感觉到这个房子越大，离我们越远的房子，就会感觉越小，其实房子的大小都是一样的，只是在视觉上的一种不同。 rotate 旋转transform: rotate(45deg); /* 让元素在平面2D中旋转，相当于沿着Z轴旋转 */transform: rotateX(45deg); /* 让元素沿着X轴转45度 */transform: rotateY(45deg); /* 让元素沿着Y轴转45度 */transform: rotateZ(45deg); /* 让元素沿着Z轴转45度 */ 【3D 旋转.html】 translate 平移/* 沿着X轴的正方向移动45px */transform: translateX(45px);/* 沿着Y轴的正方向移动45px */transform: translateY(45px);/* 沿着Z轴的正方向移动45px */transform: translateZ(45px); 【3D 平移.html】 【立方体.html】 transform-styletransform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。注意这个属性只能给父元素添加 flat: 默认值，2d显示preserve-3d: 3d显示 transform-style 与 perspective 区别 透视：透视只是相当于设置了一个距离，辅助我们查看 3D 效果的工具 preserve-3d：给父盒子添加，让子元素保留 3D 的位置，说白了，只有设置了 preserve-3d，这个元素才能被称之为 3d 元素 一个 3d 元素可以没有 perspective，但是不能没有 transform-style 【3D 导航案例.html】 【切割轮播图案例】 【3D 相册案例】 过渡结束事件// 给最后一个ul添加过渡结束事件（节流阀）uls[uls.length - 1].addEventListener(&#x27;transitionend&#x27;, function() &#123; isCanAnimate = true&#125;) 动画 动画可以通过设置多个节点来精确控制一个或者一组动画，常用来实现复杂的动画效果 动画与过渡的区别： 过渡必须触发，需要两个状态的改变。动画可以一直运行下去，不需要触发。实现效果与过渡差不多 使用一个动画的基本步骤： 1.通过 @keyframes 指定动画序列2.通过百分比或者 from/to 将动画分割成多个节点3.在各个节点中分别定义样式4.通过 animation 将动画应用于相应的元素 animationanimation 是一个复合属性，一共有 8 个参数 animation-name: 动画名称，由@keyframes定义的animation-duration: 动画的持续时间 默认0sanimation-timing-function: 动画的过渡类型 ease(默认) linear stepsanimation-delay: 动画的延迟时间 默认0sanimation-iteration-count: 动画的循环次数 默认1次 infinite：无限循环animation-direction: 设置动画在循环中的方向 normal：正向(默认) reverse(反向) alternate(往复循环)animation-fill-mode: 设置动画结束时的状态 none：默认 backwards：动画结束时停留在开始状态 forwards: 动画结束时停留在结束的状态animation-play-state: 设置动画的状态。running：运动(默认) paused：暂停 动画库的使用https://daneden.github.io/animate.css/ 字体图标我们经常把网页常用的一些小的图标，做成精灵图，然后通过 background-position 去调整位置，但是这个需要引入图片，并且图片大小改变之后会失真。在 CSS3 中可以使用字体图片，即使用图标跟使用文字一样 优点： 1、将所有图标打包成字体库，减少请求 2、具有矢量性，可保证清晰度，可以修改文字的颜色或者样式 3、使用灵活，便于维护 阿里巴巴矢量图标：http://www.iconfont.cn/ Font Awesome 使用 http://fontawesome.dashgame.com/ 弹性布局(伸缩布局) 布局：其实就是调整元素在水平和垂直方向上的布局方式 CSS3 在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。 当给一个盒子设置了 display：flex 之后，这个盒子就有了 主轴 和 侧轴 的概念主轴：默认是水平方向向右，子元素在主轴上排列侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向向下 给容器设置的样式 flex-direction 用来调整主轴的方向，默认是水平方向，可选值有： row：主轴方向为水平向右（默认）column：主轴方向为竖直向下row-reverse: 主轴方向为水平向左column-reverse: 主轴方向是竖直向上 justify-content 用来设置子元素在 主轴方向的对齐方式 ，可选的值有： flex-start: 弹性盒子元素将向起始位置对齐flex-end: 弹性盒子元素将向结束位置对齐center: 弹性盒子元素将向行中间位置对齐space-between: 第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的space-around: 弹性盒子元素会平均地分布在行里（不会贴边） align-items 用于调整 侧轴的对其方式 ，可选的值有： flex-start：元素在侧轴的起始位置对其flex-end：元素在侧轴的结束位置对其center：元素在侧轴上居中对其stretch：元素的高度会被拉伸到最大（不能给死高度） flex-wrap 控制 flex 容器是单行或者多行，默认不换行 nowrap：不换行（默认），会压缩子盒子的宽度wrap：当宽度不够的时候，会换行 align-content 用来设置多行时侧轴的排列方式 flex-start：各行向侧轴的起始位置堆叠flex-end：各行向弹性盒容器的结束位置堆叠center：各行向弹性盒容器的中间位置堆叠space-between：第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布space-around：各行在侧轴中平均分布stretch：拉伸，不设置高度的情况下 align-items 与 align-content 的区别 align-items调整的是侧轴的对其方式，不换行一般用align-itemsalign-content: 必须是多行才生效，如果单行，没有效果。换行了就用 align-content; !&gt; 上述属性都是给父盒子设置的，这些样式影响的是所有的子元素，接下来的几个属性是给子盒子设置的，用来单独设置子元素的样式 给子元素设置的样式 flex 用来设置子盒子如何分配主轴剩余空间 flex: 1; order 定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 order: 1; align-self align-self 用于设置当前元素在侧轴的位置，是给子元素设置，优先级比 align-items 的优先级高 取值与 align-items 的取值一样 阮一峰的博客http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 【案例：6 面神骰】 【案例：携程网】 【案例：360 浏览器】 other微调元素 margin-top: - ; transform: translateY(); position: relative; top: - ;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wqdy.top/tags/css/"}]},{"title":"编码规范及配置 ESLint","slug":"其他/编码规范及配置-eslint","date":"15/11/2018","updated":"15/11/2018","comments":true,"path":"416.html","link":"","permalink":"https://wqdy.top/416.html","excerpt":"","text":"编码规范 Airbnb JavaScript Style Guide Google JavaScript Style Guide JavaScript Standard Style Guide ESLint JavaScript 语句后应该加分号么？ Vue + ESLint + Prettier[vue 官方风格指南(https://cn.vuejs.org/v2/style-guide/)] 安装 nodehttps://nodejs.org/zh-cn/ 配置 ESlint$ npm install eslint -g$ npm install eslint-plugin-html -g$ eslint -v$ eslint --init# google 标准# $ npm install eslint-config-google -g# airbnb 标准# $ npm install eslint-config-airbnb eslint-plugin-jsx-a11y eslint-plugin-import eslint-plugin-react -g# standard 标准$ npm install eslint-plugin-standard eslint-config-standard eslint-plugin-node eslint-plugin-promise -g# vue$ npm install eslint-plugin-vue -g# es6 语法支持$ npm install babel-eslint vue-eslint-parser -g .eslintrc.json 文件 &#123; // plugin与extend的区别：extend提供的是eslint现有规则的一系列预设 // 而plugin则提供了除预设之外的自定义规则，当你在eslint的规则里找不到合适的的时候 &quot;extends&quot;: [&quot;google&quot;, &quot;plugin: vue/essential&quot;], &quot;plugins&quot;: [&quot;html&quot;], &quot;parserOptions&quot;: &#123; &quot;sourceType&quot;: &quot;module&quot; &#125;, &quot;rules&quot;: &#123; &quot;valid-jsdoc&quot;: 2, &quot;require-jsdoc&quot;: 0, &quot;no-var&quot;: 0, &quot;vars-on-top&quot;: 0, &quot;eqeqeq&quot;: 2, &quot;space-before-function-paren&quot;: [2, &quot;always&quot;], &quot;semi&quot;: [2, &quot;never&quot;], &quot;comma-dangle&quot;: [2, &quot;never&quot;], &quot;linebreak-style&quot;: [2, &quot;unix&quot;], &quot;no-invalid-this&quot;: 0, &quot;max-len&quot;: 0, &quot;prefer-const&quot;: 0, &quot;arrow-parens&quot;: 0 &#125;&#125;&#123; &quot;extends&quot;: [&quot;standard&quot;, &quot;plugin:vue/essential&quot;], // &quot;extends&quot;: [&quot;standard&quot;, &quot;plugin:vue/recommended&quot;], &quot;plugins&quot;: [&quot;html&quot;], &quot;parser&quot;: &quot;vue-eslint-parser&quot;, &quot;parserOptions&quot;: &#123; &quot;parser&quot;: &quot;babel-eslint&quot;, &quot;ecmaVersion&quot;: 6, &quot;sourceType&quot;: &quot;module&quot; &#125;, &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;node&quot;: true &#125;, &quot;rules&quot;: &#123; &quot;no-new&quot;: 0, &quot;no-undef&quot;: 0, &quot;no-unused-vars&quot;: 1, &quot;space-before-function-paren&quot;: [2, &quot;always&quot;], &quot;eqeqeq&quot;: 0, &quot;handle-callback-err&quot;: 0, &quot;no-useless-escape&quot;: 0, &quot;new-cap&quot;: 0, &quot;vue/name-property-casing&quot;: 0 // vue &#125;&#125; vscode 插件安装 ESLint vscode 配置 User Settings &#123; &quot;javascript.validate.enable&quot;: false, &quot;typescript.validate.enable&quot;: false, &quot;eslint.nodePath&quot;: &quot;C:\\\\Program Files\\\\nodejs\\\\node.exe&quot;, &quot;eslint.options&quot;: &#123; &quot;configFile&quot;: &quot;C:/Users/C/.vscode/.eslintrc.json&quot; &#125;, &quot;eslint.alwaysShowStatus&quot;: true, &quot;eslint.autoFixOnSave&quot;: true, &quot;eslint.validate&quot;: [&quot;javascript&quot;, &quot;javascriptreact&quot;, &#123; &quot;language&quot;: &quot;html&quot;, &quot;autoFix&quot;: true &#125;, &#123; &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true &#125;]&#125; 配置 prettier$ npm install prettier -g$ npm install eslint-plugin-prettier -g vscode 插件安装 prettier vscode 配置 User Settings &#123; // 禁用默认html格式化 &quot;html.format.enable&quot;: false, &quot;prettier.semi&quot;: false, &quot;prettier.singleQuote&quot;: true, &quot;prettier.jsxSingleQuote&quot;: true, &quot;prettier.eslintIntegration&quot;: true, &quot;prettier.htmlWhitespaceSensitivity&quot;: &quot;ignore&quot;, // 标签换行长度 &quot;prettier.printWidth&quot;: 800, &quot;prettier.bracketSpacing&quot;: true&#125; vuter &#123; &quot;vetur.format.defaultFormatter.js&quot;: &quot;none&quot;, // HTML Default Formatter &quot;vetur.format.defaultFormatter.html&quot;: &quot;prettyhtml&quot; &quot;vetur.format.defaultFormatterOptions&quot;: &#123; &quot;prettyhtml&quot;: &#123; &quot;printWidth&quot;: 1000, &quot;singleQuote&quot;: false, &quot;wrapAttributes&quot;: false, &quot;sortAttributes&quot;: false &#125; &#125;&#125; 配置 eslint 校验 typescriptnpm install eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-config-alloy -g https://github.com/AlloyTeam/eslint-config-alloy/ &#123; &quot;extends&quot;: [&quot;standard&quot;, &quot;alloy&quot;, &quot;alloy/typescript&quot;, &quot;plugin:vue/essential&quot;], &quot;plugins&quot;: [&quot;html&quot;, &quot;typescript&quot;], // &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;, &quot;parserOptions&quot;: &#123; &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;, // &quot;parser&quot;: &quot;babel-eslint&quot;, &quot;ecmaVersion&quot;: 6, &quot;sourceType&quot;: &quot;module&quot; &#125;, &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;node&quot;: true, &quot;commonjs&quot;: true &#125;, &quot;rules&quot;: &#123; &quot;no-new&quot;: 0, &quot;no-undef&quot;: 0, &quot;no-unused-vars&quot;: 1, &quot;no-var&quot;: [0, &quot;always&quot;], &quot;space-before-function-paren&quot;: [2, &quot;always&quot;], &quot;typescript/class-name-casing&quot;: 2 &#125;&#125; ESLint 规则列表.eslintrc.json 规则值： &quot;off&quot;或者0 // 关闭规则关闭&quot;warn&quot;或者1 // 在打开的规则作为警告（不影响退出代码）&quot;error&quot;或者2 // 把规则作为一个错误（退出代码触发时为1 忽略检测警告 // 忽略检测下一行/* eslint-disable-next-line */// 忽略当前整个文件/* eslint-disable */// 忽略 no-new 规则/* eslint-disable no-new */ 规则列表 https://eslint.org/docs/rules/ &quot;rules&quot;: &#123; &quot;no-alert&quot;: 0,//禁止使用alert confirm prompt &quot;no-array-constructor&quot;: 2,//禁止使用数组构造器 &quot;no-bitwise&quot;: 0,//禁止使用按位运算符 &quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee &quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名 &quot;no-class-assign&quot;: 2,//禁止给类赋值 &quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句 &quot;no-console&quot;: 2,//禁止使用console &quot;no-const-assign&quot;: 2,//禁止修改const声明的变量 &quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1) &quot;no-continue&quot;: 0,//禁止使用continue &quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符 &quot;no-debugger&quot;: 2,//禁止使用debugger &quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符 &quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/ &quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125; &quot;no-dupe-args&quot;: 2,//函数参数不能重复 &quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复 &quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句 &quot;no-empty&quot;: 2,//块语句中的内容不能为空 &quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空 &quot;no-empty-label&quot;: 2,//禁止使用空label &quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符 &quot;no-eval&quot;: 1,//禁止使用eval &quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值 &quot;no-extend-native&quot;: 2,//禁止扩展native对象 &quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定 &quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换 &quot;no-extra-parens&quot;: 2,//禁止非必要的括号 &quot;no-extra-semi&quot;: 2,//禁止多余的冒号 &quot;no-fallthrough&quot;: 1,//禁止switch穿透 &quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3. &quot;no-func-assign&quot;: 2,//禁止重复的函数声明 &quot;no-implicit-coercion&quot;: 1,//禁止隐式转换 &quot;no-implied-eval&quot;: 2,//禁止使用隐式eval &quot;no-inline-comments&quot;: 0,//禁止行内备注 &quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数） &quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式 &quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量 &quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格 &quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性 &quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同 &quot;no-labels&quot;: 2,//禁止标签声明 &quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块 &quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句 &quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以） &quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型 &quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格 &quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格 &quot;no-multi-spaces&quot;: 1,//不能用多余的空格 &quot;no-multi-str&quot;: 2,//字符串不能用\\换行 &quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行 &quot;no-native-reassign&quot;: 2,//不能重写native对象 &quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有! &quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算 &quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值 &quot;no-new-func&quot;: 1,//禁止使用new Function &quot;no-new-object&quot;: 2,//禁止使用new Object() &quot;no-new-require&quot;: 2,//禁止使用new require &quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number &quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON() &quot;no-octal&quot;: 2,//禁止使用八进制数字 &quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列 &quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值 &quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接 &quot;no-plusplus&quot;: 0,//禁止使用++，-- &quot;no-process-env&quot;: 0,//禁止使用process.env &quot;no-process-exit&quot;: 0,//禁止使用process.exit() &quot;no-proto&quot;: 2,//禁止使用__proto__属性 &quot;no-redeclare&quot;: 2,//禁止重复声明变量 &quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/ &quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错 &quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式 &quot;no-script-url&quot;: 0,//禁止使用javascript:void(0) &quot;no-self-compare&quot;: 2,//不能比较自身 &quot;no-sequences&quot;: 0,//禁止使用逗号运算符 &quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 &quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用 &quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格 &quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2] &quot;no-sync&quot;: 0,//nodejs 禁止同步方法 &quot;no-ternary&quot;: 0,//禁止使用三目运算符 &quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格 &quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super &quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;; &quot;no-undef&quot;: 1,//不能有未定义的变量 &quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined &quot;no-undefined&quot;: 2,//不能使用undefined &quot;no-unexpected-multiline&quot;: 2,//避免多行表达式 &quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾 &quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false; &quot;no-unreachable&quot;: 2,//不能有无法执行的代码 &quot;no-unused-expressions&quot;: 2,//禁止无用的表达式 &quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数 &quot;no-use-before-define&quot;: 2,//未定义前不能使用 &quot;no-useless-call&quot;: 2,//禁止不必要的call和apply &quot;no-void&quot;: 2,//禁用void操作符 &quot;no-var&quot;: 0,//禁用var，用let和const代替 &quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注 &quot;no-with&quot;: 2,//禁用with &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格 &quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来 &quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号 &quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter &quot;block-scoped-var&quot;: 0,//块语句中使用var &quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格 &quot;callback-return&quot;: 1,//避免多次调用回调什么的 &quot;camelcase&quot;: 2,//强制驼峰法命名 &quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号 &quot;comma-spacing&quot;: 0,//逗号前后的空格 &quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾 &quot;complexity&quot;: [0, 11],//循环复杂度 &quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的 &quot;consistent-return&quot;: 0,//return 后面是否允许省略 &quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名 &quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super &quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125; &quot;default-case&quot;: 2,//switch语句最后必须有default &quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾 &quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号 &quot;eol-last&quot;: 0,//文件以单一的换行符结束 &quot;eqeqeq&quot;: 2,//必须使用全等 &quot;func-names&quot;: 0,//函数表达式必须有名字 &quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式 &quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格 &quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤 &quot;handle-callback-err&quot;: 0,//nodejs 处理错误 &quot;id-length&quot;: 0,//变量名长度 &quot;indent&quot;: [2, 4],//缩进风格 &quot;init-declarations&quot;: 0,//声明时必须赋初值 &quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格 &quot;lines-around-comment&quot;: 0,//行前/行后备注 &quot;max-depth&quot;: [0, 4],//嵌套块深度 &quot;max-len&quot;: [0, 80, 4],//字符串最大长度 &quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度 &quot;max-params&quot;: [0, 3],//函数最多只能有3个参数 &quot;max-statements&quot;: [0, 10],//函数内最多有几个声明 &quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 &quot;new-parens&quot;: 2,//new时必须加小括号 &quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行 &quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格 &quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法 &quot;one-var&quot;: 1,//连续声明 &quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的 &quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首 &quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行 &quot;prefer-const&quot;: 0,//首选const &quot;prefer-spread&quot;: 0,//首选展开运算 &quot;prefer-reflect&quot;: 0,//首选Reflect的方法 &quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &#x27;&#x27; &quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号 &quot;radix&quot;: 2,//parseInt必须指定第二个参数 &quot;id-match&quot;: 0,//命名检测 &quot;require-yield&quot;: 0,//生成器函数必须有yield &quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾 &quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格 &quot;sort-vars&quot;: 0,//变量声明时排序 &quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格 &quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格 &quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格 &quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格 &quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格 &quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格 &quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格 &quot;spaced-comment&quot;: 0,//注释风格要不要有空格什么的 &quot;strict&quot;: 2,//使用严格模式 &quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN() &quot;valid-jsdoc&quot;: 0,//jsdoc规则 &quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值 &quot;vars-on-top&quot;: 2,//var必须放在作用域顶部 &quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格 &quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来 &quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"eslint","slug":"eslint","permalink":"https://wqdy.top/tags/eslint/"}]},{"title":"总结 —— 遍历","slug":"前端/js/总结 —— 遍历","date":"04/11/2018","updated":"20/02/2022","comments":true,"path":"396.html","link":"","permalink":"https://wqdy.top/396.html","excerpt":"","text":"原生 js 中 for 语句可使用 continue 跳出当前循环， break 跳出整个循环 如果 for 语句在函数中，使用 return 可以结束 for 循环，同时也会结束函数后续代码的执行 for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i])&#125; 原生 js 中数组的 forEach 方法遍历数组 不能用 break continue 语句跳出整个循环不支持 return 操作输出，return 只用于跳出当前循环 arr.forEach(function(item, index, arr) &#123; console.log(item) console.log(this)&#125;)// 返回值: undefined 原生 js 中 for…in 语句遍历对象 支持 break, continue 跳出循环 会枚举原型链中的属性 for (var key in obj) &#123; console.log(key) // 键 console.log(obj[key]) // 值&#125; 如果使用 for in 遍历数组，会产生一些问题 var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]a.name = &#x27;d&#x27;for (var index in arr) &#123; console.log(index) // &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;name&#x27;&#125; 数组的索引值 index 是 String 类型 会将 expando 属性也遍历出来 在某些情况下，在遍历数组元素时顺序是任意的 es6 for…of 方法遍历类数组集合(Array, Map, Set, String, Arguments) 支持 break, continue 和 throw let arr = [1, 2, 3, 4]for (const item of arr) &#123; console.log(item)&#125; for…of 与 for…in 的区别参考 MDN 无论是 for…in 还是 for…of 语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。 for…in 语句以任意顺序迭代对象的可枚举属性。 for…of 语句遍历可迭代对象定义要迭代的数据。 jquery 中的 each 方法遍历 jQuery 对象集合，为每个匹配的元素执行一个函数 $(selector).each(function(index, element) &#123; // index 表示当前元素在所有匹配元素中的索引号 // element 表示当前元素 dom 对象 // this 在函数内部，this指向了element&#125;)$(&#x27;li&#x27;).each(function(index, ele) &#123; // $(ele).css(&quot;backgroundColor&quot;, arr[index]) $(this).css(&#x27;backgroundColor&#x27;, arr[index])&#125;) php 中 foreach 语句用来遍历数组(关联数组和索引数组均可)。 foreach($arr as $key =&gt; $value) &#123; // $arr: 要遍历的数组 // $key: 键，可以是任意变量名 // $value: 值，可以是任意变量名&#125;foreach($arr as $value) &#123;&#125; // 遍历关联数组$arr = array( &quot;name&quot;=&gt;&quot;zs&quot;, &quot;age&quot;=&gt;18, &quot;sex&quot;=&gt;20);foreach($arr as $k =&gt; $v) &#123; echo $k . &quot;=&quot; . $v . &quot;&lt;br&gt;&quot;;&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"},{"name":"遍历","slug":"遍历","permalink":"https://wqdy.top/tags/%E9%81%8D%E5%8E%86/"}]},{"title":"ajax 笔记","slug":"前端/js/js-ajax-笔记","date":"03/11/2018","updated":"03/11/2018","comments":true,"path":"1646.html","link":"","permalink":"https://wqdy.top/1646.html","excerpt":"","text":"前言我们使用 php 动态渲染页面时，有很多比较麻烦的地方。 在前端写好页面以后，需要后台进行修改，意味这后端程序员也需要懂前端的知识，其实渲染的工作应该交给前端来做。 前端没有写好页面的话，后端无法开始工作，需要等待前端的页面完成之后才能开始工作，拖延项目的进度。 这种渲染，属于同步渲染，先获取数据, 如果数据获取的慢了, 会严重影响整个页面渲染速度, 且数据更新需要页面刷新 AJAX 即 Asynchronous [e’sɪŋkrənəs] Javascript And XML， AJAX 不是一门新的语言，而是对现有技术的综合利用。 本质是在 HTTP 协议的基础上以异步的方式与服务器进行通信 同步与异步同步和异步概念： 同步：指的就是事情要一件一件做。等做完前一件才能做后一件任务 异步：不受当前任务的影响，两件事情同时进行，做一件事情时，不影响另一件事情的进行 编程中：异步程序代码执行时不会阻塞其它程序代码执行，从而提升整体执行效率 网页异步应用： 验证你的用户名是否已经存在（一边输入，一边获取你的信息，和后台比对）。 百度搜索提示，及相关内容展示（一边输入，一边找出了你可能要的内容）。 新浪微博评论（异步加载）。 XMLHttpRequest 可以以异步方式的请求数据处理程序, 可实现对网页的部分更新， 而不是刷新整个页面 XMLHttpRequest 对象 浏览器内建对象，用于与服务器通信(交换数据) ， 由此我们便可实现对网页的部分更新，而不是刷新整个页面。这个请求是异步的，即在往服务器发送请求时，并不会阻碍程序的运行，浏览器会继续渲染后续的结构。 发送 get 请求XMLHttpRequest 以异步的方式发送 HTTP 请求，因此在发送请求时，一样需要遵循 HTTP 协议。 使用 XMLHttpRequest 发送 get 请求的步骤 // 1. 创建一个 XMLHttpRequest 对象var xhr = new XMLHttpRequest()// 2. 设置请求行// 第一个参数:请求方式 get/post// 第二个参数:请求的地址 需要在url后面拼上参数列表// 第三个参数：true 为异步，false为同步，默认为true，设为false没有意义xhr.open(&#x27;get&#x27;, &#x27;01.php?name=zs&#x27;)// 3. 设置请求头(get不用设置)// 请求头中可以设置 Content-Type,用以说明请求主体的内容是如何编码// get 请求时没有请求体,无需设置请求头// 4. 设置请求体// get 请求的请求体为空,因为参数列表拼接到 url 后面了xhr.send(null) // 参数为 null 或什么都不写 注意点 : get 请求，设置请求行时，需要把参数列表拼接到 url 后面 get 请求不用设置请求头，不用说明请求主体的编码方式 get 请求的请求体为 null 发送 post 请求// 1. 创建一个 XMLHttpRequest 对象var xhr = new XMLHttpRequest()// 2. 设置请求行 post请求的参数列表在请求体xhr.open(&#x27;post&#x27;, &#x27;02.php&#x27;)// 3. 设置请求头, post 请求必须要设置 content-type, 标记请求体内容的解析方式// 如果不设置请求头,请求能够发送出去，但是后端无法解析获取数据xhr.setRequestHeader(&#x27;content-type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;)// 4. 设置请求体xhr.send(&#x27;name=Jepson&amp;age=18&#x27;) 注意点 : post 请求，设置请求行时，不拼接参数列表 post 必须设置请求头中的 content-type 为 application/x-www-form-urlencoded， 标记请求体解析方式 post 请求需要将参数列表设置到请求体中 获取响应 readyStatereadyState：记录了 XMLHttpRequest 对象的当前状态 readyState 有五种可能的值： xhr.readyState &#x3D; 0 时，UNSENT open 尚未调用 xhr.readyState &#x3D; 1 时，OPENED open 已调用 xhr.readyState &#x3D; 2 时，HEADERS_RECEIVED 接收到头信息 xhr.readyState &#x3D; 3 时，LOADING 接收到响应主体 xhr.readyState = 4 时，DONE 响应完成 HTTP 响应分为 3 个部分，状态行、响应头、响应体。 // 给xhr注册一个 onreadystatechange 事件，当 xhr 的状态发生状态发生改变时，会触发这个事件。// onreadystatechange 只会监听 2， 3， 4 的状态变化xhr.onreadystatechange = function() &#123; console.log(xhr.readyState) if (xhr.readyState == 4) &#123; //1. 获取状态行 console.log(&#x27;状态行:&#x27; + xhr.status) // 成功返回 200 if (xhr.status == 200) &#123; //2. 获取响应头 console.log(&#x27;所有的响应头:&#x27; + xhr.getAllResponseHeaders()) console.log(&#x27;指定响应头:&#x27; + xhr.getResponseHeader(&#x27;content-type&#x27;)) //3. 获取响应体 console.log(xhr.responseText) &#125; &#125;&#125; 案例【判断用户名是否存在】 【用户登录案例】 【聊天机器人案例】 数据交互 浏览器端只是负责用户的交互和数据的收集以及展示，真正的数据都是存储在服务器端的。 我们现在通过 ajax 的确可以返回一些简单的数据（一个字符串），但是在实际开发过程中，肯定会会设计到大量的复杂类型的数据传输，比如数组、对象等，但是每个编程语言的语法都不一样。 因此我们会采用通过的数据交换格式（ XML 、JSON ）来进行数据的交互。 XML(了解即可)什么是 XML XML 指可扩展标记语言（EXtensible Markup Language） XML 是一种标记语言，很类似 HTML XML 的设计宗旨是传输数据，而非显示数据 XML 标签没有被预定义。您需要自行定义标签。 语法规范 第一行必须是版本信息 必须有一个根元素（有且仅有一个） 标签不可有空格、不可以数字或 . 开头、大小写敏感 不可交叉嵌套，都是双标签，如果是单标签，必须闭合 属性双引号（浏览器自动修正成双引号了） 特殊符号要使用实体 注释和 HTML 一样 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;students&gt; &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;desc&gt;路人甲&lt;/desc&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;desc&gt;路人乙&lt;/desc&gt; &lt;/student&gt;&lt;/students&gt; php 获取 xml 文件的内容 // 注意: 如果需要返回 xml 数据, 需要将 content-type 改成 text/xml, 不然浏览器以 text/html 解析header( &#x27;content-type:text/xml;charset=utf-8&#x27; );// file_get_content 用于获取文件的内容// 参数: 文件的路径$result = file_get_content( &quot;data.xml&quot; );echo $result; js 解析 xml // 获取服务端返回的 xml 数据，需要使用 xhr.responseXML，这是一个 document 对象，可以使用 DOM 中的方法查找元素。var data = xhr.responseXML// 获取所有的学生var students = data.querySelectorAll(&#x27;student&#x27;) 缺点：虽然可以描述和传输复杂数据，但是其解析过于复杂, 并且体积较大，所以实现开发已经很少使用了 JSON 数据JSON (JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript 规范，采用独立于编程语言的文本格式来存储和表示数据 数据在键值对中 数据由逗号分隔(最后一个 键值对不能带逗号) 花括号保存对象，方括号保存数组 键和值使用双引号 var obj = &#123; a: &#x27;Hello&#x27;, b: &#x27;World&#x27; &#125; // 这是一个对象// 这是一个 JSON 字符串，本质是一个字符串var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27; JSON 数据在不同语言进行传输时，类型为字符串，不同的语言各自也都对应有解析方法，解析完成后就能很方便的使用了 php 处理 json php 关联数组 &#x3D;&#x3D;&gt; json ( json_encode ) // php的关联数组$obj = array( &quot;a&quot; =&gt; &quot;hello&quot;, &quot;b&quot; =&gt; &quot;world&quot;, &quot;name&quot; =&gt; &quot;鹏鹏&quot;);// json字符串$json = json_encode( $obj );echo $json; json &#x3D;&#x3D;&gt; php 对象&#x2F;关联数组 ( json_decode ) $json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;; // json字符串// 第一个参数：json字符串// 第二个参数：// false，将json转换成对象(默认)// true：将json转换成数组(推荐)$obj = json_decode($json,true);echo $obj[&#x27;a&#x27;];// 通过json文件获取到的内容就是一个json字符串。$data = file_get_contents(&quot;data.json&quot;);// 将json转换成数组$result = json_decode($data, true);print_r($result); JS 处理 json JSON.stringify(obj) ：JS 对象 &#x3D;&#x3D;&gt; JSON 字符串 var obj = &#123; a: &#x27;Hello&#x27;, b: &#x27;World&#x27; &#125;var result = JSON.stringify(obj) // &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27; JSON.parse(obj) ：JSON 字符串 &#x3D;&#x3D;&gt; JS 对象 var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;var obj = JSON.parse(json) // &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125; 【案例：获取表格数据.html】 兼容性处理 (了解, 不用处理)现在一般最多兼容到 IE8, 这里以后见到了知道是在处理兼容性就行了 var xhr = nullif (XMLHttpRequest) &#123; //现代浏览器 IE7+ xhr = new XMLHttpRequest()&#125; else &#123; //老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象： xmlHttp = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;)&#125; 封装 ajax 工具函数 每次发送 ajax 请求，其实步骤都是一样的，重复了大量代码，我们完全可以封装成一个工具函数 //1. 创建xhr对象//2. 设置请求行//3. 设置请求头//3. 设置请求体//4. 监听响应状态//5. 获取响应内容 参数提取 参数名 参数类型 描述 传值 默认值 type string 请求方式 get&#x2F;post 只要不传 post，就是 get url string 请求地址 接口地址 如果不传地址，不发送请求 async boolean 是否异步 true&#x2F;fase 只要不传 false，那就是 true，异步请求 data object 请求数据 &#123;key:value,key1:value2&#125; 需要把这个对象拼接成参数的格式 uname&#x3D;hucc&amp;upass&#x3D;12345 dataType string 返回的数据类型 xml&#x2F;json&#x2F;text text success function 响应成功时调用 - - error function 响应失败时调用 - - 参数检测// 要求参数obj必须传递，否则直接不发送请求if (!obj || typeof obj !== &#x27;object&#x27;) &#123; return&#125;// 如果type传递的是post，那就发送post请求，否则发送get请求var type = obj.type == &#x27;post&#x27; ? &#x27;post&#x27; : &#x27;get&#x27;var url = obj.urlif (!url) &#123; return&#125;// 只有当async传递了false，才会发送同步请求，不然只发送异步请求var async = obj.async == false ? false : true 完整版本var $ = &#123; ajax: function(options) &#123; // 如果options参数没有传递，直接返回。 if (!options || typeof options !== &#x27;object&#x27;) &#123; return &#125; // 处理默认参数 // 如果参数不是post，那就默认为get var type = options.type === &#x27;post&#x27; ? &#x27;post&#x27; : &#x27;get&#x27; // 如果没有传url，直接返回 var url = option.url if (!url) &#123; return &#125; // 如果参数不是 false，那就默认是 true，发异步请求 var async = options.async == false ? false : true // 把 option.data 对象中的数据拼接成键值对的字符串 var data = this.getData(options.data) var xhr = new XMLHttpRequest() // 设置请求行 // 如果是get请求，并且要上传参数，需要把参数拼接到url后面 if (type === &#x27;get&#x27;) &#123; url += &#x27;?&#x27; + data data = null &#125; xhr.open(type, url, async) // 设置请求头 if (type === &#x27;post&#x27;) &#123; xhr.setRequestHeader(&#x27;content-type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;) &#125; // 设置请求参数 xhr.send(data) xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; //判断一下,如果dataType的值是json,就转成js对象.如果是xml,就返回dom对象,其他都是普通文本 if (options.dateType === &#x27;json&#x27;) &#123; var result = JSON.parse(xhr.responseText) &#125; else if (option.dataType === &#x27;xml&#x27;) &#123; var result = xhr.responseXML &#125; else &#123; var result = xhr.responseText &#125; /*执行成功函数*/ options.success &amp;&amp; options.success(result) &#125; else &#123; options.error &amp;&amp; options.error() &#125; &#125; &#125; &#125;, getData: function(obj) &#123; // 将obj对象转换成参数 // 将对象转换成参数列表 if (!obj || typeof obj !== &#x27;object&#x27;) &#123; return null &#125; var arr = [] for (var k in obj) &#123; arr.push(k + &#x27;=&#x27; + obj[k]) &#125; return arr.join(&#x27;&amp;&#x27;) &#125;&#125; 【登录案例】 jQuery 中的 ajax 方法 jQuery 为我们提供了更强大的 Ajax 封装 $.ajax参数列表 参数名称 描述 取值 示例 url 接口地址 url:”02.php” type 请求方式 get&#x2F;post type:”get” timeout 超时时间 单位毫秒 timeout:5000 dataType 服务器返回的格式 json&#x2F;xml&#x2F;text(默认) dataType:”json” data 发送的请求数据 对象 data:{name:”zs”, age:18} beforeSend 调用前的回调函数 function(){} beforeSend:function(){ alert(1) } success 成功的回调函数 function (data) {} success:function (data) {} error 失败的回调函数 function (error) {} error:function(data) {} complete 完成后的回调函数 function () {} complete:function () {} 使用示例： $.ajax(&#123; type: &#x27;get&#x27;, // 请求类型 url: &#x27;02.php&#x27;, // 请求地址 data: &#123; name: &#x27;zs&#x27;, age: 18 &#125;, // 请求数据 dataType: &#x27;json&#x27;, // 希望接受的数据类型 timeout: 5000, // 设置超时时间 beforeSend: function() &#123; // alert(&quot;发送前调用&quot;); // jq的ajax方法中beforeSend函数中如果执行了return false,那么请求就不发送了 &#125;, success: function(res) &#123; // 如果有 dataType:&quot;json&quot;，或后台有header(content-type: text/json)，res就是已经转换好的js对象 // alert(&quot;成功时调用&quot;); console.log(data) &#125;, error: function(error) &#123; // alert(&quot;失败时调用&quot;); console.log(error) &#125;, complete: function() &#123; // alert(&quot;请求完成时调用&quot;); // 不管成功失败都会执行 &#125;&#125;) 【案例：登录案例.html】 接口化开发请求地址即所谓的接口，通常我们所说的接口化开发，其实是指一个接口对应一个功能， 并且严格约束了请求参数 和响应结果 的格式，这样前后端在开发过程中，可以减少不必要的讨论， 从而并行开发，可以极大的提升开发效率，另外一个好处，当网站进行改版后，服务端接口进行调整时，并不影响到前端的功能。 获取短信验证码【案例：register】 需求文档(产品) 总需求：点击获取验证码按钮，向服务端发送请求, 调用服务器端短信接口, 服务器端根据传参, 调用第三方短信接口, 给手机发送验证码需求1：格式校验(1) 手机号码不能为空 如果为空提示&quot;手机号不能为空&quot;(2) 手机号码格式必须正确, 提示&quot;请输入正确的手机号码&quot;需求2：点击发送时，按钮显示为&quot;发送中&quot;,并且不能重复提交请求需求3：根据不同的响应结果，进行响应。(1)如果接口调用成功 如果响应代码为100，倒计时 如果响应代码为101，提示手机号重复(2)如果接口调用失败，告诉用户&quot;服务器繁忙，请稍候再试&quot; 接口文档 接口说明：获取短信验证码接口地址：getCode.php请求方式：get接口传参：mobile 手机号返回类型 json接口返回：&#123; &quot;code&quot;:&quot;101&quot;, &quot;msg&quot;:&quot;手机号码存在&quot;, &quot;mobile&quot;:&quot;18511249258&quot; &#125;参数说明: code 当前业务逻辑的处理成功失败的标识 100:成功 101:手机号码存在 msg 当前系统返回给前端提示 mobile 当前的手机号码 注册接口【案例：register】 表单序列化 serialize jquery 提供了一个serialize()方法序列化表单，说白就是将表单中带有 name 属性的所有参数拼成一个格式为name=value&amp;name1=value1这样的字符串。方便我们获取表单的数据。 // serialize 方法将表单参数序列化成一个字符串。必须指定 name 属性// name=pp&amp;pass=123456&amp;repass=123456&amp;mobile=15751776629&amp;code=1234$(&#x27;form&#x27;).serialize() jquery 的 ajax 方法，data 参数能够直接识别表单序列化的数据 $.post(&#123; url: &#x27;register.php&#x27;, data: $(&#x27;form&#x27;).serialize(), dataType: &#x27;json&#x27;, success: function(info) &#123; console.log(info) &#125;&#125;) 需求文档 注册功能总需求：点击注册按钮，向服务端发送请求需求1:表单校验 1.1 用户名不能为空，否则提示&quot;请输入用户名&quot; 1.2 密码不能为空，否则提示&quot;请输入密码&quot; 1.3 确认密码必须与密码一直，否则提示&quot;确认密码与密码不一致&quot; 1.4 手机号码不能为空，否则提示&quot;请输入手机号码&quot;; 1.5 手机号码格式必须正确，否则提示&quot;手机号格式错误&quot; 1.6 短信验证码必须是4位的数字，否则提示&quot;验证码格式错误&quot;需求2：点击注册按钮时，按钮显示为&quot;注册中...&quot;,并且不能重复提交请求需求3：根据不同响应结果，处理响应 3.1 接口调用成功 100 提示用户注册成功，3s后跳转到首页 101 提示用户&quot;用户名已经存在&quot; 102 提示用户&quot;验证码错误&quot; 3.2 接口调用失败，提示&quot;服务器繁忙，请稍后再试&quot;,恢复按钮的值 接口文档 接口说明：注册接口地址：register.php请求方式：post接口传参：name:用户名 pass:密码 code:验证码 mobile:手机号返回类型 json接口返回：&#123; &quot;code&quot;:&quot;100&quot;, &quot;msg&quot;:&quot;注册成功&quot;, &quot;name&quot;:&quot;Jepson&quot; &#125;参数说明: code 当前业务逻辑的处理成功失败的标识 100:成功 101:用户存在 102:验证码错误 msg 当前系统返回给前端提示 name: 注册的用户名 模板引擎 是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的 HTML 文档。 为什么要使用模板引擎我们通过 ajax 获取到数据后，需要把数据渲染到页面，在学习模板引擎前，我们的做法是大量的拼接字符串，对于结构简单的页面，这么做还行 ，但是如果页面结构很复杂，使用拼串的话代码可阅读性非常的差，而且非常容易出错，后期代码维护也是相当的麻烦。 总结来说拼串渲染两大缺点： js 中大量充斥着 html 结构拼串代码， 很冗余，可读性差 字符串拼接很麻烦， 且维护起来也很麻烦， 容易出错 常见的模板引擎BaiduTemplate：http://tangram.baidu.com/BaiduTemplate/velocity.js：https://github.com/shepherdwind/velocity.js/ArtTemplate：https://github.com/aui/artTemplate artTemplate 是使用最广泛，效率最高的模板引擎，需要大家掌握。 artTemplategithub 地址 中文 api 地址 artTemplate 的基本使用1. 引入模板引擎的 js 文件 &lt;script src=&#x27;template-web.js&#x27;&gt;&lt;/script&gt; 2. 准备模板 &lt;!-- 指定了type为text/html后，这一段script标签并不会解析，也不会显示。--&gt;&lt;script type=&quot;text/html&quot; id=&quot;myTmp&quot;&gt; &lt;p&gt;姓名：隔壁老王&lt;/p&gt; &lt;p&gt;年龄：18&lt;/p&gt; &lt;p&gt;技能：查水表&lt;/p&gt; &lt;p&gt;描述：年轻力气壮&lt;/p&gt;&lt;/script&gt; 3. 准备数据 //3. 准备数据,数据是后台获取的，可以随时变化var json = &#123; userName: &#x27;隔壁老王&#x27;, age: 18, skill: &#x27;查水表&#x27;, desc: &#x27;年轻气壮&#x27;&#125; 4. 将模板与数据进行绑定 //第一个参数：模板的id//第二个参数：数据//返回值：根据模板生成的字符串。var html = template(&#x27;myTmp&#x27;, json)console.log(html) 5. 修改模板 &lt;script type=&quot;text/html&quot; id=&quot;myTmp&quot;&gt; &lt;p&gt;姓名：&#123;&#123;userName&#125;&#125;&lt;/p&gt; &lt;p&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/p&gt; &lt;p&gt;技能：&#123;&#123;skill&#125;&#125;&lt;/p&gt; &lt;p&gt;描述：&#123;&#123;desc&#125;&#125;&lt;/p&gt;&lt;/script&gt; 6. 将数据显示到页面 var div = document.querySelector(&#x27;div&#x27;)div.innerHTML = html artTemplate 标准语法if 语法 &#123;&#123;if gender=&#x27;男&#x27;&#125;&#125;&lt;div class=&quot;man&quot;&gt; &#123;&#123;else&#125;&#125; &lt;div class=&quot;woman&quot;&gt; &#123;&#123;/if&#125;&#125; &lt;/div&gt;&lt;/div&gt; each 语法 &lt;!-- 1. &#123;&#123;each data&#125;&#125; 可以通过$value 和 $index获取值和下标 2. &#123;&#123;each data v i&#125;&#125; 自己指定值为v，下标为i--&gt;&#123;&#123;each data v i&#125;&#125;&lt;li&gt; &lt;a href=&quot;&#123;&#123;v.url&#125;&#125;&quot;&gt; &lt;img src=&quot;&#123;&#123;v.src&#125;&#125;&quot; alt=&quot;&quot; /&gt; &lt;p&gt;&#123;&#123;v.content&#125;&#125;&lt;/p&gt; &lt;/a&gt;&lt;/li&gt;&#123;&#123;/each&#125;&#125; //如果返回的数据是个数组，必须使用对象进行包裹，因为在&#123;&#123;&#125;&#125;中只写书写对象的属性。var html = template(&#x27;navTmp&#x27;, &#123; data: info &#125;) 瀑布流案例封装 jQuery 瀑布流插件// 特点分析：// 1. 跟以前将的瀑布流不一样的是，这次的瀑布流固定版心为1200px// 2. 瀑布流固定摆放5列，每一列的宽度固定为232px。// 思路分析：// 1. 计算每一列之间的缝隙// 2. 初始化一个数组，用户存储每一列的高度 [0,0,0,0,0]// 3. 查找数组的最小列，每次都把图片定位到最小列的位置// 4. 更新数组最小列的高度（加上定位过来的图片的高度） 代码参考： $.fn.waterfall = function() &#123; var $box = $(this) var $item = $box.children() var boxWidth = $box.width() //父盒子的宽度 var itemWidth = 232 //每个盒子固定宽度为232 var columns = 5 //固定摆放5列 var gap = (boxWidth - columns * itemWidth) / (columns - 1) //缝隙的宽度 10 var arr = [0, 0, 0, 0, 0] //初始化数组 $item.each(function() &#123; //查找最小列 var min = arr[0] var minIndex = 0 for (var i = 0; i &lt; arr.length; i++) &#123; if (min &gt; arr[i]) &#123; min = arr[i] minIndex = i &#125; &#125; //设置位置 $(this).css(&#123; left: minIndex * (itemWidth + gap), top: min &#125;) //更新数组 arr[minIndex] = min + $(this).outerHeight() + gap &#125;)&#125; 瀑布流完整版// 需求分析：// 1. 页面刚开始，没有任何一张图片。因此需要从通过ajax获取图片// 2. 使用模版引擎将获取到的数据渲染到页面// 3. 因为图片路径是从服务端获取的，加载需要时间，需要等待图片加载完成后才能使用瀑布流进行布局。// 4. 给window注册scroll事件，当触底时，需要动态的加载图片。// 5. 加载时，显示加载中的提示信息，并且要求不能重复发送ajax请求// 6. 当服务端返回图片数量为0时，提示用户没有更多数据。 同源与跨域同源同源策略的基本概念 1995 年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。同源策略：最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”：协议相同、域名相同、端口相同 同源策略的目的 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 同源策略的限制范围 随着互联网的发展，“同源策略”越来越严格，目前，如果非同源，以下三种行为都将收到限制。 Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求响应被拦截 虽然这些限制是很有必要的，但是也给我们日常开发带来不好的影响。比如实际开发过程中，往往都会把服务器端架设到一台甚至是一个集群的服务器中，把客户端页面放到另外一个单独的服务器。那么这时候就会出现不同源的情况，如果我们知道两个网站都是安全的话，我们是希望两个不同源的网站之间可以相互请求数据的。这就需要使用到 跨域 。 跨域jsonp( 无兼容性问题 ) JSONP(JSON with Padding) 可用于解决主流浏览器的跨域数据访问的问题。 原理：服务端返回一个定义好的 js 函数的调用，并且将服务器的数据以该函数参数的形式传递过来，这个方法需要前后端配合 script 标签是不受同源策略的限制的，它可以载入任意地方的 JavaScript 文件。类似的还有img和link标签 jsonp 演化过程 1php 文件 header(&quot;content-type:text/html;charset=utf-8&quot;);echo &quot;alert(1111)&quot;; html 文件 &lt;script src=&quot;http://www.api.com/testjs.php&quot;&gt;&lt;/script&gt; 原理：其实 src 的路径是什么文件不重要，无论引入 js 文件还是 php 文件，最后返回给浏览器的都是字符串，因此我们 script 标签是可以引入一个 php 文件的。 jsonp 演化过程 2php 文件 header(&quot;content-type:text/html;charset=utf-8&quot;);echo &quot;var a = 118;&quot;; html 文件 &lt;script src=&quot;http://www.api.com/testjs.php&quot;&gt;&lt;/script&gt;&lt;script&gt; // a打印出来了118 console.log(a)&lt;/script&gt; 我们现在做到了一件事情，从不同源的 php 文件中获取到了数据 缺点：获取数据的 script 标签必须写在使用的 script 标签的前面，必须保证先有数据才能对数据进行渲染。 jsonp 演化过程 3php 代码 header(&quot;content-type:text/html;charset=utf-8&quot;);$arr = array( &quot;name&quot;=&gt;&quot;zs&quot;, &quot;age&quot;=&gt;18);$result = json_encode($arr);// 这是一段js函数的调用的代码，$result就是我们想要的数据echo &quot;func($result)&quot;; js 代码 &lt;script&gt; function func(data) &#123; console.log(data) &#125;&lt;/script&gt;&lt;script src=&quot;http://www.api.com/testjs.php&quot;&gt;&lt;/script&gt; 缺点：后端必须知道前端声明的方法的名字，后端才能调用。 jsonp 演化过程 4php 代码 header(&quot;content-type:text/html;charset=utf-8&quot;);$arr = array( &quot;name&quot;=&gt;&quot;zs&quot;, &quot;age&quot;=&gt;18);$result = json_encode($arr);// 这是一 段js函数的调用的代码，$result就是我们想要的数据echo $_GET[&#x27;callback&#x27;].&quot;($result)&quot;; javascript 代码 function fun(data) &#123; console.log(data)&#125;var button = document.querySelector(&#x27;button&#x27;)button.onclick = function() &#123; var script = document.createElement(&#x27;script&#x27;) script.src = &#x27;http://www.api.com/testjs.php?callback=fun&#x27; document.body.appendChild(script)&#125; jsonp 的原理就是 借助 script 标签 src 请求资源时，不受同源策略的限制 在服务端返回一个函数的调用，将数据作为当前调用函数的实参 在浏览器端，声明一个全局函数，通过形参就可以获取到服务端返回的对应的值 jquery 对于 jsonp 的封装!&gt; jsonp 仅支持 get 请求 // 使用起来相当的简单，跟普通的get请求没有任何的区别，只需要把 dataType 固定成 jsonp 即可$.ajax(&#123; type: &#x27;get&#x27;, url: &#x27;http://www.Jepson.com/testjs.php&#x27;, dataType: &#x27;jsonp&#x27;, data: &#123; uname: &#x27;zs&#x27;, upass: &#x27;123456&#x27; &#125;, success: function(info) &#123; console.log(info) &#125;&#125;) XMLHttpRequest2.0 XMLHttpRequest 是一个 javascript 内置对象，使得 Javascript 可以进行异步的 HTTP 通信。2008 年 2 月，就提出了 XMLHttpRequest Level 2 草案。 老版本的 XMLHttpRequest 的缺点： 仅支持传输文本数据，无法传输二进制文件，比如图片视频等。 传输数据时，没有进度信息，只能提示完成与否。 受到了”同源策略”的限制 新版本的功能： 可以设置 timeout 超时时间 可以使用 formData 对象管理表单数据 允许请求不同域名下的数据（跨域） 支持上传二进制文件 可以获取数据传输的进度信息 注意：我们现在使用 new XMLHttpRequest 创建的对象就是 2.0 对象了，我们之前学的是 1.0 的语法，现在学习一些 2.0 的新特性即可。 timeout 设置超时xhr.timeout = 3000 // 设置超时时间xhr.ontimeout = function() &#123; alert(&#x27;请求超时&#x27;)&#125; formData 管理表单数据formData 对象类似于 jquery 的 serialize 方法，序列化表单，实现表单的异步提交 !&gt; 但 serialize 方法无法实现文件上传 使用： 实例化一个 formData 对象， new FormData(form); form 就是表单元素，DOM 对象 formData 对象可以直接作为 xhr.send(formData) 的参数。注意此时数据是以二进制的形式进行传输。 formData 有一个 append 方法，可以添加参数。formData.append(“id”, “1111”); 这种方式只能以 post 形式传递，不需要设置请求头，浏览器会自动为我们设置一个合适的请求头。 代码示例： // 1. 使用formData必须发送post请求xhr.open(&#x27;post&#x27;, &#x27;02-formData.php&#x27;)// 2. 获取表单元素var form = document.querySelector(&#x27;#myForm&#x27;)// 3. 创建form对象，可以直接作为send的参数。var formData = new FormData(form)// 4. formData可以使用append方法添加参数formData.append(&#x27;id&#x27;, &#x27;1111&#x27;)// 5. 发送，不需要指定请求头，浏览器会自动选择合适的请求头xhr.send(formData) 如果要获取 formData 中的数据，可以使用 formData.get(&#39;&#39;) 获取 文件上传 以前，文件上传需要借助表单进行上传，但是表单上传是同步的，也就是说文件上传时，页面需要提交和刷新，用户体验不友好，xhr2.0 中的 formData 对象支持文件的异步上传。 var formData = new FormData()// 获取上传的文件，传递到后端var file = document.getElementById(&#x27;file&#x27;).files[0]console.dir(file)formData.append(&#x27;file&#x27;, file)xhr.send(formData)$(&#x27;#upload&#x27;).on(&#x27;change&#x27;, function() &#123; // FormData 用于管理表单数据的 var form = document.querySelector(&#x27;#form1&#x27;) var formData = new FormData(form) // 发送给服务器 var xhr = new XMLHttpRequest() xhr.open(&#x27;post&#x27;, &#x27;upload.php&#x27;) xhr.send(formData) // 直接发送 formData xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; var r = xhr.responseText &#125; &#125;&#125;)// jquery$(&#x27;#upload&#x27;).on(&#x27;change&#x27;, function() &#123; // 准备要上传的数据 var formData = new FormData() // 如果 formData 中有文件对象了，就不需要再添加了 formData.append(&#x27;file&#x27;, this.files[0]) // 发送 AJAX 请求，上传文件 $.ajax(&#123; url: &#x27;upload.php&#x27;, contentType: false, // 设置编码类型 processData: false, // 设置传递值方式 data: formData, type: &#x27;post&#x27;, success: function(res) &#123; if (res.success) &#123; &#125; &#125; &#125;)&#125;) !&gt; 如果使用 $.ajax 发送 ， 需要添加如下两项参数​ contentType: false, 设置编码类型​ processData: false, 设置传递值方式 显示文件进度信息xhr2.0 还支持获取上传文件的进度信息，因此我们可以根据进度信息可以实时的显示文件的上传进度。 需要注册 xhr.upload.onprogress = function(e)&#123;&#125; 事件，用于监听文件上传的进度。注意：需要在 send 之前注册。 上传的进度信息会存储事件对象 e 中 e.loaded 表示已上传的大小；e.total 表示整个文件的大小 代码参考： xhr.upload.onprogress = function(e) &#123; inner.style.width = ((e.loaded / e.total) * 100).toFixed(2) + &#x27;%&#x27; span.innerHTML = ((e.loaded / e.total) * 100).toFixed(2) + &#x27;%&#x27;&#125;// toFixed(2) 保留两位小数xhr.send(formData) 默认上传文件限制 8M，需要配置 php.ini，允许 php 上传大文件 跨域资源共享(CORS)CORS 的使用 新版本的 XMLHttpRequest 对象，可以向不同域名的服务器发出 HTTP 请求。这叫做跨域资源共享（Cross-origin resource sharing，简称 CORS）。 跨域资源共享（CORS）的前提 浏览器支持这个功能( 兼容性 IE10+ ) 服务器必须允许这种跨域 服务器允许跨域的代码： // 允许所有的域名访问这个接口header(&quot;Access-Control-Allow-Origin:*&quot;);// 允许 www.abc.com 这个域名访问这个接口header(&quot;Access-Control-Allow-Origin:http://www.abc.com&quot;); CORS 的具体流程（了解） 浏览器发送跨域请求 服务器端收到一个跨域请求后，在响应头中添加 Access-Control-Allow-Origin Header 资源权限配置。发送响应 浏览器收到响应后，查看是否设置了header(&#39;Access-Control-Allow-Origin:请求源域名或者*&#39;); 如果当前域已经得到授权，则将结果返回给浏览器，否则浏览器忽略此次响应 结论： 跨域行为是浏览器行为，响应是回来了, 只是浏览器安全机制做了限制, 对于跨域响应内容进行了忽略。 服务器与服务器之间是不存在跨域问题的 jsonp 与 cors 的对比 jsonp 兼容性好，老版本浏览器也支持，但是 jsonp 仅支持 get 请求，发送的数据量有限，使用麻烦 cors 需要浏览器支持 cors 功能才行。使用简单，只要服务端设置允许跨域，对于客户端来说，跟普通的 get、post 请求并没有什么区别 跨域的安全性问题：因为跨域是需要服务端配合控制的 ，也就是说不论 jsonp 还是 cors，如果没有服务端的允许，浏览器是没法做到跨域的 【案例：图灵机器人】","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://wqdy.top/tags/ajax/"}]},{"title":"javascript 高级","slug":"前端/js/js-高级","date":"18/10/2018","updated":"18/10/2018","comments":true,"path":"1652.html","link":"","permalink":"https://wqdy.top/1652.html","excerpt":"","text":"沙箱模式沙箱其实就是一个独立的环境，这个环境中任何的改变，都不会对外部环境产生影响 函数自调用一样，在自调用函数内部的变量是不会影响到外部的，因此函数自调用模式也叫沙箱模式 ;(function(window) &#123; var fn = function() &#123; console.log(&#x27;这是fn函数&#x27;) &#125;&#125;)(window) 代码写在自调用函数里面，减少全局污染 想要在外面使用 fn 函数，可将 fn 暴露到全局 window.fn = fn; 将 fn 函数的地址赋值给了 window 上的 fn 属性 一般，我们一个 js 文件只会暴露一个核心的功能（函数、方法）： 目的还是为了减少全局污染 严格模式 语法：&#39;use strict&#39; 作用：让 js 引擎以更加严格的模式执行 js 代码 最佳实践：在某个函数内部开启严格模式，而不是在全局环境中开启 注意： 严格模式只对当前作用域起作用 应该在当前作用域最顶端使用use strict，否则严格模式无效 使用严格模式好处： 规范 提高代码执行效率 // 严格模式应该配合沙箱模式一起使用。// 沙箱模式 + 严格模式：;(function() &#123; &#x27;use strict&#x27;&#125;)() 严格模式规定 变量必须显示声明 函数参数不能重名 禁止使用八进制 不能使用保留字作为变量名称：implements, interface, let, package, private, protected, public, static, yield 如果不符合上述规范，会直接报错 正则表达式 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串（数据验证）、将匹配的子串替换（数据删除或替换）或者从某个串中取出符合某个条件的子串等（数据提取） 创建正则表达式 构造函数的方式 // RegExp(regular expression)var reg = new RegExp(/a/) // 匹配字母中有 a 正则字面量 var reg = /a/ 正则有 test 方法，作用是测试字符串是否符合正则表达式的规律，如果符合， 返回 true console.log(reg.test(&#x27;abc&#x27;)) // trueconsole.log(reg.test(&#x27;def&#x27;)) // false 元字符 正则表达式由一些普通字符和元字符组成，普通字符包括大小写字母、数字等，而元字符则具有特殊的含义 常见元字符\\d 匹配一个数字字符。等价于 [0-9] \\D 匹配一个非数字字符。等价于 [^0-9] \\w 匹配包括下划线的任何单词字符。等价于[A-Za-z0-9_] \\W 匹配任何非单词字符。等价于 [^A-Za-z0-9_] \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [\\f\\n\\r\\t\\v] \\S 匹配任何非空白字符。等价于 [^\\f\\n\\r\\t\\v] \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， n 匹配字符 n。\\n 匹配换行符。\\\\ 匹配 \\，\\( 则匹配 (。 . 匹配除换行符 \\n 之外的任何单字符。要匹配包括 ‘\\n’ 在内的任何字符，可用(.|\\n) | 指明两项之间的一个选择。，优先级最低，| 的左右都是单独的整体 () 优先级最高，标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。使用 $0…$9 属性。要匹配这些字符，请使用 \\( 和 \\) 。每个()就是一个子匹配 ‘\\1’和’$1’用来指定第一个子匹配 /f|boot/ // 匹配 `f` 和 `boot`/(f|b)oot/ // 匹配 `foot` 和 `boot` 空白字符 \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 字符类的元字符 [] 在正则表达式中表示 单个 字符的位置，[] 里面写这个位置可以出现的字符 ;/[abc]/ // 匹配 a,b,c 任意一个字符 [^] 在中扩号中的 ^ 表示非的意思 // ^ 在方括号表达式开头中使用，此时它表示不接受该字符集合;/[^abc]/ // 匹配除了a, b, c以外的其他字符 [a-z] [1-9]表示范围 ;/[a-z]/ // 小写字母;/[A-Z]/ // 大写字母;/[0-9]/ // 数字;/[a-zA-Z0-9]/ // 所有的小写字母和大写字母以及数字 边界类元字符 我们前面学习的正则只要有满足的条件的就会返回 true，并不能做到精确的匹配。 ^ 匹配输入字符串的开始位置 $ 匹配输入字符串的结尾位置 ;/^chuan/ // 以chuan开头;/chuan$/ // 以chuan结尾;/^chuan$/ // 精确匹配 chuan// 精确匹配chuan,表示必须是这个console.log(/^chuan$/.test(&#x27;chuanchuan&#x27;)) // fasle 以后表单校验要精确匹配 \\b 匹配一个字边界，即字与空格间的位置。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。/\\bCha/ : 匹配 Chapter 的开头三个字符/ter\\b/ : 匹配 Chapter 的结尾三个字符 \\B 表示非单词边界。位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。/\\Bapt/ 表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt 量词类元字符 量词用来控制出现的次数，一般来说量词和边界会一起使用 * 匹配前面的子表达式零次或多次，等价于 &#123;0,&#125; + 匹配前面的子表达式一次或多次，等价于 &#123;1,&#125; ? 匹配前面的子表达式零次或一次，等价于 &#123;0,1&#125; 。当该字符紧跟在任何一个其他限制符 (*, +,?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串 &#123;n&#125; n 是一个非负整数。匹配确定的 n 次 &#123;n,&#125; n 是一个非负整数。至少匹配 n 次 &#123;n,m&#125; m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次 // &#123;&#125; 就近修饰单个字符console.log(/chuan&#123;2&#125;/.test(&#x27;chuanchuan&#x27;)) // falseconsole.log(/(chuan)&#123;2&#125;/.test(&#x27;chuanchuan&#x27;)) // trueconsole.log(/chuan&#123;2&#125;/.test(&#x27;chuann&#x27;)) // true 其他字符 g 全局标记，指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配 i 标记指定不区分大小写。表达式的结尾处 m 表明可以进行多行匹配，但是这个只有当使用^和$模式时才会起作用，在其他的模式中，加不加入 m 都可以进行多行匹配 优先级从高到低的优先级顺序： \\ 转义符 (), (?:) , (?=), [] 圆括号和方括号 *, + , ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125; 限定符 ^, $, \\任何元字符、任何字符 定位点和序列（即：位置和顺序） | 替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。 正则的使用字符串使用正则 replace() var str = &#x27; 123AD asadf asadfasf adf &#x27;// 1. 替换掉字符串中的所有空白var str2 = str.replace(/\\s/g, &#x27;&#x27;) // g: global, 全局搜索// 2. 将所有的ad替换成xxvar str2 = str.replace(/ad/g, &#x27;xx&#x27;)// 3. 将所有的ad/AD替换成xxvar str2 = str.replace(/ad/gi, &#x27;xx&#x27;) // i： ignore 忽略大小写var str = &#x27;abc,efg,123,abc,123,a&#x27;// 4. 所有的逗号替换成句号var str2 = str.replace(/,/g, &#x27;。&#x27;)var jsonStr = &#x27;[&#123;&quot;name&quot;:&quot;张三&quot;,score:80&#125;,&#123;&quot;name&quot;:&quot;张三&quot;,score:90&#125;,&#123;&quot;name&quot;:&quot;张三&quot;,score:81&#125;]&#x27;// 5. 把所有成绩都修改成100分var str2 = jsonStr.replace(/\\d&#123;1,2&#125;/g, &#x27;100&#x27;) match() &#x3D;&#x3D;&gt; 匹配， 匹配符合正则表达式的字符 var str2 = &#x27;zs的手机号是18938383838, ls的手机号13989907890， ww的手机号是13848962389，zl的手机号是18970890908&#x27;// 需求： 匹配出来所有的手机号, 返回一个数组var str3 = str2.match(/1[3-9]\\d&#123;9&#125;/g)console.log(str3) 正则的方法 test() &#x3D;&#x3D;&gt; 测试字符串是否符合正则表达式的规律，符合，就返回 true exec() &#x3D;&#x3D;&gt; 提取，提取字符串中符合正则表达式的字符，需要用括号分组， 如果没有进行分组，返回的是符合整个正则表达式的字符 var str = &#x27;今天是2018-10-16，我这里的需求是提取出年月日&#x27;// var reg = /\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/; ==&gt; 符合整个正则表达式的字符var reg = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/ // ==&gt; 有分组存在 ，默认组名为 undefinedvar reg2 = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/ // ?&lt;组名&gt; 添加组名var ret = reg.exec(str) // 提取出分组的内容以下标的形式存在返回的数组里面var ret2 = reg2.exec(str)console.log(ret)console.log(ret2)// index 代表 匹配到 ret 在 str 中的下标 实例 [xyz] 字符集合。匹配所包含的任意一个字符。例如， [abc] 可以匹配 “plain” 中的 ‘a’ [^xyz] 负值字符集合。匹配未包含的任意字符。例如， [^abc] 可以匹配 “plain” 中的’p’、’l’、’i’、’n’ [a-z] 匹配所有小写字母 [-a-z] 或 [a-z-] 匹配所有小写字母和 - [A-Za-z0-9] 匹配任何大写字母小写字母和数字 \\b([a-z]+)\\1\\b/gi 一个单词连续出现的位置 将通用资源指示符 (URI) 分解为其组件 var str = &#x27;https://www.baidu.com:80/index.html&#x27;var patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/arr = str.match(patt1)for (var i = 0; i &lt; arr.length; i++) &#123; document.write(arr[i]) document.write(&#x27;&lt;br&gt;&#x27;)&#125;// https://www.baidu.com:80/index.html// https// www.baidu.com// :80// /index.html 后向引用后向引用 正则表达式一个最重要的特性就是将匹配成功的模式的某部分进行存储供以后使用这一能力 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符 ?:、?= 或 ?! 来忽略对这部分正则表达式的保存 ?: 非获取匹配。匹配但不获取匹配结果，不存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， industr(?:y|ies) 就是一个比 industry|industries 更简略的表达式 ?= 正向预查。在任何匹配的字符串开始处匹配查找字符串。非获取匹配，不获取供以后使用。例如，’Windows (?&#x3D;95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 ?! 负向预查，在任何不匹配的字符串开始处匹配查找字符串。非获取匹配，不获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 后向引用一个最简单，最有用的应用是提供了确定文字中连续出现两个相同单词的位置的能力。请看下面的句子： Is is the cost of of gasoline going up up? 根据所写内容，上面的句子明显存在单词多次重复的问题。如果能有一种方法无需查找每个单词的重复现象就能修改该句子就好了。下面的 JScript 正则表达式使用一个子表达式就可以实现这一功能 var ss = &#x27;Is is the cost of of gasoline going up up?&#x27;var re = /\\b([a-z]+) \\1\\b/gimvar rv = ss.replace(re, &#x27;$1&#x27;) 在这个示例中，子表达式就是圆括号之间的每一项。所捕获的表达式包括一个或多个字母字符，即由[a-z]+所指定的。该正则表达式的第二部分是对前面所捕获的子匹配的引用，也就是由附加表达式所匹配的第二次出现的单词。\\1用来指定第一个子匹配。单词边界元字符确保只检测单独的单词。如果不这样，则诸如 “is issued” 或 “this is” 这样的短语都会被该表达式不正确地识别。","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"Web Api","slug":"前端/js/js-web-api","date":"20/09/2018","updated":"20/09/2018","comments":true,"path":"1658.html","link":"","permalink":"https://wqdy.top/1658.html","excerpt":"","text":"Web Api 基本概念API（Application Programming Interface,应用程序编程接口） API 是一些预先定义的方法，这些方法能够实现某些特定的功能 任何开发语言都会提供自己的 API API 的特征输入和输出(参数&#x2F;返回值) 通俗的讲，API 就是编程语言给我提供的一些 工具，通过这些工具，我们可以非常轻易的完成一些功能。 Web API : 是浏览器提供的 一套操作网页(web)的方法(API), 通过这套 API 我们可以非常轻松的操作页面的元素和浏览器的一些功能 **ECMAScript - JavaScript 的核心 ** ECMAScript 是一套标准, 规范了语言的基本语法和数据类型 与具体实现无关 DOM - 文档对象模型 一套操作页面元素的 API 通过 DOM 提供的 API 可以获取&#x2F;操作网页上的元素 BOM - 浏览器对象模型 一套操作浏览器功能的 API 通过 BOM 可以操作浏览器窗口, 比如刷新、控制浏览器跳转等 DOM 文档对象模型DOM 基本概念 DOM ( Document Object Model ) 文档对象模型，是W3C组织推荐的一套操作网页元素的 API DOM 又称为文档树模型，因为整个 HTML 文档是一个树形的结构 DOM 中常见的概念 : 文档 document : 一个网页可以称为文档；（换句话说：操作页面，其实就是操作 document） console.log(document)// DOM 会把整个网页当成一个对象，我们操作这个网页，只要操作这个document对象// DOM 会把网页中的所有的东西都当作对象 节点node : 网页中的所有内容都是节点 (标签、属性、文本) &lt;ul class=&quot;box&quot;&gt; ul: 标签节点 class=&quot;box&quot;: 属性节点 &lt;!-- 这是一些测试 --&gt; 注释节点 &lt;li&gt;测试&lt;/li&gt; 测试:文本节点 &lt;li&gt;测试&lt;/li&gt; &lt;li&gt;测试&lt;/li&gt;&lt;/ul&gt; 元素 element : 网页中的标签节点 获取元素的方法 document.getElementById() // 通过id 获取元素// 参数 : 字符串类型的id// 返回值 : 一个元素（dom对象）var div = document.getElementById(&#x27;div&#x27;)console.dir(div) // 以对象的形式显示console.log(div) // 以内容的形式显示 ​ 关于console.log()和console.dir()的区别 ​ console.log() ：打印一个元素的时候，是以标签的形式进行展示的 ​ console.dir() ：打印一个元素的时候，是以对象的形式进行展示的 getElementsByClassName() // 通过类名获取元素// 参数：字符串类型的类名// 返回值：伪数组document.getElementsByClassName(&#x27;class&#x27;) getElementsByTagName() // 通过标签名获取元素// 参数：标签名字符串// 返回值：伪数组var ps = document.getElementsByTagName(&#x27;p&#x27;) getElementsByName() // 通过name属性值获取元素// 参数 : name值// 返回值 : 伪数组var ps = document.getElementsByName(&#x27;aa&#x27;) querySelector() // 根据css选择器获取元素 (重点)// 参数：是一个css选择器// 返回值：只会返回一个对象，如果有很多个，会返回第一个document.querySelector(&#x27;#box&#x27;) querySelectorAll() // 根据css选择器获取元素 (重点)// 参数：是一个css选择器// 返回值：伪数组document.querySelectorAll(&#x27;.box&#x27;) 注意事项 getElementById() 只能由 document 调用，如果通过其他元素调用会报错，其他方法可由已经获取到的 dom 对象调用 querySelector和 getElementById如果获取不到元素会返回 null；getElementsByClassName 、getElementsByTagName 、getElementsByName 、querySelectorAll 如果没有获取到元素也会返回一个伪数组，只不过伪数组长度为 0 伪数组不是数组，不能使用属性的方法，但是可以跟数组一样进行遍历和使用下标进行操作；伪数组不能直接注册事件，需要遍历后拿到标签再注册事件 在 DOM 中, 获取元素操作需要写在 html 内容的后面，保证页面加载完成之后才能获取到内容 事件学习认识事件 事件：理解为浏览器的感知系统 , 触发 –&gt; 响应机制，javascript 是基于事件驱动的 // 点击事件// 结构 : 事件源.onclick = function () &#123;..&#125; 事件三要素 : 事件源 + 事件名称 + 事件处理函数 事件源 : 给谁注册事件 ( 按钮 btn ) 事件名称 : 注册了什么事件 ( click 事件 ) 事件处理函数 : 事件触发后要执行的代码(函数形式) 注意：事件处理函数并不会立马执行，而是当事件触发的时候才会执行（浏览器会自动调用） 注册事件的基本语法 : var box = document.getElementById(&#x27;box&#x27;)//on:当 click:点击 当按钮被点击的时候触发box.onclick = function() &#123; console.log(&#x27;代码会在box被点击后执行&#x27;)&#125; 两种按钮 &lt;button&gt;点亮&lt;/button&gt;&lt;input type=&quot;button&quot; value=&quot;哈&quot; /&gt;都是可点击的普通按钮，一个是文字显示在标签内容里, 而且还可以放其他标签，一个是文字显示在vaue中 焦点事件 focus : 获得焦点 blur : 失去焦点 鼠标事件 click : 单击 dblclick ：双击 mouseover/mouseout : 进入&#x2F;离开元素 mouseenter/mouseleave : 进入&#x2F;离开元素 mousedown ：按下 mouseup ：抬起&#x2F;释放 mousemove ：移动 键盘事件 keydown/keypress ：按下 keyup： 释放 事件中的 this this 指向注册事件的事件源 var btn = document.getElementById(&#x27;btn&#x27;)btn.onclick = function() &#123; // 给 btn 注册的事件，因此 this 表示 btn this.value = &#x27;哈哈&#x27;&#125; 练习： &lt;!-- 1. 给多个按钮注册点击事件，点击的那个变成红色 --&gt;.red &#123; background: red &#125;&lt;button&gt;1&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;&lt;script&gt; // 给多个按钮注册点击事件，点击的那个变成红色，其他的恢复默认 var btns = document.getElementsByTagName(&#x27;button&#x27;) for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function() &#123; // console.log(i) // 点击按钮时打印 2 // btns[i].className = &#x27;red&#x27; // 此时 i = 2，报错 for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].className = &#x27;&#x27; // 恢复默认样式 ，排他思想 &#125; this.className = &#x27;red&#x27; // 给自己添加样式 &#125; &#125;&lt;/script&gt;// 2. 点击按钮，显示对应的图片 1-6&lt;input type=&quot;button&quot; value=&quot;第一张&quot; title=&quot;1&quot; /&gt;&lt;img id=&quot;img&quot; src=&quot;images/1.jpg&quot; alt=&quot;&quot; /&gt; 阻止浏览器默认行为 对于 a 标签来说，默认的行为就是进行页面跳转，如果不想让 a 标签进行跳转，可以在注册事件中使用return false &lt;a id=&quot;link&quot; href=&quot;http://www.baidu.com&quot;&gt;这是a&lt;/a&gt;&lt;script&gt; var link = document.getElementById(&#x27;link&#x27;) link.onclick = function() &#123; alert(&#x27;呵呵&#x27;) // 阻止页面跳转 return false &#125;&lt;/script&gt; e.preventDefault() 只会阻止浏览器的默认行为，并不会停止函数执行 return false 后的代码不在执行 在 jQuery 中，return false在调用时会执行 3 个单独的操作： event.preventDefault() event.stopPropagation() 停止回调执行并在调用时立即返回 属性操作 在 DOM 中，页面标签的属性和 DOM 对象的属性是一一对应的，因此我们可以通过修改 DOM 对象的属性来修改标签的属性 普通标签属性 常见的属性有：src、title、src、href、class、id 等 // 在 js 中 class 是关键字，因此对应的是 className 属性div.className = &#x27;hg&#x27; // 修改类名会把原类名直接覆盖掉 表单属性操作 常见的表单属性有：disabled、type、value、checked、selected 对于 disabled、checked、selected 三个属性来说，比较特殊。在 DOM 对象中，这些属性是一个布尔类型的属性，值只有 true 或者 false !&gt; reset() 方法可把表单中的元素重置为它们的默认值 【案例：禁用文本框】 【案例：随机下拉框选中】 【案例：表格全选案例】 标签的自定义属性 我们之前讨论的属性，都是 HTML 规范中，标签本来就有的属性，对于标签自定义的一些属性，比较特殊 在 html 页面中，定义一个自定义属性 &lt;div id=&quot;box&quot; aa=&quot;bb&quot;&gt;&lt;/div&gt; 在对应的 DOM 对象中是不存在的，在 DOM 对象中只会存在固定的那些属性 var box = document.getElementById(&#x27;box&#x27;)console.log(box.aa) // undefined attribute 方法 attribute 系列方法用于设置标签的属性，不管是自定义的还是固有的属性 // 获取标签的属性box.getAttribute(属性名)// 设置标签的属性box.setAttribute(属性名, 属性值)// 移除标签的属性box.removeAttribute(属性名) 区别 : // &lt;div a=&quot;1&quot; id=&quot;box&quot;&gt;&lt;/div&gt;// 1. 直接给标签里只能添加固有的属性 title 等 标签+对象里都有显示// 2. 给标签添加自定义属性--标签上显示console.log(box.a) // undefined =&gt; 对象中不显示console.log(box.getAttribute(&#x27;a&#x27;)) // 1 =&gt;// 3. 给对象添加自定义属性 -- 标签中不显示box.b = 2console.log(box.b) // 2 =&gt; 对象中显示console.log(box.getAttribute(&#x27;b&#x27;)) // null// 4. Attribute方法box.setAttribute(&#x27;c&#x27;, 3) // 标签中显示console.dir(box)console.log(box.c) // undefined =&gt;对象中不显示console.log(box.getAttribute(&#x27;c&#x27;)) // 3console.log(box.attributes) // &#123;0: a, 1: id, 2: c, a: a, id: id, c: c, length: 3&#125;console.log(box.attributes.c) // c=&#x27;3&#x27; tab 栏案例 (重点)[案例：获取当前元素的索引] // 方式1：// 存btns[i].setAttribute(&#x27;index&#x27;, i)// 取console.log(this.getAttribute(&#x27;index&#x27;))// 方式2：// 存btns[i].index = i// 取console.log(this.index)// 区别在于: 第一个显示在标签内 第二个不显示在标签内 推荐第二种 【案例：tab 栏切换】 标签的内容属性innerText 和 innerHTML 共同点 : 都是用来获取和设置标签的内容的 区别： innerHTML 能够识别标签，标签能够生效 innerText 只识别文本，标签会被转义 var div = document.getElementById(&#x27;div&#x27;)// 获取内容// 获取标签内容的时候，只会获取文本，标签扔掉了console.log(div.innerText) // 哈哈// 获取标签内容的时候，不管标签还是文本，都能获取到console.log(div.innerHTML) // &lt;h1&gt;哈哈&lt;/h1&gt;// 设置内容// 设置标签内容的时候，覆盖原来内容，对标签进行转义div.innerText = &#x27;&lt;h1&gt;嘿嘿&lt;/h1&gt;&#x27;// 设置内容的时候，覆盖原来内容，标签也能生效，浏览器能解析这个标签div.innerHTML = &#x27;&lt;h1&gt;嘿嘿&lt;/h1&gt;&#x27; 浏览器兼容性：指网页在各种浏览器上的显示效果不一致。或者是一些属性和方法在低版本的浏览器中不支持 innerText 是 IE 提出来的属性，因此低版本的火狐浏览器不支持这个属性。 火狐有一个 textContent 属性，效果跟 innerText 一样，但是 IE678 不支持这个属性 书写 innerText 的兼容性代码 function getInnerText(element) &#123; if (typeof element.innerText === &#x27;string&#x27;) &#123; return element.innerText &#125; else &#123; return element.textContent &#125;&#125; 行内样式操作（style 属性） 标签不仅可以通过 class 属性操作样式 (嵌套样式)，还可以通过 style 属性操作样式 (行内样式)。 同样的 DOM 对象可以通过 className 操作样式 (嵌套样式)，也可以通过 style 属性操作样 (行内样式)。 css : 嵌套样式 &#x3D;&gt; js : 类名 div.className &#x3D; ‘red’ css : 行内样式 &#x3D;&gt; js : style 对象 div.style.color &#x3D; ‘red’ 样式属性 style 属性是一个对象，里面存储了所有行内样式的键值对 style 属性只能获取和设置行内样式，嵌套样式通过 style 获取不到 如果样式的名字带 - ，比如 background-color ，在 style 对象中使用 backgroundColor &#x3D;&gt; （因为 - 在 js 中不是一个合法的标识符） style 设置的样式是行内样式，优先级要高于通过 className 设置的样式 &lt;div style=&quot;color:red;background-color:blue;&quot;&gt;哈哈&lt;/div&gt; var div = document.querySelector(&#x27;div&#x27;)// 获取样式console.log(div.style)console.log(div.style.color) // red// 设置样式div.style.width = &#x27;200px&#x27;div.style.height = &#x27;200px&#x27;div.style.fontSize = &#x27;100px&#x27;div.className = &#x27;box&#x27; getComputedStyle 获取元素计算后的样式 语法： window.getComputedStyle( 获取的元素， 伪类) ​ 伪类 &#x3D;&#x3D;&gt; ::after ::before，如果写上了伪类，表示要获取元素的伪类的样式，如果不需要获取的话，该参数写 null ​ 返回值： 返回一个样式对象 var div = document.querySelector(&#x27;div&#x27;)// 获取元素自身的var ret = window.getComputedStyle(div, null).fontSizevar ret1 = window.getComputedStyle(div, null).backgroundColor// 推荐：对于复合样式，需要获取什么样式，写具体的样式名，这样能更好的兼容更多浏览器// 获取伪类的var ret2 = window.getComputedStyle(div, &#x27;::after&#x27;).width 关于 body 的样式操作var bd = document.querySelector(&#x27;body&#x27;)console.log(bd) // 通过 querySelector 获取 body 元素console.log(document.body) // 直接获取 body 元素document.documentElement // 可以获取 html 元素document.head // 直接获取 head 元素document.title // 获取的是 title 中的文本 【案例：开关灯案例】 【案例：随机背景颜色案例】 【案例：百度换肤】 关于 cssText (了解) 使用 cssText 可以设置 style 的属性值 &lt;div style=&quot;width: 100px; height: 100px&quot;&gt;哈哈哈&lt;/div&gt;&lt;script&gt; // 优点：可以一次性设置多个值 // 缺点：会覆盖整个style属性且不利于阅读 var div = document.querySelector(&#x27;div&#x27;) div.style.cssText = &#x27;background:red;color:yellow&#x27;&lt;/script&gt; 节点操作 (超级重要)节点属性 (了解)节点分类： ​ 元素节点、文本节点、属性节点、注释节点 节点常用的属性 childNodes : 获取所有的子节点 nodeType: 节点类型：元素节点 &#x3D; 1 属性-2(过时) 注释-8 文本-3 nodeType 链接-MDN nodeName: 节点名称 nodeValue: 节点值 节点查找 (重点)孩子节点&lt;ul&gt; &lt;!-- 下面是li --&gt; &lt;li&gt;导航1&lt;/li&gt; &lt;li&gt;导航2&lt;/li&gt; &lt;li&gt;导航3&lt;/li&gt; &lt;li&gt;导航4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var ul = document.querySelector(&#x27;ul&#x27;) // 获取ul所有的子节点（包括了元素节点和其他很多类型的节点，基本不常用） console.log(ul.childNodes) // 获取第一个子节点 (不常用) console.log(ul.firstChild) // 获取最后一个子节点 (不常用) console.log(ul.lastChild) // 获取所有的子元素，兼容性：IE678会把注释节点算上 console.log(ul.children) // 获取第一个子元素 有兼容性问题（IE678） console.log(ul.firstElementChild) // 获取最后一个子元素 有兼容性问题（IE678） console.log(ul.lastElementChild) // 获取第n个子元素 有兼容性问题（IE678） console.log(ul.children[n])&lt;/script&gt; 兄弟节点 nextSibling : 下一个兄弟节点 (基本不常用) nextElementSibling : 下一个兄弟元素（IE678 不兼容） previousSibling : 上一个兄弟节点 (基本不常用) previousElementSibling : 上一个兄弟元素 有兼容性问题 可以封装一个兼容性方法 &lt;p&gt;导航1&lt;/p&gt;&lt;p class=&quot;p&quot;&gt;导航2&lt;/p&gt;&lt;p&gt;导航3&lt;/p&gt;&lt;script&gt; var p2 = document.querySelector(&#x27;.p&#x27;) console.log(p2) console.log(p2.nextSibling) console.log(p2.nextElementSibling) console.log(p2.previousSibling) console.log(p2.previousElementSibling)&lt;/script&gt; 【案例 1：表单校验】 父亲节点 parentNode : 父节点（没有兼容性问题） parentElement : 父元素 div.parentNode // 获取父节点 添加节点 (重点)appendChild()// 作用：在子元素的最后添加一个元素// 语法：parent.appendChild(newChild)// 父元素.appendChild(新子元素) 注意 : 如果 newChild 已经存在于 DOM 树中，则它会被从原始位置删除 insertBefore()// 作用：在某个子元素之前添加一个元素// 语法：parent.insertBefore(newChild, refChild) 必须要父节点来调用，newChild 为需要添加的那个节点，refChild 为添加到哪一个节点的前面 没有 insertAfter() // 将元素添加到最后div.appendChild(p) // (常用)div.insertBefore(p, null)// 将元素添加到 s1 之前(常用)div.insertBefore(p, s1)// 将元素添加到 s1 之后// 没有 insertAfterdiv.insertBefore(p, s1.nextElementSibling)// 将元素添加到最前div.insertBefore(p, div.children[0]) // (常用)div.insertBefore(p, div.firstElementChild) 克隆节点 (重点)// 语法：var newNode = 节点.cloneNode([isDeep])// isDeep参数：false / true// false：默认值：是浅复制，只会复制标签节点本身，不会复制节点的孩子// true: 深度复制，会复制标签，还会复制标签的所有内容 克隆出来的节点跟原来的节点没有关系了，修改了也不会相互影响 如果克隆的节点带了 id，我们需要给 id 重新设置一个值，不让 id 冲突 var newNode = div.cloneNode(true)console.log(newNode) 创建节点(3 种方式) (重点)document.write（基本不用）可以生成新的节点，但是不推荐使用。如果页面已经加载完成了，再用 document.write 写内容的话，会把之前的页面给覆盖掉 原理：页面从上往下加载的时候，会开启一个文档流，当页面加载完，文档流就会关闭。document.write 的本意就是在文档流上写入内容。如果页面没加载完成，文档流还是开着的，document.write 直接在这个文档流上写东西，如果页面加载完成了，还是用 document.write 写东西，会重新开启一个新的文档流，往新的文档流上写东西，旧的文档流就被新的文档流覆盖了。 window.onload = function() &#123; document.write(&#x27;呵呵&#x27;)&#125; innerHTML (偶尔用)innerHTML 也可以创建节点 使用 innerHTML 创建节点时，如果原来有内容的话，会把原先的内容覆盖 慎用：很容易出现效率问题 div.innerHTML = &#x27;&lt;h1&gt;哈哈&lt;/h1&gt;&#x27; createElement (常用)// 语法：var element = document.createElement(&#x27;tagName&#x27;)// 返回：一个元素// 需要配合 appendChild 和 innerText 来使用var div = document.querySelector(&#x27;div&#x27;)var h1 = document.createElement(&#x27;h1&#x27;)console.log(h1)h1.style.background = &#x27;red&#x27;h1.innerText = &#x27;哈&#x27;div.appendChild(h1) 删除节点 (重点)// 语法：parent.removeChild(child)// 解析：父元素.removeChild(子元素)// 功能：由父元素调用，删除里面的一个子元素div.removeChild(p)p.parentNode.removeChild(p) 【案例 : 节点操作-删除节点】 1. 使用 children 和 TagName =&gt; 需要配合 i--// 原因 :动态计算 , 每删除一个,都会重新分配一次下标2. 使用 querySelectorAll(&#x27;li&#x27;) =&gt; ok的// 原因 : 静态计算 [案例 : 许愿墙案例] 功能1: 克隆10个tip, 并且随机分布功能2: 点击提高层级功能3: 点击x, 删除当前tip功能4: 双击tip头部, 删除当前tip 替换节点// 语法：// newChild 为用来替换 oldChild 的新节点parentNode.replaceChild(newChild, oldChild) 注意 : 如果 newChild 已经存在于 DOM 树中，则它会被从原始位置删除 节点操作综合案例【动态生成表格】 BOM BOM（Browser Object Model）：浏览器对象模型，提供了一套操作浏览器功能的工具 重点 ：定时器、 offset 系列 window window 对象是一个全局对象，也可以说是 JavaScript 中的顶级对象 所有定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法 像 document、alert()、console.log() 这些都是 window 的属性，其实 BOM 中基本所有的属性和方法都是 window 的 window 对象下的属性和方法调用的时候可以省略 window .onload（掌握） window.onload 事件会在 窗体加载完成 后执行，通常我们称之为入口函数。 window.onload = function() &#123; //代码会在窗体加载完成后执行。 //窗体加载完成 包括文档树(DOM html)的加载、还有图片、文件的加载完成。&#125; 如果有图片加载，那么代码一定要写到 window.onload 里面，否则会出现图片没有加载完成，获取到的宽度和高度不对的情况。 浏览器会对页面的加载做优化，在加载图片的时候，图片的引入会延迟。 &lt;img src=&quot;./01.png&quot; alt=&quot;&quot;&gt;window.onload = function () &#123; var img = document.querySelector(&#x27;img&#x27;) console.log(img.width) console.log(img.height)&#125; .open() 与 .close() (了解) window.open() 打开一个窗口 // 语法：window.open(url, [name], [features])// 参数1：需要载入的 url 地址// 参数2：新窗口的名称或者 targt 属性// _blank:如果指定为 _blank，表示在新的窗口打开// 参数3：窗口的属性，指定窗口的大小// 返回值：会返回刚刚创建的那个窗口，在 window.close() 时使用// 示例：var newWin = window.open(&#x27;http://www.baidu.com&#x27;, &#x27;_blank&#x27;, &#x27;width=300,height=300&#x27;)// 参数配置：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open window.close() 关闭窗口 newWin.close() // newWin 是刚刚创建的那个窗口window.close() // 把当前窗口给关闭 延时器与定时器 (重点)setTimeout 延时器 可以在延迟一定时间后执行指定的代码 设置延时器 // 语法: setTimeOut(callback,time)// 参数1: 回调函数, 时间到了就会执行// 参数2: 延时的时间 毫秒为单位 1s = 1000毫秒// 返回 : 延时器的id,用于清除var timer = setTimeOut(function() &#123; //1秒后将执行一次&#125;, 1000) 清除延时器 // 语法 : clearTimeOut(timerId)// 参数 : 延时器id// 示例 :clearTimeOut(timer) // 清除上面定义的延时器 setInterval 定时器 setInterval 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间间隔。 (每隔一段时间执行一段代码) 定时器除非清除，否则会一直执行下去。 设置定时器 // 语法 :var timerId = setInterval(func,dealy)// 参数1 ： 重复执行的函数// 参数2 : 每次间隔的毫秒数// 返回 : 定时器的id, 用于清除// 示例 :var timer = setInterval(function() &#123; // 1s 之后开始重复执行&#125;, 1000) 清除定时器 // 语法 : clearInterval(intervalId)// 参数 : 定时器id// 示例 :clearInterval(timerId) // 清除上面的定时器 案例【短信验证码案例.html】 location 对象 location 对象也是 window 的一个属性 location 其实对应的就是浏览器中的地址栏 常用属性和方法 location.href : 控制地址栏的地址，实现页面跳转 document.onclick = function() &#123; location.href = &#x27;http://www.baidu.com&#x27; // 点击页面跳转到百度首页&#125; [案例 : 注册成功，3 秒后跳转] 页面跳转： location.href = &#39;url地址&#39; location.assign(&#39;url地址&#39;) location.replace(&#39;url地址&#39;) (不记录历史) location.reload() 让页面重新加载 document.onclick = function() &#123; location.reload() // 重新刷新&#125; location 的其他值 http://www.bbb.com:8080/index.html?id=666&amp;psd=123#xxx location.hash &#x2F;&#x2F;哈希值 其实就是锚点 &#x3D;&#x3D;&gt; #xxx location.host &#x2F;&#x2F;服务器 服务器名+端口号 &#x3D;&gt; www.bbb.com:8080 location.hostname &#x2F;&#x2F;服务器名 &#x3D;&gt; www.bbb.com location.pathname &#x2F;&#x2F;路径名 &#x3D;&gt; index.html location.port &#x2F;&#x2F;端口 &#x3D;&gt; 8080 location.protocol &#x2F;&#x2F;协议 &#x3D;&gt; http location.search &#x2F;&#x2F;参数 &#x3D;&gt; ?id&#x3D;666&amp;psd&#x3D;123 其他对象 history 对象表示页面的历史 // 随便打开一个网页 可以演示// 后退：history.back()history.go(-1)// 前进：history.forward()history.go(1) screen 对象 console.log(screen.width) // 屏幕的宽度console.log(screen.height) // 屏幕的高度console.log(screen.availWidth) // 浏览器可占用的宽度console.log(screen.availHeight) // 浏览器可占用的高度 缓动动画缓动动画初体验动画公式 : var step = (target - current) / 10current += step [案例演示 : ] 1. 三步走- 获取当前位置- 累加小碎步- 重复赋值回去2. 定时器 缺点 : 打开控制台, 查看盒子的结构行内样式 left, 发现并没有跑到 400px, 只能跑到 396.4&#x2F;395.5 原因 : offsetLeft 获取值的时候, 只会获取整数 , (对小数部分会四舍五入,整数有时候往上取整,有时候往下取整); 可以在获取的 offset 地方打印查看 缓动动画 - 移动 400 位置动画公式 : var step = (target - current) / 10step = Math.ceil(step) // 往上取整current += step// 为什么往上取整 :// 1. 如果不取整，赋值为小数的话,下次取值还是会取个 整数回来，这就是之前的缺点// 2. 往上取整的额原因是：(400-395)/10 = 0.5 如果往下取整为0，那就不会走了，所以// 为了保证可以走，往上取整 取 1 步数 为 1 案例演示 注意点 : 1.查看位置 : left有时候为 395.5/ 396.42.打印: offsetLeft =&gt; 395 / 3963.step为整数 往上取整 缓动动画 - 回到 0 点位置动画公式 : var step = (target - current) / 10step = Math.floor(step) //往下取整current += step// 为什么往下取整 :// 1. 如果不取整，赋值为小数的话,下次取值还是会取个整数回来，这就是之前的缺点// 2. 往上取整的额原因是 : (0-5)/10 = -0.5 如果往上取整为0 那就不会走了，所以// 为了保证可以走，往下取整 : 取 -1 步数 为 -1 案例演示注意点 : 1. 先把盒子 设置 left : 400px 位置; 回到0位置2. 查看位置 : left有时候为 4.53. 打印: offsetLeft =&gt; 54. step为整数 往下取整 缓动动画 - 封装函数function animate(element, target) &#123; if (element.timerId) &#123; clearInterval(element.timerId) &#125; element.timerId = setInterval(function() &#123; // 1. 获取当前位置 var current = element.offsetLeft // 2. 累加小碎步 var step = (target - current) / 10 // 往上取整 ? 为什么，因为 0.5 如果网下取整也是0 ，不会走 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step) current += step // 1 // 3. 重新赋值 element.style.left = current + &#x27;px&#x27; //400 if (current == target) &#123; clearInterval(element.timerId) &#125; &#125;, 15)&#125; [案例 : 筋斗云] [案例：开机提示关闭] 事件对象事件对象的概述 在触发某个事件的时候，都会产生一个事件对象 Event，这个对象中包含所有与事件相关的一些信息，包括触发事件的元素，事件的类型以及其他与事件相关的信息 鼠标事件触发时，事件对象中会包含鼠标的位置信息。 键盘事件触发时，事件对象中会包含按下的键相关的信息。 获取事件对象现代浏览器获取 : (掌握) // 给一个形参即可btn.onclick = function(e) &#123; // e 就是事件对象，里面包含了事件触发时的一些信息 console.log(e)&#125; 低版本浏览器 (ie678): (了解) btn.onclick = function() &#123; // IE678 通过 window.event 获取事件对象 console.log(window.event)&#125; 兼容性 : btn.onclick = function(e) &#123; // 只要用到了事件对象，就要记得处理浏览器兼容性 // 低版本IE event 不存在为undefined e = e || window.event&#125; 事件对象的常用属性 事件对象中有很多很多的属性，但是很多属性并不常用。我们经常用到的是鼠标位置信息和键盘码相关的信息 鼠标位置信息 clientX 与 clientY ： 相对于浏览器可视区左上角的位置（不随滚动条滚动而改变） pageX 与 pageY ：相对于网页内容（文档 document）左上角的位置 screenX 与 screenY ：相对于屏幕左上角的位置 offsetX 与 offsetY ：鼠标相对于事件源左上角的位置 document.onmousemove = function(e) &#123; console.log(e.clientX, e.clientY) console.log(e.pageX, e.pageY) console.log(e.screenX, e.screenY)&#125; [案例 : 拖拽案例] 键盘码// 键盘按下的那个键的键盘码e.keyCode 注册事件的两种方式on + 事件名称 onclick、onmouseover 这种 on+事件名称的方式注册事件几乎所有的浏览器都支持 // 注册事件box.onclick = function() &#123; // 事件处理程序&#125;// 移除事件box.onclick = null on+事件名称注册事件的缺点：同一个元素同一类型的事件，只能注册一个，如果注册了多个，会出现覆盖问题 addEventListener 现代浏览器支持的注册事件的新方式，这种方式注册的事件不会出现覆盖问题 addEventListener 的语法 // type：事件的类型：click mouseover 字符串类型，不带 on// fn：函数，每次点击，执行这个函数// useCapture: 可选，true：事件在捕获阶段执行，false: 事件在冒泡阶段执行(默认)element.addEventListener(type, fn, useCapture)btn.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;哈哈&#x27;)&#125;) removeEventListen 的语法 // type：事件的类型// fn：要移除的那个函数element.removeEventListener(type, fn)btn.removeEventListener(&#x27;click&#x27;, fn)// 注意 : 如果想让注册的事件能移除，不能用匿名函数 低版本浏览器兼容问题: (了解) IE678 不支持 addEventListener 与 removeEventListen 两个方法，但是支持 attachEvent 与 detachEvnet attachEvent 的用法： // type: 事件类型，需要加上on// fn: 需要执行的那个事件attachEvent(type, fn)btn.attachEvent(&#x27;onclick&#x27;, function() &#123; alert(&#x27;哈哈&#x27;)&#125;) detachEvent 的用法： detachEvent(type, fn) 兼容性封装（了解）// 添加事件function addEvent(element, type, fn) &#123; // 能力检测 if (element.addEventListener) &#123; element.addEventListener(type, fn) &#125; else if (element.attachEvent) &#123; element.attachEvent(&#x27;on&#x27; + type, fn) &#125; else &#123; // 如果都不行，那就用on方式 element[&#x27;on&#x27; + type] = fn &#125;&#125;// 移除事件function removeEvent(element, type, fn) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, fn, false) &#125; else if (element.detachEvent) &#123; element.detachEvent(&#x27;on&#x27; + type, fn) &#125; else &#123; element[&#x27;on&#x27; + type] = null &#125;&#125; 事件流事件冒泡当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为冒泡 说白了就是：当我们触发了子元素的某个事件后，父元素对应的事件也会触发 on 创建的事件默认为冒泡，无法修改 [案例 : 弹窗案例] 阻止事件冒泡 e.stopPropagation() box.onclick = function(e) &#123; e.stopPropagation()&#125;// 参数1：true =&gt; 捕获， false =&gt; 冒泡（默认）box.addEventListener(&#x27;click&#x27;, function() &#123;&#125;, 参数1) event.stopImmediatePropagation 阻止事件冒泡并且阻止相同事件的其他侦听器被调用如果有多个相同类型事件的事件监听函数绑定到同一个元素，当该类型的事件触发时，它们会按照被添加的顺序执行。如果其中某个监听函数执行了 event.stopImmediatePropagation() 方法，则当前元素剩下的监听函数将不会被执行 阻止事件冒泡的兼容性封装 function stopPropagation(e) &#123; if (e &amp;&amp; e.stopPropagation) &#123; e.stopPropagation() // 标准浏览器 &#125; else &#123; window.event.cancelBubble = true // 兼容 IE &#125;&#125; 事件捕获事件冒泡是 ie 提出来的 路径 : 触发事件的目标元素(son) &gt; you &gt; father &gt; body &gt; document 事件捕获是火狐提出来的 路径 : document &gt; body &gt; father &gt; you &gt; 触发事件的目标元素 (son) 解析 : 事件的处理将从 DOM 层次的根开始，而不是从触发事件的目标元素开始，事件被从目标元素的所有祖先元素依次往下传递 // 当 addEventListener 第三个参数为 true 时，表示事件捕获arr[i].addEventListener( &#x27;click&#x27;, function() &#123; // &#125;, true) 事件流的三个阶段 事件的捕获阶段 事件的目标阶段（触发自己的事件） 事件的冒泡阶段 事件有三个阶段 : 捕获事件和冒泡事件都存在的话，首先发生的是捕获阶段，然后是目标阶段，最后才是冒泡阶段 addEventListener 第三个参数为是否捕获 如果为 true 时，表示该事件在捕获阶段发生 如果为 false 时，表示该事件在冒泡阶段发生 某一个事件只会执行一次 三大系列offset 系列 (重要) offset 系列用于用于获取元素自身的大小和位置，在 webapi 中有广泛应用offset 系列主要有：offsetHeight、offsetWidth、offsetParent、offsetLeft、offsetTop offsetHeight 与 offsetWidth 获取元素真实的高度和宽度 （内容大小 + border + padding）（关注盒子本身，不关注盒子内部内容） 获取到的是数值类型，方便计算 offsetHeight 与 offsetWidth 是只读属性，不能设置 style.height 与 style.width 只能获取和设置行内样式 不包括内边距、边框和外边距 获取到的是字符串类型，需要转换 offsetParent 获取离当前元素最近的定位父元素(absolute、relative)，如果没有，那就找 body parentNode : 父节点（没有兼容性问题） parentElement : 父元素 offsetLeft 与 offsetTop 获取元素自身与 offsetParent 真实的距离 获取到的是数值类型，方便计算 只读属性，只能获取，不能设置 style.left 与 style.top 只能获取和设置行内样式 获取到的是字符串，需要转换 scroll 系列 scroll 系列是用来获取盒子内容的大小和位置 scroll 系列主要有 : scrollWidth、scrollHeight、scrollLeft、scrollTop scrollWidth 与 scrollHeight scrollWidth 与 scrollHeight 是盒子内容的宽度和高度。与盒子大小无关，仅仅与盒子的内容有关系（padding + 内容） 如果内容没有溢出，scrollHeight 就是盒子高度 (scrollWidth 同理) &#x3D;&gt; 与 clientHeight、clientWidth 相同 如果内容超过盒子，scrollHieght 就是内容高度 (scrollWidth 同理) scrollTop scrollTop 用于获取内容垂直滚动的像素数。如果没有滚动条，那么 scrollTop 值是 0 内容超过盒子，盒子设置 overflow: scroll 就可出现滚动条 此属性是可读写的 scrollLeft scrollLeft 用于获取内容水平滚动的像素数 此属性是可读写的 浏览器切忌这种出现水平滚动条，用户体验极差，避免 scrollX 与 scrollY 只读属性 scrollY：文档在垂直方向已滚动的像素值pageYOffset 属性是 scrollY 属性的别名为了跨浏览器兼容，请使用 window.pageYOffset 代替 window.scrollY onscroll 事件 对于有滚动条的盒子，可以使用 onscroll 注册滚动事件，每滚动一像素，就会触发该事件 var div = doucment.getElementById(&#x27;div&#x27;)div.onscroll = function() &#123; console.log(div.scrollLeft) console.log(div.scrollTop)&#125; 场景 : 获取页面被卷去的高度和宽度 通常来说，scroll 家族用的最多的地方就是用来获取页面 被卷去的高度，非常的常用 对于老式的浏览器，需要获取 html 或者 body 的 scrollTop 对于现在浏览器，使用 window.pageYOffset 进行获取 页面被卷去的高度和宽度的兼容性封装 // 给整个页面注册滚动事件document.onscroll = function() &#123; var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0 console.log(scrollLeft, scrollTop)&#125; [案例 : 固定导航案例] client 家族 clien t 家族用于获取盒子可视区的大小 (内容 + padding) client 家族有 clientWidth、clientHeight、clientLeft、clientTop clientWidth、clientHeight 可视区宽高 clientTop 与 clientLeft 完全没有用，他们就是 borderTop 与 borderLeft onresize 事件：onresize 事件会在窗口被调整大小的时候发生。 window.onresize = function() &#123; // 事件处理程序&#125; 场景 : client 系列一般用来获取页面的可视区宽高 低版本浏览器 : 获取的 html 和 body 高版本的浏览器 : window.innerWidth (掌握)（只读属性） // 因为求的是窗口大小所以用 windowwindow.onresize = function() &#123; var W = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth console.log(W) var H = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight console.log(H)&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"webapi","slug":"webapi","permalink":"https://wqdy.top/tags/webapi/"}]},{"title":"sublime 插件、快捷键","slug":"其他/sublime-插件、快捷键","date":"12/09/2018","updated":"12/09/2018","comments":true,"path":"428.html","link":"","permalink":"https://wqdy.top/428.html","excerpt":"","text":"插件 Sublime Tutor ：键盘快捷方式教程Help &gt; Sublime Tutor AlignTab ：自定义快捷键 快捷键 Ctrl + X 如果已经选中文本，则剪切该文本。如果未选中任何文本，则剪切光标所在行 Ctrl + Z 撤消 Ctrl + Shift + V 缩进粘贴 Ctrl + Shift + Z 或 Ctrl + Y 恢复 Ctrl + L Select line - Repeat to select next lines Ctrl + D Select word - Repeat select others occurrences Ctrl + Shift + D 如果已经选中文本，则复制该文本。如果未选中任何文本，则复制光标所在行 Ctrl + Enter Insert line after Ctrl + Shift + Enter Insert line before Alt + F3 选择所有相同单词的实例 Tab 或 Ctrl + ] 缩进 Shift + Tab 或 Ctrl + [ 取消缩进 Ctrl + Shift + K Delete Line Ctrl + KK Delete from cursor to end of line Ctrl + K + Backspace Delete from cursor to start of line Alt + Shift + W 使用标签包裹选中部分 Ctrl + ← 移动光标至上一个词 Ctrl + → 移动光标至下一个词 Ctrl + Shift + ↓ Move line&#x2F;selection down Ctrl + Shift + ↑ Move line&#x2F;selection up Home 移动光标至行首 End 移动光标至行尾 Ctrl + Home 移动光标至文档开头 Ctrl + End 移动光标至文档结尾 Ctrl + M 跳转到左&#x2F;右圆括号、方括号、大括号 Ctrl + Shift + M 选择括号内的内容 Ctrl + R 跳转到定义 Ctrl + / Comment&#x2F;un-comment current line Ctrl + Shift + / Block comment current selection Ctrl + N 新建标签 Ctrl + PgUp 向左切换标签 Ctrl + PgDn 向右切换标签 Ctrl + W 关闭标签 Ctrl + Shift + T 重新打开标签 Shift + 鼠标右键 竖向选择 Ctrl + Shift + &#39; 选择与光标关联的开始和结束标签 Ctrl + Shift + A 选择容器内内容 Ctrl + Shift + ; 移除与你的光标相关的父标签(清除标记) Ctrl + Shift + Y 计算数学表达式 Alt + ↓&amp;↑ 以 0.1 的步长改变数字 Alt + Shift + ↓&amp;↑ 以 10 的步长改变数字 Ctrl + ↓&amp;↑ 以 1 的步长改变数字 Ctrl+K+U Ctrl+K+L 改变大小写 http://sublime.emptystack.net/ issues “Error: 404 Not FoundSorry, the requested URL ‘http://127.0.0.1:51004/view/29&#39; caused an error:‘buffer_id(29) is not valid (closed or unsupported file format)’NOTE: If you run multiple instances of Sublime Text, you may want to adjust the server_port option in order to get this plugin work again.” Quick Fix 1: Remove Strikethrough Extension Sublime Text &gt; Preferences &gt; Package Settings &gt; OmniMarkupPreviewer &gt; Settings - Userpaste the following to remove the strikeout package. &#123; &#x27;renderer_options-markdownrenderer&#x27;: &#123; &quot;extensions&quot;:[&quot;tables&quot;,&quot;fenced_code&quot;,&quot;codehilite&quot;] ; &#125;&#125; Quick Fix 2: Fix the Strikethrough Extension (if you need it) Find the python-markdown sublime package. /Packages/OmniMarkupPreviewer/OmniMarkupLib/Renderers/libs/mdx_strikeout.py Replace the makeExtension() method with the following: def makeExtension(*args, **kwargs): return StrikeoutExtension(*args, **kwargs)Save, quit and reload Sublime Text.","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://wqdy.top/tags/sublime/"}]},{"title":"Markdown 语法","slug":"其他/markdown-语法","date":"12/09/2018","updated":"12/09/2018","comments":true,"path":"426.html","link":"","permalink":"https://wqdy.top/426.html","excerpt":"","text":"Markdown 基本语法待… Markdown 使用技巧换行 方法 1：连续两个以上空格+回车 方法 2：使用 html 语言换行标签：&lt;br&gt; 居中 使用 align 属性 使用&lt;center&gt;标签（HTML5 不支持） 首行缩进两个字符 &amp;nbsp; 不换行空格，全称 No-Break Space &amp;ensp; 半角的空格，全称是 En Space &amp;emsp; 全角的空格，全称是 Em Space，占据的宽度正好是 1 个中文宽度 字体 *斜体*或_斜体_ **粗体** ***加粗斜体*** ~~删除线~~ 字号与颜色：使用内嵌 HTML &lt;font color=&quot;#0099ff&quot; size=&quot;3&quot; face=&quot;黑体&quot;&gt;color=#0099ff size=3 face=&quot;黑体&quot;&lt;/font&gt; 效果：color&#x3D;#0099ff size&#x3D;3 face&#x3D;”黑体” 背景色使用内嵌 HTML 借助 table，tr，td 等表格标签的 bgcolor 属性 &lt;table&gt; &lt;tr&gt;&lt;td bgcolor=&quot;orange&quot;&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果：背景色是：orange 分割线在一行中用三个以上的星号 * 、减号 - 、底线 _ 来建立一个分隔线，中间用空格隔开，行内不能有其他东西。（除第一个符号的左侧最多添加三个空格外三个相同符号两侧可以添加任意多个空格） 链接文字 行内式：[文字](url &quot;title&quot;) 参考式：[文字][1] [1]:url &quot;title&quot; 自动链接：&lt;url&gt;，将链接用&lt;&gt;包起来，Markdown 会自动把它转成链接。 图片： 行内式：![alt_text](url &quot;title&quot;) alt_text：图片的 alt 标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于 SEO，可以方便搜索引擎根据 alt_text 里面的关键词搜索到图片。 url：可以是图片的本地地址或者是网址。”title”：鼠标悬置于图片上会出现的标题文字，可以不写。 参考式：同上 使用 img 标签：&lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;，&lt;div align=center&gt;&lt;/div&gt; 实现居中 折叠按钮&lt;details&gt; &lt;summary&gt; 点击展开 &lt;/summary&gt; &lt;!-- 内部展示内容 --&gt;&lt;/details&gt; 点击展开 设置小三角样式： summary::-webkit-details-marker &#123; color: #42b983;&#125; Markdown 编辑器typora","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://wqdy.top/tags/markdown/"}]},{"title":"git 版本控制系统","slug":"其他/git-版本控制系统","date":"12/09/2018","updated":"12/09/2018","comments":true,"path":"421.html","link":"","permalink":"https://wqdy.top/421.html","excerpt":"","text":"为什么要有版本控制系统在开发过程中，经常需要对一个文件进行修改甚至删除，但是我们又希望能够保存这个文件的历史记录，如果通过备份，那么管理起来会非常的复杂 什么是版本控制系统 版本控制系统（Version Control System）:是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。 版本控制系统的分类参考文章：关于版本控制的介绍 本地版本控制系统 本地版本控制系统就是在一台机器上，记录版本的不同变化，保证内容不会丢失 如果多人开发，每个人都在不同的系统和电脑上开发，没办法协同工作。 集中式版本控制系統 svn 是集中式的版本控制系统，集中式版本控制系统都有一个单一的集中管理的服务器（中央服务器），保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 需要一个中央服务器来管理代码的的版本和备份 所有的用户电脑都是从中央服务器获取代码或者是将本地的代码提交到中央服务器 依赖与网络环境，如果连不上中央服务器，就无法提交和获取代码。 分布式版本控制系统 git 是分布式的版本控制系统。分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份 需要一台服务器作为代码仓库 每个用户电脑都是一个服务器（代码仓库），并且和代码仓库是镜像的，用户修改和获取代码都是提交到自己的服务器当中。 不需要网络就可以进行工作。 当连接网络时，用户可以选择将自己的服务器与代码仓库进行同步。 Gitgit 官方中文文档 Git 核心概念 **WorkSpace**：工作区，即从仓库中 checkout 出来的，需要通过 Git 进行版本控制的目录和文件，可以简单的理解为在电脑里真实看到的文件 **Stage(Index)**：暂存区，或者叫做待提交更新区；在提交进入 Repository 之前，可以把所有的更新放在暂存区, 用 git add 的文件都在这里 **Repository(Remote/Local)**：仓库，一个存放在远端&#x2F;本地的版本库，用 git commit 提交的文件就到 Local Repository,用 git push 提交的文件就到 Remote Repository **.git**：存放 Git 管理信息的目录，初始化仓库的时候会自动创建 Git 初始设置设置用户名和邮箱# 用户名使用英文# --global 全局设置git config --global user.name &#x27;your_name&#x27;git config --global user.email &#x27;your_email@example.com&#x27;# 查看账号信息git config --list# 重置信息git config --unset -- user.name 全局设置会在 ~/.gitconfig 中以如下形式输出设置文件，可以直接编辑这个文件来修改设置 [user]name = your_nameemail = your_email@example.com 每个仓库的 Git 配置文件都放在 .git/config 文件中，可以直接修改此文件$ cat .git/config 查看配置文件 # 解决中文变成数字加百分号，也可以在设置中将编码修改为 utf-8git config --global core.quotepath false 设置 SSH KeyGitHub 上连接已有仓库时的认证，是通过使用了 SSH 的公开密钥认证方式进行的。现在我们来创建公开密钥认证所需的 SSH Key，并将其添加至 GitHub 运行下面的命令 ssh-keygen -t rsa -C &quot;your_email@example.com&quot;Generating public/private rsa key pair.Enter file in which to save the key(/Users/your_user_directory/.ssh/id_rsa):按回车键Enter passphrase (empty for no passphrase):输入密码Enter same passphrase again:再次输入密码 输入密码后会出现以下结果 Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa.Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub.The key fingerprint is:SHA256:hbn1zPihlVDe/Y2FvzzZU8l+AOSlVRlaOmro/nTQDGg cui3155@gmail.com(fingerprint值+your_email@example.com)The key&#x27;s randomart image is:+---[RSA 2048]----+| o o++|...| . . . +|| ... |+----[SHA256]-----+ id_rsa 文件是私有密钥，id_rsa.pub 是公开密钥 添加公开密钥在 GitHub 中添加公开密钥，今后就可以用私有密钥进行认证了点击右上角的账户设定按钮（Account Settings），选择 SSH Keys 菜单。点击 AddSSH Key 之后，在 Title 中输入适当的密钥名称。Key 部分请粘贴 id_rsa.pub 文件里的内容 id_rsa.pub 的内容可以用如下方法查看 cat ~/.ssh/id_rsa.pubssh-rsa公开密钥的内容your_email@example.com 完成以上设置后，就可以用手中的私人密钥与 GitHub 进行认证和通信了 ssh -T git@github.comThe authenticity of host &#x27;github.com (192.30.255.113)&#x27; can&#x27;t be established.RSA key fingerprint is (fingerprint值).Are you sure you want to continue connecting (yes/no)?输入yesWarning: Permanently added &#x27;github.com,192.30.255.113&#x27; (RSA) to the list of known hosts.Enter passphrase for key &#x27;/c/Users/C.DESKTOP-3S4APJ4/.ssh/id_rsa&#x27;: 出现如下结果即为成功 Hi cuilongjin! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 提高命令输出的可读性将 color.ui 设置为 auto 可以让命令的输出拥有更高的可读性 git config --global color.ui true ~/.gitconfig 中会增加下面一行 [color]ui = true 这样一来，各种命令的输出就会变得更容易分辨。 文件名大小写问题git 默认对文件名大小写不敏感 # 设置 git 大小写敏感git config core.ignorecase false# 或者先删除文件在添加进去 设置头像通过 Gravatar 服务 配置别名# 配置 st 别名表示 statusgit config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branchgit config --global alias.unstage &#x27;reset HEAD&#x27;git config --global alias.last &#x27;log -1&#x27;git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot; 搭建 Git 服务器搭建 Git 服务器 配置多用户根据不同邮箱生成对应的私钥公钥 ssh-keygen -t rsa -C email 将公钥上传到对应的用户账号中 在 .ssh 目录创建 config 文件，配置私钥对应的服务器，每个账号单独配置一个 Host，每个 Host 要取一个别名，每个 Host 主要配置 HostName 和 IdentityFile 两个属性即可 # 配置用户1Host githubHostName github.comIdentityFile ~/.ssh/id_rsa_githubUser cuilongjin# 配置用户2Host gitlabHostName git.gitlab.netIdentityFile ~/.ssh/id_rsa_gitlabUser cuilongjin Host 的名字可以任意，不过这个会影响 git 相关命令，例如： Host mygithub 这样定义的话，命令如下 git clone git@mygithub:cuilongjin/cuilongjin.git 即 git@ 后面紧跟的名字改为 mygithub 执行 ssh -T git@github、ssh -T git@gitlab 测试是否成功 配置局部 git 用户名和邮箱，如果没有局部配置，默认用全局配置 git config user.name &quot;Your name&quot;git config user.email &quot;your_email@gmail.com&quot; 或者直接找到 .git/config 文件，添加 [user]name = Your nameemail = your_email@gmail.com Git 基本操作git initmkdir projectcd projectgit init 如果初始化成功，执行了 git init 命令的目录下就会生成 .git 目录。这个 .git 目录里存储着管理当前目录内容所需的仓库数据 mkdir project 命令创建 project 空文件夹 pwd 命令用于显示当前目录 git add# 将指定文件夹添加到暂存区（目录中的所有文件，包括新增/修改/删除的文件）--not-all 忽略删除的git add 目录名# 将 指定文件 添加到暂存区 （文件可以是新增/修改/删除的）git add README.md# 将当前目录下所有的js文件添加到暂存区（文件可以是新增/修改的，不包括删除的）git add *.js# 添加当前目录及子目录下件 （文件可以是新增/修改/删除的）git add .# 添加当前仓库下所有的文件 （文件可以是新增/修改/删除的）git add -Agit add --all git commit# 将文件从暂存区提交到仓库git commit -m &#x27;提交说明&#x27;# 如果是一个已经暂存过的文件，可以快速提交，如果是未追踪的文件，那么命令将不生效。git commit -a -m &#x27;提交说明&#x27;# 修改最近的一次提交说明， 如果提交说明不小心输错了，可以使用这个命令git commit --amend -m &#x27;提交说明&#x27; -m 参数后的 &#39;First commit&#39; 称作提交信息，是对这个提交的概述,如果想要记述得更加详细，请不加 -m ，直接执行 git commit 命令，执行后编辑器就会启动。在编辑器中记述提交信息的格式如下:​ 第一行：用一行文字简述提交的更改内容​ 第二行：空行​ 第三行以后：记述更改的原因和详细内容 git status# 建立 README.md 文件作为管理对象touch README.mdgit status# 简化日志输出格式git stauts -s (short) git status 命令可以让我们时刻掌握仓库当前的状态，但不能看到具体修改了什么内容，需要用 git diff 这个命令来查看具体修改内容。 git diff# 查看当前工作树和最新add之间（暂存区）的差别（difference）git diff# 如果尚未用 `git add` 命令向暂存区添加任何东西，则程序只会显示工作树与最新提交状态之间的差别# “+”号标出的是新添加的行，被删除的行则用“-”号标出#查看README.md文件的修改git diff -- README.md# 查看工作树和最新提交的差别git diff HEAD# 查看暂存区与仓库区的不同git diff --cached# 查看两个版本之间的不同git diff c265262 de4845b HEAD 是指向当前分支中最新一次提交的指针 git log# 显示当前版本之前的提交信息git logcommit 9f129bae19b2c82fb4e98cde5890e52a6c546922Author: cuilongjin &lt;cuilongjin@gmail.com&gt;Date: Sun Oct 8 22:08:39 2017 +0900 First commit# 只显示提交信息的第一行git log --pretty=oneline # 完整显示版本号git log --oneline # 只显示前7位版本号# 显示指定目录、文件的日志git log 目录名或文件名# 显示文件的改动（q键退出命令）git log -p 文件名# 显示所有曾经提交的版本（包括被删除的）git reflog# 图表形式显示git log --graph --pretty=&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an %ae&gt;%Creset&#x27; git resetgit reset -h &#x27;查看帮助&#x27;--mixed &#x27;reset HEAD and index&#x27;(默认)--soft &#x27;reset only HEAD&#x27;--hard &#x27;reset HEAD, index and working tree&#x27;--merge &#x27;reset HEAD, index and working tree&#x27;--keep &#x27;reset HEAD but keep local changes&#x27; HEAD 表示当前版本，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^ ，当然往上 100 个版本写 100 个^比较容易数不过来，所以写成 HEAD~100 使用 commit_id 回退 , git reflog 用来记录你的每一次命令和 commit_id git reset --soft HEAD^git reset --hard commit_idgit reset HEAD [file] git checkout –filegit checkout -- README.md 把 README.md 文件在 工作区的修改全部撤销 ，用版本库里的版本替换工作区的版本 这里有两种情况： 一种是 README.md 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态 一种是 README.md 已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态 总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态，可用于撤销文件修改或恢复误删文件 git remotegit remote add origin git@github.com:cuilongjin/git_test.git 添加后，远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库 # 查看远程库的信息git remote -vorigin git@github.com:cuilongjin/git_test.git (fetch)origin git@github.com:cuilongjin/git_test.git (push)# 查看指定远程库的详细信息git remote show &lt;远程库&gt; 上面显示了可以抓取和推送的 origin 的地址。如果没有推送权限，就看不到 push 的地址 # 删除已有的 GitHub 远程库git remote rm origin# 修改远程库名称git remote rename &lt;原远程库名&gt; &lt;新远程库名&gt; git pull# 获取远程仓库的更新，并且与本地的分支进行合并git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;# 如果远程分支是与当前分支合并，则冒号后面的部分可以省略git pull origin next 等同于 git fetch origin &amp;&amp; git merge origin/next# 远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支# 加上参数 -p 就会在本地删除远程已经删除的分支$ git pull -p# 等同于下面的命令$ git fetch --prune origin$ git fetch -p# 合并 pull 两个不同的项目出现 fatal: refusing to merge unrelated historiesgit pull origin master ----allow-unrelated-histories git pushgit push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 第一次推送分支时，加上 -u 参数，git 会把本地分支和远程分支关联起来，在以后的推送或者拉取时就可以简化命令git push -u origin master# 如果没有本地分支，表示删除远程分支git push origin :master# 等同于$ git push origin --delete master# 以强制覆盖的方式推送修改后的 repo （重新上传 repo）（不指定分支即所有分支）git push origin --force --all remote: error: GH007: Your push would publish a private email address.解决方法——http://github.com/settings/emails 把 Keep my email address private 这一项去掉勾选即可。 如果推送失败，则因为远程分支比你的本地更新，需要先用 git pull 拉取远程的新提交 git clonegit clone git@github.com:cuilongjin/仓库名.git [指定文件夹]# 默认远程主机为 origin ， -o 指定主机名git clone --o origin1 git@github.com:cuilongjin/仓库名.git Git 支持多种协议，包括 https，但通过 ssh 支持的原生 git 协议速度最快 从远程库 clone 时，默认情况下，只能看到本地的 master 分支要在 dev 分支上开发，就必须创建远程 origin 的 dev 分支到本地，于是用这个命令创建本地 dev 分支 git checkout -b dev origin/dev# 指定本地 dev 分支与远程 origin/dev 分支的链接git branch --set-upstream dev origin/dev 克隆指定分支 # git clone -b|--branch 分支名或tag名 仓库地址 git fetch# 将某个远程仓库的更新，全部取回本地。默认取回所有分支（branch）的更新git fetch &lt;远程仓库&gt;# 取回特定分支的更新git fetch &lt;远程仓库&gt; &lt;分支名&gt; git fetch 和 git pull 区别 git pull 获取远程仓库的更新，并且与本地的分支进行合并 git fetch 所取回的更新，在本地主机上要用 “远程仓库&#x2F;分支名” 的形式读取，即不会与本地分支合并 git 忽视文件在仓库中，有些文件是不想被 git 管理的，比如数据的配置密码、写代码的一些思路等。git 可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 .class 文件 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件 在仓库的根目录创建一个 .gitignore 的文件，文件名是固定的 将不需要被 git 管理的文件路径添加到 .gitignore 中，把 .gitignore 也提交到 Git，Git 就会自动忽略这些文件 # 忽视 index.txt 文件index.txt# 忽视 .gitignore 文件.gitignore# 忽视 css 下的 index.css 文件css/index.css# 忽视 css 下的所有的 css 文件css/*.css# 忽视 css 下的所有文件css/*.*# 忽视 css 文件夹css GitHub 已经为我们准备了各种配置文件 https://github.com/github/gitignore 强制添加被 .gitignore 忽略的文件 # 强制添加被.gitignore忽略的文件git add -f &lt;file&gt;# 检查哪个规则忽略了此文件，以便修订规则git check-ignore -v &lt;file&gt;.gitignore:x:xxx.xx xxxxxx git branch在 git 中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。git 中使用 HEAD 指向当前分支 git branch* master-r 参数查看远程分支-a 查看所有分支(远程分支会用红色表示出来) *（星号）表示当前所在的分支 git checkout -b 创建、切换分支 # 以 branch 为基础创建名为 feature-A 的分支git checkout -b feature-A &lt;branch&gt; 连续执行下面两条命令也能收到同样效果 # 创建 feature-A 分支git branch feature-A# 将当前分支切换为 feature-A 分支git checkout feature-A# 切换回上一个分支git checkout - git branch -d 删除分支 # 删除本地 feature-A 分支git branch -d feature-A# 强行删除本地 feature-A 分支git branch -D feature-A# 删除远程 feature-A 分支git push origin :feature-A或 git push origin --delete feature-A git branch -m 重命名分支 # 重命名本地分支git branch -m old_branch new_branch# 重命名远程分支# 重命名本地分支 -&gt; 删除远程分支 -&gt; 推送到远程分支 git merge合并分支 # 将 feature-A 合并到 master 上# 首先切换到 master 分支，然后执行git merge [--squash] [--no-ff] -m &quot;描述&quot; feature-A--squash # 只是将&lt;branch&gt;中的修改内容迁移过来，而不保留其中的commit历史--no-ff # 创建合并提交，为了在历史记录中明确记录下本次分支合并 git stash# 把当前工作现场“储藏”起来git stash# 查看存储的工作现场git stash list 恢复工作现场 # 恢复工作现场，stash 内容并不删除git stash apply# 删除 stash 内容git stash drop# 恢复的同时把 stash 内容也删了git stash pop 恢复指定的 stash，用命令：git stash apply stash@&#123;0&#125; 廖雪峰 Git 教程创建与合并分支 廖雪峰 Git 教程分支管理策略 廖雪峰 Git 教程 Bug 分支 git tag 创建标签 # 首先切换到需要打标签的分支上# 默认标签是打在最新提交的 commit 上的git tag v1.0# 对指定某一次提交打标签git tag v1.0 &lt;commit id&gt;# 创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字git tag -a v1.0 -m &quot;version1.0 released&quot; &lt;commit id&gt;# 通过 -s 用私钥签名一个标签(需配置gpg密钥对)git tag -s v1.0 -m &quot;signed version1.0 released&quot; &lt;commit id&gt; 查看标签 # 查看所有标签git tagv1.0# 查看所有标签信息git show# 查看 v1.0 标签信息git show v1.0commit id:xxxAuthor:xxxDate:xxx 推送标签到远程 # 推送 v1.0 标签到远程git push origin v1.0# 推送全部尚未推送的本地标签到远程git push origin --tags 删除标签 # 删除本地标签 v1.0git tag -d v1.0# 删除远程标签 v1.0git push origin :refs/tags/v1.0或 git push origin --delete tag v1.0 git 仓库分离将一个 git 仓库里的一部分文件转出作为一个独立的仓库并保留提交记录 commit log # 这就是那个大仓库 big-projectgit clone git@github.com:**/big-project.gitcd big-project# 把所有 `source/page` 目录下的相关提交整理为一个新的分支 pagegit subtree split -P source/page -b page# 另建一个新目录并初始化为 git 仓库mkdir ../pagecd ../pagegit init# 拉取旧仓库的 page 分支到当前的 master 分支git pull ../big-project page 快速克隆大项目克隆单个分支 git clone --branch &lt;branch_name&gt; &lt;remote-address&gt; 只克隆最新的提交记录 git clone &lt;remote-address&gt; --depth 1 – depth 代表克隆的深度，–depth 1 代表只克隆最新一次提交记录以及这次提交之后的最新内容，不克隆历史提交，所造成的影响就是不能查看历史提交记录 克隆单个分支的最新一次提交 git clone --branch &lt;branch_name&gt; &lt;remote-address&gt; --depth 1 git 修改提交历史修改最后一条 commit git commit --amend 修改多条 commit git rebase -i HEAD~3 修改最近三次提交git rebase -i --root 修改所有提交git rebase -i [startpoint] [endpoint] 指定了一个编辑区间（不包含[startpoint]），如果不指定[endpoint]，则该区间的终点默认是当前分支 HEAD 所指向的 commit# edit 模式下git commit --amend --author=&quot;author &lt;email&gt;&quot; # 修改提交人信息git commit --amend --date=&quot;commit_time&quot; # 修改时间 时间格式 Sat, 24 Dec 2016 18:12:09 +0800 Commands p, pick &#x3D; use commit: 直接使用 commit 不做任何修改，其中 p 是 pick 的缩写，以下雷同 r, reword &#x3D; use commit, but edit the commit message: 使用 commit，修改 commit 注释 e, edit &#x3D; use commit, but stop for amending :使用 commit，但是遇到此命令时会停止合并，可以修改提交信息 s, squash &#x3D; use commit, but meld into previous commit: 使用 commit，但是会合并到前一个 commit 中，默认保留所有的 commit 注释，并变为可以修改状态 f, fixup &#x3D; like “squash”, but discard this commit’s log message：和 squash 类似，但是会抛弃 commit 的 log 信息 x, exec &#x3D; run command (the rest of the line) using shell：使用 shell 运行命令 d, drop &#x3D; remove commit：丢弃 commit，（并删除该提交所做的修改） https://www.jianshu.com/p/67f20d19605a git-bisectgit 有一个以二分法帮助定位问题的命令——bisect。 # 开始二分查找问题git bisect start# 标记当前有问题git bisect bad# 标记哪个 commit 或 tag 时是没问题的git bisect good v1.0.0# 此时 git 会 checkout 两个点之间的某个 commit，# 如果此时还是有问题：git bisect bad# 如果此时没有问题：git bisect good# 接着 git 会 checkout 下一个「有问题」和「没问题」之间的 commit# 直到定位到问题，git 会提示：xxxxxxx is first bad commit 参考：https://git-scm.com/book/zh/v2/Git-工具-使用-Git-调试 git filter-branch彻底删除不需要的文件 # 删除 ./node_modules 目录git filter-branch -f --prune-empty --index-filter &quot;git rm --cached --ignore-unmatch -fr ./node_modules&quot; -- --all 修改提交用户名 git filter-branch -f --env-filter &quot;GIT_AUTHOR_NAME=your new author name&quot; -- --all 修改提交邮箱 git filter-branch -f --env-filter &quot;GIT_AUTHOR_EMAIL=your new author email&quot; -- --all othergit add .的时候遇到warning: LF will be replaced by CRLF in ……&#96;git config core.autocrlfgit config --global core.autocrlf false# true：添加文件到git仓库时，git将其视为文本文件。他将把crlf变成lf# false：line-endings将不做转换操作。文本文件保持原来的样子# input：把crlf转成lf，当有人Check代码时还是lf方式。因此在window操作系统下，不要使用这个设置# CRLF (carriagereturnlinefeed)：表示句尾使用回车换行两个字符(即Windows编程时使用&quot;\\r\\n&quot;换行)# LF(line feed)：表示句尾只使用换行(Unix Style)# CR：表示只使用回车 Git 永久删除文件(包括历史记录)https://help.github.com/articles/removing-sensitive-data-from-a-repository/ # 在仓库的根目录执行git filter-branch --force --index-filter &#x27;git rm --cached --ignore-unmatch 文件路径&#x27; --prune-empty --tag-name-filter cat -- --all# 文件路径相对于git仓库根目录# 删除文件夹 添加 -r 命令# 以强制覆盖的方式推送修改后的 repo （不指定分支即所有分支）（重新上传 repo）git push origin --force --all# 强制推送 tagsgit push origin --force --tags# 清理和回收空间rm -rf .git/refs/original/git reflog expire --expire=now --allgit gc --prune=nowgit gc --aggressive --prune=now 重新绑定，而不是合并创建的旧（受污染）存储库历史记录中的任何分支 git 修改已提交的某一次的邮箱和用户信息 git filter-branch -f --env-filter \\&quot;GIT_AUTHOR_NAME=&#x27;Newname&#x27;; GIT_AUTHOR_EMAIL=&#x27;newemail&#x27;; \\GIT_COMMITTER_NAME=&#x27;committed-name&#x27;; GIT_COMMITTER_EMAIL=&#x27;committed-email&#x27;;&quot; HEAD fork 的项目( A )与原项目 (B) 保持同步# 将 A 克隆到本地做中转# 添加 B 远程仓库地址并拉取git remote add update &lt;B 远程仓库地址&gt;git fetch update master:updated# 合并并解决冲突git merge updated# 也可以直接合并远程分支git merge update/master 远程分支删除以后，本地显示仍然存在的解决办法# 显示所有分支：git branch -a# 命令查看远程分支和本地分支的对应关系git remote show origin# 会看到refs/remotes/origin/&lt;branch&gt; stale (use &#x27;git remote prune&#x27; to remove)# 执行下面命令同步删除git remote prune origin或者git fetch -p","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wqdy.top/tags/git/"}]},{"title":"linux 入门","slug":"运维/linux-入门","date":"12/09/2018","updated":"12/09/2018","comments":true,"path":"1662.html","link":"","permalink":"https://wqdy.top/1662.html","excerpt":"","text":"宝塔面板 neofetch screenfetch netdata linux 系统性能监测工具 htop 系统状况监控 nano linux下文本编辑器 grafana linux 目录表&#x2F; 根目录 &#x2F;bin 、 &#x2F;usr&#x2F;bin 可执行二进制文件目录，如常用的命令 ls cat 等 &#x2F;boot 放置系统启动时用到的一些文件，如内核文件 &#x2F;dev 存放系统下的设备文件，访问该目录下的文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom/mnt &#x2F;etc 系统配置文件，重要的配置文件有 文件大小表示方式 单位 英文 字节 B (Byte) 千 K (KibiByte) 兆 M (MebiByte) 千兆 G (GigaByte) 太 T (TeraByte) 拍 P (PetaByte) 艾 E (ExaByte) 泽 Z (ZettaByte) 尧 Y (YottaByte) linux 常用命令 命令 作用 ls list 查看当前文件夹下的内容 pwd print work directory 查看当前所在文件夹 cd[目录名] change directory 切换文件夹 touch[文件名] touch 如果文件不存在，新建文件如果文件已经存在，修改文件的末次修改日期 mkdir[目录名] make directory 创建目录 rm[文件名] remove 删除指定的文件名 clear 清屏 ls 常用选项 -a 显示所有目录和文件，包括隐藏文件 $ ls -a. .. .xxx.txt# 以.开头的文件/文件夹为隐藏文件/文件夹# . 代表当前目录# .. 代表上一级目录# 蓝色为目录，白色为文件 -l 以列表方式显示文件的详细信息 -h 配合-l 以人性化的方式显示文件大小 选项可以合写，无顺序 $ ls -alh ls 通配符 * 代表任意个数个字符 ？代表任意一个字符 [] 表示可以匹配字符组中的任意一个 [abc] 匹配a、b、c 中的任意一个 [a-f] 匹配 a-f 任意一个字符 cd 常用选项 cd&#x2F;cd ~ 切换到当前用户的主目录 cd .. 切换到上一级目录 cd - 在最近两次工作目录间切换 mkdir -p 可以递归创建目录 $ madir -p a/b/c 同一目录下文件夹名称不能和文件名同名 rm 删除时直接删除，不放入回收站 -f 强制删除，忽略不存在的文件，无需提示 -r 递归的删除目录下的内容，或用于删除文件夹 终端命令格式$ command [-options][paramete] command : 命令名，相应功能的英文单词或单词缩写-options： 选项paramete ：参数 查阅帮助信息$ command --help$ man command# man 是manual缩写,手册# 使用man 时的操作键# 空格 显示手册的下一屏# enter 一次滚动手册页的一行# b 回滚一屏# f 前滚一屏# q 退出# /word 搜索word字符串 终端技巧 自动补全 在敲出 文件&#x2F;目录&#x2F;命令的前几个字母后，按下 tab 键 如果输入没有歧义，系统会自动补全 如果输入有歧义，再按一下 tab 键，系统会提示可能存在的命令 曾经使用过的命令 按上下键可在曾经使用过的命令间切换，Ctrl+c 退出选择 文件和目录常用命令拷贝和移动文件 tree [目录名]： 以树状图列出文件目录结构 -d 只显示目录，不显示文件 cp 源文件 目标文件： copy 复制文件或者目录 $ cp ~/Documemt/readme.txt ./readme.txt# 将 ~/Documemt/ 目录下的 readme.txt 文件复制到./目录下并以readme.txt命名# 如果不修改文件名，只需要写目标路径$ cp ~/Documemt/readme.txt ./ -i ：覆盖文件前提示 y 覆盖 n 不覆盖 -r ：若给出的源文件是目录文件，将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 mv 源文件 目标文件：move 移动文件或目录&#x2F; 文件或目录重命名 $ mv ~/Documemt/readme.txt ./# 将 ~/Documemt/ 目录下的 readme.txt 文件移动到./目录下$ mv readme.txt demo.txt# 将readme.txt文件名修改为demo.txt -i ：覆盖文件前提示 y 覆盖 n 不覆盖 查看文件内容 cat 文件名： concatenate 查看文件内容、创建文件、文件合并、追加文件内容等功能，会一次显示所有内容，适合内容较少的文本文件 -b：对非空输出行编号 -n：对输出的所有行编号 linux 中还有一个 nl 命令和 cat -b 的效果等价 more 文件名：分屏显示文件内容 ，按空格显示下一屏，适合查看内容较多的文本 # 使用 more 时的操作键 和 man 相同# 空格 显示手册的下一屏# enter 一次滚动手册页的一行# b 回滚一屏# f 前滚一屏# q 退出# /word 搜索word字符串 grep 搜索文本 文件名： 搜索文本文件内容，输出包含该文本的行 linux 中的文本搜索工具，允许对文本文件进行模式查找（正则表达式），如果搜索文本中间有空格可以使用引号包裹 -n 显示匹配行和行号 -v 显示不包含匹配文本的所有行（相当于求反） -i 忽略大小写 ^a 行首，搜索以 a 开头的行 ke$ 行尾，搜索以 ke 结束的行 其他 echo 文字内容 ：会在终端中显示参数指定的文本，通常会和重定向联合使用 重定向 &gt; 和 &gt;&gt;： linux 允许将命令执行结果重定向到一个文件，将本应显示在终端上的内容输出&#x2F;追加到指定文件中，保存命令输出结果 &gt; 表示输出，会覆盖文件原有的内容 &gt;&gt; 表示追加，会将文件追加到已有文件的末尾 # 创建 a 文件并将 “hello world”输出到 a 文件中 ，与touch区别$ echo hello world &gt; a# 将命令 “ls -lh” 的结果输出到 a 文件中$ ls -lh &gt; a 管道 | linux 允许将一个命令的输出通过管道作为另一个命令的输入，另一个命令对第一个命令的输出进行二次处理 可以理解为现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两端，左端塞东西（写），右端取东西（读） # more：分屏显示内容# 分屏显示命令 “ls -lha” 的输出结果$ ls -lha ~ | more# grep：在命令执行结果的基础上查询指定文本# 查找 “ls -lha ~” 的结果中包含Do的行并显示$ ls -lha ~ | grep Do 远程管理命令关机&#x2F;重启shutdown 选项 时间 `-r` 重新启动 不指定选项和参数，默认表示一分钟之后关闭电脑 远程维护服务器时，最好不要关闭系统，而应该重新启动系统 # 常用命令示例# 重新启动电脑，now 表示现在$ shutdown -r now# 系统在今天20:00 关机$ shutdown 20:00# 系统十分钟后自动关机$ shutdown +10# 取消关机计划$ shutdown -c 查看或配置网卡信息ifconfig: configure a network interface 查看&#x2F;配置计算机当前的网卡配置信息 # 查看网卡配置信息$ ifconfig# 查看网卡对应的IP地址$ ifconfig | grep inet 在 linux 中物理网卡通常以 ensxx 表示 127.0.0.1 本地环回&#x2F;环回地址，一般用来测试本机网卡是否正常 ping ip地址： ping 检测到目标 ip 地址连接是否正常 ping 127.0.0.1 检查本地网卡是否工作正常 远程登录和复制文件 ssh 用户名@ip ：secure shell 关机&#x2F;重新启动 scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径：secure copy 远程复制文件 SSH ：SSH 客户端是一种使用 Secure Shell (SSH) 协议连接到远程计算机的软件协议 数据传输是加密的，可以防止远程管理过程中的信息泄露，也能防止 DNS 欺骗和 IP 欺骗 数据传输是压缩的，可以提高传输速度 有关 ssh 配置信息都保存在用户家目录下的 .ssh目录下 域名和端口号域名：由一串用点分割的名字组成，例如 www.baidu.com ，是 IP 地址的别名，方便记忆 端口号：通过 IP 地址可以找到网络上的计算机，通过端口号可以找到计算机上运行的程序 SSH 服务器默认端口号为 22，Web 服务器为 80，HTTPS 为 443，FTP 服务器为 21，如果没有指定端口号，使用默认端口号 SSH 基本使用$ ssh [-p port] user@remote# user 远程服务器上的用户名，如果不指定默认当前用户# remote 远程机器的地址，可以是IP/域名，或者别名# port 是SSH server 监听的端口，如果不指定，默认22# 使用 exit 退出当前用户登录# ssh 在 linux 或 Unix 系统下可直接使用，win下需要安装软件 putty xshell scp 基本使用# 从远程服务器拷贝文件$ scp user@remoteip:文件名或路径 文件名或路径# -r 复制目录# -P 指定端口是要用大写的 P# 上传文件到服务器$ scp 文件名或路径 user@remote ip:文件名或路径 scp 命令只能在 Linux 或 Unix 下使用 在 win 系统中需安装 filezilla 使用 FTP 进行文件传输 FileZilla 传输文件时，使用的是 FTP 服务而不是 SSH 服务，因此端口号应该为 21 ssh 高级 免密码登陆 配置公钥：执行 ssh-keygen 即可生成 ssh 钥匙，一路回车即可 id_rsa.pub 公钥 、 id_rsa 私钥 上传公钥到服务器：执行 ssh-copy-id -p port user@remote，公钥保存在服务器 .ssh 目录下 authorized_keys 本地使用私钥对数据进行加密&#x2F;解密，服务器使用公钥对数据进行加密&#x2F;解密 非对称加密算法 使用公钥加密的数据，需要使用私钥解密 使用公私钥加密的数据，需要使用公钥解密 配置别名 ~/.ssh/config Host vultr HostName ip地址 User root port 22 直接使用 ssh vultr 即可实现登陆，scp 同样适用 修改 ssh 配置允许自定义工具连接服务器# 切换到 root 角色sudo -i# 修改 SSH 配置文件 /etc/ssh/sshd_configvi /etc/ssh/sshd_config# 修改PermitRootLogin yes # 开启root用户访问PasswordAuthentication yes # 开启密码登陆# 给root用户设置密码passwd root# 重启SSH服务使修改生效service sshd restart 用户和权限的相关命令用户和权限的基本概念 用户管理包括 用户 和 组 管理 在 linux 中可以指定每一个用户针对不同的文件或目录不同的权限 对文件&#x2F;目录的权限包括 权限 英文 缩写 数字代号 读 red r 4 写 write w 2 执行 excute x 1 无 - 0 组：实际工作中，可以预先对组设置好权限，然后将不同的用户添加到不同的组中（简化了用户权限设置） # ls -l 扩展$ ls -l-rw-rw-r-- 1 用户名 组名 大小 时间 名称drwxrwxr-x 2 - rw- rw- r– 1 用户名 组名 d rwx rwx r-x 2 文件&#x2F;目录 当前用户权限 当前组所对应的权限 其他用户权限 硬链接数 硬链接数：表示有多少种方式可以访问到当前目录&#x2F;文件，文件的硬链接数通常为 1，目录的硬链接数取决于该目录有多少个子目录。 修改文件&#x2F;目录权限 chmod$ chmod +/-rwx 文件名|目录# + 增加权限 - 删除权限# 直接修改文件/目录的读、写、执行权限，但不能精确到 拥有者/组/其他$ chmod +x 文件名 // 增加文件可执行权限$ chmod -r 目录 // 删除目录可读权限# 目录的可读权限：读取目录内容（如果没有此权限，可cd，不能ls）# 目录的可写权限：修改目录内容# 目录的可执行权限：对目录执行终端命令（如果没有此权限，甚至无法 cd 到目录） chmod 高级用法 超级用户 root 账户用于系统的维护和管理，对操作系统的所有资源具有所有访问权限 不推荐直接使用 root 账户登录系统 在 linux 安装过程中，系统会自动创建一个标准用户账号 sudo su 是 substitute user 缩写，表示使用另一个用户身份 sudo 命令用来以其他身份来执行命令，预设身份为 root 用户使用 sudo 时，需先输入密码，之后有五分钟的有效期，超过期限去重新输入密码 组管理groupadd 组名 ：添加组 groupdel 组名 ：删除组 cat /etc/group ：确认组信息 chgrp 组名 文件/目录名 ：修改文件&#x2F;目录的所属组 -R 递归修改 创建组&#x2F;删除组的终端命令都需要通过 sudo 来执行 组信息保存在 &#x2F;etc&#x2F;group 文件中 &#x2F;etc 目录是专门用来保存 系统配置信息的目录 用户管理创建用户&#x2F;设置密码&#x2F;删除用户 useradd -m -g 组 新建用户名 ：添加新用户 ​-m 自动建立用户家目录 ​-g 指定用户所在的组，否则会建立一个和用户名同名的组 passwd 用户名：设置用户密码 ​ 如果是普通用户，直接用 passwd 可以修改自己的账户密码 userdel -r 用户名：删除用户 ​-r 选项自动删除用户家目录 cat /etc/passwd | grep 用户名：确认用户信息 ​ 新建用户后，用户信息保存在 /etc/passwd 文件中 创建用户&#x2F;删除用户&#x2F;修改其他用户密码 的命令都需要通过 sudo 执行 用户信息保存在 /etc/passwd 文件中 查看用户信息 id [用户名]：查看用户 UID 和 GID 信息 who ：查看当前所有登陆的用户列表 $ who用户名 时间 (:0) # :0 表示当前电脑用户名 时间 (172.16.xx.xx) whoami ：查看当前登录用户的账户名 passwd 文件 由六个分号组成七个信息 用户名 密码（x，表示加密的密码） UID（用户标识） GID（组标识） 用户全名 家目录 登录使用的 shell，就是登陆之后使用的终端，ubuntu 默认使用 dash usermod 用来设置用户的主组&#x2F;附加组 和登录 shell 主组：在用户新建时指定，在 etc/passwd 的第四列 GID 对应的组 附加组：在 etc/group 中最后一列表示该组的用户列表，用于指定用户的附加权限 设置用户的附加组之后，需要重新登录才能生效 # 修改用户的主组$ usermod -g 组 用户名# 修改用户的附加组$ usermod -G 组 用户名# 修改用户登录shell$ usermod -s /bin/bash 默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，使用以下命令将用户添加到 sudo 附加组中 usermod -G sudo 用户名 which /etc/passwd 是用于保存用户信息的文件 /usr/bin/passwd 是用于修改用户密码的程序 # which 可用于查看执行命令所在的位置$ which ls# /bin/ls$ which useradd# /usr/sbin/useradd cd 这个命令是内置在系统内核中的，没有独立文件，因此用 which 无法找到 bin 和 sbin /bin (binary) 是二进制执行文件目录，主要用于具体应用 /sbin (system binary) 是系统管理员专用的二进制文件目录，主要用于系统管理 /usr/bin (user commands for applications) 后期安装的一些软件 /usr/sbin (super user commands for applications) 超级用户的一些管理程序 bin 存储普通可执行文件，sbin 存储跟系统管理相关的可执行文件 切换用户su - 用户名：切换用户，并且切换目录 - 可以切换到用户家目录，否则保持位置不变 exit： 退出当前登录用户 su 不接用户名，可以切换到 roo，不推荐，不安全 exit 示意图： 修改文件权限chowm 修改拥有者 chgrp 修改组 chmod 修改权限 # 修改文件/目录的拥有者$ chown 用户名 文件名/目录名# 递归修改文件/目录的组$ chgrp -R 组名 文件名/目录名# 递归修改文件权限# 755 三个数字分别代表 用户 u /组 g /其他用户 o 的权限$ chmod -R 755 文件名/目录名 r –&gt; 4 w –&gt; 2 x –&gt; 1 无权限 –&gt; 0 ，想要什么权限直接将数字相加 系统信息相关命令 查询服务器上当前系统日期和时间 &#x2F; 磁盘空间占用情况 &#x2F; 程序执行情况 时间和日期date ：查看系统时间 cal ：calendar 查看日历， -y 选项可以查看一年的日历 磁盘和空间目录df -h ：disk free 显示磁盘剩余空间 -h 以人性化的方式显示文件大小 du -h [目录名] ：disk usage 显示目录占用空间情况，不指定目录默认表示当前目录 -h 以人性化的方式显示文件大小 进程信息PID 进程代号 ps au : process status 查看进程的详细状况，默认只显示当前用户通过终端启动的程序 ​ps 选项(没有减号) ​a 显示终端上的所有进程，包括其他用户的进程 ​u 显示进程的详细状态 ​x 显示不是通过终端启动的进程 top : 动态显示运行中的进程并且排序 ，输入 q 退出 kill [-9] 进程代号 : 终止指定代号的进程，-9 表示强行终止 其他命令查找文件find [路径] -name “*.txt” : 查找指定路径下扩展名为.txt 的文件，包括子目录 ​ 如果省略路径，表示在当前文件夹下查找 软连接ln -s 被链接的源文件 链接文件 ：建立文件的软链接，类似于 Windows 下的快捷方式 注意： 如果没有 -s 选项建立的是一个硬链接文件（两个文件占用相同大小的磁盘空间，几乎不用） 源文件要使用绝对路径，可以方便移动链接文件后，仍然能够正常使用 文件软硬链接示意图 在 linux 中文件名和文件的数据是分开存储的 在 linux 中，只有文件的硬链接数为 0 文件才会被删除 在日常工作中几乎不会建立文件的硬链接 打包和解包tar 是 Linux 中常用的备份工具，此命令可以把一系列文件打包到一个大文件中，也可以把一个打包的大文件恢复成一系列文件 # 打包文件tar -cvf 打包文件.tar 被打包的文件/路径 (多个文件一次写在后面，用空格隔开)# 解包文件tar -xvf 打包文件.tar c 生成档案文件，创建打包文件 x 解开档案文件 v 列出归档接档的详细过程 f 指定档案文件名称， f 选项必须放在最后 压缩和解压缩gzip tar 和 gzip 命令结合使用实现文件打包和压缩 tar 只负责打包，但不压缩 用 gzip 压缩 tar 打包后的文件，扩展名为 xxx.tar.gz tar 命令中 -z 选项可以调用 gzip # 压缩文件tar -zcvf 打包文件.tar.gz 被压缩文件/路径# 解压缩文件tar -zxvf 打包文件.tar.gz# 解压缩到指定路径# -C 解压到指定路径，（路径必须存在）tar -zxvf 打包文件.tar.gz -C 目标路径 bzip2 tar 和 bzip2 命令结合使用实现文件打包和压缩（用法同 gzip） tar 只负责打包，但不压缩 用 bzip2 压缩 tar 打包后的文件，扩展名为 xxx.tar.bz2 tar 命令中 -j 选项可以调用 bzip2 # 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩文件/路径# 解压缩文件tar -jxvf 打包文件.tar.bz2# 解压缩到指定路径# -C 解压到指定路径，（路径必须存在）tar -jxvf 打包文件.tar.bz2 -C 目标路径 软件安装apt : Advanced Packaging Tool ，linux 下安装包管理工具，可以方便的安装&#x2F;卸载&#x2F;更新软件包 # 安装软件sudo apt install 软件包# 卸载软件sudo apt remove 如软件名# 更新已安装的包sudo apt upgrade 防火墙管理CentOS7 默认的防火墙不是 iptables,而是 firewalle # 添加规则firewall-cmd --add-port=16343/tcpfirewall-cmd --zone=public --add-port=16343/tcp --permanent （--permanent 永久生效，没有此参数重启后失效）# 重新载入firewall-cmd --reload# 查看firewall-cmd --zone=public --query-port=80/tcp# 删除firewall-cmd --zone=public --remove-port=80/tcp --permanent# 开启防火墙systemctl start firewalld.service# 关闭防火墙systemctl stop firewalld.service# 列出端口信息firewall-cmd --list-ports 使用 iptables # 先检查是否安装了iptablesservice iptables status# 安装iptablesyum install -y iptables# 升级iptablesyum update iptables# 安装iptables-servicesyum install iptables-services# 停止firewalld服务systemctl stop firewalld# 禁用firewalld服务systemctl mask firewalld#注册iptables服务systemctl enable iptables.service# 开启 iptables 防火墙systemctl start iptables.service# 重启iptables防火墙systemctl restart iptables.service# 关闭 iptables 防火墙systemctl stop iptables.service# 查看 iptables 防火墙状态systemctl status iptables.service# 查看iptables现有规则iptables -L -n# 允许所有iptables -P INPUT ACCEPT# 清空所有默认规则iptables -F# 清空所有自定义规则iptables -X# 所有计数器归0iptables -Z# 允许来自于lo接口的数据包(本地访问)iptables -A INPUT -i lo -j ACCEPT# 开放22端口iptables -A INPUT -p tcp --dport 22 -j ACCEPT# 开放21端口(FTP)iptables -A INPUT -p tcp --dport 21 -j ACCEPT# 开放80端口(HTTP)iptables -A INPUT -p tcp --dport 80 -j ACCEPT# 开放443端口(HTTPS)iptables -A INPUT -p tcp --dport 443 -j ACCEPT# 允许pingiptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT# 允许接受本机请求之后的返回数据 RELATED,是为FTP设置的iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT# 其他入站一律丢弃iptables -P INPUT DROP# 所有出站一律绿灯iptables -P OUTPUT ACCEPT# 所有转发一律丢弃iptables -P FORWARD DROP#保存上述规则service iptables save #!/bin/shiptables -P INPUT ACCEPTiptables -Fiptables -Xiptables -Ziptables -A INPUT -i lo -j ACCEPTiptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A INPUT -p tcp --dport 21 -j ACCEPTiptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A INPUT -p tcp --dport 443 -j ACCEPTiptables -A INPUT -p icmp --icmp-type 8 -j ACCEPTiptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPTiptables -P INPUT DROPiptables -P OUTPUT ACCEPTiptables -P FORWARD DROPservice iptables savesystemctl restart iptables.service sudo -i 为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令。提示输入密码时该密码为当前账户的密码。没有时间限制。执行该命令后提示符变为“#”而不是“$”。想退回普通账户时可以执行“exit”或“logout” 。su 切换到某某用户模式，提示输入密码时该密码为切换后账户的密码，用法为“su 账户名称”。如果后面不加账户时系统默认为 root 账户，密码也为超级账户的密码。没有时间限制。sudo su 运行 sudo 命令给 su 命令提权，运行 su 命令。sudo -i 运行结果 PWD&#x3D;&#x2F;rootsudo su 运行结果 PWD&#x3D;&#x2F;home&#x2F;用户名（当前用户主目录） sudo : 暂时切换到超级用户模式以执行超级用户权限，提示输入密码时该密码为当前用户的密码，而不是超级账户的密码。不过有时间限制，Ubuntu 默认为一次时长 15 分钟。","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wqdy.top/tags/linux/"}]},{"title":"js 模块化编程","slug":"前端/js/js-模块化编程","date":"08/09/2018","updated":"28/07/2021","comments":true,"path":"407.html","link":"","permalink":"https://wqdy.top/407.html","excerpt":"","text":"js 模块化编程 最初 js 不是一种模块化编程语言(es6 开始支持)。为了能够尽可能的实现 js 的模块化，我们会把代码写成这样: 最原始: 封装函数写法 function fn1() &#123; // code&#125;function fn2() &#123; // code&#125; 上面的函数 fn1() 和 fn2()，组成一个模块。使用的时候，直接调用就行了，这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系 对象写法 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面 var module1 = &#123; _count: 0, fn1: function() &#123; //code &#125;, fn2: function() &#123; //code &#125;&#125; 上面的函数 fn1()和 fn2()，都封装在 module1 对象里。使用的时候，就是调用这个对象的属性：module1.fn1() 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值：module1._count = 666 立即执行函数(自调用函数)写法 (沙箱模式) // 使用 立即执行函数，可以达到不暴露私有成员的目的var module1 = (function() &#123; var _count = 0 // 一般私有的变量，申明变量名时，以 _ 开头 function fn1() &#123; // code &#125; function fn2() &#123; // code &#125; return &#123; fn1: fn1, fn2: fn2 &#125;&#125;)() 使用上面的写法，外部代码无法读取内部的 _count 变量：console.info(module1._count) &#x3D;&gt; undefined 模块化的标准让模块拥有更好的通用性 AMD : Async Module Definition 异步模块定义：依赖前置、提前执行： 在一开始就将所有的依赖项全部加载 CMD : Common Module Definition 通用模块定义：依赖就近、延迟执行： 在需要的时候才去 require 加载依赖项 commonJS: node.js 同步加载模块，适用于服务端 ES 标准模块化规范 AMD (Asynchronous Module Definition) 异步加载模块 requireJs 库应用这一规范 // module add.jsdefine(function () &#123; return &#123; add: function (a, b) &#123; return a + b &#125; &#125;&#125;)// main.js// 第一个参数是要请求的模块, 第二个参数是依赖模块请求完成的回调函数require([&#x27;add&#x27;], function (add) &#123; console.log(&#x27;1 + 2 = &#x27; + add(1, 2)&#125;) CMD (Common Module Definition) 同步加载模块 SeaJS // module add.jsdefine(function(require, exports, module) &#123; // 正确写法 // 给 module.exports 赋值 module.exports = &#123; add: function (a, b) &#123; return a + b &#125; &#125; // 或使用 return return &#123; add: function (a, b) &#123; return a + b &#125; &#125; // 错误用法 // 对 module.exports 的赋值需要同步执行，不能放在回调函数里 setTimeout(function() &#123; module.exports = &#123; a: &#x27;hello&#x27; &#125; &#125;, 0) // exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口 exports = &#123; add: function (a, b) &#123; return a + b &#125; &#125;&#125;)// main.jsvar &#123; add &#125; = require(&#x27;./add&#x27;) // 此处是同步加载，且可以实现条件加载，因为只有运行到该行代码的时候才会加载模块console.log(&#x27;1 + 2 = &#x27; + add(1, 2)// 同步加载这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于&quot;假死&quot;状态 AMD 和 CMD 区别AMD 和 CMD 最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。 AMD(requirejs)是将所有文件同时加载、一次性引入、推崇依赖前置、也就是在定义模块时要先声明其依赖的模块、加载完模块后会立马执行该模块(运行时加载)，所有模块都加载执行完后会进入 require 的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行 CMD(seajs)强调的是一个文件一个模块、可按需引入、推崇依赖就近、加载完某个模块后不会立即执行，只是下载而已，所有依赖模块加载完成后进入主逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的 // AMDdefine([&#x27;./a&#x27;, &#x27;./b&#x27;], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() b.doSomething()&#125;)// CMDdefine(function(require, exports, module) &#123; var a = require(&#x27;./a&#x27;) a.doSomething() var b = require(&#x27;./b&#x27;) // 依赖可以就近书写 b.doSomething()&#125;) CommonJS 规范 Node 应用由模块组成，采用 CommonJS 模块规范，每个文件就是一个模块，有自己的作用域 在前端浏览器里面并不支持 module.exports 有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global node 中模块分类 核心模块：由 node 本身提供，不需要单独安装（npm），可直接引入使用 fs：文件操作模块 http：网络操作模块 path：路径操作模块 url：解析地址的模块 querystring：解析参数字符串的模块 第三方模块：由社区或个人提供，需要通过 npm 安装后使用，比如：mime 自定义模块：由开发人员自己创建，比如：tool.js、user.js 模块导入 核心模块直接引入使用：require(&#39;fs&#39;) 加载文件操作模块 // 引入模块let fs = require(&#x27;fs&#x27;) 第三方模块，需要先使用 npm 进行下载 自定义模块，需要加上相对路径 ./ 或者 ../ ，可以省略 .js 后缀，如果文件名是 index.js 那么 index.js 也可以省略 // 加载模块require(&#x27;./a&#x27;) // 推荐使用，省略 .js 后缀require(&#x27;./a.js&#x27;) 模块可以被多次导入，但是只会在第一次加载 模块导出 在模块的内部，module 变量代表的就是当前模块，它的 exports 属性就是对外的接口，加载某个模块，加载的就是 module.exports 属性，这个属性指向一个空的对象 // module.exports 指向的是一个对象，我们给对象增加属性即可module.exports.name = &#x27;zs&#x27;module.exports.age = 18setTimeout(function() &#123; module.exports.gender = &#x27;man&#x27;&#125;, 0) let m = require(&#x27;./module.js&#x27;)console.log(m.name) // zsconsole.log(m.age) // 18console.log(m.gender) // undefinedsetTimeout(function() &#123; console.log(m.gender) // man&#125;, 0) // 也可以直接给 module.exports 赋值，但是多次导出会覆盖module.exports = &#x27;123&#x27;module.exports = () =&gt; &#123;&#125;module.exports = &#123;&#125;// 对 module.exports 的赋值需要同步执行，不能放在回调函数里setTimeout(function() &#123; module.exports = &#123; a: 1 &#125;&#125;, 0) let m = require(&#x27;./module.js&#x27;)console.log(m) // &#123;&#125;setTimeout(function() &#123; console.log(m.a) // undefined&#125;, 0) module.exports 与 exports exports 不是 module.exports 的缩写，exports 是单独存在的 exports 和 module.exports 默认指向同一个对象 模块最终导出的一定是 module.exports 中的数据 结论: 直接添加属性两者皆可 赋值对象时，只能使用 module.exports console.log(module.exports === exports) // ==&gt; true// 等价操作module.exports.num = 123exports.num = 123// 赋值为新对象exports = &#123;&#125;module.exports = &#123;&#125;// 模块导出的是 module.exports 指向的对象 nodejs 中 require 加载模块的规则require(‘mime’) 以 mime 为例 如果加载的模块是一个路径，表示加载的自定义模块，根据路径查找对应的 js 文件 如果加载的模块是一个名字，不是一个路径，说明加载的是核心模块或者是第三方模块 判断是否是核心模块，如果不是核心模块，会在当前目录下查找是否有 node_modules 目录 如果有，在 node_modules 目录下查找 mime 这个文件夹，找到 mime 文件夹下的 package.json 文件，找到 main 属性，即模块的入口文件，如果没有 main，默认查找当前目录下的 index.js 文件 如果没有找到对应的模块，回去上一层目录，继续查找，一直找到根目录 C: || D: || E: 报错： can not find module xxx ES 模块化 - import 和 exportModules 不是对象，import 命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能 export 导出多个模块，都放在一个对象里 export default 默认只能导出一个，一个模块只允许有一个 export default，否则报错export default 后面不可以用 var、let、const 可用 export default function(){} function add(){} 命名导出(Named exports) // 导出export const a = 1 // 声明后立即导出，这可以与 `var`, `let`, `const`, `class`, and `function` 配合使用const b = 2export &#123; b &#125; // 导出以前声明的值 必须用对象包裹，否则报错export function c () &#123;&#125;export const d = function () &#123;&#125;export &#123; something as somethingElse &#125; // 在导出时重命名// 导入import &#123; a, b, c, d, e &#125; from &#x27;test.js&#x27;a // 1b // 2c // ƒ c() &#123;&#125;d // ƒ d() &#123;&#125;e // undefined 默认导出(Default Export) 仅当源模块只有一个导出时，才建议使用此做法 // 导出export default a = 1// 等价于let a = 1export &#123; a as default &#125;// 等价于let a = 1export default a// 导入import a from &#x27;test.js&#x27;a // 1// 导入的名字可以任意import b from &#x27;test.js&#x27;b // 1 将默认和命名导出组合在同一模块中是不好的做法，尽管它是规范允许的。 // 导出export default a = 1export const b = 2export const c = 3// 导入import * as tool from &#x27;test.js&#x27;tool.a // 1tool.b // 2tool.c // 3// 或者import a, &#123; b as d, c &#125; from &#x27;test.js&#x27;// 以下写法错误import &#123; b as d, c &#125;, a from &#x27;test.js&#x27; // ximport a, e from &#x27;test.js&#x27; // x es import() 函数参数同 import 命令的参数，返回一个 promise 对象 import() 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，才会加载指定的模块。另外，import() 函数与所加载的模块没有静态连接关系 import 命令会被 js 引擎静态分析，import 语句放在 if 代码块之中毫无意义，因此会报句法错误，即不能用于条件加载 import() 类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载 应用： 按需加载，条件加载，动态模块路径 import(&#x27;./module.js&#x27;).then((&#123; export1, export2 &#125;) =&gt; &#123; // ...&#125;) 同时加载多个模块 Promise.all([ import(&#x27;./module1.js&#x27;), import(&#x27;./module2.js&#x27;), import(&#x27;./module3.js&#x27;),]).then(([module1, module2, module3]) =&gt; &#123; // ···&#125;) import() 也可以用在 async 函数之中。 在 webpack 中使用 import() 动态加载模块时，webpack 默认会将所有 import() 的模块都进行单独打包，https://webpack.js.org/api/module-methods/#import-1 CommonJS 模块 和 ES 模块化区别CommonJS 模块 // commonJsModule.jsvar num = 1let obj = &#123;&#125;var addNum = () =&gt; num++var addObj = () =&gt; obj.num = nummodule.exports = &#123; addNum, num, addObj, obj, get getNum() &#123; return num &#125;&#125; let m = require(&#x27;./commonJsModule.js&#x27;)console.log(m.num) // 1m.addNum()console.log(m.num) // 1// 这里 num 输出的结果还是原来的值，因为 num 是一个原始类型的值，会被缓存// 除非写成一个函数，才能得到内部变动的值console.log(m.getNum) // 2// 引用类型console.log(m.obj) // &#123;&#125;m.addObj()console.log(m.obj) // &#123; count: 2 &#125;// 重新赋值m = &#123;&#125;console.log(m.obj) // undefined ES 模块 // esModule.jsexport let num = 1export let obj = &#123;&#125;export function addNum() &#123; num++&#125; import &#123; num,obj, addNum &#125; from &#x27;./esModule.js&#x27;console.log(num) // 1addNum()console.log(num) // 2// 重新赋值 报错num = 3 // TypeError: Assignment to constant variable.console.log(num)// 修改属性obj.a = 1console.log(obj) // &#123; a: 1 &#125; CommonJS 模块是运行时加载，ES6 模块是编译时输出接口CommonJS和 ES 模块都可以对导出对象内部属性的值进行改变CommonJS 模块输出的是一个值的拷贝，类似浅拷贝ES 模块输出的 不论是基本类还是引用类型的数据，都是值的引用ES 模块对导出的数据不可以重新赋值（只读状态），重新赋值会编译报错（即导出的数据指针指向不能变），但可以改变对象的属性，类似 const 声明的变量CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 Modules不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"},{"name":"模块化","slug":"模块化","permalink":"https://wqdy.top/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"javascript 基础","slug":"前端/js/js-基础","date":"08/09/2018","updated":"08/09/2018","comments":true,"path":"1653.html","link":"","permalink":"https://wqdy.top/1653.html","excerpt":"","text":"书写位置第一种: 写在script标签中 第二种: 引入一个 js 文件 注意： script 可以放在很多地方，但是我们一般规范写在 body 的最后面； 使用 src 引入的标签不能再在标签内写 js 代码 (写了不会执行) !&gt; 通过 src 请求到的 js 文件，会被解析到 script 标签内，并且覆盖原 script 标签内的 js 代码 !&gt; script 标签的 src 属性可以写任何路径或文件，并不仅仅只能写 js 文件 注释 注释代码不会被执行，仅仅起到一个提示的作用。注释可以对复杂的代码进行解释，方便后期的维护和开发。 单行注释 : // 这是单行注释， 单行注释只能写一行代码// 快捷键： ctrl + / 多行注释 : /* 这是多行注释，在多行注释中可以 换行 快捷键 ctrl + shift + / 不可嵌套*/ 输出语句 (5 种) alert : 警告框 // alert会弹出一个警告框alert(&#x27;hello world&#x27;) confirm : 确认框 // confirm弹出一个确定框confirm(&#x27;我帅吗？&#x27;) prompt : 输入框 // prompt:弹出一个输入框，可以输入值prompt(&#x27;请输入你的真是年龄&#x27;) document.write : 网页中写入内容 // 可以识别标签document.write(&#x27;hello world&#x27;)document.write(&#x27;&lt;h1&gt;hello world&lt;/h1&gt;&#x27;)document.write(Date()) // 输出当前时间 console.log：控制台输出 // F12打开控制台，在console中可以看到打印的信息console.log(&#x27;hello word&#x27;) 变量// var 声明变量var ageage = 12 // 先声明,后赋值var age = 12 // 同时声明+赋值var age, name, sex // 直接声明变量,可一次声明多个，用逗号隔开height = 100 // 不声明变量，直接赋值(不会报错，但是不推荐)console.log(height) // 不声明变量，也不赋值变量，直接使用（会报错）vfunction add(num1, num2) &#123; return num1 + num2 // 把两个数字加起来&#125;/*var student = &#123; name:&#x27;小明&#x27;&#125;*/ 变量命名要求（变量是[标识符][1]的一种） 以字母、下划线或美元符号（$）开头 由字母、下划线、美元符号（$）和数字组成 标识符区分大小写 标识符不能使用关键字和保留字 如果重新声明 JavaScript 变量，该变量的值不会丢失 var car=&#39;yellow&#39;; var car car 的值依然是 ‘yellow’ 关键字 (有特殊意义的一些单词)break do instanceof typeof case else new var in catch finally return void continue for switch while try debugger function this with default if throw delete 保留字abstract enum int short boolean export interface static extends long super Char final native Class synchronized package throws Const goto private transient degubber implements volatile double import public byte float protected 交换两个变量的值 使用临时变量 (必须掌握) var temp = aa = bb = temp 不使用临时变量 a = a + bb = a - ba = a - b 基本数据类型Number 浮点数 var num = 3.1416 // 3.1416var num = 3.12e2 // 312var num = 3.12e-1 // 0.312 整数 var num = 10 // 10var num = 070 // 56 (八进制)var num = 0xa // 10 (十六进制) 特殊值 NaN Infinity var num = 1 / 0 // Infinity (无穷大) 通过 isNaN(num) 可以判断是否是一个数字，返回 false 的时候，表示是一个数字 浮点数精度丢失问题 // 在进行浮点数运算的时候，可能会出现精度丢失的问题0.1 + 0.2 = 0.300000000000000040.2 + 0.2 = 0.4// 尽量少用浮点数进行运算，不要让浮点数进行比较// 解决办法 : 根据小数点后面的位数量 乘以对应的整数0.1 + 0.2 ==&gt; (0.1*10+0.2*10) / 10 = 0.3 String只要是在单引号或双引号内的就是 String 类型 var name1 = &#x27;hello&#x27;var name2 = &#x27;july&#x27;var name3 = &#x27;3.1416&#x27;// 使用索引位置来访问字符串中的每个字符,字符串的索引从 0 开始var character = name1[3] // l// 内置属性 length 来计算字符串的长度console.log(name1.length) // 5 若在字符串中使用引号，字符串中的引号不要与字符串的引号相同，或在字符串添加转义字符 \\ 字符串可以是对象 var x = &#x27;john&#x27;var y = new String(&#x27;john&#x27;)typeof x // Stringtypeof y // Object Boolean布尔型，只有 true 和 false 两个值，且是小写 true : 1、2、1.1、-1、&#39;0&#39;、&#39;1&#39;、[]、Infinity、-Infinity、… false : 0、&#39;&#39;、null、NaN、undefined 所有非 0 数都是 true，0 是 false 真值： 在 JavaScript 中，**Truthy**（真值）指的是在布尔值上下文中，转换后的值为真的值。所有值都是真值，除非它们被定义为 假值（即除 false、0、&quot;&quot;、null、undefined 和 NaN 以外皆为真值） Arrayvar car = new Array()cat[0] = &#x27;yellow&#x27;cat[1] = &#x27;red&#x27;cat[2] = &#x27;blue&#x27;// 或var cat = [&#x27;yellow&#x27;, &#x27;red&#x27;, &#x27;blue&#x27;] 关键词 new 用于声明新变量的类型 Object由花括号分隔，属性和方法的容器；对象的属性以名称和值对的形式 (name : value) 来定义；多个属性由逗号分隔。对象的方法定义了一个函数，并作为对象的属性存储。对象方法通过添加 () 调用 var cat = new Object()cat.name = &#x27;kitty&#x27;cat.age = &#x27;2&#x27;cat.eat = function() &#123;&#125;// 或var cat = &#123; name: &#x27;kitty&#x27;, age: 2, eat: function() &#123;&#125;&#125; 对象属性有两种访问方式： name = cat.namename = cat[&#x27;name&#x27;] 对象方法的访问： eat = cat.eat() // 输出函数执行结果eat = cat.eat // 输出函数表达式 Null只有一个值：null，表示对象不存在 var cat = null // 将cat的值清空 str.match()方法匹配不到返回 null 通过 document.querySelector、getElementById() 获取不到元素返回 null Undefined只有一个值：undefined 已声明未赋值的变量 var aconsole.log(a) // undefined 没有明确返回值的变量 // 获取对象不存在的属性var obj = &#123; a: 1, b: 2 &#125;console.log(obj.c) // undefined// 数组下标不存在var arr = [&#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27;]arr[5] // undefined// 函数没有返回值function getSum(a, b) &#123; console.log(a + b)&#125;// getSum(20, 30) // 50var result = getSum(20, 30)console.log(result) // undefined// 函数参数没有传入function f(i) &#123; console.log(i)&#125;f() // undefined typeof 操作符 是一个操作符而不是函数，圆括号可以使用，但不是必需的 var numtypeof num // undefinedtypeof num1 // undefined// 对未初始化和未声明的变量执行 typeof 操作符都返回 undefined 值var num = 1typeof num // numbervar num = &#x27;1&#x27;typeof num // stringvar flag = truetypeof flag // bolleantypeof true // booleantypeof null // object ==&gt; null 被认为是一个空的对象引用var cat = &#123; name: &#x27;kitty&#x27; &#125;typeof cat // object 判断语句if 语句 单独的 if 语句 // 语法if (条件) &#123; // 只有当条件为 true 时,执行代码&#125; // else部分没有执行语句则 省略var age = 10if (age &gt;= 18) &#123; console.log(&#x27;可以访问该网站&#x27;)&#125; if..else 语句 // 语法if (条件) &#123; // 当条件为 true 时执行的代码&#125; else &#123; // 当条件不为 true 时执行的代码&#125;var age = 10if (age &gt;= 18) &#123; console.log(&#x27;可以玩吃鸡&#x27;)&#125; else &#123; console.log(&#x27;不可以玩吃鸡&#x27;)&#125; if..else if ..else 语句 if (条件1) &#123; // 当条件1为 true 时执行的代码&#125; else if (条件2) &#123; // 当条件2 为true 时执行的代码&#125; else &#123; // 当条件1和 条件2 都不为true 时执行的代码&#125; 三元运算符条件 ? 表达式1 : 表达式21. 如果 `条件` 的值为true，会返回表达式1的值2. 如果`条件`的值为false，会返回表达式2的值// 求两个数的最大值var max = n1 &gt; n2 ? n1 : n2 switch 语句 if..else 适用于范围的判断，switch..case 适用于具体的值的判断 // 语法switch (变量) &#123; case 值1: 语句1 break case 值2: 语句2 break … default: 默认语句 break&#125; 注意 :break 可以省略，如果省略，代码会继续执行下一个 caseswitch 语句在比较值时使用的是 全等 操作符, 因此不会发生类型转换（例如，字符串’10’ 不等于数值 10） 循环语句while 循环 基本语法 : // 当循环条件为true时，执行循环体// 当循环条件为false时，结束循环while (循环条件) &#123; // 循环体：需要循环执行的语句&#125; 代码示例: // 计算1-100之间所有数的和 (讲)// 初始化变量var i = 1var sum = 0while (i &lt;= 100) &#123; // 判断条件 sum += i // 循环体 i++ // 自增，修改循环条件（不能省略）&#125;console.log(sum) do..while 循环 do..while 循环和 while 循环非常像，二者经常可以相互替代，但是 do..while 的特点是不管条件成不成立，都会执行一次。 基础语法 : do &#123; // 循环体&#125; while (条件) 代码示例 : // 初始化变量var i = 1var sum = 0do &#123; sum += i // 循环体 i++ // 自增&#125; while (i &lt;= 100) // 循环条件 for 循环 for 循环语法： // 1. for循环使用分号分隔// 2. for循环有2个分号，两个分号不能少for (初始化语句; 判断语句; 自增语句) &#123; // 循环体&#125; 执行顺序：1243 —- 243 —–243(直到循环条件变成 false) 初始化语句 判断语句 自增或者自减 循环体 for 循环代码示例： // 打印1-5之间所有数for (var i = 1; i &lt;= 5; i++) &#123; console.log(i)&#125;console.log(i) // 6 即便循环已经结束了，我们依然可以访问 i 的值 思考 1： // 1 求1-100之间所有数的和、平均值// 2 求1-100之间所有数的乘积// 3 计算1-100之间能3整除的数的和 思考 2： // 1 计算1-100之间不能被7整除的数的和// 2 求1-100之间所有偶数的和// 3 同时求1-100之间所有偶数和奇数的和 思考 3（双重 for 循环）： // 1 网页打印5*5方形★阵 document.write()// 2 网页打印直角三角形// 3 网页打印9*9乘法表 for ..in 循环详见遍历对象 break 和 continue break: 结束&#x2F;中止循环（可以用在 switch 语句和循环语句中） 立即跳出当前整个循环，即循环结束，开始执行循环后面的内容（直接跳传出大括号） continue: 结束本次循环，进行下一次循环 （只能用在循环语句中） 立即跳出当前循环，继续下一次循环（跳到 i++的地方） 在一个循环里，continue 和 break 后面不能在写任何语句，因为永远无法执行到 思考 1 : // 输出结果是什么？ 1 2 3 4 6for (var i = 1; i &lt;= 10; i++) &#123; if (i == 5) &#123; continue &#125; if (i == 7) &#123; break &#125; console.log(i)&#125; 总结 : 循环有很多种，但是以后用得最多的是 for 循环 当不明确循环次数的时候，可以使用 while 循环 当无论如何都要执行一次代码的时候，可以使用 do..while 循环 循环可以相互替代 Array 数组 将多个元素，按一定顺序排列放到一个集合中 ， 那么这个集合我们就称之为数组 可以存放任意类型的数据（一般一个数组只存放一种类型） 特点 : 用逗号隔开，有顺序，有长度，数组长度可以动态调整 用途 : 存储大量的数据 // 为什么要有数组?// 1. 我们知道,一个变量能够存储一个值, 当我们想要存储多个值的时候, 就可以使用数组。比如存储一个班级里面所有学生的名;// 2. 使用数组可以对多个相同类型的值统一的管理,存储起来方便,操作的时候,也会很方便 创建数组 通过 构造函数 创建数组 var arr = new Array() // 创建了一个空数组var arr = new Array(4) // 创建了一个数组，长度为4,里面全是空值var arr = new Array(&#x27;4&#x27;) // 创建了一个数组，长度为1,内容为字符串 &#x27;4&#x27;var arr = new Array(2, 3) // 创建了一个数组，里面存放了2个数字 通过 数组字面量 创建数组 var arr1 = [] // 创建一个空数组var arr2 = [4] // 创建了一个数组，长度为1,内容为数字 4var arr2 = [2, 3] // 创建一个包含2个数值的数组，多个数组项以逗号隔开var arr3 = [&#x27;2&#x27;, &#x27;b&#x27;] // 创建一个包含两个字符串的数组 数组的长度与下标 数组的长度 : 跟字符串一样,数组有一个 length 属性,, 指数组中存放的元素的个数 var arr = [] // 空数组 长度为 0var arr = [1, 3, 5]arr.length // 长度就是3arr.length = 0 // 设置length属性改变数组中元素的个数 数组的下标（又称索引） : 因为数组有序的，有序的就应该有自己的序号，而这个序号就是每个元素对应的下标，下标从 0 开始 , 到 arr.length-1 结束 // 数组取值，如果下标不存在，则返回 undefinedvar arr = [&#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27;]arr[0] // zsarr[2] // wwarr[5] // undefined// 数组的赋值// 格式：数组名[下标] = 值// 如果下标有对应的值，会把原来的值覆盖，如果下标不存在，会给数组新增一个元素。var arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]arr[0] = &#x27;yellow&#x27; // 把red替换成了yellowarr[3] = &#x27;pink&#x27; // 给数组新增加了一个pink的值// 如果下标有跨度,中间全是empty 不合法// 在数组末尾添加新的元素arr[arr.length] = 值arr.push(值) 数组的遍历 遍历 : 对数组的每一个元素都访问一次就叫遍历 数组遍历的基本语法： for (var i = 0; i &lt; arr.length; i++) &#123; // 数组遍历的固定结构&#125; 冒泡排序// 将数组中的数从小到大排列var arr = [1, 4, 6, 7, 9, 3, 5, 8]// var arr = [1,2,3,4,5,6,7,8]var numi = 0var numj = 0for (var j = 0; j &lt; arr.length - 1; j++) &#123; numj += 1 var flag = true for (var i = 0; i &lt; arr.length - 1 - j; i++) &#123; // document.write(&#x27;(&#x27; + arr[i] + &#x27;,&#x27; + arr[i + 1] + &#x27;)&#x27;) numi += 1 // 两两比较，如果前面的大于后面的，交换位置 if (arr[i] &gt; arr[i + 1]) &#123; flag = false var temp temp = arr[i] arr[i] = arr[i + 1] arr[i + 1] = temp // document.write(&#x27;交换了&#x27;) &#125; &#125; // document.write(&#x27;，arr=（&#x27; + arr + &#x27;）&#x27;) // document.write(&#x27;&lt;br&gt;&#x27;) // 如果一趟下来，一次交换都没有做，说明就已经排好序，就不需要继续比 if (flag) &#123; break &#125; // console.log(arr)&#125;console.log(arr)console.log(numi)console.log(numj) 对象查看一个对象的类型(类型识别)typeof // 只能查看基本数据类型的类型instanceof // 判断对象的具体类型constructor.name // 获取对象的具体类型 适用于任何类型的检测Object.prototype.toString.call(&#x27;str&#x27;) // &#x27;[object String]&#x27; 适用于任何类型的检测 typeof 用于查看基本数据的数据类型， number string boolean undefined null 比较特殊，结果是 object 如果查看复杂数据类型，返回的都是 object 类型 函数的结果是 function // typeof 判断// 简单类型typeof 12 // &#x27;number&#x27;typeof &#x27;abc&#x27; // &#x27;string&#x27;typeof true // &#x27;boolean&#x27;typeof undefined // &#x27;underfined&#x27;typeof null // &#x27;object&#x27;// 复杂类型 (引用类型)typeof function() &#123;&#125; // &#x27;function&#x27;typeof [] // &#x27;object&#x27;typeof &#123;&#125; // &#x27;object&#x27; instanceof 判断 // 语法object instanceof constructor 用来检测 constructor.prototype 是否存在于参数 object 的原型链中 不能用于类型识别 // instanceof 判断var simpleStr = &#x27;This is a simple string&#x27;var myString = new String()var newStr = new String(&#x27;String created with constructor&#x27;)var myObj = &#123;&#125;var myNonObj = Object.create(null)var myArr = []var myFn = function() &#123;&#125;simpleStr instanceof String // 返回 false, 检查原型链会找到 undefinedmyString instanceof String // 返回 truenewStr instanceof String // 返回 truemyString instanceof Object // 返回 truemyObj instanceof Object // 返回 true, 尽管原型没有定义;(&#123;&#125; instanceof Object) // 返回 true, 同上myNonObj instanceof Object // 返回 false, 一种创建对象的方法，这种方法创建的对象不myArr instanceof Array // truemyArr instanceof Object // truemyFn instanceof Object // truemyFn instanceof Function // true constructor.name Undefined&#x2F;Null 没有 constructor 属性 var myArr = []var myFn = function() &#123;&#125;var myObj = &#123;&#125;// 原型的构造函数myArr.constructor.name // ArraymyFn.constructor.name // ObjectmyObj.constructor.name // Function// 自定义构造函数function Teacher(name, age) &#123; this.name = name this.age = age&#125;var tea = new Teacher(&#x27;zs&#x27;, 18)tea.constructor.name // Teacher Object.prototype.toString 适用于任何类型的检测，不能识别自定义对象类型 Object.prototype.toString.call(&#x27;str&#x27;) // &#x27;[object String]&#x27; 原始类型与引用类型 原始类型（简单数据类型&#x2F;值类型） Number String Boolean Undefined Null 引用类型（复杂数据类型） Object Array function 自定义的对象 var num1 = 123var num2 = num1num2 = 456console.log(num1) // 123var obj1 = &#123; a: 1 &#125;var obj2 = obj1 // obj1和obj2，均指向了同一个对象obj2.a = 3 // 对obj2的任何操作console.log(obj1.a) // 3 同时也会影响到 obj1 原始数据类型和引用数据类型，主要是根据内存存储方式来区分的 原始类型储存在栈（Stack）中，存的是值本身（值类型），进行赋值的时候，赋值的是值本身 引用类型储存在堆（Heap）中，并非储存变量真实数值而是引用（也叫地址），进行赋值的时候，赋值的是地址，而不是数据本身 内置对象 JS 内置对象就是指 Javascript 自带的一些对象，供开发者使用，这些对象提供了一些常用的的功能。 常见的内置对象有 Math、String、Array、Date 等 跳转到定义ctrl+左键 火狐开发者网站 MDN Math 对象 属性 PI Math.PI 最大值&#x2F;最小值 Math.max()Math.min() 取整 Math.ceil() // 向上取整Math.floor() // 向下取整Math.round() // 四舍五入，如果是.5，则取更大的那个数 (-1.5 -&gt; -1) 随机数 Math.random() // 返回一个[0,1)之间的数，能取到0，取不到1// [0~N]随机数 parseInt(Math.random * (N+1))// [4~9] ==&gt; [0~5]+4 绝对值 Math.abs() // 求绝对值 次幂和平方 Math.pow(num, power) // 求 num 的 power 次方Math.sqrt(num) // 对 num 开平方 练习 // 随机生成一个 rgb 颜色?function randomRGB() &#123; var colorA = parseInt(Math.random() * 256) var colorB = parseInt(Math.random() * 256) var colorC = parseInt(Math.random() * 256) return &#x27;rgb(&#x27; + colorA + &#x27;,&#x27; + colorB + &#x27;,&#x27; + colorC + &#x27;)&#x27;&#125; Date 对象 Date 对象用来处理日期和时间 创建一个日期对象 // 不传参数：创建一个当前时间的对象var date = new Date()// 日期格式字符串：创建一个指定时间的日期对象// &#x27;-&#x27; 在 safari 下不识别，推荐用 /var date = new Date(&#x27;2018/12/02&#x27;)var date = new Date(&#x27;2018/12/02 00:02:05&#x27;)// 日期以逗号分隔：注意月份从0开始var date = new Date(2018, 11, 2, 0, 2, 5) // 2018/12/02// 时间戳var date = new Date(1543680125000) 日期格式化(了解) date.toString() // 默认的日期格式 ，包括日期和时间date.toLocalString() // 本地风格的日期格式（兼容性）date.toDateString() // 只显示日期date.toLocalDateString()date.toTimeString() // 只显示时间date.toLocalTimeString() 获取日期的指定部分 getMilliseconds() // 获取毫秒值getSeconds() // 获取秒getMinutes() // 获取分钟getHours() // 获取小时getDay() // 获取星期，0-6 0：星期天getDate() // 获取日，即当月的第几天getMonth() // 返回月份，注意月份从0开始getFullYear() // 返回4位的年份 如 2018// 思考：// 封装一个函数，返回当前的时间，格式是：yyyy-MM-dd HH:mm:ss 时间戳 var date = +new Date() // 1970年01月01日00时00分00秒起至现在的总毫秒数// 思考// 如何统计一段代码的执行时间？ 基本包装类型 简单数据类型是没有方法的。为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String&#x2F;Number&#x2F;Boolean 基本包装类型：把基本类型包装成复杂类型 var str = &#x27;abc&#x27;var result = str.indexOf(&#x27;a&#x27;)// 发生了三件事情// 1. 把简单类型转换成复杂类型：var s = new String(str)// 2. 调用包装类型的 indexOf 方法：var result = s.indexOf(&#x27;a&#x27;)// 3. 销毁刚刚创建的复杂类型 Number 对象 Number 对象是数字的包装类型，数字可以直接使用这些方法 num.toFixed(2) ：返回保留 2 位小数的新数的字符串格式num.toString() ：转换成字符串并返回 Boolean 对象 Boolean 对象是布尔类型的包装类型 toString() // 转换成字符串并返回 undefined 和 null 没有包装类型，所以调用 toString 方法会报错","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"}]},{"title":"html 基础","slug":"前端/html/html-基础","date":"27/08/2018","updated":"27/08/2018","comments":true,"path":"394.html","link":"","permalink":"https://wqdy.top/394.html","excerpt":"","text":"认识 WEB认识网页!&gt; 网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及 Flash 等 浏览器浏览器是网页显示、运行的平台，常用的浏览器有 IE、火狐（Firefox）、谷歌（Chrome）、Safari 和 Opera 等。我们平时称为五大浏览器 常见浏览器内核浏览器内核，英文叫做：Rendering Engine，中文翻译很多，排版引擎、解释引擎、渲染引擎，现在流行称为浏览器内核，负责读取网页内容，整理讯息，计算网页的显示方式并显示页面 因为浏览器太多啦， 但是现在主要流行的就是下面几个： 浏览器 内核 备注 IE Trident IE、猎豹安全、360 极速浏览器、百度浏览器 firefox Gecko 可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友 flash、神一样的对手 chrome Safari webkit 从 Safari 推出之时起，它的渲染引擎就是 Webkit，一提到 webkit，首先想到的便是 chrome，可以说，chrome 将 Webkit 内核 深入人心，殊不知，Webkit 的鼻祖其实是 Safari chrome Chromium&#x2F;Blink 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用 Blink 内核。二次开发 Opera blink 现在跟随 chrome 用 blink 内核 拓展阅读： 移动端的浏览器内核主要说的是系统内置浏览器的内核 Android 手机而言，使用率最高的就是 Webkit 内核，大部分国产浏览器宣称的自己的内核，基本上也是属于 webkit 二次开发 iOS 以及 WP7 平台上，由于系统原因，系统大部分自带浏览器内核，一般是 Safari 或者 IE 内核 Trident 的 Web 标准（重点）Web 标准是由 W3C 组织和其他标准化组织制定的一系列标准的集合 W3C 万维网联盟是国际最著名的标准化组织。1994 年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献 w3c 就类似于现实世界中的联合国。 Web 标准的好处遵循 web 标准可以让不同我们写的页面更标准更统一外，还有许多优点： 让 Web 的发展前景更广阔 内容能被更广泛的设备访问 更容易被搜寻引擎搜索 降低网站流量费用 使网站更易于维护 提高页面浏览速度 Web 标准构成构成： 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 标准 说明 结构 结构用于对网页元素进行整理和分类，咱们主要学的是 HTML。 表现 表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是 CSS 行为 行为是指网页模型的定义及交互的编写，咱们主要学的是 Javascript 理想状态我们的源码： .HTML .css .js web 标准小结 web 标准有三层结构，分别是结构（html）、表现（css）和行为（javascript） 理想状态下，他们三层都是独立的， 放到不同的文件里面 深度阅读：五大主流浏览器内核的源起以及国内各大浏览器内核总结 HTML 初识超文本标记语言 HTML 指的是超文本标记语言 (Hyper Text Markup Language)是用来描述网页的一种语言。 HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) 所谓超文本，有 2 层含义： 因为它可以加入图片、声音、动画、多媒体等内容（超越文本限制） 不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本）。 HTML 骨架标签标签： 在 HTML 页面中，带有 &lt; &gt; 符号的元素被称为 HTML 标签， HTML 骨架格式（一个 html 的基本格式）： &lt;!-- HTML 标签：页面中最大的标签，我们称为根标签 --&gt;&lt;html&gt; &lt;!--文档的头部，注意在 head 标签中我们必须要设置的标签是 title --&gt; &lt;head&gt; &lt;!-- 文档的标题，让页面拥有一个属于自己的网页标题 --&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;!-- 文档的主体包含文档的所有内容，页面内容基本都是放到 body 里面的 --&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; HTML 标签名、类名、标签属性和大部分属性值统一用小写 HTML 标签分类分类： 双标签 &lt;标签名&gt; 内容 &lt;/标签名&gt; 比如 &lt;body&gt; 我是文字 &lt;/body&gt; 该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;&#x2F;标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。 和开始标签相比，结束标签只是在前面加了一个关闭符“&#x2F;”。 我们以后接触的基本都是双标签 单标签 &lt;标签名&gt; 比如&lt;br&gt; 里面不需要包含内容， 只有一个开始标签不需要关闭。 HTML 标签关系主要针对于双标签 的相互关系分为两种： 请大家务必熟悉记住这种标签关系，因为后面我们标签嵌套特别多，很容易弄混他们的关系。 嵌套关系 &lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; 2.并列关系 &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 书写规范： 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个 tab 键的身位（一个 tab 是 4 个或 2 个空格）。如果是并列关系，最好上下对齐。 代码开发工具（书写代码） Dreamweaver SublimeText WebStorm HBuilder VScode sublime 有非常多的优点， 最开心的就是非常轻量级，打开速度超快，后面更高的功能，后面再接触。 sublime 生成 html 骨架小技巧 双击打开软件 新建文件（ctrl+n） 保存（ctrl+s）,保存为：文件名.html （ 注意 后缀名必须是 .html ) 放大缩小代码 按住 ctrl 在 滚动鼠标滚轮 或者 ctrl+ 加号 键 和 ctrl + 减号键 生成页面骨架结构 html: 5 按下 tab 键 或者 ! 按下 tab 键 在浏览器中预览页面 右键在 浏览器中打开 文档类型&lt;!DOCTYPE&gt;用法： &lt;!DOCTYPE html&gt; 作用： 声明位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。 就是告诉浏览器按照HTML5 规范解析页面. 团队约定： HTML 文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明 页面语言 lang&lt;html lang=&quot;en&quot;&gt; &lt;!-- 指定html 语言种类 --&gt;&lt;/html&gt; 最常见的 2 个： en定义语言为英语 zh-CN定义语言为中文 &lt;html lang=&quot;zh-CN&quot;&gt; 指定该 html 标签内容所用的语言为中文 团队约定： 考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值 @拓展阅读： 简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理 Html 的程序对页面语言内容来做一些对应的处理或者事情。比如可以 告诉搜索引擎做精确的识别 让语法检查程序做语言识别 帮助翻译工具做识别 帮助网页阅读程序做识别等等 字符集&lt;meta charset=&quot;UTF-8&quot; /&gt; 字符集(Character set)是多个字符的集合。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。 utf-8 是目前最常用的字符集编码方式，常用的字符集编码方式还有 gbk 和 gb2312。 gb2312 简单中文 包括 6763 个汉字 GUO BIAO BIG5 繁体中文 港澳台等用 GBK 包含全部中文字符 是 GB2312 的扩展，加入对繁体字的支持，兼容 GB2312 这句话是告诉浏览器当前 html 文档使用 UTF-8 进行的字符编码。 团队约定： 一般情况下统一使用 “UTF-8” 编码, 请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。 HTML 标签的语义化白话： 所谓标签语义化，就是指标签的含义。 根据标签的语义，在合适的地方给一个最为合理的标签，让结构更清晰。 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化（SEO） 语义是否良好： 当我们去掉 CSS 之后，网页结构依然组织有序，并且有良好的可读性。( 裸奔起来一样好看 ) 遵循的原则：先确定语义的 HTML ，再选合适的 CSS。所以，我们接下来学习 html 标签，要根据语义去记忆。 HTML 网页中任何元素的实现都要依靠 HTML 标签。 HTML 常用标签首先 HTML 和 CSS 是两种完全不同的语言，我们学的是结构，就只写 HTML 标签，认识标签就可以了。 不会再给结构标签指定样式了。 HTML 标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。 排版标签排版标签主要和 css 搭配使用，显示网页结构的标签，是网页布局最常用的标签。 标题标签 h (熟记)单词缩写： head 头部. 标题 title 文档标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML 提供了 6 个等级的标题，即 标题标签语义： 作为标题使用，并且依据重要性递减 其基本语法格式如下： &lt;h1&gt;标题文本&lt;/h1&gt;&lt;h2&gt;标题文本&lt;/h2&gt;&lt;h3&gt;标题文本&lt;/h3&gt;&lt;h4&gt;标题文本&lt;/h4&gt;&lt;h5&gt;标题文本&lt;/h5&gt;&lt;h6&gt;标题文本&lt;/h6&gt; 显示效果如下： 小结 : 加了标题的文字会变的加粗，字号也会依次变大 一行是只能放一个标题的 段落标签 p ( 熟记)单词缩写： paragraph 段落 [ˈpærəgræf] 无须记这个单词 作用语义： 可以把 HTML 文档分割为若干段落 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 &lt;p&gt;文本内容&lt;/p&gt; 是 HTML 文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签 hr(认识)单词缩写： horizontal 横线 [ˌhɔrəˈzɑntl] 同上 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： &lt;hr&gt; &lt;!-- 是单标签 --&gt; 换行标签 br (熟记)单词缩写： break 打断 ,换行 在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 &lt;br&gt; div 和 span 标签(重点)div span 是没有语义的 是我们网页布局主要的 2 个盒子 想必你听过 css+div div 就是 division 的缩写 分割， 分区的意思 其实有很多 div 来组合网页 span 跨度，跨距；范围 语法格式： &lt;div&gt;这是头部&lt;/div&gt;&lt;span&gt;今日价格&lt;/span&gt; 只不过他们有区别，现在我们主要记住使用方法和特点就好了 div 标签 用来布局的，一行只能放一个 div span 标签 用来布局的，一行上可以放好多个 span 后面后面讲显示模式的时候，会告诉大家 排版标签总结 标签名 定义 说明 &lt;hx&gt;&lt;/hx&gt; 标题标签 作为标题使用，并且依据重要性递减 &lt;p&gt;&lt;/p&gt; 段落标签 可以把 HTML 文档分割为若干段落 &lt;hr /&gt; 水平线标签 没啥可说的，就是一条线 &lt;br /&gt; 换行标签 &lt;div&gt;&lt;/div&gt; div 标签 用来布局的，但是现在一行只能放一个 div &lt;span&gt;&lt;/span&gt; span 标签 用来布局的，一行上可以放好多个 span 文本格式化标签(熟记)在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。 &lt;strong&gt;&lt;/strong&gt; 加粗强调 &lt;i&gt;&lt;/i&gt; 倾斜 标签属性使用 HTML 制作网页时，如果想让 HTML 标签提供更多的信息，可以使用 HTML 标签的属性加以设置。其基本语法格式如下： &lt;标签名 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; …&gt; 内容 &lt;/标签名&gt;&lt;手机 颜色=&quot;红色&quot; 大小=&quot;5寸&quot;&gt; &lt;/手机&gt; 图片标签 img单词缩写： image 图像 要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签&lt;img&gt;以及和他相关的属性。（它是一个单身狗） 语法如下： &lt;img src=&quot;图像URL&quot;&gt; 该语法中 src 属性用于指定图像文件的路径和文件名，他是 img 标签的必需属性。 src 图像的路径 alt 图像不能显示时的替换文本 title 鼠标悬停时显示的文本 width 设置图像的宽度 height 设置图像的高度 注意: 标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 采取 键值对 的格式 key&#x3D;”value” 的格式 比如: &lt;!-- 正常的 --&gt;&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;!-- 带有边框的 --&gt;&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot;&gt;&lt;!-- 有提示文本的 --&gt;&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; title=&quot;这是个小蒲公英&quot;&gt;&lt;!-- 有替换文本的 --&gt;&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; alt=&quot;图片不存在&quot;&gt; 重点掌握点： 请说出 图像标签哪个属性是必须要写的？ 请说出 图像标签中 alt 和 title 属性区别？ 链接标签单词缩写： anchor 的缩写 [ˈæŋkə(r)] 。基本解释 锚, 铁锚 的 在 HTML 中创建超链接非常简单，只需用标签把文字包括起来就好。 语法格式： &lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;&lt;a href=&quot;mailto:邮箱&quot;&gt;文本或图像&lt;/a&gt; 属性 作用 href 用于指定链接目标的 url 地址，（必须属性）当为标签应用 href 属性时，它就具有了超链接的功能 target 用于指定链接页面的打开方式，其取值有_self、_blank、inner，其中_self 为默认值，__blank 为在新窗口中打开，inner 在内部打开。 注意： 在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。图片链接： &lt;a href=&quot; &quot;&gt;&lt;img src=&quot; &quot;&gt;&lt;/a&gt; style 属性：text-decoration:none 链接没有下划线 # 链接到文档顶部（什么都不写也会返回到页面顶端） 跳转某一页面某一锚点&lt;a href=&quot;index.html#锚点&quot;&gt;&lt;/a&gt; 空连接 javascript:void(null) 链接 css： &lt;link rel=&quot;stylesheet&quot; href=&quot;mycss.css&quot; /&gt; 链接 js： &lt;script type=&quot;text/javascript&quot; src=&quot;myscripts.js&quot;&gt;&lt;/script&gt; 注释标签在 HTML 中还有一种特殊的标签——注释标签。如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。 简单解释： 注释内容不会显示在浏览器窗口中，但是作为 HTML 文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 语法格式： &lt;!-- 注释语句 --&gt;快捷键是： ctrl + / 或者 ctrl +shift + / 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行 表格标签 table目标： 理解： 能说出表格用来做什么的 表格的基本结构组成 应用： 能够熟练写出 n 行 n 列的表格 能简单的合并单元格 表格作用： 表格现在还是较为常用的一种标签，但不是用来布局，而是显示、展示表格式数据。 因为它可以让数据显示的非常的规整，可读性非常好。 特别是后台展示数据的时候表格运用是否熟练就显得很重要，一个清爽简约的表格能够把繁杂的数据表现得很有条理，虽然 div 布局也可以做到，但是总没有表格来得方便。 创建表格在 HTML 网页中，要想创建表格，就需要使用表格相关的标签。 创建表格的基本语法： &lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; table 用于定义一个表格标签。 tr 标签 用于定义表格中的行，必须嵌套在 table 标签中。 td 用于定义表格中的单元格，必须嵌套在 &lt;tr&gt;&lt;/tr&gt; 标签中。 字母 td 指表格数据（table data），即数据单元格的内容，现在我们明白，表格最合适的地方就是用来存储数据的。 总结： 表格的主要目的是用来显示特殊数据的 一个完整的表格有表格标签（table），行标签（tr），单元格标签（td）组成，没有列的标签 &lt;tr&gt;&lt;/tr&gt; 中只能嵌套 &lt;td&gt;&lt;/td&gt; 类的单元格 &lt;td&gt;&lt;/td&gt; 标签，他就像一个容器，可以容纳所有的元素 表格属性表格有部分属性我们不常用，这里重点记住 cellspacing 、 cellpadding。 border 设置表格的边框 border=&quot;1px dashed #ccc&quot; dashed 虚线 cellspacing 设置单元格与单元格边框之间的空白距离 cellpadding 设置单元格内容与单元格边框之间的空白距离 width 设置表格宽度 height 设置表格高度 align 设置表格水平对齐方式 （left center right） 写在 table 标签中控制表格位置 写在 tr 标签中控制表格内文本位置 表头单元格标签 th 作用： 一般表头单元格位于表格的第一行或第一列，并且文本加粗居中 语法： 只需用表头标签&lt;th&gt;&lt;&#x2F;th&gt;替代相应的单元格标签&lt;td&gt;&lt;&#x2F;td&gt;即可。 th 也是一个单元格 只不过和普通的 td 单元格不一样，它会让自己里面的文字居中且加粗 表格标题 caption定义和用法 &lt;table&gt; &lt;caption&gt; &lt;h2&gt; 我是表格标题 &lt;/h2&gt; &lt;/caption&gt;&lt;/table&gt; 注意： caption 元素定义表格标题，通常这个标题会被居中且显示于表格之上。 caption 标签必须紧随 table 标签之后。 这个标签只存在表格里面才有意义。 caption 没有加粗效果，一般用 h 标签实现加粗 合并单元格(难点)合并单元格 2 种方式： 跨行合并（向下合并）：rowspan&#x3D;”合并单元格的个数” 跨列合并（向右合并）：colspan&#x3D;”合并单元格的个数” 合并后需删除多余的单元格 总结表格 标签名 定义 说明 &lt;table&gt;&lt;/table&gt; 表格标签 就是一个四方的盒子 &lt;tr&gt;&lt;/tr&gt; 表格行标签 行标签要再 table 标签内部才有意义 &lt;td&gt;&lt;/td&gt; 单元格标签 单元格标签是个容器级元素，可以放任何东西 &lt;th&gt;&lt;/th&gt; 表头单元格标签 它还是一个单元格，但是里面的文字会居中且加粗 &lt;caption&gt;&lt;/caption&gt; 表格标题标签 表格的标题，跟着表格一起走，和表格居中对齐 clospan 和 rowspan 合并属性 用来合并单元格的 表格提供了 HTML 中定义表格式数据的方法。 表格中由行中的单元格组成。 表格中没有列元素，列的个数取决于行的单元格个数。 表格不要纠结于外观，那是 CSS 的作用。 表格的学习要求： 能手写表格结构，并且能简单合并单元格。 拓展阅读@表格划分结构（了解） 对于比较复杂的表格，表格的结构也就相对的复杂了，所以又将表格分割成三个部分：题头、正文和脚注。而这三部分分别用:thead, tbody, tfoot 来标注， 这样更好的分清表格结构 &lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。用来放标题之类的东西。&lt;thead&gt; 内部必须拥有&lt;tr&gt; 标签！ &lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。放数据本体 。 &lt;tfoot&gt;&lt;/tfoot&gt; 放表格的脚注之类。 以上标签都是放到 table 标签中。 列表标签 特点：用来布局 无序列表 ul无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： &lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 注意： 1. &lt;ul&gt;&lt;/ul&gt; 中只能嵌套&lt;li&gt;&lt;/li&gt; ，直接在&lt;ul&gt;&lt;/ul&gt; 标签中输入其他标签或者文字的做法是不被允许的2. &lt;li&gt;与&lt;/li&gt; 之间相当于一个容器，可以容纳所有元素3. HTML5 已不支持 &lt;ul&gt; 属性，用css ul &#123; list-style-type: disc; 圆点列表&#125;ul &#123; list-style-type: circle; 圆圈列表&#125;ul &#123; list-style-type: square; 正方形列表&#125;ul &#123; list-style-image: url(&#x27;&#x27;); 指定列表项标记的图像&#125;ul li &#123; background-image: url(/img.jpg);&#125; 有序列表 ol （了解）有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： &lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ol&gt; 所有特性基本与 ul 一致。 但是实际中比 无序列表 用的少很多。 ol start 属性 定义有序列表起始序号 ol type 属性 定义序号类型 “A” 大写字母列表 “a” 小写字母列表 “I” 罗马字母列表 “i” 小写罗马字母列表 ol css 属性 list-style-type 指定列表项标记的类型 {list-style-type:upper-roman;} 大写罗马字体 {list-style-type:lower-alpha;} 小写字母 自定义列表（理解）定义列表常用于对术语或名词进行解释和描述，自定义列表的列表项前没有任何项目符号。其基本语法如下： &lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 列表总结 标签名 定义 说明 &lt;ul&gt;&lt;/ul&gt; 无序标签 里面只能包含 li 没有顺序，我们以后布局中最常用的列表 &lt;ol&gt;&lt;/ol&gt; 有序标签 里面只能包含 li 有顺序， 使用情况较少 &lt;dl&gt;&lt;/dl&gt; 自定义列表 里面有 2 个兄弟， dt 和 dd 我们现在还没有学布局，现在只要保证 2 个点： 学会什么时候用无序列表， 学会什么时候用自定义列表 无序列表和自定义列表代码怎么写？ 具体的我们刚才看的布局，等我们学了 css 在来全面布局。 表单标签语法: &lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt; 各种表单控件&lt;/form&gt; 常用属性： 属性 属性值 作用 action url 地址 用于指定接收并处理表单数据的服务器程序的 url 地址。 method get&#x2F;post 用于设置表单数据的提交方式，其取值为 get 或 post。 name 名称 用于指定表单的名称，以区分同一个页面中的多个表单。 作用 表单目的是为了收集用户信息。 在 HTML 中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域 3 个部分构成。 常用标签： &lt;form&gt; 定义供用户输入的表单&lt;input&gt; 定义输入域&lt;textarea&gt; 定义文本域 (一个多行的输入控件)&lt;label&gt; 定义了 input 元素的标签，一般为输入标题&lt;fieldset&gt; 定义了一组相关的表单元素，并使用外框包含起来&lt;legend&gt; 定义了 fieldset 元素的标题select&gt; 定义了下拉选项列表&lt;optgroup&gt; 定义选项组&lt;option&gt; 定义下拉列表中的选项 selected 预选&lt;button&gt; 定义一个点击按钮&lt;datalist&gt; 指定一个预先定义的输入控件选项列表&lt;output&gt; 定义一个计算结果 注意: 每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form 表单域。 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域：他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的 url 地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input 标签 语法： &lt;input type=&quot;属性值&quot; value=&quot;你好&quot;&gt; type 属性设置不同的属性值用来指定不同的控件类型 除了 type 属性还有别的属性 type 属性 text 单行文本输入框 password 密码输入框 radio 单选按钮 checkbox 复选框 button 普通按钮 submit 提交按钮 reset 重置按钮 image 图片按钮 ，添加 src 属性引入图片 file 上传文件 value 属性值&lt;!-- input 框在用户未输入时的默认值 --&gt;用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot;&gt; input placeholder 属性与 value 属性区别 placeholder 属性提供一种提示，描述输入域所期待的值，提示会在输入字段为空时显示，并会在字段获得焦点时消失。属性适用于以下类型的 input 标签：text、search、url、telephone、email 以及 password value 属性为 input 元素设定值，对于不同的输入类型，value 属性的用法也不同 type=&quot;button&quot;, &quot;reset&quot;, &quot;submit&quot; - 定义按钮上的显示的文本 type=&quot;text&quot;, &quot;password&quot;, &quot;hidden&quot; - 定义输入字段的初始值 type=&quot;checkbox&quot;, &quot;radio&quot;, &quot;image&quot; - 定义与输入相关联的值 &lt;input type=&quot;checkbox&quot;&gt; 和 &lt;input type=&quot;radio&quot;&gt; 中必须设置 value 属性。value 属性无法与 &lt;input type=&quot;file&quot;&gt; 一同使用。 name 属性用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; name 表单的名字， 这样，后台可以通过这个 name 属性找到这个表单项。 页面中的表单项很多，name 主要作用就是用于区别不同的表单项。 name 属性后面的值，是我们自己定义的。 radio 如果是一组，我们必须给他们命名相同的名字 name ，这样就可以多个选其中的一个啦 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; 男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; 女 checked 属性 表示默认选中状态。 较常见于 单选按钮和复选按钮。 性 别:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女 上面这个，表示就默认选中了 男 这个单选按钮 label 标签(理解)作用： 用于绑定一个表单元素, 当点击 label 标签的时候, 被绑定的表单元素就会获得输入焦点 如何绑定元素呢？ 第一种用法就是用 label 直接包括 input 表单 &lt;label&gt; 用户名： &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;请输入用户名&quot;&gt;&lt;/label&gt; 适合单个表单选择 第二种用法 for 属性规定 label 与哪个表单元素绑定 &lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot;&gt; textarea 控件(文本域) 语法： &lt;textarea&gt; 文本内容&lt;/textarea&gt; 作用： 通过 textarea 控件可以轻松地创建多行文本输入框 cols&#x3D;”每行中的字符数” rows&#x3D;”显示的行数” 我们实际开发不用 文本框和文本域区别 表单 名称 区别 默认值显示 用于场景 input type&#x3D;”text” 文本框 只能显示一行文本 单标签，通过 value 显示默认值 用户名、昵称、密码等 textarea 文本域 可以显示多行文本 双标签，默认值写到标签中间 留言板 select 标签语法： &lt;select multiple=&quot;multiple&quot;&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option selected&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意： &lt;select&gt; 中至少包含一对 option 在 option 中定义 selected &#x3D;” selected “时，当前项即为默认选中项，不写默认第一项。 multiple 属性可以选多个 HTML5 新的表单属性HTML5 的 form 和 input 标签添加了几个新属性 form 新属性：autocomplete novalidate input 新属性：autocompleteautofocus 在页面加载后设置或返回文本域是否自动获取焦点formormactionformenctypeformmethodformnovalidateormtargetheight 与 widthlistmin 与 maxmultiplepattern (regexp)placeholderrequiredstepreadOnly 设置或返回文本域是否应是只读的 H5 新增标签：六大结构标签&lt;header&gt;网站的头部&lt;/header&gt;&lt;footer&gt;网站的底部&lt;/footer&gt;&lt;nav&gt;导航&lt;/nav&gt;&lt;aside&gt;侧边栏&lt;/aside&gt;&lt;article&gt;文章页&lt;/article&gt;&lt;section&gt;区块&lt;/section&gt; 路径(重点、难点)实际工作中，我们的文件不能随便乱放，否则用起来很难快速的找到他们，因此我们需要一个文件夹来管理他们 目录文件夹： 就是普通文件夹，里面只不过存放了我们做页面所需要的 相关素材，比如 html 文件， 图片 等等 页面中的图片会非常多， 通常我们再新建一个文件夹专门用于存放图像文件（images），这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。路径可以分为： 相对路径和绝对路径 相对路径以引用文件的网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径 同一级路径 只需输入图像文件的名称即可 下一级路径 / 上一级路径 ../ 相对路径，是从代码所在的这个文件出发， 去寻找我们的目标文件的，而 我们所说的 上一级 下一级 同一级 简单说，就是 图片 位于 HTML 页面的位置 绝对路径绝对路径以 Web 站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。 “D:\\web\\img\\logo.gif”，或完整的网络地址，例如 “http://www.itcast.cn/images/logo.gif&quot; 注意： 绝对路径用的较少，我们理解下就可以了 锚点定位通过创建锚点链接，用户能够快速定位到目标内容 创建锚点链接分为两步： 1. 使用相应的id名标注跳转目标的位置。 (找目标)&lt;h3 id=&quot;two&quot;&gt;第2集&lt;/h3&gt;2. 使用 &lt;a href=&quot;#id名&quot;&gt;链接文本&lt;/a&gt; 创建链接文本（被点击的）&lt;a href=&quot;#two&quot;&gt;&lt;/a&gt; 延伸base 标签描述了基本的链接地址&#x2F;链接目标，该标签作为 HTML 文档中所有的链接标签的默认链接(包括 &lt;a&gt;、&lt;img&gt;、&lt;link&gt;、&lt;form&gt;标签中的 URL) 语法： &lt;head&gt; &lt;base href=&quot;&quot; target=&quot;_blank&quot;&gt;&lt;/head&gt; 总结： base 可以设置整体链接的打开状态 base 写到 &lt;head&gt; &lt;/head&gt; 之间 把所有的连接 都默认添加 target=&quot;_blank&quot; &lt;pre&gt; 标签可定义预格式化的文本。 被包围在 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。 &lt;pre&gt; 此例演示如何使用 pre 标签 对空行和 空格 进行控制&lt;/pre&gt; 所谓的预格式化文本就是 ，按照我们预先写好的文字格式来显示页面， 保留空格和换行等。 有了这个标签，里面的文字，会按照我们书写的模式显示，不需要段落和换行标签了。但是，比较少用，因为不好整体控制。 meta 标签 &lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词 每 30 秒中刷新当前页面: &lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt; 特殊字符 （理解） 显示结果 描述 实体名称 实体编号 空格 &amp;nbsp; &amp;#160; &lt; 小于号 &amp;lt; &amp;#60; &gt; 大于号 &amp;gt; &amp;#62; &amp; 和号 &amp;amp; &amp;#38; &quot; 引号 &amp;quot; &amp;#34; &#39; 撇号 &amp;apos;(IE 不支持) &amp;#39; ￠ 分 &amp;cent; &amp;#162; £ 镑 &amp;pound; &amp;#163; ¥ 人民币 &amp;yen; &amp;#165; € 欧元 &amp;euro; &amp;#8364; § 小节 &amp;sect; &amp;#167; © 版权 &amp;copy; &amp;#169; ® 注册商标 &amp;reg; &amp;#174; ™ 商标 &amp;trade; &amp;#8482; × 乘号 &amp;times; &amp;#215; ÷ 除号 &amp;divide; &amp;#247; 总结： 是以运算符&amp;开头,以分号运算符;结尾。 他们不是标签，而是符号。 HTML 中不能使用小于号 “”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体 html5 发展之路什么是 XHTMLXHTML 是更严格更纯净的 HTML 代码。 XHTML 指可扩展超文本标签语言（EXtensible HyperText Markup Language）。 XHTML 的目标是取代 HTML。 XHTML 与 HTML 4.01 几乎是相同的。 XHTML 是更严格更纯净的 HTML 版本。 XHTML 是作为一种 XML 应用被重新定义的 HTML。 XHTML 是一个 W3C 标准。 查文档经常查阅文档是一个非常好的学习习惯。 W3C : http://www.w3school.com.cn/ MDN: https://developer.mozilla.org/zh-CN/","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wqdy.top/tags/html/"}]},{"title":"Fixed 定位脱离 Viewport 的 bug","slug":"前端/css/css-fixed定位脱离viewport的bug","date":"27/08/2018","updated":"27/08/2018","comments":true,"path":"393.html","link":"","permalink":"https://wqdy.top/393.html","excerpt":"","text":"Fixed 定位脱离 Viewport 的 bug&lt;style&gt; .outer &#123; overflow: hidden; width: 300px; height: 300px; background: yellow; &#125; .mid &#123; margin: 20px; width: 200px; height: 200px; transform: translate(0, 0); background: greenyellow; &#125; .inner &#123; position: fixed; top: 0; left: 0; width: 100px; height: 100px; background: pink; z-index: 1 &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;mid&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对于声明 transfrom 值非 none 元素，其子元素中若存在 position: fixed 将以声明 transform 的最近祖先作为基准而定位，这是因为 transfrom 值非 none 的元素定义了一个局部坐标系统，导致 postion: fixed 以此坐标系统计算布局。","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wqdy.top/tags/css/"}]},{"title":"css-z-index 堆叠顺序","slug":"前端/css/css-z-index-堆叠顺序","date":"27/08/2018","updated":"27/08/2018","comments":true,"path":"392.html","link":"","permalink":"https://wqdy.top/392.html","excerpt":"","text":"9.3.2 堆叠顺序（z-index）在使用定位布局时，可能会出现盒子重叠的情况。加了定位的盒子，默认后来者居上， 后面的盒子会压住前面的盒子。 应用 z-index 层叠等级属性可以调整盒子的堆叠顺序。 z-index 的特性如下： 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上 如果属性值相同，则按照书写顺序，后来居上 数字后面无单位 只应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效 层叠水平仅在直接父级层叠上下文中进行比较，即层叠上下文 A 中的子元素的层叠水平不会和另一个层叠上下文中的子元素进行比较 层叠上下文（stacking context）：创建层叠上下文的元素自己会成为一个参考对象 层叠水平（stacking level） 层叠顺序（stacking order） 满足下面规则的元素将会构造出一个 Stacking Context 结构： html 根元素默认会创建层叠上下文 position不为static且z-index不是 auto 的元素 display为flex且z-index不是 auto 的元素 opacity不等于 1 transform不等于 none &lt;html&gt; &lt;div class=&quot;me&quot;&gt; &lt;div class=&quot;you&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/html&gt;&lt;style&gt; .me &#123; width: 100px; height: 100px; &#125; .you &#123; width: 100px; height: 100px; left: 50px; position: relative; z-index: -1; &#125;&lt;/style&gt; you 在这里和 me 做比较，比较开始，首先 you 寻找参考对象，上一层 me 是吗？显然不是，因为 me 没有触发上面任一条件创建层叠上下文，所以继续往上寻找，找到 html。对于 me，也直接往上找到 html，所以这个例子里 me 和 you 是在以 html 为参考对象进行比较，换句话说就是在 html 创建的层叠上下文环境中进行比较！然后按照七阶图，负值 index 在 block 元素之下！所以 me 在 you 之上。 然后我们修改下 me，加个z-index:0; 按照之前的思路演算一遍，you 的参考对象变成 me 了！而 me 仍然是 html，然后 me 和 html 再做比较，me 参考对象是 html，html 的参考对象是 html，OK，在同一上下文了，me 明显高于 html，所以 you 高于 me。 参考链接 元素上下层叠关系总结 北风吹雪：不起眼的 z-index 却能牵扯出这么大的学问 张鑫旭:深入理解 CSS 中的层叠上下文和层叠顺序","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wqdy.top/tags/css/"}]},{"title":"CSS 基础","slug":"前端/css/css-基础","date":"27/08/2018","updated":"27/08/2018","comments":true,"path":"1616.html","link":"","permalink":"https://wqdy.top/1616.html","excerpt":"","text":"1.CSS 初识 概念：CSS(Cascading Style Sheets) ，通常称为 CSS 样式表或层叠样式表（级联样式表） 作用： 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。 CSS 以 HTML 为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。 2. 引入 CSS 样式表（书写位置）2.1 行内式（内联样式） 又称行内样式、行间样式。是通过标签的 style 属性来设置元素的样式 其基本语法格式如下： &lt;div style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt;内容&lt;/div&gt; 实际上任何 HTML 标签都拥有 style 属性，用来设置行内式 案例： &lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;青春不常在，抓紧谈恋爱&lt;/div&gt; 注意： style 其实就是标签的属性 样式属性和值中间是 : 多组属性值之间用 ; 隔开 只能控制当前的标签和以及嵌套在其中的子标签，造成代码冗余 缺点： 没有实现样式和结构相分离 2.2 内部样式表（内嵌样式表） 又称内嵌式，是将 CSS 代码集中写在 HTML 文档的 head 头部标签中，并且用 style 标签定义 其基本语法格式如下： &lt;style&gt; div &#123; color: red; font-size: 12px; &#125;&lt;/style&gt; 注意： style 标签一般位于 head 标签中 type&#x3D;”text&#x2F;css” 在 html5 中可以省略 只能控制当前的页面 缺点： 没有彻底分离 2.3 外部样式表（外链式） 又称链入式，是将所有的样式放在一个或多个以 .CSS 为扩展名的外部样式表文件中，通过 link 标签将外部样式表文件链接到 HTML 文档中 其基本语法格式如下： &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件路径&quot; /&gt;&lt;/head&gt; 注意： link 是个单标签 link 标签需要放在 head 头部标签中，并且指定 link 标签的三个属性 属性 作用 rel 定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 type 定义所链接文档的类型，在这里需要指定为“text&#x2F;CSS”，表示链接的外部文件为 CSS 样式表。我们都可以省略 href 定义所链接外部样式表文件的 URL，可以是相对路径，也可以是绝对路径。 2.4 三种样式表总结（位置） 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 没有实现样式和结构相分离 较少 控制一个标签（少） 内部样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面（中） 外部样式表 完全实现结构和样式相分离 需要引入 最多，强烈推荐 控制整个站点（多） 3. CSS 样式规则 选择器用于指定 CSS 样式作用的 HTML 标签，花括号内是对该对象设置的具体样式。 属性和属性值以“键值对”的形式出现。 属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。 属性和属性值之间用英文 : 连接。 多个“键值对”之间用英文 ; 进行区分。 4. CSS 选择器（重点）4.1 CSS 基础选择器4.1.1 标签选择器 概念： 标签选择器（元素选择器）是指用HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。 语法： 标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125; 4.1.2 类选择器类选择器使用 .（英文点号）进行标识，后面紧跟类名. 语法： 类名选择器 .类名 &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125; 标签 &lt;p class=&quot;类名&quot;&gt;&lt;/p&gt; 优点： 可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签 注意 可以使用字母，数字，- ，_ 必须以字母开头，区分大小写，不要纯数字、中文等命名 一个 class 可以出现多次，一个元素可以有多个 class，各个类名中间用空格隔开 4.1.3 id 选择器id 选择器使用 # 进行标识，后面紧跟 id 名 其基本语法格式如下： id 选择器 #id名 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125; 注意 必须以字母开头 区分大小写 只可出现一次 4.1.4 通配符选择器通配符选择器用 * 号表示，选择所有的标签。 其基本语法格式如下： &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 例如下面的代码，使用通配符选择器定义 CSS 样式，清除所有 HTML 标记的默认边距。 * &#123; margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/&#125; 注意： 会匹配页面所有的元素，降低页面响应速度，不建议随便使用 4.2 CSS 复合选择器4.2.1 后代选择器（重点） 后代选择器又称为包含选择器（标签有直接或间接嵌套关系，可隔代选择） 中间用 空格 连接 语法： 父级 子级 &#123; 属性: 属性值; 属性: 属性值;&#125;.class h3 &#123; color: red; font-size: 16px;&#125; 4.2.2 子元素(子代)选择器 子元素选择器只能选择作为某元素**子元素(亲儿子)**的元素（直接嵌套，不能隔代）。 其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接 语法： .class &gt; h3 &#123; color: red; font-size: 14px;&#125; 白话： 比如: .demo &gt; h3 &#123;color: red;&#125; 说明 h3 一定是 demo 亲儿子 demo 元素包含着h3 4.2.3 交集选择器 由两个选择器构成，找到的标签必须满足：既有标签一的特点，也有标签二的特点。 两个选择器之间 不能有空格，如 h3.special。 记忆技巧： 交集选择器 是 并且的意思。 即…又…的意思 比如: p.one 选择的是类名为 .one 的 p 标签; 用的相对来说比较少，不太建议使用。 4.2.4 并集选择器（重点） 并集选择器（CSS 选择器分组）是各个选择器通过,连接而成的，通常用于集体声明。 任何形式的选择器（包括标签选择器、class 类选择器 id 选择器等），都可以作为并集选择器的一部分。 比如 .one, p , #test &#123;color: #F00;&#125;表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色通常用于集体声明 4.2.5 伪类选择器伪类选择器实质上是让设计师可以根据元素特定的状态，设置不同的视觉效果。具体有:link、:visited、:hover、:active、:focus、:focus-within、:target、:root和:checked。 a:link 用于设置链接初始状态时的样式 a:visited 用于设置链接被点击过后的样式 设置 font-size 不起作用 a:hover 用于设置鼠标悬停在链接上方时，链接的样式 a:active 用于设置鼠标按键按下，但未释放时，链接的样式 :first-child li:first-child 选择属于其父元素的第一个子元素(不一定是 li 元素) :last-child li:last-child 选择属于其父元素的最后一个子元素 :nth-child(2) li:nth-child(2) 选择属于其父元素的第二个子元素 :nth-child(even) li:nth-child(even) 选择属于其父元素的偶数项的子元素 :nth-child(3n+1) li:nth-child(3n+1) 选择属于其父元素的正向 3n+1 项(n 从 0 开始)的子元素 nth-last-child(3n+1) li:nth-last-child(-n+5) 选择属于其父元素的反向-n+5 项(n 从 0 开始)的子元素(即选择最后五个 li 元素) :only-child li:only-child 选择属于其父元素的唯一子元素的每个 &lt;li&gt; 元素 :only-of-type li:only-of-type 选择属于其父元素唯一 &lt;li&gt; 元素的每个 &lt;li&gt; 元素 :first-of-type li:first-of-type 选择属于其父元素的第一个&lt;li&gt; 元素 :last-of-type li:last-of-type 选择属于其父元素的最后一个 &lt;li&gt; 元素 :nth-of-type(2) li:nth-of-type(2) 选择属于其父元素的第二个 &lt;li&gt; 元素 :enabled input:enabled 选择每个启用的 &lt;input&gt; 元素 :disabled input:disabled 选择每个禁用的 input&gt; 元素 :checked input:checked 选择每个被选中的 &lt;input&gt; 元素 :focus 用于设置元素处于 focus 状态下的样式。 :focus-within 用于设置当子元素处于 focus 状态时，该元素的样式。 :empty p:empty 选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点） :target #news:target 选择当前活动的 #news 元素 :root 选择文档的根元素 :not(p) li:not(:last-of-type) 选择最后一个 li 之外其他所有 li :placeholder-shown 用于设置元素 placeholder 显示时的样式 伪元素 ::selection ::selection 选择被用户选取的元素部分 ::first-letter p::first-letter 选择每个 &lt;p&gt; 元素的首字母。 ::first-line p::first-line 选择每个 &lt;p&gt; 元素的首行 ::placeholder input::placeholder 选择 input 内部的占位符，给其设置样式 ::before div::before 在每个 &lt;div&gt; 元素的内容之前插入内容 ::after div::after 在每个 &lt;div&gt; 元素的内容之后插入内容 属性选择器 [attribute] [disabled] 选择带有 disabled 属性所有元素。 [attribute&#x3D;value] [target&#x3D;_blank] 选择 target&#x3D;”_blank” 的所有元素。 [attribute~&#x3D;value] [title~&#x3D;flower] 选择 title 属性包含单词 “flower” 的所有元素。 [attribute|&#x3D;value] [lang|&#x3D;en] 选择 lang 属性值以 “en” 开头后续以-分隔的所有元素。 :lang(language) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 &lt;p&gt; 元素 [attribute^&#x3D;value] a[src^&#x3D;”https”] 选择其 src 属性值以 “https” 开头的每个 &lt;a&gt; 元素 [attribute$&#x3D;value] a[src$&#x3D;”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 &lt;a&gt; 元素 [attribute*&#x3D;value] a[src*&#x3D;”abc”] 选择其 src 属性中包含 “abc” 子串的每个 &lt;a&gt; 元素 #nav == [id=nav] 选择 id&#x3D;nav 的所有元素 li:last-child 是选择 li 元素的父元素下的最后一个子元素，不一定是 li li:last-of-type 是选择 li 元素的父元素的最后一个 li 元素 li:not(:last-of-type) 选择最后一个 li 之外其他所有 li ::before ::after 必须指定 content 属性，否则无效；生成的伪元素默认是行内样式；生成的伪元素无法被找到，更不能被 hover 等；一般用来清除浮动(只有::after 可以)或添加小图标 关于单冒号和双冒号问题： 关于:before与::before的区别:before是css2中伪元素的写法，但是呢，在css3中严格规定，伪类采用单冒号，伪元素需要使用双冒号。为了兼容旧的代码，当浏览器碰到了:before之后，会自动的转换成::before。如果需要兼容老的浏览器，比如IE678，推荐使用:before如果不需要兼容老的浏览器，比如移动端，推荐使用::before 链接伪类注意 写的时候，他们的顺序尽量不要颠倒 按照 lvha 的顺序。否则可能引起错误。 记忆法 love hate 爱上了讨厌 **lv **包包 非常 hao 因为叫链接伪类，所以都是 利用交集选择器 a:link a:hover 因为 a 链接浏览器具有默认样式，所以我们实际工作中都需要给链接单独指定样式。 实际工作开发中，我们很少写全四个状态，一般我们写法如下： a &#123; /* a是标签选择器 所有的链接 */ font-weight: 700; font-size: 16px; color: gray;&#125;a:hover &#123; /* :hover 是链接伪类选择器 鼠标经过 */ color: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */&#125; 5. CSS 属性5.1 font:字体5.1.1 font-size:大小 作用： font-size 属性用于设置字号 p &#123; font-size: 20px;&#125; 谷歌浏览器默认的文字大小为 16px，最小为 12px。 em、百分比 相对父元素大小 设置 body 默认字体大小为 100%，其他文字大小以此为基础设置百分比值 5.1.2 font-family:字体 作用： font-family 属性用于设置哪一种字体。 p&#123; font-family:&quot;微软雅黑&quot;;&#125; 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。 如果字体名中包含空格、#、$ 等符号，则该字体必须加英文状态下的单引号或双引号，例如 font-family: “Times New Roman”;。 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。 p&#123;font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;&#125; CSS Unicode 字体 为什么使用 Unicode 字体 在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。 xp 系统不支持 类似微软雅黑的中文。 解决： 方案一： 你可以使用英文来替代。 比如font-family:&quot;Microsoft Yahei&quot;。 方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。 font-family: &quot;\\5FAE\\8F6F\\96C5\\9ED1&quot;; 表示设置字体为“微软雅黑”。 字体名称 英文名称 Unicode 编码 宋体 SimSun \\5B8B\\4F53 新宋体 NSimSun \\65B0\\5B8B\\4F53 黑体 SimHei \\9ED1\\4F53 微软雅黑 Microsoft YaHei \\5FAE\\8F6F\\96C5\\9ED1 楷体_GB2312 KaiTi_GB2312 \\6977\\4F53_GB2312 隶书 LiSu \\96B6\\4E66 幼园 YouYuan \\5E7C\\5706 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 细明体 MingLiU \\7EC6\\660E\\4F53 新细明体 PMingLiU \\65B0\\7EC6\\660E\\4F53 5.1.3 font-weight:字体粗细 在 html 中如何将字体加粗我们可以用标签来实现 使用 b 和 strong 标签是文本加粗。 可以使用 CSS 来实现，但是 CSS 是没有语义的。 属性值 描述 normal 默认值（不加粗的） bold 定义粗体（加粗的） 100~900 400 等同于 normal，而 700 等同于 bold 我们重点记住这句话 5.1.4 font-style:字体风格 在 html 中如何将字体倾斜我们可以用标签来实现 字体倾斜除了用 i 和 em 标签， 可以使用 CSS 来实现，但是 CSS 是没有语义的 font-style 属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： 属性 作用 normal 默认值，浏览器会显示标准的字体样式 font-style: normal; italic 浏览器会显示斜体的字体样式。 5.1.5 line-height:文字行高 作用： 设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。 使用行高实现单行文字垂直居中 单位： line-height 常用的属性值单位有三种，分别为像素 px，相对值 em 和百分比%，实际工作中使用最多的是像素 px 技巧： 一般情况下，行距比字号大 7.8 像素左右就可以了。line-height: 24px; 文字垂直居中就设置行高等于他外部元素的高度 line-height 不要代替 height ，height 不写 line-height 会把盒子撑起来，不建议这样， height 该写也得写 行高测量 行高和高度的三种关系 如果 行高 等 高度 文字会 垂直居中 如果行高 大于 高度 文字会 偏下 如果行高小于高度 文字会 偏上 300%、3em、3 之间区别 300% 先计算后继承 3 先继承后计算 3em 5.1.6 font: 综合设置字体样式 (重点)font 属性用于对字体样式进行综合设置 基本语法格式如下： font: [&lt;font-style&gt;||&lt;font-weight&gt;]?&lt;font-size&gt;[/&lt;line-height&gt;]?&lt;font-family&gt;(必不可少，否则无效)font:italic bold 20px/2 arial,serif;//表示font-style:italic font-weight:bold font-size:20px line-height:2 font-family:arial,serif 注意： 使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。 其中不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用。 line-height 值如果不写，浏览器会默认添加 normal 5.2 text 属性5.2.1 color:文本颜色 作用： color 属性用于定义文本的颜色， 其取值方式有如下 3 种： 表示表示 属性值 预定义的颜色值 red，green，blue 等等 十六进制 #FF0000，#FF6600，#29D794 RGB 代码 rgb(255,0,0)或 rgb(100%,0%,0%)rgba(255,0,0,1)1 表示不透明，0 表示全透明全透明也可以用 color：transparent 注意 我们实际工作中， 用 16 进制的写法是最多的，而且我们更喜欢简写方式比如 #f00 代表红色 5.2.2 text-align:文本水平对齐方式 作用： text-align 属性用于设置当前这个标签内部的 内容（可以是文字 、行内标签、行内块标签）的水平对齐方式 其可用属性值如下： 属性 解释 left 左对齐（默认值） right 右对齐 center 居中对齐 justify 两端对齐 注意： 是让盒子里面的 内容水平居中 ， 而不是让盒子居中对齐 5.2.3 text-indent:首行缩进 作用： text-indent 属性用于设置首行文本的缩进， 属性值 其属性值可为不同单位的数值、em 字符宽度的倍数、或相对于父元素宽度的百分比%，允许使用负值（设置成很大的负值可以用来隐藏文字） 建议使用 em 作为设置单位。 可以继承 1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度 p &#123; /*行间距*/ line-height: 25px; /*首行缩进2个字 em 1个em 就是1个字的大小*/ text-indent: 2em;&#125; 5.2.4 text-decoration 文本的装饰text-decoration 通常我们用于给链接修改装饰效果 值 描述 none 默认。定义标准的文本。 取消下划线（最常用） underline 定义文本下的一条线。下划线 也是我们链接自带的（常用） overline 定义文本上的一条线。（不用） line-through 定义穿过文本的一条线。（不常用） 多个属性值写在同一个 text-decoration 里会叠加多个属性值写在不同的 text-decoration 里，属性不会累加，优先级高的会完全取代优先级低的 5.2.5 CSS 外观属性总结 属性 表示 注意点 color 颜色 我们通常用 十六进制 比如 而且是简写形式 #fff line-height 行高 控制行与行之间的距离 text-align 水平对齐 可以设定文字水平的对齐方式 text-indent 首行缩进 通常我们用于段落首行缩进 2 个字的距离 text-indent: 2em; text-decoration 文本修饰 记住 添加 下划线 underline 取消下划线 none 5.3 背景(background)属性color/* 背景颜色 */background-color: 颜色值; /* 默认的值是transparent透明的inherit继承 *//* 半透明背景 */background: rgba(0, 0, 0, 0.3);/* 只作用于盒子背景颜色，不会影响文本和背景图片 *//* 最后一个参数是 alpha 透明度 取值范围 0~1 之间 *//* 0.3 的 0 可以省略 *//* C3 属性，低于 ie9 的版本不支持 */ opacity 属性 设置整个标签的透明度，取值范围 0~1之间 image/* 背景图片 */background-image: none(默认) url(图片地址) url(&#x27;demo1.png&#x27;), url(&#x27;demo2.png&#x27;); /* demo1 在 demo2 上层 */ 在 background-color 上层 推荐背景图片 url 加引号 多个背景图片，使用逗号隔开 img 和背景图片的区别： img 直接可以显示在页面，不需要设置宽高，但是背景图片必须要给盒子设置宽高才能显示，背景图片撑不开容器 img 上面写不了内容（除非后期使用定位），而背景图片完全可以 在实际工作中：img 一般用来做产品图片展示（经常更新），而背景图片一般用来做背景或者一些很少更新的小 icon img &#123; width: 200px; /* 插入图片更改大小 width 和 height */ height: 200px; margin-top: 30px; /* 插入图片更改位置 可以用 margin 或 padding 盒模型 */ margin-left: 50px; /* 插入的图片也是一个盒子 */&#125;div &#123; width: 400px; height: 400px; border: 1px solid purple; background: #fff url(&#x27;images/sun.jpg&#x27;) no-repeat; background-position: 30px 50px; /* 背景图片更改位置用 */&#125; repeat/* 背景平铺 */background-repeat: repeat：背景图像在纵向和横向上平铺（默认的） no-repeat：背景图像不平铺（常用） repeat-x：背景图像在横向上平铺 repeat-y：背景图像在纵向平铺 space：中间有空白，保证显示每个图片完整 round：通过缩放保证每个图片显示完整，有可能图片会被拉伸; position/* 背景位置 */background-position: length：百分数 | 由浮点数字和单位标识符组成的长度值 position：top | center | bottom | left | center | right 方位名词; 注意： 必须先指定 background-image 属性 x 轴向右为正方向，y 轴向下为正方向，z 轴向屏幕外是正方向 如果 position 后面是精确坐标， 那么第一个是 x ，第二的一定是 y 如果指定的两个值是精确单位和方位名字混合使用，则第一个值是 x 坐标，第二个值是 y 坐标 如果指定两个值都是方位名字，则两个值前后顺序无关，比如 left top 和 top left 效果一致 如果只指定了一个方位名词，另一个值默认居中对齐。如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中 可设置像素值或百分比（百分比对应容器百分比位置，50% 50% 等价于 center center 即居中） right 10px top 20px 表示距离右边 10px 距离上边 20px attachment/* 背景附着就是解释背景是滚动的还是固定的 */background-attachment: scroll：背景图像是随对象内容滚动 fixed：背景图像固定 inherit; size 跟 width 或者 height 属性是一致的，其实就是设置背景图片的宽高 设置百分比则是相对于容器的百分比，而不是图片，50% 不是将图片缩小一半 特殊值：cover 和 contain 图片等比缩放恰好覆盖整个元素 cover 某一边正好 100%，另一边等于或者大于元素对应方向的长度 contain 某一边正好 100%，另一边等于或者小于元素对应方向的长度 origin/* 设置背景零点参考的盒模型即设置（0.0）坐标位置 */background-origin: padding-box（默认值） | border-box | content-box; clip/* 设置背景裁剪参考的盒模型 */background-clip: border-box （默认值）背景区域：border + padding + content padding-box 背景区域：padding + content content-box 背景区域：content text (需要加 -webkit- 前缀) 背景区域 ：文字; 背景属性简写!&gt; background: bg-image || bg-position&#x2F;bg-size || repeat-style || bg-attachment || bg-origin|| bg-clip(origin 和 clip 只设置一个值时则他俩为同一个值) || bg-color 多重背景：background 设置背景的时候，可以设置多个背景图片，使用逗号隔开。注意颜色只能设置一次，并且颜色通常都是在最后面进行设置。 background 是一个合写的属性，如果在 background 之前设置了 background 相关的样式，会被覆盖掉 5.4 display 属性（重点）属性值：​ none 此元素不会被显示，不占空间，后续元素会补充上去（visibility：hidden 不显示，但空间保留）​ block 显示为块级元素​ inline 显示为内联元素​ inline-block 显示为行内块 5.4.1 块级元素(block)display: block; 常见的块元素有 &lt;h1&gt;~&lt;h6&gt; 、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt; 、dl、 dt 、dd、 header 、 footer 、aside、 nav 、 article 、 section …等，其中&lt;div&gt;标签是最典型的块元素。 块级元素的特点 （1）独占一行 （2）高度，宽度、外边距以及内边距都可以控制。 （3）继承父元素的宽度，高度不继承 （4）是一个容器及盒子，里面可以放行内或者块级元素。 注意： 只有文字才能组成段落 因此 p 里面不能放块级元素，特别是 p 不能放 div 同理还有这些标签 h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。 5.4.2 行内元素(inline)display: inline; 常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、lable 、&lt;span&gt; 等，其中 &lt;span&gt; 标签最典型的行内元素。有的地方也成内联元素 行内元素的特点： （1）相邻行内元素在一行上，一行可以显示多个。 （2）高、宽直接设置是无效的。 （3）默认宽度就是它本身内容的宽度。 （4）不可设置竖直方向的 marging 和 padding,但是可以设置水平方向的 margin 和 padding （5）行内元素只能容纳文本或则其他行内元素。 注意： &lt;a&gt; 不能直接嵌套 &lt;a&gt; 特殊情况 a 里面可以放块级元素，但是给 a 转换一下块级模式最安全。 5.4.3 行内块元素（inline-block）display: inline-block; 在行内元素中有几个特殊的标签——&lt;img&gt;、&lt;input&gt;、&lt;td&gt;、textarea ，select ，button，可以对它们设置宽高和对齐属性，这些元素把它们称为行内块元素。 行内块元素的特点： （1）和相邻行内元素（行内块）在一行上。一行可以显示多个，超出范围会整块换行（2）默认宽度就是它本身内容的宽度。（3）高度，行高、外边距以及内边距都可以控制。（4）可以设置垂直居中 {vertical-align：middle；} 5.5 盒子阴影 box-shadow (CSS3) 语法: box-shadow: 水平阴影 垂直阴影 模糊距离（虚实） 阴影尺寸（影子大小） 阴影颜色 内/外阴影；; 前两个属性是必须写的，其余的可以省略。 水平阴影、垂直阴影、阴影尺寸可为负值，模糊距离不能为负 外阴影 (outset) 是默认的 但是不能写 想要内阴影可以写 inset div &#123; width: 200px; height: 200px; border: 10px solid red; /* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4); */ /* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色 内/外阴影； */ box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);&#125; 颜色如果没设置则为 border 或文字颜色，阴影不占空间，内外阴影可以叠加，中间用逗号隔开 6. CSS 三大特性目标： 理解 能说出 css 样式冲突采取的原则 能说出哪些常见的样式会有继承 应用 能写出 CSS 优先级的算法 能会计算常见选择器的叠加值 6.1 CSS 层叠性 概念： 所谓层叠性是指多种 CSS 样式的叠加。 是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 原则： 样式冲突，遵循的原则是就近原则。 同一标签同一属性，后面的会覆盖前面的 样式不冲突，不会层叠 CSS层叠性最后的执行口诀： 长江后浪推前浪，前浪死在沙滩上。 6.2 CSS 继承性 概念： 子标签会继承父标签的某些样式，如文本颜色和字号。 想要设置一个可继承的属性，只需将它应用于父元素即可。 简单的理解就是： 子承父业。 注意： 恰当地使用继承可以简化代码，降低 CSS 样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。 子元素可以继承父元素的样式（text-，font-，line- 这些元素开头的可以继承，以及 color 属性） a 标签不会继承 color， text-decoration none 属性值不会继承，其他属性值会继承 h 标签会继承的父元素的 font-size，但是具体的值是继承下来的 font-size 的值* 2 6.3 CSS 优先级（重点） 概念： 定义 CSS 样式时，经常出现两个或更多规则应用在同一元素上，此时， 选择器相同，则执行层叠性 选择器不同，就会出现优先级的问题。 !important &gt; style &gt; id &gt; 类/伪类 &gt; 标签 &gt; * &gt; 继承 1). 权重计算公式关于 CSS 权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性） 标签选择器 计算权重公式 继承或者 * 0,0,0,0 每个元素（标签选择器），伪元素选择器 0,0,0,1 每个类，伪类，属性选择器 0,0,1,0 每个 ID 0,1,0,0 每个行内样式 style&#x3D;”” 1,0,0,0 每个!important 重要的 ∞ 无穷大 值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 关于 CSS 权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性） div { color: pink!important; } 2). 权重叠加我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。 就是一个简单的加法计算 div ul li ——&gt; 0,0,0,3 .nav ul li ——&gt; 0,0,1,2 a:hover —–—&gt; 0,0,1,1 .nav a ——&gt; 0,0,1,1 注意： 数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 &#x3D;0,0,0,10 而不是 0,0, 1, 0， 所以不会存在 10 个 div 能赶上一个类选择器的情况。 3). 继承的权重是 0这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。 1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。2） 如果没有选中，那么权重是 0，因为继承的权重为 0.（**!important 也无效**） 7. 盒子模型（CSS 重点）css 学习三大重点： css 盒子模型 、 浮动 、 定位 主题思路： 目标： 理解： 能说出盒子模型有哪四部分组成 能说出内边距的作用以及对盒子的影响 能说出 padding 设置不同数值个数分别代表的意思 能说出块级盒子居中对齐需要的 2 个条件 能说出外边距合并的解决方法 应用： 能利用边框复合写法给元素添加边框 能计算盒子的实际大小 能利用盒子模型布局模块案例 7.1 盒子模型（Box Model） 所谓盒子模型： 就是把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 总结: 盒子模型有元素的内容（）、边框（border）、内边距（padding）、和外边距（margin）组成。 盒子里面的文字和图片等元素是 内容区域 盒子的厚度 我们成为 盒子的边框 盒子内容与边框的距离是内边距（类似单元格的 cellpadding) 盒子与盒子之间的距离是外边距（类似单元格的 cellspacing） css 中设置的宽高默认是内容部分 7.2 盒子边框（border）​ 语法： border: border-width || border-style || border-color || none; 属性 作用 border-width 定义边框粗细，单位是 px border-style 边框的样式 border-color 边框颜色 边框的样式： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 7.2.1 盒子边框写法总结表很多情况下，我们不需要指定 4 个边框，我们是可以单独给 4 个边框分别指定的。 上边框 下边框 左边框 右边框 border-top-style:样式; border-bottom-style:样式; border-left-style:样式; border-right-style:样式; border-top-width:宽度; border- bottom-width:宽度; border-left-width:宽度; border-right-width:宽度; border-top-color:颜色; border- bottom-color:颜色; border-left-color:颜色; border-right-color:颜色; border-top:宽度 样式 颜色; border-bottom:宽度 样式 颜色; border-left:宽度 样式 颜色; border-right:宽度 样式 颜色; 7.2.2 表格的细线边框 通过表格的cellspacing=&quot;0&quot;,将单元格与单元格之间的距离设置为 0， 但是两个单元格之间的边框会出现重叠，从而使边框变粗 通过 css 属性： table&#123; border-collapse:collapse; &#125; collapse 单词是合并的意思 border-collapse:collapse; 表示相邻边框合并在一起。 &lt;style&gt; table &#123; width: 500px; height: 300px; border: 1px solid red; &#125; td &#123; border: 1px solid red; text-align: center; &#125; table, td &#123; border-collapse: collapse; /*合并相邻边框*/ &#125;&lt;/style&gt; 7.2.3 圆角边框(CSS3) 语法： border-radius: length; /*圆角的半径*/ 其中每一个值可以为数值或百分比的形式。 四个值的顺序是：左上、右上、右下、左下，依旧是顺时针旋转。每个角又有水平半径垂直半径，前四个代表水平，后四个代表垂直，中间用&#x2F;隔开 技巧： border-radius: 50%; /*让一个正方形 变成圆圈 */border-top-left-radius：10px; /*单独设置一个角*/ 7.3 内边距（padding）7.3.1 内边距padding 属性用于设置内边距。 是指 边框与内容之间的距离。 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 当我们给盒子指定 padding 值之后， 发生了 2 件事情： 内容和边框 有了距离，添加了内边距。 盒子会变大。 如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定 padding， 则不会撑开盒子。 注意： 后面跟几个数值表示的意思是不一样的。 值的个数 表达意思 1 个值 padding：上下左右内边距; 2 个值 padding: 上下内边距 左右内边距 ； 3 个值 padding：上内边距 左右内边距 下内边距； 4 个值 padding: 上内边距 右内边距 下内边距 左内边距 ； 7.3.2 内盒尺寸计算（元素实际大小） 宽度 Element Height &#x3D; content height + padding + border （Height 为内容高度） 高度 Element Width &#x3D; content width + padding + border （Width 为内容宽度） 盒子的实际的大小 &#x3D; 内容的宽度和高度 + 内边距 + 边框 会撑大原来的盒子 box-sizing: content-box（为默认，宽高不包含padding和border）box-sizing: border-box; 此时宽高包含border在内 7.4 外边距（margin）7.4.1 外边距margin 属性用于设置外边距。 margin 就是控制盒子和盒子之间的距离，可以为负值 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 margin 值的简写 （复合写法）代表意思 跟 padding 完全相同。 行内元素设置 margin-top&#x2F;bottom 无效 7.4.2 块级盒子水平居中 可以让一个块级盒子实现水平居中必须： 盒子必须指定了宽度（width） 然后就给左右的外边距都设置为 auto， 实际工作中常用这种方式进行网页布局，示例代码如下： .header &#123; width: 960px; margin: 0 auto;&#125; 常见的写法，以下下三种都可以。 margin-left: auto; margin-right: auto; margin: auto; margin: 0 auto; 7.4.3 文字居中和盒子居中区别 盒子内的文字水平居中是 text-align: center, 而且还可以让 行内元素和行内块居中对齐 块级盒子水平居中 左右 margin 改为 auto text-align: center; /* 文字 行内元素 行内块元素水平居中 */margin: 10px auto; /* 块级盒子水平居中 左右margin 改为 auto 就阔以了 上下margin都可以 */ 7.4.4 外边距合并（塌陷）使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。 (1). 相邻块元素垂直外边距的合并 当上下相邻的两个块元素相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和而是取两个值中的较大者，这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 解决方案：尽量只给一个盒子添加 margin 值。 (2). 嵌套块元素垂直外边距的合并（塌陷） 对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，父元素的上外边距会与子元素的上外边距发生合并（父元素会跟着下来），合并后的外边距为两者中的较大者 解决方案： 可以为父元素定义上边框。 可以为父元素定义上内边距 可以为父元素添加 overflow:hidden。 还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。 7.4.5 清除元素的默认内外边距(重要)为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除 代码： * &#123; padding: 0; /* 清除内边距 */ margin: 0; /* 清除外边距 */&#125; 注意： 行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。 8. CSS 浮动(float)目标 记忆 能够说出 CSS 的布局的三种机制 理解 能够说出普通流在布局中的特点 能够说出我们为什么用浮动 能够说出我们为什么要清除浮动 应用 能够利用浮动完成导航栏案例 能够清除浮动 8.1 浮动8.1.1 CSS 布局的三种机制CSS 提供了 3 种机制来设置盒子的摆放位置，分别是普通流（标准流）、浮动和定位，其中： 普通流（标准流） 块级元素会独占一行，从上向下顺序排列； 常用元素：div、hr、p、h1~h6、ul、ol、dl 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行； 常用元素：span、a、i、em 等 浮动 让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示。 定位 将盒子定在浏览器的某一个位置——CSS 离不开定位，特别是后面的 js 特效。 8.1.2 为什么需要浮动？思考题： 我们首先要思考以下 2 个布局中最常见的问题？ 如何让多个盒子(div)水平排列成一行？ 如何实现盒子的左右对齐？ 虽然我们前面学过行内块（inline-block） 但是他却有自己的缺陷： 它可以实现多个元素一行显示，但是中间会有空白缝隙，不能满足以上第一个问题。 它不能实现以上第二个问题，盒子左右对齐 pink 老师一句话总结他们 因为一些网页布局要求，标准流不能满足我们的需要了，因此我们需要浮动来完成网页布局。 8.1.3 什么是浮动(float)概念：元素的浮动是指设置了浮动属性的元素会 脱离标准普通流的控制 移动到指定位置。 作用 让多个盒子(div)水平排列成一行，使得浮动成为布局的重要手段。 可以实现盒子的左右对齐等等.. 浮动最早是用来控制图片，实现文字环绕图片的效果。 语法在 CSS 中，通过 float 属性定义浮动，语法如下： 选择器 &#123; float: 属性值; &#125; 属性值 描述 none 元素不浮动（默认值） left 元素向左浮动 right 元素向右浮动 特点 float 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下，遮挡起来了 原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。 元素不在受标准流显示模式的限制,块级元素不再继承父元素的宽度，行内元素可以直接设置宽高 浮动的元素互相贴靠一起的，中间没有空白，但是如果父级宽度装不下这些浮动的盒子， 多出的盒子会掉下来（掉下来的位置会根据上一个浮动盒子的高度决定, 会以上一个盒子的底边线为基准线水平移动，如果在移动的过程里面被挡住了，那么就会卡在这里地方） 左浮从左往右排，右浮从右往左排 文字和 img 标签不会和浮动元素重叠 margin 的 auto 值对于脱标元素没有作用 实际重要的导航栏中，我们不会直接用链接 a 而是用 li 包含链接(li+a)的做法。 li+a 语义更清晰，一看这就是有条理的列表型内容。 如果直接用 a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名 8.2 清除浮动 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响 准确地说，所谓的清除浮动，是清除浮动后造成的影响 清除浮动主要为了解决父级元素因为子级浮动引起内部高度为 0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 8.2.1 清除浮动的方法在 CSS 中，clear 属性用于清除浮动 语法： 选择器&#123;clear:属性值;&#125; clear 清除 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 但是我们实际工作中， 几乎只用 clear: both; 1).额外标签法(隔墙法)是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如&lt;div style=&quot;”clear:both”&quot;&gt;&lt;/div&gt; 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。 2).父级添加 overflow 属性方法可以给父级添加: overflow为 hidden| auto| scroll 都可以实现。; 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 3).使用 after 伪元素清除浮动::after 方式为空元素额外标签法的升级版，好处是不用单独加标签了 使用方法： .clearfix::after &#123; content: &#x27;&#x27;; display: block; height: 0; clear: both; visibility: hidden;&#125;/*content: &quot;&quot;; display: block; clear: both; 这三个必须写*/.clearfix &#123; *zoom: 1;&#125; /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于 IE6-7 不支持:after，使用 zoom:1 触发 hasLayout。 8.2.2 清除浮动总结 父级没高度 子盒子浮动了 影响下面布局了，我们就应该清除浮动了。 清除浮动的方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差。 父级 overflow:hidden; 书写简单 溢出隐藏 父级 after 伪元素 结构语义化正确 由于 IE6-7 不支持:after，兼容性问题 9. 定位(position)定位也是用来布局的，它有两部分组成： 定位 = 定位模式 + 边偏移 9.1 边偏移通过 top、bottom、left 和 right 属性定义元素的边偏移： 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离。 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离。 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离。 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。 9.2 定位模式 (position)在 CSS 中，通过 position 属性定义元素的定位模式，语法如下： 选择器 &#123; position: 属性值;&#125; 定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 9.2.1 静态定位(static) - 了解 静态定位是元素的默认定位方式，无定位的意思。它相当于 border 里面的 none， 不要定位的时候用。 静态定位 按照标准流特性摆放位置，它没有边偏移。 静态定位在布局时我们几乎不用的 9.2.2 相对定位(relative) - 重要 相对定位是元素相对于它原来在标准流中的位置来说的。（自恋型） 原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。 9.2.3 绝对定位(absolute) - 重要 依据最近的已经定位的父级元素（默认父元素的 padding 部分）来进行定位（拼爹型） 不保留原来的位置，完全是脱标的。 因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。 定位口诀 —— 子绝父相—— 子级是绝对定位，父级要用相对定位。 子元素的 0 点为 margin-box 右上角，父元素的 0 点为 padding-box 右上角 9.2.4 固定定位(fixed) - 重要 完全脱标 —— 完全不占位置； 只认浏览器的可视窗口 —— 浏览器可视窗口 + 边偏移属性 来设置元素的位置； 跟父元素没有任何关系；单独使用的 不随滚动条滚动。 9.3 定位(position)的扩展9.3.1 绝对定位的盒子居中 注意：绝对定位&#x2F;固定定位的盒子不能通过设置 margin: auto 设置水平居中。 在使用绝对定位时要想实现水平居中，可以按照如下方法（垂直居中同理）： left: 50%;：让盒子的左侧移动到父级元素的水平中心位置； margin-left: -100px;：让盒子向左移动自身宽度的一半。 居中还可以这样：{margin: auto; left: 0; right: 0; top: 0; bottom: 0;} 9.3.2 堆叠顺序（z-index）在使用定位布局时，可能会出现盒子重叠的情况。加了定位的盒子，默认后来者居上， 后面的盒子会压住前面的盒子。 应用 z-index 层叠等级属性可以调整盒子的堆叠顺序。 z-index 的特性如下： 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面不能加单位。 兄弟元素间相互比较（若 A 在 B 上面，B 的子元素不管怎么设置都不可能覆盖 A） 注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。 9.3.3 定位改变 display 属性前面我们讲过，display 是显示模式， 可以改变显示模式有以下方式: 可以用 inline-block 转换为行内块 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似， 默认转换的特性转换为行内块。 所以说， 一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。 同时注意： 浮动元素、绝对定位(固定定位）元素不再有外边距合并（塌陷）的问题。 9.4 定位小结 定位模式 是否脱标占有位置 移动位置基准 模式转换（行内块） 使用情况 静态 static 不脱标，正常模式 正常模式 不能 几乎不用 相对定位 relative 不脱标，占有位置 相对自身位置移动 不能 基本单独使用 绝对定位 absolute 完全脱标，不占有位置 相对于定位父级移动位置 能 要和定位父级元素搭配使用 固定定位 fixed 完全脱标，不占有位置 相对于浏览器移动位置 能 单独使用，不需要父级 10. CSS 书写规范空格规范【强制】 选择器 与 { 之间必须包含空格。 示例： .selector &#123;&#125; 【强制】 属性名与之后的 : 之间不允许包含空格， : 与 属性值之间必须包含空格。 示例： font-size: 12px; 选择器规范【强制】 并集选择器，每个选择器声明必须独占一行。 示例： /* good */.post,.page,.comment &#123; line-height: 1.5;&#125;/* bad */.post, .page, .comment &#123; line-height: 1.5;&#125; 【建议】 一般情况下，选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。 示例： /* good */#username input &#123;&#125;.comment .avatar &#123;&#125;/* bad */.page .header .login input &#123;&#125;.comment div * &#123;&#125; 属性规范【强制】 属性定义必须另起一行。以分号结尾 示例： /* good */.selector &#123; margin: 0; padding: 0;&#125;/* bad */.selector &#123; margin: 0; padding: 0;&#125; 11. CSS 补充知识11.1 元素的显示与隐藏 目的 让一个元素在页面中消失或者显示出来 场景 类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！ 11.1.1 display 显示（重点） display 设置或检索对象是否及如何显示。 display: none; /*隐藏对象*/display: block; /*除了转换为块级元素之外，同时还有显示元素的意思。*/ 特点： 隐藏之后，不再保留位置。 实际开发场景： 配合后面 js 做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 11.1.2 visibility 可见性 (了解) 设置或检索是否显示对象。 visibility: visible; /*对象可视*/visibility: hidden; /*对象隐藏*/ 特点： 隐藏之后，继续保留原有位置。（停职留薪） 11.1.3 overflow 溢出(重点) 检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。 属性值 描述 visible 不剪切内容也不添加滚动条（默认） hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条，包括上下和左右 auto 超出自动显示滚动条，不超出不显示滚动条 实际开发场景： 清除浮动 隐藏超出内容，隐藏掉, 不允许内容超过父盒子。 11.1.4 显示与隐藏总结 属性 区别 用途 display 隐藏对象，不保留位置 配合后面 js 做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 隐藏对象，保留位置 使用较少 overflow 只是隐藏超出大小的部分 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围 11.2 鼠标样式 cursor设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 属性值 描述 default 小白 默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 url() 图片 none 鼠标消失 help 问号 zoom-in 放大镜 zoom-out 缩小镜 11.3 轮廓线 outline是绘制于元素周围的一条线，位于 border 的外围，不占空间，不影响元素布局，可起到突出元素的作用。如 input 输入框 outline: outline-color ||outline-style || outline-width; 四个边不能单独设置 但是我们都不关心可以设置多少，我们平时都是去掉的。 最直接的写法是 ： outline: 0; 或者 outline: none; &lt;input type=&quot;text&quot; style=&quot;outline: 0;&quot; /&gt; 11.4 防止拖拽文本域 resize实际开发中，我们文本域右下角是不可以拖拽： &lt;textarea style=&quot;resize: none;&quot;&gt;&lt;/textarea&gt; 11.5 vertical-align (了解不推荐使用)行内、行内块、表单元格 垂直方向的对齐方式: vertical-align vertical-align: baseline | sub | super | top(对齐line) | text-top(对齐文字) | middle | bottom | text-bottom | &lt;percentage&gt;(参照line-height向上) | &lt;length&gt;(参照baseline向上);baseline: 当前元素的基线和父元素的基线对齐;middle: 当前元素的中线和父元素的基线加上x高度的一半对齐; 注意： vertical-align 不影响块级元素中的内容对齐，它只针对于行内元素或者行内块元素， 但是由于操作非常复杂,我们工作中基本不使用 去除图片底侧空白缝隙 原因： 图片或者表单等行内块元素，他的基线会和父级盒子的基线对齐。就是图片底侧会有一个空白缝隙。 解决方法： 给 img vertical-align:middle 等等。 让图片不要和基线对齐。 给 img 添加 display：block; 转换为块级元素就不会存在问题了。推荐使用 文字溢出省略号显示white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 white-space: normal; /* 默认处理方式 */ nowrap; /* 强制在同一行内显示所有文本，直到文本结束或者遭遇 br 标签才换行 */ text-overflow设置或检索是否使用一个省略标记（…）标示对象内文本的溢出 text-overflow: clip; 不显示省略标记(...)，而是简单的裁切 ellipsis; 当对象内文本溢出时显示省略标记(...) 注意：一定要首先强制一行内显示，再次和 overflow 属性搭配使用 总结/* 强制一行内显示文本 */white-space: nowrap;/* 超出的部分隐藏 */overflow: hidden;/* 文字用省略号替代超出的部分 */text-overflow: ellipsis;/* 强制最多三行显示文本 */display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden;text-overflow: ellipsis; 换行方式浏览器默认情况下，如果一个单词很长，导致一行中剩下的空间已经放不下时，浏览器会把这个单词挪到下一行去 word-wrap: break-word 标明是否允许浏览器在单词内进行断句，他会首先尝试挪到下一行，看看下一行的宽度够不够，不够的话就进行单词内的断句。 word-break 属性规定自动换行的处理方法 word-break: normal|break-all|keep-allnormal：使用浏览器默认的换行规则break-all：允许在单词内换行，它不会尝试把长单词挪到下一行，而是直接进行单词内的断句keep-all：只能在半角空格或连字符处换行 white-space：normal | pre | nowrap | pre-wrap | pre-line normal：连续的空白符会被合并，换行符会被当作空白符来处理。填充 line 盒子时，必要的话会换行。 nowrap：和 normal 一样，连续的空白符会被合并。但换行符无效，除非手动添加换行标签pre：所有空白符都会被保留。不会自动换行，原样输出pre-wrap：保留空白符序列，但是正常地进行换行pre-line：合并空白符序列，但是保留换行符 pre 标签换行pre &#123; white-space: pre-wrap;&#125; 11.7 CSS 精灵技术（sprite) 重点CSS 精灵技术（也称 CSS Sprites、CSS 雪碧）。 CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），通过 background 属性精确定位到精灵图中的某个小图。 11.8 滑动门各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 核心技术就是利用 CSS 精灵（主要是背景位置）和 盒子 padding 撑开宽度, 以便能适应不同字数的导航栏。 一般的经典布局都是这样的： &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span&gt;导航栏内容&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; css 样式 * &#123; padding: 0; margin: 0;&#125;body &#123; background: url(images/wx.jpg) repeat-x;&#125;li &#123; padding-left: 16px; height: 33px; float: left; line-height: 33px; margin: 0 10px; background: url(./images/to.png) no-repeat left;&#125;a &#123; padding-right: 16px; height: 33px; display: inline-block; color: #fff; background: url(./images/to.png) no-repeat right; text-decoration: none;&#125;li:hover,li:hover a &#123; background-image: url(./images/ao.png);&#125; 总结： a 设置 背景左侧，padding 撑开合适宽度。 span 设置背景右侧， padding 撑开合适宽度 剩下由文字继续撑开宽度。 之所以 a 包含 span 就是因为 整个导航都是可以点击的。 12. CSS 三角形div &#123; width: 0; /*宽度高度为0*/ height: 0; line-height: 0; /*照顾兼容性 低版本的浏览器，加上 font-size: 0; line-height: 0;*/ font-size: 0; border-top: 10px solid red; border-right: 10px solid green; border-bottom: 10px solid blue; border-left: 10px solid #000;&#125;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wqdy.top/tags/css/"}]},{"title":"神奇的js","slug":"前端/js/神奇的js","date":"07/04/2018","updated":"07/04/2018","comments":true,"path":"2009.html","link":"","permalink":"https://wqdy.top/2009.html","excerpt":"","text":"取整(不四舍五入)~~2.33 === 22.33 | 0 === 22.33 &gt;&gt; 0 === 2Math.floor(2.33) 浮点数精度丢失问题// 在进行浮点数运算的时候，可能会出现精度丢失的问题// 尽量少用浮点数进行运算，不要让浮点数进行比较0.1 + 0.2 = 0.30000000000000004// 解决办法 : 根据小数点后面的位数量 乘以对应的整数0.1 + 0.2 ==&gt; (0.1*10+0.2*10) / 10 = 0.3 js 中的隐式转换(!(~+[])+&#123;&#125;)[--[~+&quot;&quot;][+[]]*[~+[]] + ~~!+[]]+(&#123;&#125;+[])[[~!+[]]*~+[]] === &#x27;sb&#x27;","categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"}],"tags":[]},{"title":"Hexo+Github 搭建博客教程及进阶设置","slug":"其他/hexo-github-搭建博客教程及进阶设置","date":"22/12/2017","updated":"22/12/2017","comments":true,"path":"423.html","link":"","permalink":"https://wqdy.top/423.html","excerpt":"","text":"Hexo 文档 配置环境安装 Node作用：用来生成静态页面的 到Node.js 官网下载相应平台的最新版本，一路安装即可。 安装 Git作用：把本地的 hexo 内容提交到 github 上去。Git 官网下载 申请 GitHub作用：是用来做博客的远程创库、域名、服务器之类的。 github 账号注册，github 配置 安装 HEXO执行如下命令安装 hexo： npm install hexo-cli -g 初始化命令： hexo init 文件夹的目录如下： ├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml 网站配置文件 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America&#x2F;New_York, Japan, 和 UTC 其中，description 主要用于 SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author 参数用于主题显示文章的作者 生成静态页面 将 md 文件放到 source/_posts 文件夹下执行命令： hexo g/generate # 生成静态页面至 public 目录# -w/--watch 参数监视文件变动 安装本地服务 npm install hexo-server --save 启动本地服务，进行文章预览调试，命令： hexo server # 开启预览访问端口(默认端口4000，&#x27;ctrl + c&#x27;关闭server)# --debug 参数开启调试模式 -p/--port 参数重设端口 浏览器输入http://localhost:4000 预览 自定义 IP 服务器默认运行在 0.0.0.0，您可以覆盖默认的 IP 设置，如下： hexo server -i 192.168.1.1 配置 Github建立 Repository建立与你用户名对应的仓库，仓库名必须为your_user_name.github.io，固定写法 建立关联 打开站点配置文件_config.yml 翻到最下面，改成我这样子的，注意 : 后面要有空格 deploy: type: git repository: ssh://git@github.com/cuilongjin/cuilongjin.github.io.git branch: master 为了便于以后管理，可以创建备份分支，$ git checkout -b hexo创建 hexo 分支用于备份原始文件 所有的修改添加均在此分支下进行，并 push 到远程 hexo 分支 执行如下命令 npm install hexo-deployer-git --save 然后，执行配置命令： hexo deploy # 将 .deploy 目录部署到 GitHub 然后再浏览器中输入http://your_user_name.github.io/就行了 部署步骤每次部署的步骤，可按以下三步来进行。 hexo cleanhexo generatehexo deploy 写作执行下列命令来创建一篇新文章 hexo new [layout] &lt;title&gt; 在文章中插入指定大小的图片 &#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; Bootstrap Callout 使用方式 &#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default、primary、success、info、warning、danger 主题NexT v5.1.x NexT v6.0.0 next 主题个性化配置 下载 NexT 主题cd your-hexo-sitegit submodule add git@github.com:cuilongjin/hexo-theme-next.git themes/next 启用主题打开站点配置文件 _config.yml ， 找到 theme 字段，并将其值更改为 next NexT 主题的目录架构 ├── .github #github信息├── languages #多语言| ├── _en.yml #默认语言| └── zh-CN.yml #简体中文| └── zh-TW.yml #繁体中文├── layout #布局，根目录下的*.swig文件是对主页，分页，存档等的控制| ├── _custom #可以自定义的模板，覆盖原有模板| | ├── head.swig #文首样式| | ├── header.swig #头部样式| | ├── sidebar.swig #侧边栏样式| ├── _macro #可以自定义的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl自定义局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── js #javascript源代码| └── lib #引用库├── _config.yml #主题配置文件└── README.md #说明文件 在菜单上添加页面以添加 about 页面为例，在 hexo 目录下执行： hexo new page &quot;about&quot; 然后你会发现 source 里面多了个目录 about，里面有个 index.md。其实你也可以手动建立。 然后在主题配置文件 _config.yml 中找到 menu 一项，添加一行 About: &#x2F;about 设置「阅读全文」在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 推荐 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在主题配置文件 _config.yml ，启用auto_excerpt auto_excerpt: enable: truelength: 150 默认截取的长度为 150 字符，可以根据需要自行设定 建议使用 &lt;!-- more --&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。 添加 RSS在博客根目录下执行： npm install --save hexo-generator-feed 打开站点配置文件 _config.yml ，添加： # Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 打开主题配置文件 _config.yml ，添加： rss: /atom.yml 添加本地搜索安装 hexo-generator-search，执行以下命令： npm install hexo-generator-search --save 打开主题配置文件 _config.yml ，添加： local_search: enable: true 自定义样式themes\\next\\source\\css\\_custom\\custom.styl 文件中添加自定义样式 修改头像样式.site-author-image &#123; border-radius: 50%;&#125; 更改主题背景// 背景图片相关body &#123; background-image: url(../images/background.jpg); height: 100%; width: 100%; background-repeat: repeat-x; background-attachment: fixed; background-size: cover;&#125; 图片放入 themes\\next\\source\\images 中即可 改变背景色和透明度，添加： .main-inner &#123; background: #fff; opacity: 0.9;&#125;// 文章内容的透明度.content-wrap &#123; opacity: 0.85;&#125;// 侧边框的透明度设置.sidebar &#123; opacity: 0.85;&#125;// 菜单栏的透明度设置.header-inner &#123; background: rgba(255, 255, 255, 0.85);&#125;// 搜索框的透明度设置.popup &#123; opacity: 0.9;&#125; 修改 local-search 加载图标在blog/themes/next/layout/_third-party/search/localsearch.swig中寻找： &lt;i class=&quot;fa fa-spinner fa-pulse fa-5x fa-fw&quot;&gt;&lt;/i&gt; 将其修改为： &lt;i class=&quot;fa fa-circle-o-notch fa-spin fa-5x fa-fw margin-bottom&quot;&gt;&lt;/i&gt; 修改文章内链接文本样式// 文章内链接文本样式.post-body p a &#123; color: #0593d3; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: 1px solid #fc6423; &#125;&#125; 自定义代码块样式code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight,pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125; 修改文章底部的那个带 # 号的标签编辑主题配置文件 _config.yml ，修改 tag_icon: tag 在每篇文章末尾统一添加”本文结束”标记打开 \\themes\\next\\layout\\_macro\\post.swig 文件，在 post-body 之后， post-footer 之前添加如下代码： &lt;div&gt; &#123;% if not is_index and theme.passage_end_tag.enable %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;margin-top: 20px;&quot;&gt;-------------本文结束-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件 _config.yml ，在末尾添加： # 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 添加顶部加载条cd themes/nextgit clone https://github.com/theme-next/theme-next-pace source/lib/pace 修改主题配置文件 _config.yml 将 pace: false 改为 pace: true 自定义颜色 /* 自定义进度条颜色 */.pace &#123; .pace-progress &#123; background: #1e92fb; // 进度条颜色 height: 3px; &#125; .pace-progress-inner &#123; box-shadow: 0 0 10px #1e92fb, 0 0 5px #1e92fb; // 阴影颜色 &#125; .pace-activity &#123; border-top-color: #1e92fb; // 上边框颜色 border-left-color: #1e92fb; // 左边框颜色 &#125;&#125; 浏览器切换标签离开当前页面时改变 title 提示themes/next/lauout/_script/vendors.swig &lt;script&gt; let a = &#x27;? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ☕️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ☘️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ☺️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ☹️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?&#x27; document.addEventListener(&#x27;visibilitychange&#x27;, function() &#123; if (document.visibilityState == &#x27;hidden&#x27;) &#123; normal_title = document.title document.title = a.split(&#x27; &#x27;)[parseInt(Math.random() * 235)] &#125; else document.title = normal_title &#125;)&lt;/script&gt; 设置首页隐藏指定文章自定义 front-matter 的参数例如，自定义添加一个 notshow 参数，值为 true 表示隐藏 修改主题的 \\themes\\next\\layout\\index.swig 文件 将 &#123;% block content %&#125; &lt;section id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include &#x27;_partials/pagination.swig&#x27; %&#125;&#123;% endblock % 改成 &#123;% block content %&#125; &lt;section id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;% for post in page.posts %&#125; &#123;% if post.notshow != true %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include &#x27;_partials/pagination.swig&#x27; %&#125;&#123;% endblock %&#125; 添加评论系统Gitmen 评论GitHub 授权接入Gitment 是使用的 GitHub Issues 作为评论系统，在接入 Gitment 前，需要获得 GitHub 的授权，获得相应的客户端 id 和客户端私钥，以备站点使用。 OAuth application 注册接入 添加 Gitment 如果您使用的是 Hexo 框架的 Next 主题博客，想要添加 Gitment 的时候，记得将自己的 Next 主 题更新到最新版。 打开主题配置文件 _config.yml 修改如下： gitment: enable: true github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment 其中 lazy 的含义，是否懒加载相应评论框，如果为 true，文章底部评论是收起状态，提示显示 Gitment 评论按钮，单击展开评论框 LiveRe 评论注册LiveRe 打开主题配置文件 _config.yml 添加： # Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid Hypercomments 超级评论注册Hypercomments 打开主题配置文件 _config.yml 添加： # Hypercomments# hypercomments_id: your id valine 评论系统添加分享cd themes/nextgit clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton 打开主题配置文件 _config.yml ，加入： needmoreshare2: enable: true postbottom: enable: true float: enable: true SEO 优化添加站点地图（sitemap.xml）npm install hexo-generator-sitemap hexo-generator-baidu-sitemapnpm install hexo-generator-baidu-sitemap 在站点配置文件中添加如下代码: sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 配置成功后，会生成sitemap.xml和baidusitemap.xml，前者适合提交给谷歌搜素引擎，后者适合提交百度搜索引擎。 提交博客地址到搜索引擎如果你不主动提交你的博客地址给各大搜索引擎，那么即使你站内优化做得再好，搜索引擎根本都不知道你的博客的存在。 所以别忘记在你创建完博客的那一刻就去提交。如果你此刻还没有提交，现在就去吧。 Google https://www.google.com/webmasters/tools/submit-url 必应 https://www.bing.com/toolbox/webmaster/ Baidu https://ziyuan.baidu.com/linksubmit/index Google 站长工具 和 Google AnalysisGA 是用来统计访问信息的，站长工具是用来查看网站的查询和搜索数据 注册Google Analysis 编辑主题配置文件 _config.yml ， 修改字段 google_analytics， 值设置成你的 Google 跟踪 ID。跟踪 ID 通常是以 UA- 开头 Google 站长工具 提交 sitemap 添加蜘蛛协议 robots.txtrobots.txt，代码如下 # hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://cuilongjin.top/sitemap.xmlSitemap: https://cuilongjin.top/baidusitemap.xml 把robots.txt放在你的hexo站点的source文件下即可 给出站链接添加 nofollow 标签设置忽略文件渲染打开站点配置文件 _config.yml ，修改 skip_render 参数的值 # 路径是相对source目录的# 不对文件进行渲染，保持文件原有内容skip_render: - &quot;*.html&quot; - &quot;demo/**&quot; // 排除 demo 整个目录 - README.md 再次使用 hexo d 命令部署博客的时候就不会在渲染这些文件了 添加 google adsense注册账号 https://www.google.com/adsense/start/ 获取代码 &lt;script async src=&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;&lt;script&gt; ;(adsbygoogle = window.adsbygoogle || []).push(&#123; google_ad_client: &#x27;ca-pub-9068539038073295&#x27;, enable_page_level_ads: true &#125;)&lt;/script&gt; 将网站关联到 AdSense 在主题配置文件中添加广告控制开关 # 添加 Google AdSensegoogle_adsense: true 主题文件夹下找到 &#x2F;layout&#x2F;_partial&#x2F;head.swig 里添加代码： &#123;% if theme.google_adsense %&#125; &lt;script async src=&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt; &lt;script&gt; (adsbygoogle = window.adsbygoogle || []).push(&#123; google_ad_client: &quot;ca-pub-9068539038073295&quot;, enable_page_level_ads: true &#125;) &lt;/script&gt;&#123;% endif %&#125; 重新部署网站 等待审核，审核成功会向你发送邮件 文章加密访问https://github.com/MikeCoder/hexo-blog-encrypt 安装 npm install hexo-blog-encrypt 在 站点配置文件 中启用该插件: # 文章加密 https://github.com/MikeCoder/hexo-blog-encryptencrypt: enable: true # 默认的提示和摘要内容 default_abstract: 这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你确实想看，请与我联系 default_message: 输入密码，查看文章 在需要加密的文章的头部添加上对应的字段，如 password, abstract, message password: 该博客加密使用的密码abstract: 该博客的摘要，会显示在博客的列表页message: 博客查看时，密码输入框上面的描述性文字 存在问题 字数统计功能字数会显得比实际值大 加密文章内代码复制失效 添加评分系统https://widgetpack.com 注册 获得 id，即为左上角的数字： 主题配置文件中修改 rating: enable: true id: 在侧栏找到 rating 的 setting：推荐将投票方式改为 ip 投票，因为这个平台提供的账号投票基本不面向国内。 添加萌萌哒看板娘https://blog.bill.moe/hexo-live2d-poster-girl/ 添加 Hitokoto 一言功能https://hitokoto.cn/api 安装 Hexo Adminnpm install hexo-adminhexo server 然后打开 localhost:4000&#x2F;admin&#x2F; 设置登陆 admin 的用户名和密码，打开http://localhost:4000/admin/#/auth-setup 可以直接输入你想要的用户名和密码，把生成的文本复制到 hexo 根目录配置文件中_config.yml # hexo-admin authentificationadmin: username: username password_hash: $2a$10$L.XAIqIWgTc5S1zpvV3MEu7/rH34p4Is/nq824smv8EZ3lIPCp1su secret: my super secret phrase 主题更新命令： cd themes/nextgit submodule update 推荐你使用 Hexo 数据文件特性进行主题配置 目前，通过 pull 或下载新的 release 版本来更新 NexT 主题的体验并不平滑。当用户使用 git pull 更新 NexT 主题时经常需要解决冲突问题，而在手动下载 release 版本时也经常需要手动合并配置 现在来说，NexT 推荐用户存储部分配置在站点的 _config.yml 中，而另一部分在主题的 _config.yml 中。这一方式固然可用，但也有一些缺点 配置项被分裂为两部分 用户难以弄清何处存放配置选项 为了解决这一问题，NexT 将利用 Hexo 的数据文件特性。因为数据文件是在 Hexo 3 中被引入，所以你需要更新至 Hexo 3.0 以后的版本来使用这一特性。 如果你仍然希望使用 Hexo 2.x，你依旧可以按老的方式进行配置。NexT 仍然兼容 Hexo 2.x（但可能会出现错误）。 带来的好处 使用这一特性，你现在可以将你的全部配置置于同一位置 (source/_data/next.yml），并且不需要修改 next/_config.yml。如果在新的 release 中出现了任何新的选项，那么你只需要从 next/_config.yml 中将他们复制到 source/_data/next.yml 中并设置它们的值为你想要的选项。 如何使用这一特性 请确认你的 Hexo 版本为 3.0 或更高。 在你站点的 hexo/source/_data 目录创建一个 next.yml 文件（如果 _data 目录不存在，请创建之）。 复制你站点的 _config.yml 和主题的 _config.yml 中的 NexT 配置项到 hexo/source/_data/next.yml 中。 使用 --config source/_data/next.yml 参数来启动服务器，生成或部署。 例如：hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml 。 从 NexT v5.1.x 更新https://github.com/theme-next/hexo-theme-next/blob/master/docs/cn/UPDATE-FROM-5.1.X.md","categories":[{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"github","slug":"github","permalink":"https://wqdy.top/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://wqdy.top/tags/hexo/"}]}],"categories":[{"name":"前端","slug":"frontend","permalink":"https://wqdy.top/c/frontend/"},{"name":"教程","slug":"教程","permalink":"https://wqdy.top/c/%E6%95%99%E7%A8%8B/"},{"name":"软件","slug":"software","permalink":"https://wqdy.top/c/software/"},{"name":"uncategorized","slug":"uncategorized","permalink":"https://wqdy.top/c/uncategorized/"},{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/c/wordpress/"},{"name":"NAS","slug":"NAS","permalink":"https://wqdy.top/c/NAS/"},{"name":"软件","slug":"NAS/software","permalink":"https://wqdy.top/c/NAS/software/"},{"name":"vue","slug":"vue","permalink":"https://wqdy.top/c/vue/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wqdy.top/tags/js/"},{"name":"Babel","slug":"Babel","permalink":"https://wqdy.top/tags/Babel/"},{"name":"Polyfill","slug":"Polyfill","permalink":"https://wqdy.top/tags/Polyfill/"},{"name":"vue","slug":"vue","permalink":"https://wqdy.top/tags/vue/"},{"name":"天翼云","slug":"天翼云","permalink":"https://wqdy.top/tags/%E5%A4%A9%E7%BF%BC%E4%BA%91/"},{"name":"github actions","slug":"github-actions","permalink":"https://wqdy.top/tags/github-actions/"},{"name":"github pages","slug":"github-pages","permalink":"https://wqdy.top/tags/github-pages/"},{"name":"gitee pages","slug":"gitee-pages","permalink":"https://wqdy.top/tags/gitee-pages/"},{"name":"越狱","slug":"越狱","permalink":"https://wqdy.top/tags/%E8%B6%8A%E7%8B%B1/"},{"name":"adobe","slug":"adobe","permalink":"https://wqdy.top/tags/adobe/"},{"name":"软件","slug":"软件","permalink":"https://wqdy.top/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"破解","slug":"破解","permalink":"https://wqdy.top/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://wqdy.top/tags/JetBrains/"},{"name":"vmware","slug":"vmware","permalink":"https://wqdy.top/tags/vmware/"},{"name":"github","slug":"github","permalink":"https://wqdy.top/tags/github/"},{"name":"图床","slug":"图床","permalink":"https://wqdy.top/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"jsDelivr","slug":"jsDelivr","permalink":"https://wqdy.top/tags/jsDelivr/"},{"name":"zsh","slug":"zsh","permalink":"https://wqdy.top/tags/zsh/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://wqdy.top/tags/oh-my-zsh/"},{"name":"Fluent Terminal","slug":"Fluent-Terminal","permalink":"https://wqdy.top/tags/Fluent-Terminal/"},{"name":"Windows Terminal","slug":"Windows-Terminal","permalink":"https://wqdy.top/tags/Windows-Terminal/"},{"name":"PowerShell","slug":"PowerShell","permalink":"https://wqdy.top/tags/PowerShell/"},{"name":"下载","slug":"下载","permalink":"https://wqdy.top/tags/%E4%B8%8B%E8%BD%BD/"},{"name":"百度网盘","slug":"百度网盘","permalink":"https://wqdy.top/tags/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"},{"name":"linux","slug":"linux","permalink":"https://wqdy.top/tags/linux/"},{"name":"Google Drive","slug":"Google-Drive","permalink":"https://wqdy.top/tags/Google-Drive/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://wqdy.top/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"ssl","slug":"ssl","permalink":"https://wqdy.top/tags/ssl/"},{"name":"less","slug":"less","permalink":"https://wqdy.top/tags/less/"},{"name":"screen","slug":"screen","permalink":"https://wqdy.top/tags/screen/"},{"name":"hosts","slug":"hosts","permalink":"https://wqdy.top/tags/hosts/"},{"name":"安卓","slug":"安卓","permalink":"https://wqdy.top/tags/%E5%AE%89%E5%8D%93/"},{"name":"投屏","slug":"投屏","permalink":"https://wqdy.top/tags/%E6%8A%95%E5%B1%8F/"},{"name":"wordpress","slug":"wordpress","permalink":"https://wqdy.top/tags/wordpress/"},{"name":"nodejs","slug":"nodejs","permalink":"https://wqdy.top/tags/nodejs/"},{"name":"pm2","slug":"pm2","permalink":"https://wqdy.top/tags/pm2/"},{"name":"nuxt","slug":"nuxt","permalink":"https://wqdy.top/tags/nuxt/"},{"name":"前端工具库","slug":"前端工具库","permalink":"https://wqdy.top/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E5%BA%93/"},{"name":"ssh","slug":"ssh","permalink":"https://wqdy.top/tags/ssh/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://wqdy.top/tags/ubuntu/"},{"name":"win10","slug":"win10","permalink":"https://wqdy.top/tags/win10/"},{"name":"AutoRclone","slug":"AutoRclone","permalink":"https://wqdy.top/tags/AutoRclone/"},{"name":"Gclone","slug":"Gclone","permalink":"https://wqdy.top/tags/Gclone/"},{"name":"jellyfin","slug":"jellyfin","permalink":"https://wqdy.top/tags/jellyfin/"},{"name":"plex","slug":"plex","permalink":"https://wqdy.top/tags/plex/"},{"name":"docker","slug":"docker","permalink":"https://wqdy.top/tags/docker/"},{"name":"群辉","slug":"群辉","permalink":"https://wqdy.top/tags/%E7%BE%A4%E8%BE%89/"},{"name":"网易云音乐","slug":"网易云音乐","permalink":"https://wqdy.top/tags/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"},{"name":"域名","slug":"域名","permalink":"https://wqdy.top/tags/%E5%9F%9F%E5%90%8D/"},{"name":"office","slug":"office","permalink":"https://wqdy.top/tags/office/"},{"name":"windows","slug":"windows","permalink":"https://wqdy.top/tags/windows/"},{"name":"激活","slug":"激活","permalink":"https://wqdy.top/tags/%E6%BF%80%E6%B4%BB/"},{"name":"rclone","slug":"rclone","permalink":"https://wqdy.top/tags/rclone/"},{"name":"zerotier","slug":"zerotier","permalink":"https://wqdy.top/tags/zerotier/"},{"name":"斐讯","slug":"斐讯","permalink":"https://wqdy.top/tags/%E6%96%90%E8%AE%AF/"},{"name":"echarts","slug":"echarts","permalink":"https://wqdy.top/tags/echarts/"},{"name":"fiddler","slug":"fiddler","permalink":"https://wqdy.top/tags/fiddler/"},{"name":"调试","slug":"调试","permalink":"https://wqdy.top/tags/%E8%B0%83%E8%AF%95/"},{"name":"seo","slug":"seo","permalink":"https://wqdy.top/tags/seo/"},{"name":"axios","slug":"axios","permalink":"https://wqdy.top/tags/axios/"},{"name":"idm","slug":"idm","permalink":"https://wqdy.top/tags/idm/"},{"name":"html","slug":"html","permalink":"https://wqdy.top/tags/html/"},{"name":"canvas","slug":"canvas","permalink":"https://wqdy.top/tags/canvas/"},{"name":"chrome","slug":"chrome","permalink":"https://wqdy.top/tags/chrome/"},{"name":"google","slug":"google","permalink":"https://wqdy.top/tags/google/"},{"name":"ss","slug":"ss","permalink":"https://wqdy.top/tags/ss/"},{"name":"npm","slug":"npm","permalink":"https://wqdy.top/tags/npm/"},{"name":"telegram","slug":"telegram","permalink":"https://wqdy.top/tags/telegram/"},{"name":"es6","slug":"es6","permalink":"https://wqdy.top/tags/es6/"},{"name":"promise","slug":"promise","permalink":"https://wqdy.top/tags/promise/"},{"name":"webpack","slug":"webpack","permalink":"https://wqdy.top/tags/webpack/"},{"name":"浏览器","slug":"浏览器","permalink":"https://wqdy.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"css","slug":"css","permalink":"https://wqdy.top/tags/css/"},{"name":"eslint","slug":"eslint","permalink":"https://wqdy.top/tags/eslint/"},{"name":"遍历","slug":"遍历","permalink":"https://wqdy.top/tags/%E9%81%8D%E5%8E%86/"},{"name":"ajax","slug":"ajax","permalink":"https://wqdy.top/tags/ajax/"},{"name":"webapi","slug":"webapi","permalink":"https://wqdy.top/tags/webapi/"},{"name":"sublime","slug":"sublime","permalink":"https://wqdy.top/tags/sublime/"},{"name":"markdown","slug":"markdown","permalink":"https://wqdy.top/tags/markdown/"},{"name":"git","slug":"git","permalink":"https://wqdy.top/tags/git/"},{"name":"模块化","slug":"模块化","permalink":"https://wqdy.top/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"hexo","slug":"hexo","permalink":"https://wqdy.top/tags/hexo/"}]}